From 42803cc9094f347741510f72a86a683abefc37b4 Mon Sep 17 00:00:00 2001
From: Ong Boon Leong <boon.leong.ong@intel.com>
Date: Tue, 10 Jul 2018 15:13:30 +0800
Subject: [PATCH 32/58] net: stmmac: introduce IEEE 802.1Qbu implementation

The following functionalities are added:-

PEC is meant to specify which TxQ is preemptable queue. By default,
TxQ0 must NOT be express queue.

AFSZ is meant to change the non-final fragment size of preempted
frame. A smaller value here means express frame will be transmitted by
express MAC as soon as preempted MAC (pMAC) has collected the configured
fragment size, default to 64-byte fragment.

HADV is meant to specify the time (in nano-seconds) for pMAC to
switch from release to hold state in advance.

RADV is meant to specify the time (in nano-seconds) for pMAC to
switch from hold to release state in advance.

pMAC STS is to indicate whether preemptable MAC is in either Hold
or Release state.

The newly added IEEE 802.1Qbu functionalities are also hooked into
the driver main logics:
 a) stmmac_set_features() & stmmac_dvr_probe(): to independently
    enable/disable FPE functionality
 b) stmmac_hw_setup: to include fprq (frame preemption residue queue)
    setting.

Change-Id: I2d7160f1244f7611216ed2f86bbe033bed77d2fc
Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
---
 drivers/net/ethernet/stmicro/stmmac/dw_tsn_lib.c  | 203 +++++++++++++++++++++-
 drivers/net/ethernet/stmicro/stmmac/dw_tsn_lib.h  |  48 ++++-
 drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c |   8 +
 drivers/net/ethernet/stmicro/stmmac/hwif.h        |  14 ++
 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c |  15 +-
 include/linux/stmmac.h                            |   2 +
 6 files changed, 285 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dw_tsn_lib.c b/drivers/net/ethernet/stmicro/stmmac/dw_tsn_lib.c
index 826ccf1..464369b 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dw_tsn_lib.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dw_tsn_lib.c
@@ -61,6 +61,7 @@ static bool dw_tsn_feat_en[TSN_FEAT_ID_MAX];
 static unsigned int dw_tsn_hwtunable[TSN_HWTUNA_MAX];
 static struct est_gc_config dw_est_gc_config;
 static struct tsn_err_stat dw_err_stat;
+static struct fpe_config dw_fpe_config;
 
 static unsigned int est_get_gcl_depth(unsigned int hw_cap)
 {
@@ -300,6 +301,75 @@ static int est_set_ov(void *ioaddr,
 	return 0;
 }
 
+static int fpe_set_afsz(void *ioaddr, const unsigned int afsz)
+{
+	unsigned int value;
+
+	if (!dw_tsn_feat_en[TSN_FEAT_ID_FPE])
+		return -ENOTSUPP;
+
+	if (afsz > FPE_AFSZ_MAX) {
+		TSN_WARN_NA("FPE: AFSZ is out-of-bound.\n");
+
+		return -EINVAL;
+	}
+
+	if (afsz != dw_tsn_hwtunable[TSN_HWTUNA_TX_FPE_AFSZ]) {
+		value = TSN_RD32(ioaddr + MTL_FPE_CTRL_STS);
+		value &= ~MTL_FPE_CTRL_STS_AFSZ;
+		value |= afsz;
+		TSN_WR32(value, ioaddr + MTL_FPE_CTRL_STS);
+		dw_tsn_hwtunable[TSN_HWTUNA_TX_FPE_AFSZ] = afsz;
+	}
+
+	return 0;
+}
+
+static int fpe_set_hr_adv(void *ioaddr,
+			  const unsigned int *hadv,
+			  const unsigned int *radv)
+{
+	unsigned int value;
+
+	if (!dw_tsn_feat_en[TSN_FEAT_ID_FPE])
+		return -ENOTSUPP;
+
+	value = TSN_RD32(ioaddr + MTL_FPE_ADVANCE);
+
+	if (hadv) {
+		if (*hadv > FPE_ADV_MAX) {
+			TSN_WARN("FPE: invalid HADV(%u), max=%u\n",
+				 *hadv, FPE_ADV_MAX);
+
+			return -EINVAL;
+		} else if (*hadv !=
+			   dw_tsn_hwtunable[TSN_HWTUNA_TX_FPE_HADV]) {
+			value &= ~MTL_FPE_ADVANCE_HADV;
+			value |= (*hadv & MTL_FPE_ADVANCE_HADV);
+			dw_tsn_hwtunable[TSN_HWTUNA_TX_FPE_HADV] = *hadv;
+		}
+	}
+
+	if (radv) {
+		if (*radv > FPE_ADV_MAX) {
+			TSN_WARN("FPE: invalid RADV(%u), max=%u\n",
+				 *radv, FPE_ADV_MAX);
+
+			return -EINVAL;
+		} else if (*radv !=
+			   dw_tsn_hwtunable[TSN_HWTUNA_TX_FPE_RADV]) {
+			value &= ~MTL_FPE_ADVANCE_RADV;
+			value |= ((*radv << MTL_FPE_ADVANCE_RADV_SHIFT) &
+				  MTL_FPE_ADVANCE_RADV);
+			dw_tsn_hwtunable[TSN_HWTUNA_TX_FPE_RADV] = *radv;
+		}
+	}
+
+	TSN_WR32(value, ioaddr + MTL_FPE_ADVANCE);
+
+	return 0;
+}
+
 void dwmac_tsn_init(void *ioaddr)
 {
 	unsigned int gcl_depth;
@@ -321,7 +391,7 @@ void dwmac_tsn_init(void *ioaddr)
 		TSN_WARN_NA("EST NOT supported\n");
 		cap->est_support = 0;
 
-		return;
+		goto check_fpe;
 	}
 
 	gcl_depth = est_get_gcl_depth(hw_cap3);
@@ -341,13 +411,23 @@ void dwmac_tsn_init(void *ioaddr)
 
 	TSN_INFO("EST: depth=%u, ti_wid=%u, tils_max=%u tqcnt=%u\n",
 		 gcl_depth, ti_wid, tils_max, cap->txqcnt);
+
+check_fpe:
+	if (!(hw_cap3 & GMAC_HW_FEAT_FPESEL)) {
+		TSN_INFO_NA("FPE NOT supported\n");
+		cap->fpe_support = 0;
+	} else {
+		TSN_INFO_NA("FPE capable\n");
+		cap->rxqcnt = (hw_cap2 & GMAC_HW_FEAT_RXQCNT) + 1;
+		cap->fpe_support = 1;
+	}
 }
 
 /* dwmac_tsn_setup is called within stmmac_hw_setup() after
  * stmmac_init_dma_engine() which resets MAC controller.
  * This is so-that MAC registers are not cleared.
  */
-void dwmac_tsn_setup(void *ioaddr)
+void dwmac_tsn_setup(void *ioaddr, unsigned int fprq)
 {
 	struct tsn_hw_cap *cap = &dw_tsn_hwcap;
 	unsigned int value;
@@ -359,6 +439,15 @@ void dwmac_tsn_setup(void *ioaddr)
 			 MTL_EST_INT_EN_IECC);
 		TSN_WR32(value, ioaddr + MTL_EST_INT_EN);
 	}
+	if (cap->fpe_support && fprq <= cap->rxqcnt) {
+		/* Update FPRQ */
+		value = TSN_RD32(ioaddr + GMAC_RXQ_CTRL1);
+		value &= ~GMAC_RXQCTRL_FPRQ_MASK;
+		value |= fprq << GMAC_RXQCTRL_FPRQ_SHIFT;
+		TSN_WR32(value, ioaddr + GMAC_RXQ_CTRL1);
+	} else {
+		TSN_WARN_NA("FPE: FPRQ is out-of-bound.\n");
+	}
 }
 
 void dwmac_get_tsn_hwcap(struct tsn_hw_cap **tsn_hwcap)
@@ -394,6 +483,15 @@ int dwmac_set_tsn_hwtunable(void *ioaddr,
 	case TSN_HWTUNA_TX_EST_CTOV:
 		ret = est_set_ov(ioaddr, NULL, data);
 		break;
+	case TSN_HWTUNA_TX_FPE_AFSZ:
+		ret = fpe_set_afsz(ioaddr, *data);
+		break;
+	case TSN_HWTUNA_TX_FPE_HADV:
+		ret = fpe_set_hr_adv(ioaddr, data, NULL);
+		break;
+	case TSN_HWTUNA_TX_FPE_RADV:
+		ret = fpe_set_hr_adv(ioaddr, NULL, data);
+		break;
 	default:
 		ret = -EINVAL;
 	};
@@ -957,3 +1055,104 @@ int dwmac_clr_est_err_stat(void *ioaddr)
 
 	return 0;
 }
+
+int dwmac_set_fpe_config(void *ioaddr, struct fpe_config *fpec)
+{
+	unsigned int txqmask, value;
+	struct tsn_hw_cap *cap = &dw_tsn_hwcap;
+
+	if (!dw_tsn_feat_en[TSN_FEAT_ID_FPE])
+		return -ENOTSUPP;
+
+	/* Check PEC is within TxQ range */
+	txqmask = (1 << cap->txqcnt) - 1;
+	if (fpec->txqpec & ~txqmask) {
+		TSN_WARN_NA("FPE: Tx PEC is out-of-bound.\n");
+
+		return -EINVAL;
+	}
+
+	/* When EST and FPE are both enabled, TxQ0 is always preemptable
+	 * queue. If FPE is enabled, we expect at least lsb is set.
+	 * If FPE is not enabled, we also allow PEC = 0.
+	 */
+	if (fpec->txqpec && !(fpec->txqpec & FPE_PMAC_BIT)) {
+		TSN_WARN_NA("FPE: TxQ0 must not be express queue.\n");
+
+		return -EINVAL;
+	}
+
+	/* Field masking not needed as condition checks have been done */
+	value = TSN_RD32(ioaddr + MTL_FPE_CTRL_STS);
+	value &= ~(txqmask << MTL_FPE_CTRL_STS_PEC_SHIFT);
+	value |= (fpec->txqpec << MTL_FPE_CTRL_STS_PEC_SHIFT);
+	TSN_WR32(value, ioaddr + MTL_FPE_CTRL_STS);
+
+	/* Update driver copy */
+	dw_fpe_config.txqpec = fpec->txqpec;
+
+	return 0;
+}
+
+int dwmac_set_fpe_enable(void *ioaddr, bool enable)
+{
+	if (!dw_tsn_feat_en[TSN_FEAT_ID_FPE])
+		return -ENOTSUPP;
+
+	dw_fpe_config.enable = enable & MAC_FPE_CTRL_STS_EFPE;
+	TSN_WR32((unsigned int)dw_fpe_config.enable,
+		 ioaddr + MAC_FPE_CTRL_STS);
+
+	return 0;
+}
+
+int dwmac_get_fpe_config(void *ioaddr, struct fpe_config **fpec,
+			 bool frmdrv)
+{
+	unsigned int value;
+	struct fpe_config *pfpec;
+
+	if (!dw_tsn_feat_en[TSN_FEAT_ID_FPE])
+		return -ENOTSUPP;
+
+	/* Get FPE config from driver */
+	if (frmdrv) {
+		*fpec = &dw_fpe_config;
+
+		TSN_INFO_NA("FPE: read config from driver copy done.\n");
+
+		return 0;
+	}
+
+	pfpec = &dw_fpe_config;
+
+	value = TSN_RD32(ioaddr + MTL_FPE_CTRL_STS);
+	pfpec->txqpec = (value & MTL_FPE_CTRL_STS_PEC) >>
+			MTL_FPE_CTRL_STS_PEC_SHIFT;
+
+	value = TSN_RD32(ioaddr + MAC_FPE_CTRL_STS);
+	pfpec->enable = (bool)(value & MAC_FPE_CTRL_STS_EFPE);
+
+	*fpec = pfpec;
+	TSN_INFO_NA("FPE: read config from HW done.\n");
+
+	return 0;
+}
+
+int dwmac_get_fpe_pmac_sts(void *ioaddr, unsigned int *hrs)
+{
+	unsigned int value;
+
+	if (!dw_tsn_feat_en[TSN_FEAT_ID_FPE])
+		return -ENOTSUPP;
+
+	value = TSN_RD32(ioaddr + MTL_FPE_CTRL_STS);
+	*hrs = (value & MTL_FPE_CTRL_STS_HRS) >> MTL_FPE_CTRL_STS_HRS_SHIFT;
+
+	if (hrs)
+		TSN_INFO_NA("FPE: pMAC is in Hold state.\n");
+	else
+		TSN_INFO_NA("FPE: pMAC is in Release state.\n");
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/stmicro/stmmac/dw_tsn_lib.h b/drivers/net/ethernet/stmicro/stmmac/dw_tsn_lib.h
index 9d0ecd9..ccb85d6 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dw_tsn_lib.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dw_tsn_lib.h
@@ -26,9 +26,15 @@
 
 /* DWMAC v5.xx supports the following Time Sensitive Networking protocols:
  * 1) IEEE 802.1Qbv Enhancements for Scheduled Traffic (EST)
+ * 2) IEEE 802.1Qbu Frame Preemption (FPE)
  */
 
+/* FPRQ only available in EQoS ver5.00 MAC_RxQ_Ctrl1 */
+#define GMAC_RXQCTRL_FPRQ_MASK		GENMASK(26, 24)	/* FPE Residue Queue */
+#define GMAC_RXQCTRL_FPRQ_SHIFT		24
+
 /* MAC HW features3 bitmap */
+#define GMAC_HW_FEAT_FPESEL		BIT(26)
 #define GMAC_HW_FEAT_ESTTISW		GENMASK(24, 23)
 #define GMAC_HW_FEAT_ESTTISW_SHIFT	23
 #define GMAC_HW_FEAT_ESTWID		GENMASK(21, 20)
@@ -37,6 +43,10 @@
 #define GMAC_HW_FEAT_ESTDEP_SHIFT	17
 #define GMAC_HW_FEAT_ESTSEL		BIT(16)
 
+/* MAC FPE control status */
+#define MAC_FPE_CTRL_STS		0x00000234
+#define MAC_FPE_CTRL_STS_EFPE		BIT(0)
+
 /* MTL EST control register */
 #define MTL_EST_CTRL			0x00000c50
 #define MTL_EST_CTRL_PTOV		GENMASK(31, 24)
@@ -100,6 +110,20 @@
 /* MTL EST GCL data register */
 #define MTL_EST_GCL_DATA		0x00000c84
 
+/* MTL FPE control status */
+#define MTL_FPE_CTRL_STS		0x00000c90
+#define MTL_FPE_CTRL_STS_HRS		BIT(28)	/* Hold/Release Status */
+#define MTL_FPE_CTRL_STS_HRS_SHIFT	28
+#define MTL_FPE_CTRL_STS_PEC		GENMASK(15, 8)	/* FPE Classification */
+#define MTL_FPE_CTRL_STS_PEC_SHIFT	8
+#define MTL_FPE_CTRL_STS_AFSZ		GENMASK(1, 0)	/* Extra Frag Size */
+
+/* MTL FPE Advance */
+#define MTL_FPE_ADVANCE			0x00000c94
+#define MTL_FPE_ADVANCE_RADV		GENMASK(31, 16)	/* Release Advance */
+#define MTL_FPE_ADVANCE_RADV_SHIFT	16
+#define MTL_FPE_ADVANCE_HADV		GENMASK(15, 0)	/* Hold Advance */
+
 /* EST Global defines */
 #define EST_CTR_HI_MAX			0xff	/* CTR Hi is 8-bit only */
 #define EST_PTOV_MAX			0xff	/* Max PTP time offset */
@@ -107,6 +131,11 @@
 #define EST_TIWID_TO_EXTMAX(ti_wid)	((1 << (ti_wid + 7)) - 1)
 #define EST_GCL_BANK_MAX	(2)
 
+/* FPE Global defines */
+#define FPE_AFSZ_MAX			0x3	/* Max AFSZ */
+#define FPE_ADV_MAX			0xFFFF	/* Max Release/Hold advance */
+#define FPE_PMAC_BIT			0x01	/* pMAC bit in GC entry */
+
 /* MAC Core Version */
 #define TSN_VER_MASK		0xFF
 #define TSN_CORE_VER		0x50
@@ -120,12 +149,16 @@ enum tsn_hwtunable_id {
 	TSN_HWTUNA_TX_EST_TILS = 0,
 	TSN_HWTUNA_TX_EST_PTOV,
 	TSN_HWTUNA_TX_EST_CTOV,
+	TSN_HWTUNA_TX_FPE_AFSZ,
+	TSN_HWTUNA_TX_FPE_HADV,
+	TSN_HWTUNA_TX_FPE_RADV,
 	TSN_HWTUNA_MAX,
 };
 
 /* TSN Feature Enabled List */
 enum tsn_feat_id {
 	TSN_FEAT_ID_EST = 0,
+	TSN_FEAT_ID_FPE,
 	TSN_FEAT_ID_MAX,
 };
 
@@ -150,7 +183,9 @@ enum tsn_feat_id {
 /* TSN HW Capabilities */
 struct tsn_hw_cap {
 	bool est_support;		/* 1: supported */
+	bool fpe_support;		/* 1: supported */
 	unsigned int txqcnt;		/* Number of TxQ (control gate) */
+	unsigned int rxqcnt;		/* Number of RxQ (for FPRQ) */
 	unsigned int gcl_depth;		/* GCL depth. */
 	unsigned int ti_wid;		/* time interval width */
 	unsigned int tils_max;		/* Max time interval left shift */
@@ -207,9 +242,15 @@ struct est_gc_config {
 	bool enable;			/* 1: enabled */
 };
 
+/* FPE Configuration */
+struct fpe_config {
+	unsigned int txqpec;		/* TxQ Preemption Classification */
+	bool enable;			/* 1: enabled */
+};
+
 /* TSN functions */
 void dwmac_tsn_init(void *ioaddr);
-void dwmac_tsn_setup(void *ioaddr);
+void dwmac_tsn_setup(void *ioaddr, unsigned int fprq);
 void dwmac_get_tsn_hwcap(struct tsn_hw_cap **tsn_hwcap);
 void dwmac_set_est_gcb(struct est_gc_entry *gcl, unsigned int bank);
 void dwmac_set_tsn_feat(enum tsn_feat_id featid, bool enable);
@@ -233,4 +274,9 @@ int dwmac_get_est_gcc(void *ioaddr,
 int dwmac_est_irq_status(void *ioaddr);
 int dwmac_get_est_err_stat(struct tsn_err_stat **err_stat);
 int dwmac_clr_est_err_stat(void *ioaddr);
+int dwmac_set_fpe_config(void *ioaddr, struct fpe_config *fpec);
+int dwmac_set_fpe_enable(void *ioaddr, bool enable);
+int dwmac_get_fpe_config(void *ioaddr, struct fpe_config **fpec,
+			 bool frmdrv);
+int dwmac_get_fpe_pmac_sts(void *ioaddr, unsigned int *hrs);
 #endif /* __DW_TSN_LIB_H__ */
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
index 9070b6f..ac8fbc1 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
@@ -1101,6 +1101,10 @@ const struct stmmac_ops dwmac510_ops = {
 	.est_irq_status = dwmac_est_irq_status,
 	.get_est_err_stat = dwmac_get_est_err_stat,
 	.clr_est_err_stat = dwmac_clr_est_err_stat,
+	.set_fpe_config = dwmac_set_fpe_config,
+	.set_fpe_enable = dwmac_set_fpe_enable,
+	.get_fpe_config = dwmac_get_fpe_config,
+	.get_fpe_pmac_sts = dwmac_get_fpe_pmac_sts,
 	.safety_feat_config = dwmac5_safety_feat_config,
 	.safety_feat_irq_status = dwmac5_safety_feat_irq_status,
 	.safety_feat_dump = dwmac5_safety_feat_dump,
@@ -1161,6 +1165,10 @@ const struct stmmac_ops dwmac510_xpcs_ops = {
 	.est_irq_status = dwmac_est_irq_status,
 	.get_est_err_stat = dwmac_get_est_err_stat,
 	.clr_est_err_stat = dwmac_clr_est_err_stat,
+	.set_fpe_config = dwmac_set_fpe_config,
+	.set_fpe_enable = dwmac_set_fpe_enable,
+	.get_fpe_config = dwmac_get_fpe_config,
+	.get_fpe_pmac_sts = dwmac_get_fpe_pmac_sts,
 	.safety_feat_config = dwmac5_safety_feat_config,
 	.safety_feat_irq_status = dwmac5_safety_feat_irq_status,
 	.safety_feat_dump = dwmac5_safety_feat_dump,
diff --git a/drivers/net/ethernet/stmicro/stmmac/hwif.h b/drivers/net/ethernet/stmicro/stmmac/hwif.h
index 5b17ba2..a58ed69 100644
--- a/drivers/net/ethernet/stmicro/stmmac/hwif.h
+++ b/drivers/net/ethernet/stmicro/stmmac/hwif.h
@@ -369,6 +369,12 @@ struct stmmac_ops {
 	int (*est_irq_status)(void __iomem *ioaddr);
 	int (*get_est_err_stat)(struct tsn_err_stat **err_stat);
 	int (*clr_est_err_stat)(void __iomem *ioaddr);
+	int (*set_fpe_config)(void __iomem *ioaddr,
+			      struct fpe_config *fpec);
+	int (*set_fpe_enable)(void __iomem *ioaddr, bool enable);
+	int (*get_fpe_config)(void __iomem *ioaddr,
+			      struct fpe_config **fpec, bool frmdrv);
+	int (*get_fpe_pmac_sts)(void __iomem *ioaddr, u32 *hrs);
 	/* Safety Features */
 	int (*safety_feat_config)(void __iomem *ioaddr, unsigned int asp);
 	int (*safety_feat_irq_status)(struct net_device *ndev,
@@ -495,6 +501,14 @@ struct stmmac_ops {
 	stmmac_do_callback(__priv, mac, get_est_err_stat, __args)
 #define stmmac_clr_est_err_stat(__priv, __args...) \
 	stmmac_do_callback(__priv, mac, clr_est_err_stat, __args)
+#define stmmac_set_fpe_config(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, set_fpe_config, __args)
+#define stmmac_set_fpe_enable(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, set_fpe_enable, __args)
+#define stmmac_get_fpe_config(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, get_fpe_config, __args)
+#define stmmac_get_fpe_pmac_sts(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, get_fpe_pmac_sts, __args)
 #define stmmac_safety_feat_config(__priv, __args...) \
 	stmmac_do_callback(__priv, mac, safety_feat_config, __args)
 #define stmmac_safety_feat_irq_status(__priv, __args...) \
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index eff4e2c..a15e126 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -2567,7 +2567,7 @@ static int stmmac_hw_setup(struct net_device *dev, bool init_ptp)
 	stmmac_set_hw_vlan_mode(priv, priv->ioaddr, dev->features);
 
 	/* Setup for TSN capability */
-	dwmac_tsn_setup(priv->ioaddr);
+	dwmac_tsn_setup(priv->ioaddr, priv->plat->fprq);
 
 	return 0;
 }
@@ -3689,6 +3689,12 @@ static int stmmac_set_features(struct net_device *netdev,
 		else
 			stmmac_set_est_enable(priv, priv->ioaddr, 0);
 	}
+	if (changed & NETIF_F_HW_FPE) {
+		if (features & NETIF_F_HW_FPE)
+			stmmac_set_fpe_enable(priv, priv->ioaddr, 1);
+		else
+			stmmac_set_fpe_enable(priv, priv->ioaddr, 0);
+	}
 
 	netdev->features = features;
 
@@ -4430,6 +4436,11 @@ int stmmac_dvr_probe(struct device *device,
 		priv->hw->tsn_cap |= TSN_CAP_EST;
 		dev_info(priv->device, "EST feature enabled\n");
 	}
+	if (tsn_hwcap && tsn_hwcap->fpe_support && priv->plat->tsn_fpe_en) {
+		ndev->hw_features |= NETIF_F_HW_FPE;
+		stmmac_set_tsn_feat(priv, TSN_FEAT_ID_FPE, true);
+		dev_info(priv->device, "FPE feature enabled\n");
+	}
 
 #ifdef STMMAC_VLAN_TAG_USED
 	/* Both mac100 and gmac support receive VLAN tag detection */
@@ -4441,7 +4452,7 @@ int stmmac_dvr_probe(struct device *device,
 	ndev->features |= ndev->hw_features | NETIF_F_HIGHDMA;
 
 	/* TSN features are disabled by default */
-	ndev->features &= ~(NETIF_F_HW_EST);
+	ndev->features &= ~(NETIF_F_HW_EST | NETIF_F_HW_FPE);
 
 	priv->msg_enable = netif_msg_init(debug, default_msg_level);
 
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
index 37c5f02..16c9317 100644
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -196,5 +196,7 @@ struct plat_stmmacenet_data {
 	int has_xgmac;
 	int no_msi;
 	bool tsn_est_en;
+	bool tsn_fpe_en;
+	u32 fprq;
 };
 #endif
-- 
2.7.4

