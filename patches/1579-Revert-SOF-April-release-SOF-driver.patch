From 8a722d38b71582e4beed714a2174ee96823486aa Mon Sep 17 00:00:00 2001
From: Keyon Jie <yang.jie@linux.intel.com>
Date: Tue, 26 Jun 2018 18:41:31 +0800
Subject: [PATCH 1579/2328] Revert SOF April release -- SOF driver.

Signed-off-by: Keyon Jie <yang.jie@linux.intel.com>
---
 include/sound/sof.h                          |    5 -
 include/uapi/sound/sof-abi.h                 |   29 -
 include/uapi/sound/sof-eq.h                  |  102 -
 include/uapi/sound/sof-fw.h                  |   69 -
 include/uapi/sound/sof-ipc.h                 |  853 ---------
 include/uapi/sound/sof-tone.h                |   28 -
 include/uapi/sound/sof-topology.h            |   71 -
 sound/core/pcm.c                             |    2 -
 sound/soc/Kconfig                            |    1 -
 sound/soc/Makefile                           |    1 -
 sound/soc/codecs/tdf8532.c                   |   52 -
 sound/soc/intel/Kconfig                      |    4 +-
 sound/soc/intel/boards/Kconfig               |   22 +-
 sound/soc/intel/boards/bdw-rt5677.c          |    4 -
 sound/soc/intel/boards/broadwell.c           |    4 -
 sound/soc/intel/boards/bxt_tdf8532.c         |   26 +-
 sound/soc/intel/boards/bytcht_da7213.c       |    2 -
 sound/soc/intel/boards/bytcr_rt5640.c        |    4 -
 sound/soc/intel/boards/bytcr_rt5651.c        |    4 +-
 sound/soc/intel/boards/cht_bsw_max98090_ti.c |    2 -
 sound/soc/intel/boards/cht_bsw_rt5645.c      |   10 -
 sound/soc/intel/boards/cht_bsw_rt5672.c      |    2 -
 sound/soc/intel/boards/haswell.c             |    4 -
 sound/soc/soc-topology.c                     |    3 -
 sound/soc/sof/Kconfig                        |  110 --
 sound/soc/sof/Makefile                       |   26 -
 sound/soc/sof/compressed.c                   |  168 --
 sound/soc/sof/control.c                      |  233 ---
 sound/soc/sof/debug.c                        |  137 --
 sound/soc/sof/hw-apl.c                       | 2647 --------------------------
 sound/soc/sof/hw-bdw.c                       |  757 --------
 sound/soc/sof/hw-byt.c                       |  849 ---------
 sound/soc/sof/hw-hsw.c                       |  756 --------
 sound/soc/sof/hw-spi.c                       |  253 ---
 sound/soc/sof/intel.h                        |  322 ----
 sound/soc/sof/ipc.c                          |  605 ------
 sound/soc/sof/loader.c                       |  283 ---
 sound/soc/sof/nocodec.c                      |  114 --
 sound/soc/sof/ops.c                          |  190 --
 sound/soc/sof/ops.h                          |  251 ---
 sound/soc/sof/pcm.c                          |  632 ------
 sound/soc/sof/pm.c                           |   48 -
 sound/soc/sof/sof-acpi-dev.c                 |  353 ----
 sound/soc/sof/sof-pci-dev.c                  |  307 ---
 sound/soc/sof/sof-priv.h                     |    6 -
 sound/soc/sof/sof-spi-dev.c                  |  167 --
 sound/soc/sof/topology.c                     | 1532 ---------------
 sound/soc/sof/trace.c                        |  290 ---
 sound/soc/sof/virtio-be.c                    |  126 --
 sound/soc/sof/virtio-fe.c                    |  130 --
 50 files changed, 9 insertions(+), 12587 deletions(-)
 delete mode 100644 include/uapi/sound/sof-abi.h
 delete mode 100644 include/uapi/sound/sof-eq.h
 delete mode 100644 include/uapi/sound/sof-fw.h
 delete mode 100644 include/uapi/sound/sof-ipc.h
 delete mode 100644 include/uapi/sound/sof-tone.h
 delete mode 100644 include/uapi/sound/sof-topology.h
 delete mode 100644 sound/soc/sof/Kconfig
 delete mode 100644 sound/soc/sof/Makefile
 delete mode 100644 sound/soc/sof/compressed.c
 delete mode 100644 sound/soc/sof/control.c
 delete mode 100644 sound/soc/sof/debug.c
 delete mode 100644 sound/soc/sof/hw-apl.c
 delete mode 100644 sound/soc/sof/hw-bdw.c
 delete mode 100644 sound/soc/sof/hw-byt.c
 delete mode 100644 sound/soc/sof/hw-hsw.c
 delete mode 100644 sound/soc/sof/hw-spi.c
 delete mode 100644 sound/soc/sof/intel.h
 delete mode 100644 sound/soc/sof/ipc.c
 delete mode 100644 sound/soc/sof/loader.c
 delete mode 100644 sound/soc/sof/nocodec.c
 delete mode 100644 sound/soc/sof/ops.c
 delete mode 100644 sound/soc/sof/ops.h
 delete mode 100644 sound/soc/sof/pcm.c
 delete mode 100644 sound/soc/sof/pm.c
 delete mode 100644 sound/soc/sof/sof-acpi-dev.c
 delete mode 100644 sound/soc/sof/sof-pci-dev.c
 delete mode 100644 sound/soc/sof/sof-spi-dev.c
 delete mode 100644 sound/soc/sof/topology.c
 delete mode 100644 sound/soc/sof/trace.c
 delete mode 100644 sound/soc/sof/virtio-be.c
 delete mode 100644 sound/soc/sof/virtio-fe.c

diff --git a/include/sound/sof.h b/include/sound/sof.h
index f605624..7767ec8 100644
--- a/include/sound/sof.h
+++ b/include/sound/sof.h
@@ -73,9 +73,4 @@ struct sof_dev_desc {
 	const char *nocodec_tplg_filename;
 };
 
-int sof_nocodec_setup(struct device *dev,
-		      struct snd_sof_pdata *sof_pdata,
-		      struct snd_soc_acpi_mach *mach,
-		      const struct sof_dev_desc *desc);
-
 #endif
diff --git a/include/uapi/sound/sof-abi.h b/include/uapi/sound/sof-abi.h
deleted file mode 100644
index 4e78fa1..0000000
--- a/include/uapi/sound/sof-abi.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/* SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note)) OR BSD-3-Clause) */
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- */
-
-#ifndef __INCLUDE_UAPI_ABI_H__
-#define __INCLUDE_UAPI_ABI_H__
-
-#define SOF_ABI_VERSION		1
-#define SOF_ABI_MAGIC		0x00464F53	/* "SOF\0" */
-
-/*
- * Header for all non IPC ABI data. Identifies data type, size and ABI.
- * Used by any bespoke component data structures or binary blobs.
- */
-
-struct sof_abi_hdr {
-	uint32_t magic;		/* 'S', 'O', 'F', '\0' */
-	uint32_t type;		/* component specific type */
-	uint32_t size;		/* size in bytes of data excluding this struct */
-	uint32_t abi;		/* SOF ABI version */
-	uint32_t comp_abi;	/* component specific ABI version */
-	char data[0];
-}  __attribute__((packed));
-
-#endif
diff --git a/include/uapi/sound/sof-eq.h b/include/uapi/sound/sof-eq.h
deleted file mode 100644
index 96aefd1..0000000
--- a/include/uapi/sound/sof-eq.h
+++ /dev/null
@@ -1,102 +0,0 @@
-/* SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note)) OR BSD-3-Clause) */
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Seppo Ingalsuo <seppo.ingalsuo@linux.intel.com>
- */
-
-#ifndef EQ_H
-#define EQ_H
-
-/* FIR EQ type */
-
-/* Component will reject non-matching configuration. The version number need
- * to be incremented with any ABI changes in function fir_cmd().
- */
-#define SOF_EQ_FIR_ABI_VERSION  1
-
-#define SOF_EQ_FIR_IDX_SWITCH	0
-
-#define SOF_EQ_FIR_MAX_SIZE 4096 /* Max size allowed for coef data in bytes */
-
-/*
- * eq_fir_configuration data structure contains this information
- *     uint16_t channels_in_config
- *         This describes the number of channels in this EQ config data. It
- *         can be different from PLATFORM_MAX_CHANNELS.
- *     uint16_t number_of_responses
- *         0=no responses, 1=one response defined, 2=two responses defined, etc.
- *     int16_t data[]
- *         assign_response[STREAM_MAX_CHANNELS]
- *             -1 = not defined, 0 = use first response, 1 = use 2nd response, etc.
- *             E.g. {0, 0, 0, 0, -1, -1, -1, -1} would apply to channels 0-3 the
- *	       same first defined response and leave channels 4-7 unequalized.
- *         coef_data[]
- *             Repeated data { filter_length, input_shift, output_shift, h[] }
- *	       for every EQ response defined where vector h has filter_length
- *             number of coefficients. Coefficients in h[] are in Q1.15 format.
- *             E.g. 16384 (Q1.15) = 0.5. The shifts are number of right shifts.
- */
-
-struct sof_eq_fir_config {
-	uint16_t channels_in_config;
-	uint16_t number_of_responses;
-	int16_t data[];
-};
-
-/* IIR EQ type */
-
-/* Component will reject non-matching configuration. The version number need
- * to be incremented with any ABI changes in function fir_cmd().
- */
-#define SOF_EQ_FIR_ABI_VERSION  1
-
-#define SOF_EQ_IIR_IDX_SWITCH   0
-
-#define SOF_EQ_IIR_MAX_SIZE 1024 /* Max size allowed for coef data in bytes */
-
-/* eq_iir_configuration
- *     uint32_t channels_in_config
- *         This describes the number of channels in this EQ config data. It
- *         can be different from PLATFORM_MAX_CHANNELS.
- *     uint32_t number_of_responses_defined
- *         0=no responses, 1=one response defined, 2=two responses defined, etc.
- *     int32_t data[]
- *         Data consist of two parts. First is the response assign vector that
- *	   has length of channels_in_config. The latter part is coefficient
- *         data.
- *         uint32_t assign_response[channels_in_config]
- *             -1 = not defined, 0 = use first response, 1 = use 2nd, etc.
- *             E.g. {0, 0, 0, 0, -1, -1, -1, -1} would apply to channels 0-3 the
- *             same first defined response and leave channels 4-7 unequalized.
- *         coefficient_data[]
- *             <1st EQ>
- *             uint32_t num_biquads
- *             uint32_t num_biquads_in_series
- *             <1st biquad>
- *             int32_t coef_a2       Q2.30 format
- *             int32_t coef_a1       Q2.30 format
- *             int32_t coef_b2       Q2.30 format
- *             int32_t coef_b1       Q2.30 format
- *             int32_t coef_b0       Q2.30 format
- *             int32_t output_shift  number of shifts right, shift left is negative
- *             int32_t output_gain   Q2.14 format
- *             <2nd biquad>
- *             ...
- *             <2nd EQ>
- *
- *         Note: A flat response biquad can be made with a section set to
- *         b0 = 1.0, gain = 1.0, and other parameters set to 0
- *         {0, 0, 0, 0, 1073741824, 0, 16484}
- */
-
-struct sof_eq_iir_config {
-	uint32_t channels_in_config;
-	uint32_t number_of_responses;
-	int32_t data[];
-};
-
-#endif /* EQ_H */
diff --git a/include/uapi/sound/sof-fw.h b/include/uapi/sound/sof-fw.h
deleted file mode 100644
index 2f9bd82..0000000
--- a/include/uapi/sound/sof-fw.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note)) OR BSD-3-Clause) */
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-/*
- * Firmware file format .
- */
-
-#ifndef __INCLUDE_UAPI_SOF_FW_H__
-#define __INCLUDE_UAPI_SOF_FW_H__
-
-#define SND_SOF_FW_SIG_SIZE	4
-#define SND_SOF_FW_ABI		1
-#define SND_SOF_FW_SIG		"Reef"
-
-/*
- * Firmware module is made up of 1 . N blocks of different types. The
- * Block header is used to determine where and how block is to be copied in the
- * DSP/host memory space.
- */
-enum snd_sof_fw_blk_type {
-	SOF_BLK_IMAGE	= 0,	/* whole image - parsed by ROMs */
-	SOF_BLK_TEXT	= 1,
-	SOF_BLK_DATA	= 2,
-	SOF_BLK_CACHE	= 3,
-	SOF_BLK_REGS	= 4,
-	SOF_BLK_SIG	= 5,
-	SOF_BLK_ROM	= 6,
-	/* add new block types here */
-};
-
-struct snd_sof_blk_hdr {
-	enum snd_sof_fw_blk_type type;
-	uint32_t size;		/* bytes minus this header */
-	uint32_t offset;	/* offset from base */
-} __attribute__((packed));
-
-/*
- * Firmware file is made up of 1 .. N different modules types. The module
- * type is used to determine how to load and parse the module.
- */
-enum snd_sof_fw_mod_type {
-	SOF_FW_BASE	= 0,	/* base firmware image */
-	SOF_FW_MODULE	= 1,	/* firmware module */
-};
-
-struct snd_sof_mod_hdr {
-	enum snd_sof_fw_mod_type type;
-	uint32_t size;		/* bytes minus this header */
-	uint32_t num_blocks;	/* number of blocks */
-} __attribute__((packed));
-
-/*
- * Firmware file header.
- */
-struct snd_sof_fw_header {
-	unsigned char sig[SND_SOF_FW_SIG_SIZE]; /* "Reef" */
-	uint32_t file_size;	/* size of file minus this header */
-	uint32_t num_modules;	/* number of modules */
-	uint32_t abi;		/* version of header format */
-} __attribute__((packed));
-
-#endif
diff --git a/include/uapi/sound/sof-ipc.h b/include/uapi/sound/sof-ipc.h
deleted file mode 100644
index 6f91b6ca..0000000
--- a/include/uapi/sound/sof-ipc.h
+++ /dev/null
@@ -1,853 +0,0 @@
-/* SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note)) OR BSD-3-Clause) */
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- *         Keyon Jie <yang.jie@linux.intel.com>
- */
-
-#ifndef __INCLUDE_UAPI_SOF_IPC_H__
-#define __INCLUDE_UAPI_SOF_IPC_H__
-
-#include <sound/sof-abi.h>
-
-/*
- * IPC messages have a prefixed 32 bit identifier made up as follows :-
- *
- * 0xGCCCNNNN where
- * G is global cmd type (4 bits)
- * C is command type (12 bits)
- * I is the ID number (16 bits) - monotonic and overflows
- *
- * This is sent at the start of the IPM message in the mailbox. Messages should
- * not be sent in the doorbell (special exceptions for firmware .
- */
-
-/* Global Message - Generic */
-#define SOF_GLB_TYPE_SHIFT			28
-#define SOF_GLB_TYPE_MASK			(0xf << SOF_GLB_TYPE_SHIFT)
-#define SOF_GLB_TYPE(x)				(x << SOF_GLB_TYPE_SHIFT)
-
-/* Command Message - Generic */
-#define SOF_CMD_TYPE_SHIFT			16
-#define SOF_CMD_TYPE_MASK			(0xfff << SOF_CMD_TYPE_SHIFT)
-#define SOF_CMD_TYPE(x)				(x << SOF_CMD_TYPE_SHIFT)
-
-/* Global Message Types */
-#define SOF_IPC_GLB_REPLY			SOF_GLB_TYPE(0x1U)
-#define SOF_IPC_GLB_COMPOUND			SOF_GLB_TYPE(0x2U)
-#define SOF_IPC_GLB_TPLG_MSG			SOF_GLB_TYPE(0x3U)
-#define SOF_IPC_GLB_PM_MSG			SOF_GLB_TYPE(0x4U)
-#define SOF_IPC_GLB_COMP_MSG			SOF_GLB_TYPE(0x5U)
-#define SOF_IPC_GLB_STREAM_MSG			SOF_GLB_TYPE(0x6U)
-#define SOF_IPC_FW_READY			SOF_GLB_TYPE(0x7U)
-#define SOF_IPC_GLB_DAI_MSG			SOF_GLB_TYPE(0x8U)
-#define SOF_IPC_GLB_TRACE_MSG			SOF_GLB_TYPE(0x9U)
-
-/*
- * DSP Command Message Types
- */
-
-/* topology */
-#define SOF_IPC_TPLG_COMP_NEW			SOF_CMD_TYPE(0x001)
-#define SOF_IPC_TPLG_COMP_FREE			SOF_CMD_TYPE(0x002)
-#define SOF_IPC_TPLG_COMP_CONNECT		SOF_CMD_TYPE(0x003)
-#define SOF_IPC_TPLG_PIPE_NEW			SOF_CMD_TYPE(0x010)
-#define SOF_IPC_TPLG_PIPE_FREE			SOF_CMD_TYPE(0x011)
-#define SOF_IPC_TPLG_PIPE_CONNECT		SOF_CMD_TYPE(0x012)
-#define SOF_IPC_TPLG_PIPE_COMPLETE		SOF_CMD_TYPE(0x013)
-#define SOF_IPC_TPLG_BUFFER_NEW			SOF_CMD_TYPE(0x020)
-#define SOF_IPC_TPLG_BUFFER_FREE		SOF_CMD_TYPE(0x021)
-
-/* PM */
-#define SOF_IPC_PM_CTX_SAVE			SOF_CMD_TYPE(0x001)
-#define SOF_IPC_PM_CTX_RESTORE			SOF_CMD_TYPE(0x002)
-#define SOF_IPC_PM_CTX_SIZE			SOF_CMD_TYPE(0x003)
-#define SOF_IPC_PM_CLK_SET			SOF_CMD_TYPE(0x004)
-#define SOF_IPC_PM_CLK_GET			SOF_CMD_TYPE(0x005)
-#define SOF_IPC_PM_CLK_REQ			SOF_CMD_TYPE(0x006)
-
-/* component runtime config - multiple different types */
-#define SOF_IPC_COMP_SET_VALUE			SOF_CMD_TYPE(0x001)
-#define SOF_IPC_COMP_GET_VALUE			SOF_CMD_TYPE(0x002)
-#define SOF_IPC_COMP_SET_DATA			SOF_CMD_TYPE(0x003)
-#define SOF_IPC_COMP_GET_DATA			SOF_CMD_TYPE(0x004)
-
-/* DAI messages */
-#define SOF_IPC_DAI_CONFIG			SOF_CMD_TYPE(0x001)
-#define SOF_IPC_DAI_LOOPBACK			SOF_CMD_TYPE(0x002)
-
-/* stream */
-#define SOF_IPC_STREAM_PCM_PARAMS		SOF_CMD_TYPE(0x001)
-#define SOF_IPC_STREAM_PCM_PARAMS_REPLY		SOF_CMD_TYPE(0x002)
-#define SOF_IPC_STREAM_PCM_FREE			SOF_CMD_TYPE(0x003)
-#define SOF_IPC_STREAM_TRIG_START		SOF_CMD_TYPE(0x004)
-#define SOF_IPC_STREAM_TRIG_STOP		SOF_CMD_TYPE(0x005)
-#define SOF_IPC_STREAM_TRIG_PAUSE		SOF_CMD_TYPE(0x006)
-#define SOF_IPC_STREAM_TRIG_RELEASE		SOF_CMD_TYPE(0x007)
-#define SOF_IPC_STREAM_TRIG_DRAIN		SOF_CMD_TYPE(0x008)
-#define SOF_IPC_STREAM_TRIG_XRUN		SOF_CMD_TYPE(0x009)
-#define SOF_IPC_STREAM_POSITION			SOF_CMD_TYPE(0x00a)
-#define SOF_IPC_STREAM_VORBIS_PARAMS		SOF_CMD_TYPE(0x010)
-#define SOF_IPC_STREAM_VORBIS_FREE		SOF_CMD_TYPE(0x011)
-
-/* trace and debug */
-#define SOF_IPC_TRACE_DMA_PARAMS		SOF_CMD_TYPE(0x001)
-#define SOF_IPC_TRACE_DMA_POSITION		SOF_CMD_TYPE(0x002)
-
-/* Get message component id */
-#define SOF_IPC_MESSAGE_ID(x)			(x & 0xffff)
-
-/* maximum message size for mailbox Tx/Tx */
-#define SOF_IPC_MSG_MAX_SIZE			128
-
-/*
- * SOF panic codes
- */
-#define SOF_IPC_PANIC_MAGIC			0x0dead000
-#define SOF_IPC_PANIC_MAGIC_MASK		0x0ffff000
-#define SOF_IPC_PANIC_CODE_MASK			0x00000fff
-#define SOF_IPC_PANIC_MEM			(SOF_IPC_PANIC_MAGIC | 0)
-#define SOF_IPC_PANIC_WORK			(SOF_IPC_PANIC_MAGIC | 1)
-#define SOF_IPC_PANIC_IPC			(SOF_IPC_PANIC_MAGIC | 2)
-#define SOF_IPC_PANIC_ARCH			(SOF_IPC_PANIC_MAGIC | 3)
-#define SOF_IPC_PANIC_PLATFORM			(SOF_IPC_PANIC_MAGIC | 4)
-#define SOF_IPC_PANIC_TASK			(SOF_IPC_PANIC_MAGIC | 5)
-#define SOF_IPC_PANIC_EXCEPTION			(SOF_IPC_PANIC_MAGIC | 6)
-#define SOF_IPC_PANIC_DEADLOCK			(SOF_IPC_PANIC_MAGIC | 7)
-#define SOF_IPC_PANIC_STACK			(SOF_IPC_PANIC_MAGIC | 8)
-#define SOF_IPC_PANIC_IDLE			(SOF_IPC_PANIC_MAGIC | 9)
-
-/*
- * SOF memory capabilities, add new ones at the end
- */
-#define SOF_MEM_CAPS_RAM			(1 << 0)
-#define SOF_MEM_CAPS_ROM			(1 << 1)
-#define SOF_MEM_CAPS_EXT			(1 << 2) /* external */
-#define SOF_MEM_CAPS_LP			(1 << 3) /* low power */
-#define SOF_MEM_CAPS_HP			(1 << 4) /* high performance */
-#define SOF_MEM_CAPS_DMA			(1 << 5) /* DMA'able */
-#define SOF_MEM_CAPS_CACHE			(1 << 6) /* cacheable */
-
-/*
- * Command Header - Header for all IPC. Identifies IPC message.
- * The size can be greater than the structure size and that means there is
- * extended bespoke data beyond the end of the structure including variable
- * arrays.
- */
-
-struct sof_ipc_hdr {
-	uint32_t cmd;			/* SOF_IPC_GLB_ + cmd */
-	uint32_t size;			/* size of structure */
-}  __attribute__((packed));
-
-/*
- * Generic reply message. Some commands override this with their own reply
- * types that must include this at start.
- */
-struct sof_ipc_reply {
-	struct sof_ipc_hdr hdr;
-	int32_t error;			/* negative error numbers */
-}  __attribute__((packed));
-
-/*
- * Compound commands - SOF_IPC_GLB_COMPOUND.
- *
- * Compound commands are sent to the DSP as a single IPC operation. The
- * commands are split into blocks and each block has a header. This header
- * identifies the command type and the number of commands before the next
- * header.
- */
-
-struct sof_ipc_compound_hdr {
-	struct sof_ipc_hdr hdr;
-	uint32_t count;		/* count of 0 means end of compound sequence */
-}  __attribute__((packed));
-
-/*
- * DAI Configuration.
- *
- * Each different DAI type will have it's own structure and IPC cmd.
- */
-
-#define SOF_DAI_FMT_I2S		1 /* I2S mode */
-#define SOF_DAI_FMT_RIGHT_J	2 /* Right Justified mode */
-#define SOF_DAI_FMT_LEFT_J	3 /* Left Justified mode */
-#define SOF_DAI_FMT_DSP_A	4 /* L data MSB after FRM LRC */
-#define SOF_DAI_FMT_DSP_B	5 /* L data MSB during FRM LRC */
-#define SOF_DAI_FMT_PDM		6 /* Pulse density modulation */
-
-#define SOF_DAI_FMT_CONT	(1 << 4) /* continuous clock */
-#define SOF_DAI_FMT_GATED	(0 << 4) /* clock is gated */
-
-#define SOF_DAI_FMT_NB_NF	(0 << 8) /* normal bit clock + frame */
-#define SOF_DAI_FMT_NB_IF	(2 << 8) /* normal BCLK + inv FRM */
-#define SOF_DAI_FMT_IB_NF	(3 << 8) /* invert BCLK + nor FRM */
-#define SOF_DAI_FMT_IB_IF	(4 << 8) /* invert BCLK + FRM */
-
-#define SOF_DAI_FMT_CBM_CFM	(0 << 12) /* codec clk & FRM master */
-#define SOF_DAI_FMT_CBS_CFM	(2 << 12) /* codec clk slave & FRM master */
-#define SOF_DAI_FMT_CBM_CFS	(3 << 12) /* codec clk master & frame slave */
-#define SOF_DAI_FMT_CBS_CFS	(4 << 12) /* codec clk & FRM slave */
-
-#define SOF_DAI_FMT_FORMAT_MASK		0x000f
-#define SOF_DAI_FMT_CLOCK_MASK		0x00f0
-#define SOF_DAI_FMT_INV_MASK		0x0f00
-#define SOF_DAI_FMT_MASTER_MASK		0xf000
-
-/* types of DAI */
-enum sof_ipc_dai_type {
-	SOF_DAI_INTEL_NONE = 0,
-	SOF_DAI_INTEL_SSP,
-	SOF_DAI_INTEL_DMIC,
-	SOF_DAI_INTEL_HDA,
-};
-
-/* SSP Configuration Request - SOF_IPC_DAI_SSP_CONFIG */
-struct sof_ipc_dai_ssp_params {
-	struct sof_ipc_hdr hdr;
-	uint16_t mode;
-	uint16_t clk_id;
-} __attribute__((packed));
-
-/* HDA Configuration Request - SOF_IPC_DAI_HDA_CONFIG */
-struct sof_ipc_dai_hda_params {
-	struct sof_ipc_hdr hdr;
-	/* TODO */
-} __attribute__((packed));
-
-/* DMIC Configuration Request - SOF_IPC_DAI_DMIC_CONFIG */
-struct sof_ipc_dai_dmic_params {
-	struct sof_ipc_hdr hdr;
-	/* TODO */
-} __attribute__((packed));
-
-/* general purpose DAI configuration */
-struct sof_ipc_dai_config {
-	struct sof_ipc_hdr hdr;
-	enum sof_ipc_dai_type type;
-	uint32_t id;	/* physical number if more than 1 of this type */
-
-	/* physical protocol and clocking */
-	uint16_t format;	/* SOF_DAI_FMT_ */
-	uint16_t reserved;	/* alignment */
-	uint32_t mclk;	/* mclk frequency in Hz */
-	uint32_t bclk;	/* bclk frequency in Hz */
-	uint32_t fclk;	/* cclk frequency in Hz */
-
-	/* TDM */
-	uint32_t num_slots;
-	uint32_t rx_slot_mask;
-	uint32_t tx_slot_mask;
-
-	/* data */
-	uint16_t sample_valid_bits;
-	uint16_t sample_container_bits;
-
-	/* MCLK */
-	uint16_t mclk_always_run;
-	uint16_t mclk_master;
-
-	/* HW specific data */
-	union {
-		struct sof_ipc_dai_ssp_params ssp[0];
-		struct sof_ipc_dai_hda_params hda[0];
-		struct sof_ipc_dai_dmic_params dmic[0];
-	};
-};
-
-/*
- * Stream configuration.
- */
-
-#define SOF_IPC_MAX_CHANNELS			8
-
-/* channel positions - uses same values as ALSA */
-enum sof_ipc_chmap {
-	SOF_CHMAP_UNKNOWN = 0,
-	SOF_CHMAP_NA,		/* N/A, silent */
-	SOF_CHMAP_MONO,		/* mono stream */
-	SOF_CHMAP_FL,		/* front left */
-	SOF_CHMAP_FR,		/* front right */
-	SOF_CHMAP_RL,		/* rear left */
-	SOF_CHMAP_RR,		/* rear right */
-	SOF_CHMAP_FC,		/* front centre */
-	SOF_CHMAP_LFE,		/* LFE */
-	SOF_CHMAP_SL,		/* side left */
-	SOF_CHMAP_SR,		/* side right */
-	SOF_CHMAP_RC,		/* rear centre */
-	SOF_CHMAP_FLC,		/* front left centre */
-	SOF_CHMAP_FRC,		/* front right centre */
-	SOF_CHMAP_RLC,		/* rear left centre */
-	SOF_CHMAP_RRC,		/* rear right centre */
-	SOF_CHMAP_FLW,		/* front left wide */
-	SOF_CHMAP_FRW,		/* front right wide */
-	SOF_CHMAP_FLH,		/* front left high */
-	SOF_CHMAP_FCH,		/* front centre high */
-	SOF_CHMAP_FRH,		/* front right high */
-	SOF_CHMAP_TC,		/* top centre */
-	SOF_CHMAP_TFL,		/* top front left */
-	SOF_CHMAP_TFR,		/* top front right */
-	SOF_CHMAP_TFC,		/* top front centre */
-	SOF_CHMAP_TRL,		/* top rear left */
-	SOF_CHMAP_TRR,		/* top rear right */
-	SOF_CHMAP_TRC,		/* top rear centre */
-	SOF_CHMAP_TFLC,		/* top front left centre */
-	SOF_CHMAP_TFRC,		/* top front right centre */
-	SOF_CHMAP_TSL,		/* top side left */
-	SOF_CHMAP_TSR,		/* top side right */
-	SOF_CHMAP_LLFE,		/* left LFE */
-	SOF_CHMAP_RLFE,		/* right LFE */
-	SOF_CHMAP_BC,		/* bottom centre */
-	SOF_CHMAP_BLC,		/* bottom left centre */
-	SOF_CHMAP_BRC,		/* bottom right centre */
-	SOF_CHMAP_LAST = SOF_CHMAP_BRC,
-};
-
-/* common sample rates for use in masks */
-#define SOF_RATE_8000		(1 <<  0) /* 8000Hz  */
-#define SOF_RATE_11025		(1 <<  1) /* 11025Hz */
-#define SOF_RATE_12000		(1 <<  2) /* 12000Hz */
-#define SOF_RATE_16000		(1 <<  3) /* 16000Hz */
-#define SOF_RATE_22050		(1 <<  4) /* 22050Hz */
-#define SOF_RATE_24000		(1 <<  5) /* 24000Hz */
-#define SOF_RATE_32000		(1 <<  6) /* 32000Hz */
-#define SOF_RATE_44100		(1 <<  7) /* 44100Hz */
-#define SOF_RATE_48000		(1 <<  8) /* 48000Hz */
-#define SOF_RATE_64000		(1 <<  9) /* 64000Hz */
-#define SOF_RATE_88200		(1 << 10) /* 88200Hz */
-#define SOF_RATE_96000		(1 << 11) /* 96000Hz */
-#define SOF_RATE_176400		(1 << 12) /* 176400Hz */
-#define SOF_RATE_192000		(1 << 13) /* 192000Hz */
-
-/* continuous and non-standard rates for flexibility */
-#define SOF_RATE_CONTINUOUS	(1 << 30)  /* range */
-#define SOF_RATE_KNOT		(1 << 31)  /* non-continuous */
-
-/* stream PCM frame format */
-enum sof_ipc_frame {
-	SOF_IPC_FRAME_S16_LE = 0,
-	SOF_IPC_FRAME_S24_4LE,
-	SOF_IPC_FRAME_S32_LE,
-	SOF_IPC_FRAME_FLOAT,
-	/* other formats here */
-};
-
-/* stream buffer format */
-enum sof_ipc_buffer_format {
-	SOF_IPC_BUFFER_INTERLEAVED,
-	SOF_IPC_BUFFER_NONINTERLEAVED,
-	/* other formats here */
-};
-
-/* stream direction */
-enum sof_ipc_stream_direction {
-	SOF_IPC_STREAM_PLAYBACK = 0,
-	SOF_IPC_STREAM_CAPTURE,
-};
-
-/* stream ring info */
-struct sof_ipc_host_buffer {
-	uint32_t phy_addr;
-	uint32_t pages;
-	uint32_t size;
-	uint32_t offset;
-} __attribute__((packed));
-
-struct sof_ipc_stream_params {
-	struct sof_ipc_host_buffer buffer;
-	enum sof_ipc_stream_direction direction;
-	enum sof_ipc_frame frame_fmt;
-	enum sof_ipc_buffer_format buffer_fmt;
-	uint32_t stream_tag;
-	uint32_t rate;
-	uint32_t channels;
-	uint32_t sample_valid_bytes;
-	uint32_t sample_container_bytes;
-	/* for notifying host period has completed - 0 means no period IRQ */
-	uint32_t host_period_bytes;
-	enum sof_ipc_chmap chmap[SOF_IPC_MAX_CHANNELS];	/* channel map */
-} __attribute__((packed));
-
-/* PCM params info - SOF_IPC_STREAM_PCM_PARAMS */
-struct sof_ipc_pcm_params {
-	struct sof_ipc_hdr hdr;
-	uint32_t comp_id;
-	struct sof_ipc_stream_params params;
-	enum sof_ipc_chmap channel_map[];
-}  __attribute__((packed));
-
-/* PCM params info reply - SOF_IPC_STREAM_PCM_PARAMS_REPLY */
-struct sof_ipc_pcm_params_reply {
-	struct sof_ipc_reply rhdr;
-	uint32_t comp_id;
-	uint32_t posn_offset;
-}   __attribute__((packed));
-
-/* compressed vorbis params - SOF_IPC_STREAM_VORBIS_PARAMS */
-struct sof_ipc_vorbis_params {
-	struct sof_ipc_hdr hdr;
-	uint32_t comp_id;
-	struct sof_ipc_stream_params params;
-	/* TODO */
-}  __attribute__((packed));
-
-/* free stream - SOF_IPC_STREAM_PCM_PARAMS */
-struct sof_ipc_stream {
-	struct sof_ipc_hdr hdr;
-	uint32_t comp_id;
-} __attribute__((packed));
-
-/* flags indicating which time stamps are in sync with each other */
-#define	SOF_TIME_HOST_SYNC	(1 << 0)
-#define	SOF_TIME_DAI_SYNC	(1 << 1)
-#define	SOF_TIME_WALL_SYNC	(1 << 2)
-#define	SOF_TIME_STAMP_SYNC	(1 << 3)
-
-/* flags indicating which time stamps are valid */
-#define	SOF_TIME_HOST_VALID	(1 << 8)
-#define	SOF_TIME_DAI_VALID	(1 << 9)
-#define	SOF_TIME_WALL_VALID	(1 << 10)
-#define	SOF_TIME_STAMP_VALID	(1 << 11)
-
-/* flags indicating time stamps are 64bit else 3use low 32bit */
-#define	SOF_TIME_HOST_64	(1 << 16)
-#define	SOF_TIME_DAI_64		(1 << 17)
-#define	SOF_TIME_WALL_64	(1 << 18)
-#define	SOF_TIME_STAMP_64	(1 << 19)
-
-struct sof_ipc_stream_posn {
-	struct sof_ipc_reply rhdr;
-	uint32_t comp_id;	/* host component ID */
-	uint32_t flags;		/* SOF_TIME_ */
-	uint32_t wallclock_hz;	/* frequency of wallclock in Hz */
-	uint32_t timestamp_ns;	/* resolution of timestamp in ns */
-	uint64_t host_posn;	/* host DMA position in bytes */
-	uint64_t dai_posn;	/* DAI DMA position in bytes */
-	uint64_t comp_posn;	/* comp position in bytes */
-	uint64_t wallclock;	/* audio wall clock */
-	uint64_t timestamp;	/* system time stamp */
-	uint32_t xrun_comp_id;	/* comp ID of XRUN component */
-	int32_t xrun_size;	/* XRUN size in bytes */
-}  __attribute__((packed));
-
-/*
- * Component Mixers and Controls
- */
-
-/* control data type and direction */
-enum sof_ipc_ctrl_type {
-	/*  per channel data - uses struct sof_ipc_ctrl_value_chan */
-	SOF_CTRL_TYPE_VALUE_CHAN_GET = 0,
-	SOF_CTRL_TYPE_VALUE_CHAN_SET,
-	/* component data - uses struct sof_ipc_ctrl_value_comp */
-	SOF_CTRL_TYPE_VALUE_COMP_GET,
-	SOF_CTRL_TYPE_VALUE_COMP_SET,
-	/* bespoke data - struct struct sof_abi_hdr */
-	SOF_CTRL_TYPE_DATA_GET,
-	SOF_CTRL_TYPE_DATA_SET,
-};
-
-/* control command type */
-enum sof_ipc_ctrl_cmd {
-	SOF_CTRL_CMD_VOLUME = 0, /* maps to ALSA volume style controls */
-	SOF_CTRL_CMD_ENUM, /* maps to ALSA enum style controls */
-	SOF_CTRL_CMD_SWITCH, /* maps to ALSA switch style controls */
-	SOF_CTRL_CMD_BINARY, /* maps to ALSA binary style controls */
-};
-
-/* generic channel mapped value data */
-struct sof_ipc_ctrl_value_chan {
-	enum sof_ipc_chmap channel;
-	uint32_t value;
-} __attribute__((packed));
-
-/* generic component mapped value data */
-struct sof_ipc_ctrl_value_comp {
-	uint32_t index;	/* component source/sink/control index in control */
-	union {
-		uint32_t uvalue;
-		int32_t svalue;
-	};
-} __attribute__((packed));
-
-/* generic control data */
-struct sof_ipc_ctrl_data {
-	struct sof_ipc_reply rhdr;
-	uint32_t comp_id;
-
-	/* control access and data type */
-	enum sof_ipc_ctrl_type type;
-	enum sof_ipc_ctrl_cmd cmd;
-	uint32_t index; /* control index for comps > 1 control */
-
-	/* control data - can either be appended or DMAed from host */
-	struct sof_ipc_host_buffer buffer;
-	uint32_t num_elems;	/* in array elems or bytes */
-
-	/* control data - add new types if needed */
-	union {
-		/* channel values can be used by volume type controls */
-		struct sof_ipc_ctrl_value_chan chanv[0];
-		/* component values used by routing controls like mux, mixer */
-		struct sof_ipc_ctrl_value_comp compv[0];
-		/* data can be used by binary controls */
-		struct sof_abi_hdr data[0];
-	};
-} __attribute__((packed));
-
-/*
- * Component
- */
-
-/* types of component */
-enum sof_comp_type {
-	SOF_COMP_NONE = 0,
-	SOF_COMP_HOST,
-	SOF_COMP_DAI,
-	SOF_COMP_SG_HOST,	/* scatter gather variant */
-	SOF_COMP_SG_DAI,	/* scatter gather variant */
-	SOF_COMP_VOLUME,
-	SOF_COMP_MIXER,
-	SOF_COMP_MUX,
-	SOF_COMP_SRC,
-	SOF_COMP_SPLITTER,
-	SOF_COMP_TONE,
-	SOF_COMP_SWITCH,
-	SOF_COMP_BUFFER,
-	SOF_COMP_EQ_IIR,
-	SOF_COMP_EQ_FIR,
-	SOF_COMP_FILEREAD,	/* host test based file IO */
-	SOF_COMP_FILEWRITE,	/* host test based file IO */
-};
-
-/* XRUN action for component */
-#define SOF_XRUN_STOP		1	/* stop stream */
-#define SOF_XRUN_UNDER_ZERO	2	/* send 0s to sink */
-#define SOF_XRUN_OVER_NULL	4	/* send data to NULL */
-
-/* create new generic component - SOF_IPC_TPLG_COMP_NEW */
-struct sof_ipc_comp {
-	struct sof_ipc_hdr hdr;
-	uint32_t id;
-	enum sof_comp_type type;
-	uint32_t pipeline_id;
-} __attribute__((packed));
-
-/*
- * Component Buffers
- */
-
-/* create new component buffer - SOF_IPC_TPLG_BUFFER_NEW */
-struct sof_ipc_buffer {
-	struct sof_ipc_comp comp;
-	uint32_t size;		/* buffer size in bytes */
-	uint32_t caps;		/* SOF_MEM_CAPS_ */
-} __attribute__((packed));
-
-/* generic component config data - must always be after struct sof_ipc_comp */
-struct sof_ipc_comp_config {
-	uint32_t periods_sink;	/* 0 means variable */
-	uint32_t periods_source;	/* 0 means variable */
-	uint32_t preload_count;	/* how many periods to preload */
-	enum sof_ipc_frame frame_fmt;
-	uint32_t xrun_action;
-} __attribute__((packed));
-
-/* generic host component */
-struct sof_ipc_comp_host {
-	struct sof_ipc_comp comp;
-	struct sof_ipc_comp_config config;
-	enum sof_ipc_stream_direction direction;
-	uint32_t no_irq;	/* don't send periodic IRQ to host/DSP */
-	uint32_t dmac_id;
-	uint32_t dmac_chan;
-	uint32_t dmac_config; /* DMA engine specific */
-}  __attribute__((packed));
-
-/* generic DAI component */
-struct sof_ipc_comp_dai {
-	struct sof_ipc_comp comp;
-	struct sof_ipc_comp_config config;
-	enum sof_ipc_stream_direction direction;
-	uint32_t index;
-	enum sof_ipc_dai_type type;
-	uint32_t dmac_id;
-	uint32_t dmac_chan;
-	uint32_t dmac_config; /* DMA engine specific */
-}  __attribute__((packed));
-
-/* generic mixer component */
-struct sof_ipc_comp_mixer {
-	struct sof_ipc_comp comp;
-	struct sof_ipc_comp_config config;
-}  __attribute__((packed));
-
-/* volume ramping types */
-enum sof_volume_ramp {
-	SOF_VOLUME_LINEAR	= 0,
-	SOF_VOLUME_LOG,
-	SOF_VOLUME_LINEAR_ZC,
-	SOF_VOLUME_LOG_ZC,
-};
-
-/* generic volume component */
-struct sof_ipc_comp_volume {
-	struct sof_ipc_comp comp;
-	struct sof_ipc_comp_config config;
-	uint32_t channels;
-	int32_t min_value;
-	int32_t max_value;
-	enum sof_volume_ramp ramp;
-	uint32_t initial_ramp;	/* ramp space in ms */
-}  __attribute__((packed));
-
-/* generic SRC component */
-struct sof_ipc_comp_src {
-	struct sof_ipc_comp comp;
-	struct sof_ipc_comp_config config;
-	/* either source or sink rate must be non zero */
-	uint32_t source_rate;	/* source rate or 0 for variable */
-	uint32_t sink_rate;	/* sink rate or 0 for variable */
-	uint32_t rate_mask;	/* SOF_RATE_ supported rates */
-} __attribute__((packed));
-
-/* generic MUX component */
-struct sof_ipc_comp_mux {
-	struct sof_ipc_comp comp;
-	struct sof_ipc_comp_config config;
-} __attribute__((packed));
-
-/* generic tone generator component */
-struct sof_ipc_comp_tone {
-	struct sof_ipc_comp comp;
-	struct sof_ipc_comp_config config;
-	int32_t frequency;
-	int32_t amplitude;
-	int32_t freq_mult;
-	int32_t ampl_mult;
-	int32_t length;
-	int32_t period;
-	int32_t repeats;
-	int32_t ramp_step;
-} __attribute__((packed));
-
-/* FIR equalizer component */
-struct sof_ipc_comp_eq_fir {
-	struct sof_ipc_comp comp;
-	struct sof_ipc_comp_config config;
-} __attribute__((packed));
-
-/* IIR equalizer component */
-struct sof_ipc_comp_eq_iir {
-	struct sof_ipc_comp comp;
-	struct sof_ipc_comp_config config;
-} __attribute__((packed));
-
-/* frees components, buffers and pipelines
- * SOF_IPC_TPLG_COMP_FREE, SOF_IPC_TPLG_PIPE_FREE, SOF_IPC_TPLG_BUFFER_FREE
- */
-struct sof_ipc_free {
-	struct sof_ipc_hdr hdr;
-	uint32_t id;
-} __attribute__((packed));
-
-struct sof_ipc_comp_reply {
-	struct sof_ipc_reply rhdr;
-	uint32_t id;
-	uint32_t offset;
-} __attribute__((packed));
-
-/*
- * Pipeline
- */
-
-/* new pipeline - SOF_IPC_TPLG_PIPE_NEW */
-struct sof_ipc_pipe_new {
-	struct sof_ipc_hdr hdr;
-	uint32_t comp_id;	/* component id for pipeline */
-	uint32_t pipeline_id;	/* pipeline id */
-	uint32_t sched_id;	/* sheduling component id */
-	uint32_t core;		/* core we run on */
-	uint32_t deadline;	/* execution completion deadline in us*/
-	uint32_t priority;	/* priority level 0 (low) to 10 (max) */
-	uint32_t mips;		/* worst case instruction count per period */
-	uint32_t frames_per_sched;/* output frames of pipeline, 0 is variable */
-	uint32_t xrun_limit_usecs; /* report xruns greater than limit */
-	uint32_t timer;/* non zero if timer scheduled otherwise DAI scheduled */
-}  __attribute__((packed));
-
-/* pipeline construction complete - SOF_IPC_TPLG_PIPE_COMPLETE */
-struct sof_ipc_pipe_ready {
-	struct sof_ipc_hdr hdr;
-	uint32_t comp_id;
-}  __attribute__((packed));
-
-struct sof_ipc_pipe_free {
-	struct sof_ipc_hdr hdr;
-	uint32_t comp_id;
-}  __attribute__((packed));
-
-/* connect two components in pipeline - SOF_IPC_TPLG_COMP_CONNECT */
-struct sof_ipc_pipe_comp_connect {
-	struct sof_ipc_hdr hdr;
-	uint32_t source_id;
-	uint32_t sink_id;
-}  __attribute__((packed));
-
-/*
- * PM
- */
-
-/* PM context element */
-struct sof_ipc_pm_ctx_elem {
-	uint32_t type;
-	uint32_t size;
-	uint64_t addr;
-}  __attribute__((packed));
-
-/*
- * PM context - SOF_IPC_PM_CTX_SAVE, SOF_IPC_PM_CTX_RESTORE,
- * SOF_IPC_PM_CTX_SIZE
- */
-struct sof_ipc_pm_ctx {
-	struct sof_ipc_hdr hdr;
-	struct sof_ipc_host_buffer buffer;
-	uint32_t num_elems;
-	uint32_t size;
-	struct sof_ipc_pm_ctx_elem elems[];
-};
-
-/*
- * Firmware boot and version
- */
-
-#define SOF_IPC_MAX_ELEMS	16
-
-/* extended data types that can be appended onto end of sof_ipc_fw_ready */
-enum sof_ipc_ext_data {
-	SOF_IPC_EXT_DMA_BUFFER = 0,
-	SOF_IPC_EXT_WINDOW,
-};
-
-/* FW version - SOF_IPC_GLB_VERSION */
-struct sof_ipc_fw_version {
-	uint16_t major;
-	uint16_t minor;
-	uint16_t build;
-	uint8_t date[12];
-	uint8_t time[10];
-	uint8_t tag[6];
-} __attribute__((packed));
-
-/* FW ready Message - sent by firmware when boot has completed */
-struct sof_ipc_fw_ready {
-	struct sof_ipc_hdr hdr;
-	uint32_t dspbox_offset;	 /* dsp initiated IPC mailbox */
-	uint32_t hostbox_offset; /* host initiated IPC mailbox */
-	uint32_t dspbox_size;
-	uint32_t hostbox_size;
-	struct sof_ipc_fw_version version;
-} __attribute__((packed));
-
-/*
- * Extended Firmware data. All optional, depends on platform/arch.
- */
-
-enum sof_ipc_region {
-	SOF_IPC_REGION_DOWNBOX	= 0,
-	SOF_IPC_REGION_UPBOX,
-	SOF_IPC_REGION_TRACE,
-	SOF_IPC_REGION_DEBUG,
-	SOF_IPC_REGION_STREAM,
-	SOF_IPC_REGION_REGS,
-	SOF_IPC_REGION_EXCEPTION,
-};
-
-struct sof_ipc_ext_data_hdr {
-	struct sof_ipc_hdr hdr;
-	enum sof_ipc_ext_data type;			/* SOF_IPC_EXT_ */
-};
-
-struct sof_ipc_dma_buffer_elem {
-	enum sof_ipc_region type;
-	uint32_t id;	/* platform specific - used to map to host memory */
-	struct sof_ipc_host_buffer buffer;
-};
-
-/* extended data DMA buffers for IPC, trace and debug */
-struct sof_ipc_dma_buffer_data {
-	struct sof_ipc_ext_data_hdr ext_hdr;
-	uint32_t num_buffers;
-	/* host files in buffer[n].buffer */
-	struct sof_ipc_dma_buffer_elem buffer[];
-}  __attribute__((packed));
-
-struct sof_ipc_window_elem {
-	enum sof_ipc_region type;
-	uint32_t id;	/* platform specific - used to map to host memory */
-	uint32_t flags;	/* R, W, RW, etc - to define */
-	uint32_t size;	/* size of region in bytes */
-	/* offset in window region as windows can be partitioned */
-	uint32_t offset;
-};
-
-/* extended data memory windows for IPC, trace and debug */
-struct sof_ipc_window {
-	struct sof_ipc_ext_data_hdr ext_hdr;
-	uint32_t num_windows;
-	struct sof_ipc_window_elem window[];
-}  __attribute__((packed));
-
-/*
- * DMA for Trace
- */
-
-/* DMA for Trace params info - SOF_IPC_DEBUG_DMA_PARAMS */
-struct sof_ipc_dma_trace_params {
-	struct sof_ipc_hdr hdr;
-	struct sof_ipc_host_buffer buffer;
-	uint32_t stream_tag;
-}  __attribute__((packed));
-
-/* DMA for Trace params info - SOF_IPC_DEBUG_DMA_PARAMS */
-struct sof_ipc_dma_trace_posn {
-	struct sof_ipc_reply rhdr;
-	uint32_t host_offset;	/* Offset of DMA host buffer */
-	uint32_t overflow;	/* overflow bytes if any */
-	uint32_t messages;	/* total trace messages */
-}  __attribute__((packed));
-
-/*
- * Architecture specific debug
- */
-
-/* Xtensa Firmware Oops data */
-struct sof_ipc_dsp_oops_xtensa {
-	uint32_t exccause;
-	uint32_t excvaddr;
-	uint32_t ps;
-	uint32_t epc1;
-	uint32_t epc2;
-	uint32_t epc3;
-	uint32_t epc4;
-	uint32_t epc5;
-	uint32_t epc6;
-	uint32_t epc7;
-	uint32_t eps2;
-	uint32_t eps3;
-	uint32_t eps4;
-	uint32_t eps5;
-	uint32_t eps6;
-	uint32_t eps7;
-	uint32_t depc;
-	uint32_t intenable;
-	uint32_t interrupt;
-	uint32_t sar;
-	uint32_t stack;
-}  __attribute__((packed));
-
-#endif
diff --git a/include/uapi/sound/sof-tone.h b/include/uapi/sound/sof-tone.h
deleted file mode 100644
index f9c9bf5..0000000
--- a/include/uapi/sound/sof-tone.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/* SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note)) OR BSD-3-Clause) */
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Seppo Ingalsuo <seppo.ingalsuo@linux.intel.com>
- */
-
-#ifndef TONE_H
-#define TONE_H
-
-/* Component will reject non-matching configuration. The version number need
- * to be incremented with any ABI changes in function fir_cmd().
- */
-#define SOF_TONE_ABI_VERSION		1
-
-#define SOF_TONE_IDX_FREQUENCY		0
-#define SOF_TONE_IDX_AMPLITUDE		1
-#define SOF_TONE_IDX_FREQ_MULT		2
-#define SOF_TONE_IDX_AMPL_MULT		3
-#define SOF_TONE_IDX_LENGTH		4
-#define SOF_TONE_IDX_PERIOD		5
-#define SOF_TONE_IDX_REPEATS		6
-#define SOF_TONE_IDX_LIN_RAMP_STEP	7
-
-#endif /* TONE_ABI_H */
diff --git a/include/uapi/sound/sof-topology.h b/include/uapi/sound/sof-topology.h
deleted file mode 100644
index f4d2898..0000000
--- a/include/uapi/sound/sof-topology.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/* SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note)) OR BSD-3-Clause) */
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- *         Keyon Jie <yang.jie@linux.intel.com>
- */
-
-/*
- * Topology IDs and tokens.
- *
- * ** MUST BE ALIGNED WITH TOPOLOGY CONFIGURATION TOKEN VALUES **
- */
-
-#ifndef __INCLUDE_UAPI_SOF_TOPOLGOY_H__
-#define __INCLUDE_UAPI_SOF_TOPOLOGY_H__
-
-/*
- * Kcontrol IDs
- */
-#define SOF_TPLG_KCTL_VOL_ID	256
-#define SOF_TPLG_KCTL_ENUM_ID	257
-#define SOF_TPLG_KCTL_BYTES_ID	258
-
-/*
- * Tokens - must match values in topology configurations
- */
-
-/* buffers */
-#define SOF_TKN_BUF_SIZE			100
-#define SOF_TKN_BUF_CAPS			101
-
-/* DAI */
-#define SOF_TKN_DAI_DMAC			151
-#define	SOF_TKN_DAI_DMAC_CHAN			152
-#define	SOF_TKN_DAI_DMAC_CONFIG			153
-#define SOF_TKN_DAI_TYPE			154
-#define SOF_TKN_DAI_INDEX			155
-#define SOF_TKN_DAI_SAMPLE_BITS			156
-
-/* scheduling */
-#define SOF_TKN_SCHED_DEADLINE			200
-#define SOF_TKN_SCHED_PRIORITY			201
-#define SOF_TKN_SCHED_MIPS			202
-#define SOF_TKN_SCHED_CORE			203
-#define SOF_TKN_SCHED_FRAMES			204
-#define SOF_TKN_SCHED_TIMER			205
-
-/* volume */
-#define SOF_TKN_VOLUME_RAMP_STEP_TYPE		250
-#define SOF_TKN_VOLUME_RAMP_STEP_MS		251
-
-/* SRC */
-#define SOF_TKN_SRC_RATE_IN			300
-#define SOF_TKN_SRC_RATE_OUT			301
-
-/* PCM */
-#define SOF_TKN_PCM_DMAC			351
-#define SOF_TKN_PCM_DMAC_CHAN			352
-#define SOF_TKN_PCM_DMAC_CONFIG			353
-
-/* Generic components */
-#define SOF_TKN_COMP_PERIOD_SINK_COUNT		400
-#define SOF_TKN_COMP_PERIOD_SOURCE_COUNT	401
-#define SOF_TKN_COMP_FORMAT			402
-#define SOF_TKN_COMP_PRELOAD_COUNT		403
-
-#endif
diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 14ccc74f..2b5caa8 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1160,7 +1160,6 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 	list_del_init(&pcm->list);
 	for (cidx = 0; cidx < 2; cidx++) {
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next) {
-#if 0
 			snd_pcm_stream_lock_irq(substream);
 			if (substream->runtime) {
 				substream->runtime->status->state = SNDRV_PCM_STATE_DISCONNECTED;
@@ -1168,7 +1167,6 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 				wake_up(&substream->runtime->tsleep);
 			}
 			snd_pcm_stream_unlock_irq(substream);
-#endif
 		}
 	}
 	if (!pcm->internal) {
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index e8f3acae..d227581 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -65,7 +65,6 @@ source "sound/soc/rockchip/Kconfig"
 source "sound/soc/samsung/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/sirf/Kconfig"
-source "sound/soc/sof/Kconfig"
 source "sound/soc/spear/Kconfig"
 source "sound/soc/sti/Kconfig"
 source "sound/soc/stm/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 4e760a7..5327f4d 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -49,7 +49,6 @@ obj-$(CONFIG_SND_SOC)	+= rockchip/
 obj-$(CONFIG_SND_SOC)	+= samsung/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= sirf/
-obj-$(CONFIG_SND_SOC)	+= sof/
 obj-$(CONFIG_SND_SOC)	+= spear/
 obj-$(CONFIG_SND_SOC)	+= sti/
 obj-$(CONFIG_SND_SOC)	+= stm/
diff --git a/sound/soc/codecs/tdf8532.c b/sound/soc/codecs/tdf8532.c
index ccad958..1860e82 100644
--- a/sound/soc/codecs/tdf8532.c
+++ b/sound/soc/codecs/tdf8532.c
@@ -228,7 +228,6 @@ static int tdf8532_stop_play(struct tdf8532_priv *tdf8532)
 		goto out;
 
 	ret = tdf8532_wait_state(tdf8532, STATE_STBY, ACK_TIMEOUT);
-
 	if (ret < 0)
 		goto out;
 
@@ -239,13 +238,6 @@ static int tdf8532_stop_play(struct tdf8532_priv *tdf8532)
 	ret = tdf8532_wait_state(tdf8532, STATE_IDLE, ACK_TIMEOUT);
 
 out:
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
-	/*
-	 * FIXME: this is only work around to fix the stop failed issue on SOF,
-	 * return success always to make the next start successfully.
-	 */
-	ret = 0;
-#endif
 	return ret;
 }
 
@@ -317,8 +309,6 @@ static int tdf8532_i2c_probe(struct i2c_client *i2c,
 	int ret;
 	struct tdf8532_priv *dev_data;
 	struct device *dev = &(i2c->dev);
-	u8 payload[16];
-	int ret1;
 
 	dev_dbg(&i2c->dev, "%s\n", __func__);
 
@@ -342,48 +332,6 @@ static int tdf8532_i2c_probe(struct i2c_client *i2c,
 		goto out;
 	}
 
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
-	/* We support 2 channels, 16bit 48KHz for SOF only at the moment */
-	dev_data->channels = 2;
-	/* set format */
-	payload[0] = 0x02;
-	payload[1] = 0x00;
-	payload[2] = 0x08;
-	payload[3] = 0x80;/* ModuleId */
-	payload[4] = 0x1c;/* CmdId, SetAudioConfig_cmd */
-	payload[5] = 0;/* rfa */
-	payload[6] = 0x01;/* SamplingFrequency, 48KHz */
-	payload[7] = 0x00;/* FrameSize, 2 slots per I2S frame */
-	payload[8] = 0x00;/* SlotSize, 16bit */
-	/* TDMFrameSync, TDM frame starts at rising edge frame sync */
-	payload[9] = 0x1;
-	payload[10] = 0x1;/* BitClockDelay, no delay */
-	ret1 = i2c_master_send(dev_data->i2c, payload, 11);
-
-	/* set routing */
-	payload[0] = 0x02;
-	payload[1] = 0x00;
-	payload[2] = 0x06;
-	payload[3] = 0x80;/* ModuleId */
-	payload[4] = 0x28;/* CmdId, SetAudioRoutingConfig_cmd */
-	/* channel 0 */
-	payload[5] = 0;/* AudioSource, SDI1 */
-	payload[6] = 0x00;/* SlotNr, Slot 0 */
-	/* channel 1 */
-	payload[7] = 0;/* AudioSource, SDI1 */
-	payload[8] = 0x01;/* SlotNr, Slot 1 */
-	ret1 = i2c_master_send(dev_data->i2c, payload, 9);
-
-	/* initial to disable all channels */
-	ret = tdf8532_amp_write(dev_data, SET_CHNL_DISABLE,
-			CHNL_MASK(8));
-
-#endif
-
-	if (ret < 0)
-		dev_err(&i2c->dev,
-			"i2c send set format packet returned:%d\n", ret);
-
 out:
 	return ret;
 }
diff --git a/sound/soc/intel/Kconfig b/sound/soc/intel/Kconfig
index c4336f5..c75d2aa 100644
--- a/sound/soc/intel/Kconfig
+++ b/sound/soc/intel/Kconfig
@@ -115,14 +115,12 @@ config SND_SOC_INTEL_SKYLAKE
 	  GeminiLake or CannonLake platform with the DSP enabled in the BIOS
 	  then enable this option by saying Y or m.
 
-endif ## SND_SOC_INTEL_SST_TOPLEVEL
-
-if SND_SOC_INTEL_SST_TOPLEVEL || SND_SOC_SOF_INTEL
 config SND_SOC_ACPI_INTEL_MATCH
 	tristate
 	select SND_SOC_ACPI if ACPI
 	# this option controls the compilation of ACPI matching tables and
 	# helpers and is not meant to be selected by the user.
+
 endif ## SND_SOC_INTEL_SST_TOPLEVEL
 
 # ASoC codec drivers
diff --git a/sound/soc/intel/boards/Kconfig b/sound/soc/intel/boards/Kconfig
index 86584c3..71041d8 100644
--- a/sound/soc/intel/boards/Kconfig
+++ b/sound/soc/intel/boards/Kconfig
@@ -1,6 +1,6 @@
 menuconfig SND_SOC_INTEL_MACH
 	bool "Intel Machine drivers"
-	depends on SND_SOC_INTEL_SST_TOPLEVEL || SND_SOC_SOF_INTEL
+	depends on SND_SOC_INTEL_SST_TOPLEVEL
 	help
          Intel ASoC Machine Drivers. If you have a Intel machine that
          has an audio controller with a DSP and I2S or DMIC port, then
@@ -12,7 +12,7 @@ menuconfig SND_SOC_INTEL_MACH
 
 if SND_SOC_INTEL_MACH
 
-if SND_SOC_INTEL_HASWELL || SND_SOC_SOF_HASWELL
+if SND_SOC_INTEL_HASWELL
 
 config SND_SOC_INTEL_HASWELL_MACH
 	tristate "Haswell Lynxpoint"
@@ -24,10 +24,6 @@ config SND_SOC_INTEL_HASWELL_MACH
 	  Say Y or m if you have such a device.
 	  If unsure select "N".
 
-endif ## SND_SOC_INTEL_HASWELL || SND_SOC_SOF_HASWELL
-
-if SND_SOC_INTEL_HASWELL || SND_SOC_SOF_BROADWELL
-
 config SND_SOC_INTEL_BDW_RT5677_MACH
 	tristate "Broadwell with RT5677 codec"
 	depends on X86_INTEL_LPSS && I2C && I2C_DESIGNWARE_PLATFORM && GPIOLIB
@@ -47,7 +43,7 @@ config SND_SOC_INTEL_BROADWELL_MACH
 	  Ultrabook platforms.
 	  Say Y or m if you have such a device. This is a recommended option.
 	  If unsure select "N".
-endif ## SND_SOC_INTEL_HASWELL || SND_SOC_SOF_BROADWELL
+endif ## SND_SOC_INTEL_HASWELL
 
 if SND_SOC_INTEL_BAYTRAIL
 
@@ -72,7 +68,7 @@ config SND_SOC_INTEL_BYT_RT5640_MACH
 
 endif ## SND_SOC_INTEL_BAYTRAIL
 
-if SND_SST_ATOM_HIFI2_PLATFORM || SND_SOC_SOF_BAYTRAIL
+if SND_SST_ATOM_HIFI2_PLATFORM
 
 config SND_SOC_INTEL_BYTCR_RT5640_MACH
 	tristate "Baytrail and Baytrail-CR with RT5640 codec"
@@ -163,7 +159,7 @@ config SND_SOC_INTEL_BYT_CHT_NOCODEC_MACH
 
 	  If unsure select "N".
 
-endif ## SND_SST_ATOM_HIFI2_PLATFORM || SND_SOC_SOF_BAYTRAIL
+endif ## SND_SST_ATOM_HIFI2_PLATFORM
 
 if SND_SOC_INTEL_SKYLAKE
 
@@ -205,10 +201,6 @@ config SND_SOC_INTEL_SKL_NAU88L25_MAX98357A_MACH
 	  Say Y or m if you have such a device. This is a recommended option.
 	  If unsure select "N".
 
-endif ## SND_SOC_INTEL_SKYLAKE
-
-if SND_SOC_INTEL_SKYLAKE || SND_SOC_SOF_APOLLOLAKE
-
 config SND_SOC_INTEL_BXT_DA7219_MAX98357A_MACH
 	tristate "Broxton with DA7219 and MAX98357A in I2S Mode"
 	depends on MFD_INTEL_LPSS && I2C && ACPI
@@ -246,10 +238,6 @@ config SND_SOC_INTEL_BXT_TDF8532_MACH
 	   Say Y if you have such a device.
 	   If unsure select "N".
  
-endif ##  SND_SOC_INTEL_SKYLAKE || SND_SOC_SOF_APOLLOLAKE
-
-if  SND_SOC_INTEL_SKYLAKE
-
 config SND_SOC_INTEL_KBL_RT5663_MAX98927_MACH
 	tristate "KBL with RT5663 and MAX98927 in I2S Mode"
 	depends on MFD_INTEL_LPSS && I2C && ACPI
diff --git a/sound/soc/intel/boards/bdw-rt5677.c b/sound/soc/intel/boards/bdw-rt5677.c
index d9f1456..058b8cc 100644
--- a/sound/soc/intel/boards/bdw-rt5677.c
+++ b/sound/soc/intel/boards/bdw-rt5677.c
@@ -181,7 +181,6 @@ static const struct snd_soc_ops bdw_rt5677_ops = {
 	.hw_params = bdw_rt5677_hw_params,
 };
 
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 static int bdw_rt5677_rtd_init(struct snd_soc_pcm_runtime *rtd)
 {
 	struct sst_pdata *pdata = dev_get_platdata(rtd->platform->dev);
@@ -199,7 +198,6 @@ static int bdw_rt5677_rtd_init(struct snd_soc_pcm_runtime *rtd)
 
 	return 0;
 }
-#endif
 
 static int bdw_rt5677_init(struct snd_soc_pcm_runtime *rtd)
 {
@@ -267,9 +265,7 @@ static struct snd_soc_dai_link bdw_rt5677_dais[] = {
 		.dynamic = 1,
 		.codec_name = "snd-soc-dummy",
 		.codec_dai_name = "snd-soc-dummy-dai",
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 		.init = bdw_rt5677_rtd_init,
-#endif
 		.trigger = {
 			SND_SOC_DPCM_TRIGGER_POST,
 			SND_SOC_DPCM_TRIGGER_POST
diff --git a/sound/soc/intel/boards/broadwell.c b/sound/soc/intel/boards/broadwell.c
index ad6ca17..88c26ab 100644
--- a/sound/soc/intel/boards/broadwell.c
+++ b/sound/soc/intel/boards/broadwell.c
@@ -130,7 +130,6 @@ static const struct snd_soc_ops broadwell_rt286_ops = {
 	.hw_params = broadwell_rt286_hw_params,
 };
 
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 static int broadwell_rtd_init(struct snd_soc_pcm_runtime *rtd)
 {
 	struct sst_pdata *pdata = dev_get_platdata(rtd->platform->dev);
@@ -148,7 +147,6 @@ static int broadwell_rtd_init(struct snd_soc_pcm_runtime *rtd)
 
 	return 0;
 }
-#endif
 
 /* broadwell digital audio interface glue - connects codec <--> CPU */
 static struct snd_soc_dai_link broadwell_rt286_dais[] = {
@@ -161,9 +159,7 @@ static struct snd_soc_dai_link broadwell_rt286_dais[] = {
 		.dynamic = 1,
 		.codec_name = "snd-soc-dummy",
 		.codec_dai_name = "snd-soc-dummy-dai",
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 		.init = broadwell_rtd_init,
-#endif
 		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
 		.dpcm_playback = 1,
 		.dpcm_capture = 1,
diff --git a/sound/soc/intel/boards/bxt_tdf8532.c b/sound/soc/intel/boards/bxt_tdf8532.c
index 275ecd6..f904e18 100644
--- a/sound/soc/intel/boards/bxt_tdf8532.c
+++ b/sound/soc/intel/boards/bxt_tdf8532.c
@@ -37,7 +37,7 @@ static const struct snd_soc_dapm_widget broxton_tdf8532_widgets[] = {
 };
 
 static const struct snd_soc_dapm_route broxton_tdf8532_map[] = {
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
+
 	/* Speaker BE connections */
 	{ "Speaker", NULL, "ssp4 Tx"},
 	{ "ssp4 Tx", NULL, "codec0_out"},
@@ -74,7 +74,6 @@ static const struct snd_soc_dapm_route broxton_tdf8532_map[] = {
 
 	{ "ModemUl", NULL, "ssp3 Tx"},
 	{ "ssp3 Tx", NULL, "Modem_ssp3_out"},
-#endif
 };
 
 #if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
@@ -93,7 +92,6 @@ static int bxt_tdf8532_ssp2_fixup(struct snd_soc_pcm_runtime *rtd,
 
 /* broxton digital audio interface glue - connects codec <--> CPU */
 static struct snd_soc_dai_link broxton_tdf8532_dais[] = {
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 	/* Front End DAI links */
 	{
 		.name = "Speaker Port",
@@ -381,33 +379,12 @@ static struct snd_soc_dai_link broxton_tdf8532_dais[] = {
 		.dpcm_playback = 1,
 		.no_pcm = 1,
 	},
-#else
-	{
-		/* SSP4 - Amplifier */
-		.name = "SSP4-Codec",
-		.id = 0,
-		.cpu_dai_name = "sof-audio",
-		.platform_name = "sof-audio",
-		.codec_name = "i2c-INT34C3:00",
-		.codec_dai_name = "tdf8532-hifi",
-		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
-			SND_SOC_DAIFMT_CBS_CFS,
-		.ignore_suspend = 1,
-		.dpcm_playback = 1,
-		.no_pcm = 1,
-	},
-#endif
 };
 
 static int bxt_add_dai_link(struct snd_soc_card *card,
 			struct snd_soc_dai_link *link)
 {
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 	link->platform_name = "0000:00:0e.0";
-#else
-	link->trigger[0] = SND_SOC_DPCM_TRIGGER_PRE;
-	link->trigger[1] = SND_SOC_DPCM_TRIGGER_PRE;
-#endif
 	link->nonatomic = 1;
 	return 0;
 }
@@ -455,4 +432,3 @@ module_platform_driver(broxton_tdf8532_audio)
 MODULE_DESCRIPTION("Intel SST Audio for Broxton GP MRB");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("platform:gpmrb_machine");
-MODULE_ALIAS("platform:bxt_tdf8532");
diff --git a/sound/soc/intel/boards/bytcht_da7213.c b/sound/soc/intel/boards/bytcht_da7213.c
index 1e90a9c..2179ded 100644
--- a/sound/soc/intel/boards/bytcht_da7213.c
+++ b/sound/soc/intel/boards/bytcht_da7213.c
@@ -56,7 +56,6 @@ static const struct snd_soc_dapm_route audio_map[] = {
 	{"MIC1", NULL, "Headset Mic"},
 	{"MIC2", NULL, "Mic"},
 
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 	/* SOC-codec link */
 	{"ssp2 Tx", NULL, "codec_out0"},
 	{"ssp2 Tx", NULL, "codec_out1"},
@@ -65,7 +64,6 @@ static const struct snd_soc_dapm_route audio_map[] = {
 
 	{"Playback", NULL, "ssp2 Tx"},
 	{"ssp2 Rx", NULL, "Capture"},
-#endif
 };
 
 static int codec_fixup(struct snd_soc_pcm_runtime *rtd,
diff --git a/sound/soc/intel/boards/bytcr_rt5640.c b/sound/soc/intel/boards/bytcr_rt5640.c
index 7786d93..b6a1cfe 100644
--- a/sound/soc/intel/boards/bytcr_rt5640.c
+++ b/sound/soc/intel/boards/bytcr_rt5640.c
@@ -489,7 +489,6 @@ static int byt_rt5640_init(struct snd_soc_pcm_runtime *runtime)
 	if (ret)
 		return ret;
 
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 	if (byt_rt5640_quirk & BYT_RT5640_SSP2_AIF2) {
 		ret = snd_soc_dapm_add_routes(&card->dapm,
 					byt_rt5640_ssp2_aif2_map,
@@ -509,7 +508,6 @@ static int byt_rt5640_init(struct snd_soc_pcm_runtime *runtime)
 	}
 	if (ret)
 		return ret;
-#endif
 
 	if (byt_rt5640_quirk & BYT_RT5640_MONO_SPEAKER) {
 		ret = snd_soc_dapm_add_routes(&card->dapm,
@@ -777,13 +775,11 @@ static int snd_byt_rt5640_mc_probe(struct platform_device *pdev)
 	 * (will be overridden if DMI quirk is detected)
 	 */
 	if (is_valleyview()) {
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL) /* FIXME: bytcr not supported yet */
 		struct sst_platform_info *p_info = mach->pdata;
 		const struct sst_res_info *res_info = p_info->res_info;
 
 		if (res_info->acpi_ipc_irq_index == 0)
 			is_bytcr = true;
-#endif
 	}
 
 	if (is_bytcr) {
diff --git a/sound/soc/intel/boards/bytcr_rt5651.c b/sound/soc/intel/boards/bytcr_rt5651.c
index a9e9938..456526a 100644
--- a/sound/soc/intel/boards/bytcr_rt5651.c
+++ b/sound/soc/intel/boards/bytcr_rt5651.c
@@ -144,14 +144,14 @@ static const struct snd_soc_dapm_route byt_rt5651_audio_map[] = {
 	{"Internal Mic", NULL, "Platform Clock"},
 	{"Speaker", NULL, "Platform Clock"},
 	{"Line In", NULL, "Platform Clock"},
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
+
 	{"AIF1 Playback", NULL, "ssp2 Tx"},
 	{"ssp2 Tx", NULL, "codec_out0"},
 	{"ssp2 Tx", NULL, "codec_out1"},
 	{"codec_in0", NULL, "ssp2 Rx"},
 	{"codec_in1", NULL, "ssp2 Rx"},
 	{"ssp2 Rx", NULL, "AIF1 Capture"},
-#endif
+
 	{"Headset Mic", NULL, "micbias1"}, /* lowercase for rt5651 */
 	{"Headphone", NULL, "HPOL"},
 	{"Headphone", NULL, "HPOR"},
diff --git a/sound/soc/intel/boards/cht_bsw_max98090_ti.c b/sound/soc/intel/boards/cht_bsw_max98090_ti.c
index bbb281f..d3e1c7e 100644
--- a/sound/soc/intel/boards/cht_bsw_max98090_ti.c
+++ b/sound/soc/intel/boards/cht_bsw_max98090_ti.c
@@ -88,14 +88,12 @@ static const struct snd_soc_dapm_route cht_audio_map[] = {
 	{"Headphone", NULL, "HPR"},
 	{"Ext Spk", NULL, "SPKL"},
 	{"Ext Spk", NULL, "SPKR"},
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 	{"HiFi Playback", NULL, "ssp2 Tx"},
 	{"ssp2 Tx", NULL, "codec_out0"},
 	{"ssp2 Tx", NULL, "codec_out1"},
 	{"codec_in0", NULL, "ssp2 Rx" },
 	{"codec_in1", NULL, "ssp2 Rx" },
 	{"ssp2 Rx", NULL, "HiFi Capture"},
-#endif
 	{"Headphone", NULL, "Platform Clock"},
 	{"Headset Mic", NULL, "Platform Clock"},
 	{"Int Mic", NULL, "Platform Clock"},
diff --git a/sound/soc/intel/boards/cht_bsw_rt5645.c b/sound/soc/intel/boards/cht_bsw_rt5645.c
index a159bd0..31641aa 100644
--- a/sound/soc/intel/boards/cht_bsw_rt5645.c
+++ b/sound/soc/intel/boards/cht_bsw_rt5645.c
@@ -160,43 +160,35 @@ static const struct snd_soc_dapm_route cht_rt5650_audio_map[] = {
 };
 
 static const struct snd_soc_dapm_route cht_rt5645_ssp2_aif1_map[] = {
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 	{"AIF1 Playback", NULL, "ssp2 Tx"},
 	{"ssp2 Tx", NULL, "codec_out0"},
 	{"ssp2 Tx", NULL, "codec_out1"},
 	{"codec_in0", NULL, "ssp2 Rx" },
 	{"codec_in1", NULL, "ssp2 Rx" },
 	{"ssp2 Rx", NULL, "AIF1 Capture"},
-#endif
 };
 
 static const struct snd_soc_dapm_route cht_rt5645_ssp2_aif2_map[] = {
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 	{"AIF2 Playback", NULL, "ssp2 Tx"},
 	{"ssp2 Tx", NULL, "codec_out0"},
 	{"ssp2 Tx", NULL, "codec_out1"},
 	{"codec_in0", NULL, "ssp2 Rx" },
 	{"codec_in1", NULL, "ssp2 Rx" },
 	{"ssp2 Rx", NULL, "AIF2 Capture"},
-#endif
 };
 
 static const struct snd_soc_dapm_route cht_rt5645_ssp0_aif1_map[] = {
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 	{"AIF1 Playback", NULL, "ssp0 Tx"},
 	{"ssp0 Tx", NULL, "modem_out"},
 	{"modem_in", NULL, "ssp0 Rx" },
 	{"ssp0 Rx", NULL, "AIF1 Capture"},
-#endif
 };
 
 static const struct snd_soc_dapm_route cht_rt5645_ssp0_aif2_map[] = {
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 	{"AIF2 Playback", NULL, "ssp0 Tx"},
 	{"ssp0 Tx", NULL, "modem_out"},
 	{"modem_in", NULL, "ssp0 Rx" },
 	{"ssp0 Rx", NULL, "AIF2 Capture"},
-#endif
 };
 
 static const struct snd_kcontrol_new cht_mc_controls[] = {
@@ -593,13 +585,11 @@ static int snd_cht_mc_probe(struct platform_device *pdev)
 	 * (will be overridden if DMI quirk is detected)
 	 */
 	if (is_valleyview()) {
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL) /* FIXME: bytcr not supported yet */
 		struct sst_platform_info *p_info = mach->pdata;
 		const struct sst_res_info *res_info = p_info->res_info;
 
 		if (res_info->acpi_ipc_irq_index == 0)
 			is_bytcr = true;
-#endif
 	}
 
 	if (is_bytcr) {
diff --git a/sound/soc/intel/boards/cht_bsw_rt5672.c b/sound/soc/intel/boards/cht_bsw_rt5672.c
index 0062d73..49cf30c 100644
--- a/sound/soc/intel/boards/cht_bsw_rt5672.c
+++ b/sound/soc/intel/boards/cht_bsw_rt5672.c
@@ -127,14 +127,12 @@ static const struct snd_soc_dapm_route cht_audio_map[] = {
 	{"Ext Spk", NULL, "SPOLN"},
 	{"Ext Spk", NULL, "SPORP"},
 	{"Ext Spk", NULL, "SPORN"},
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 	{"AIF1 Playback", NULL, "ssp2 Tx"},
 	{"ssp2 Tx", NULL, "codec_out0"},
 	{"ssp2 Tx", NULL, "codec_out1"},
 	{"codec_in0", NULL, "ssp2 Rx"},
 	{"codec_in1", NULL, "ssp2 Rx"},
 	{"ssp2 Rx", NULL, "AIF1 Capture"},
-#endif
 	{"Headphone", NULL, "Platform Clock"},
 	{"Headset Mic", NULL, "Platform Clock"},
 	{"Int Mic", NULL, "Platform Clock"},
diff --git a/sound/soc/intel/boards/haswell.c b/sound/soc/intel/boards/haswell.c
index 082fcbf..39c38f1 100644
--- a/sound/soc/intel/boards/haswell.c
+++ b/sound/soc/intel/boards/haswell.c
@@ -85,7 +85,6 @@ static const struct snd_soc_ops haswell_rt5640_ops = {
 	.hw_params = haswell_rt5640_hw_params,
 };
 
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 static int haswell_rtd_init(struct snd_soc_pcm_runtime *rtd)
 {
 	struct sst_pdata *pdata = dev_get_platdata(rtd->platform->dev);
@@ -103,7 +102,6 @@ static int haswell_rtd_init(struct snd_soc_pcm_runtime *rtd)
 
 	return 0;
 }
-#endif
 
 static struct snd_soc_dai_link haswell_rt5640_dais[] = {
 	/* Front End DAI links */
@@ -115,9 +113,7 @@ static struct snd_soc_dai_link haswell_rt5640_dais[] = {
 		.dynamic = 1,
 		.codec_name = "snd-soc-dummy",
 		.codec_dai_name = "snd-soc-dummy-dai",
-#if !IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL)
 		.init = haswell_rtd_init,
-#endif
 		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
 		.dpcm_playback = 1,
 		.dpcm_capture = 1,
diff --git a/sound/soc/soc-topology.c b/sound/soc/soc-topology.c
index b4242a0..419ee6f 100644
--- a/sound/soc/soc-topology.c
+++ b/sound/soc/soc-topology.c
@@ -1294,9 +1294,6 @@ static struct snd_kcontrol_new *soc_tplg_dapm_widget_dmixer_create(
 			kfree(sm);
 			continue;
 		}
-
-		/* create any TLV data */
-		soc_tplg_create_tlv(tplg, &kc[i], &mc->hdr);
 	}
 	return kc;
 
diff --git a/sound/soc/sof/Kconfig b/sound/soc/sof/Kconfig
deleted file mode 100644
index cdd5fd4..0000000
--- a/sound/soc/sof/Kconfig
+++ /dev/null
@@ -1,110 +0,0 @@
-config SND_SOC_SOF_PCI
-	tristate
-
-config SND_SOC_SOF_ACPI
-	tristate
-
-config SND_SOC_SOF_PLATFORM
-	tristate
-
-
-config SND_SOC_SOF
-	tristate "Sound Open Firmware Support"
-	default m
-	depends on SND_DMA_SGBUF
-	select SND_SOC_TOPOLOGY
-	select SND_SOC_COMPRESS
-	help
-          This adds support for SOF
-          Say Y if you have such a device.
-          If unsure select "N".
-
-config SND_SOC_SOF_NOCODEC
-	tristate "SOF nocodec mode Support"
-	depends on SND_SOC_SOF
-	help
-          This adds support for a dummy/nocodec machine driver fallback
-	  option if no known codec is detected. This is typically only
-	  enabled for developers or devices where the sound card is
-	  controlled externally
-          Say Y if you need this nocodec fallback option
-          If unsure select "N".
-
-config SND_SOC_SOF_FORCE_NOCODEC_MODE
-	tristate "SOF force nocodec Mode"
-	depends on SND_SOC_SOF_NOCODEC
-	help
-          This forces SOF to use dummy/nocodec as machine driver, even
-	  though there is a codec detected on the real platform. This is
-	  typically only enabled for developers for debug purposes, before
-	  codec/machine driver is ready, or to exclude the impact of those
-	  drivers
-          Say Y if you need this force nocodec mode option
-          If unsure select "N".
-
-config SND_SOC_SOF_INTEL
-	tristate "SOF support for Intel audio DSPs"
-	depends on SND_SOC_SOF
-	select SND_SOC_INTEL_MACH
-	help
-          This adds support for Sound Open Firmware for Intel(R) platforms.
-          Say Y if you have such a device.
-          If unsure select "N".
-
-if SND_SOC_SOF_INTEL
-
-config SND_SOC_SOF_BAYTRAIL
-	tristate "SOF support for Baytrail, Braswell and Cherrytrail"
-	select SND_SOC_SOF_ACPI
-	select SND_SOC_ACPI_INTEL_MATCH
-	help
-          This adds support for Sound Open Firmware for Intel(R) platforms
-          using the Baytrail, Braswell or Cherrytrail processors.
-          Say Y if you have such a device.
-          If unsure select "N".
-
-config SND_SOC_SOF_HASWELL
-	tristate "SOF support for Haswell"
-	select SND_SOC_SOF_ACPI
-	select SND_SOC_ACPI_INTEL_MATCH
-	help
-          This adds support for Sound Open Firmware for Intel(R) platforms
-          using the Haswell processors.
-          Say Y if you have such a device.
-          If unsure select "N".
-
-config SND_SOC_SOF_BROADWELL
-	tristate "SOF support for Broadwell"
-	depends on SND_SOC_SOF_INTEL
-	select SND_SOC_SOF_ACPI
-	select SND_SOC_ACPI_INTEL_MATCH
-	help
-          This adds support for Sound Open Firmware for Intel(R) platforms
-          using the Broadwell processors.
-          Say Y if you have such a device.
-          If unsure select "N".
-
-config SND_SOC_SOF_APOLLOLAKE
-	tristate "SOF support for Apollolake"
-	select SND_SOC_SOF_HDA_COMMON
-	help
-          This adds support for Sound Open Firmware for Intel(R) platforms
-          using the Apollolake processors.
-          Say Y if you have such a device.
-          If unsure select "N".
-
-config SND_SOC_SOF_CANNONLAKE
-	tristate "SOF support for Cannonlake"
-	select SND_SOC_SOF_HDA_COMMON
-	help
-          This adds support for Sound Open Firmware for Intel(R) platforms
-          using the Cannonlake processors.
-          Say Y if you have such a device.
-          If unsure select "N".
-
-config SND_SOC_SOF_HDA_COMMON
-	tristate
-	select SND_SOC_SOF_PCI
-	select SND_SOC_ACPI_INTEL_MATCH
-
-endif ## SND_SOC_SOF_INTEL
diff --git a/sound/soc/sof/Makefile b/sound/soc/sof/Makefile
deleted file mode 100644
index b594c4e..0000000
--- a/sound/soc/sof/Makefile
+++ /dev/null
@@ -1,26 +0,0 @@
-snd-sof-objs := core.o ops.o loader.o ipc.o pcm.o pm.o debug.o topology.o\
-		control.o trace.o compressed.o
-snd-sof-intel-byt-objs := hw-byt.o
-snd-sof-intel-hsw-objs := hw-hsw.o
-snd-sof-intel-bdw-objs := hw-bdw.o
-snd-sof-intel-hda-common-objs := hw-apl.o
-snd-sof-spi-objs := hw-spi.o
-
-snd-sof-pci-objs := sof-pci-dev.o
-snd-sof-acpi-objs := sof-acpi-dev.o
-snd-sof-platform-objs := sof-platform-dev.o
-snd-sof-nocodec-objs := nocodec.o
-
-obj-$(CONFIG_SND_SOC_SOF) += snd-sof.o
-obj-$(CONFIG_SND_SOC_SOF_NOCODEC) += snd-sof-nocodec.o
-
-obj-$(CONFIG_SND_SOC_SOF_ACPI) += sof-acpi-dev.o
-obj-$(CONFIG_SND_SOC_SOF_PCI) += sof-pci-dev.o
-obj-$(CONFIG_SND_SOC_SOF_SPI) += sof-spi-dev.o
-obj-$(SND_SOC_SOF_PLATFORM) += sof-platform-dev.o
-
-obj-$(CONFIG_SND_SOC_SOF_BAYTRAIL) += snd-sof-intel-byt.o
-obj-$(CONFIG_SND_SOC_SOF_HASWELL) += snd-sof-intel-hsw.o
-obj-$(CONFIG_SND_SOC_SOF_BROADWELL) += snd-sof-intel-bdw.o
-obj-$(CONFIG_SND_SOC_SOF_HDA_COMMON) += snd-sof-intel-hda-common.o
-obj-$(CONFIG_SND_SOC_SOF_SPIDSP) += snd-sof-spi.o
diff --git a/sound/soc/sof/compressed.c b/sound/soc/sof/compressed.c
deleted file mode 100644
index 64b35fb..0000000
--- a/sound/soc/sof/compressed.c
+++ /dev/null
@@ -1,168 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-#include <linux/slab.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/pm_runtime.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/sof.h>
-#include <sound/compress_driver.h>
-#include <uapi/sound/sof-ipc.h>
-#include "sof-priv.h"
-
-static int sof_compressed_open(struct snd_compr_stream *cstream)
-{
-	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct snd_sof_pcm *spcm = rtd->sof;
-
-	mutex_lock(&spcm->mutex);
-	pm_runtime_get_sync(sdev->dev);
-	mutex_unlock(&spcm->mutex);
-	return 0;
-}
-
-static int sof_compressed_free(struct snd_compr_stream *cstream)
-{
-	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct snd_sof_pcm *spcm = rtd->sof;
-
-	mutex_lock(&spcm->mutex);
-	pm_runtime_put(sdev->dev);
-	mutex_unlock(&spcm->mutex);
-	return 0;
-}
-
-static int sof_vorbis_set_params(struct snd_compr_stream *cstream,
-				 struct snd_compr_params *params)
-{
-	return 0;
-}
-
-static int sof_mp3_set_params(struct snd_compr_stream *cstream,
-			      struct snd_compr_params *params)
-{
-	return 0;
-}
-
-static int sof_compressed_set_params(struct snd_compr_stream *cstream,
-				     struct snd_compr_params *params)
-{
-	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-
-	switch (params->codec.id) {
-	case SND_AUDIOCODEC_VORBIS:
-		return sof_vorbis_set_params(cstream, params);
-	case SND_AUDIOCODEC_MP3:
-		return sof_mp3_set_params(cstream, params);
-	default:
-		dev_err(sdev->dev, "error: codec id %d not supported\n",
-			params->codec.id);
-		return -EINVAL;
-	}
-}
-
-static int sof_compressed_trigger(struct snd_compr_stream *cstream, int cmd)
-{
-	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct snd_sof_pcm *spcm = rtd->sof;
-	struct sof_ipc_stream stream;
-	struct sof_ipc_reply reply;
-
-	stream.hdr.size = sizeof(stream);
-	stream.hdr.cmd = SOF_IPC_GLB_STREAM_MSG;
-	stream.comp_id = spcm->stream[cstream->direction].comp_id;
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-		stream.hdr.cmd |= SOF_IPC_STREAM_TRIG_START;
-		break;
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		stream.hdr.cmd |= SOF_IPC_STREAM_TRIG_RELEASE;
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-		stream.hdr.cmd |= SOF_IPC_STREAM_TRIG_STOP;
-		break;
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		stream.hdr.cmd |= SOF_IPC_STREAM_TRIG_PAUSE;
-		break;
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	default:
-		break;
-	}
-
-	/* send IPC to the DSP */
-	return sof_ipc_tx_message(sdev->ipc, stream.hdr.cmd, &stream,
-		sizeof(stream), &reply, sizeof(reply));
-}
-
-static int sof_compressed_pointer(struct snd_compr_stream *cstream,
-				  struct snd_compr_tstamp *tstamp)
-{
-	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct sof_ipc_stream_posn posn;
-	struct snd_sof_pcm *spcm = rtd->sof;
-
-	snd_sof_ipc_stream_posn(sdev, spcm, cstream->direction, &posn);
-
-	dev_vdbg(sdev->dev, "CPCM: DMA position %llu DAI position %llu\n",
-		 posn.host_posn, posn.dai_posn);
-
-	return 0;
-}
-
-static int sof_compressed_ack(struct snd_compr_stream *cstream,
-			      size_t bytes)
-{
-	return 0;
-}
-
-static int sof_compressed_get_caps(struct snd_compr_stream *cstream,
-				   struct snd_compr_caps *caps)
-{
-	return 0;
-}
-
-static int sof_compressed_get_codec_caps(struct snd_compr_stream *cstream,
-					 struct snd_compr_codec_caps *codec)
-{
-	return 0;
-}
-
-static int sof_compressed_set_metadata(struct snd_compr_stream *cstream,
-				       struct snd_compr_metadata *metadata)
-{
-	return 0;
-}
-
-struct snd_compr_ops sof_compressed_ops = {
-	.open = sof_compressed_open,
-	.free = sof_compressed_free,
-	.set_params = sof_compressed_set_params,
-	.set_metadata = sof_compressed_set_metadata,
-	.trigger = sof_compressed_trigger,
-	.pointer = sof_compressed_pointer,
-	.ack = sof_compressed_ack,
-	.get_caps = sof_compressed_get_caps,
-	.get_codec_caps = sof_compressed_get_codec_caps,
-};
diff --git a/sound/soc/sof/control.c b/sound/soc/sof/control.c
deleted file mode 100644
index ed52aac..0000000
--- a/sound/soc/sof/control.c
+++ /dev/null
@@ -1,233 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-/* Mixer Controls */
-
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/module.h>
-#include <linux/pm_runtime.h>
-#include <sound/soc-topology.h>
-#include <sound/soc.h>
-#include <sound/control.h>
-#include <uapi/sound/sof-ipc.h>
-#include "sof-priv.h"
-
-/* simple volume table TODO: to be replaced by coefficients from topology */
-/* -52 dB to +12 dB in 2 dB steps, 33 values */
-static const u32 volume_map[] = {
-	165,
-	207,
-	261,
-	328,
-	414,
-	521,
-	655,
-	825,
-	1039,
-	1308,
-	1646,
-	2072,
-	2609,
-	3285,
-	4135,
-	5206,
-	6554,
-	8250,
-	10387,
-	13076,
-	16462,
-	20724,
-	26090,
-	32846,
-	41350,
-	52057,
-	65536, /* 0 dB for Qx.16 gain value */
-	82505,
-	103868,
-	130762,
-	164619,
-	207243,
-	260904
-};
-
-static inline u32 mixer_to_ipc(unsigned int value)
-{
-	if (value >= ARRAY_SIZE(volume_map))
-		return volume_map[0];
-	else
-		return volume_map[value];
-}
-
-static inline u32 ipc_to_mixer(u32 value)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(volume_map); i++) {
-		if (volume_map[i] >= value)
-			return i;
-	}
-
-	return i - 1;
-}
-
-int snd_sof_volume_get(struct snd_kcontrol *kcontrol,
-		       struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_mixer_control *sm =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_sof_control *scontrol = sm->dobj.private;
-	struct snd_sof_dev *sdev = scontrol->sdev;
-	struct sof_ipc_ctrl_data *cdata = scontrol->control_data;
-	unsigned int i, channels = scontrol->num_channels;
-
-	pm_runtime_get_sync(sdev->dev);
-
-	/* get all the mixer data from DSP */
-	snd_sof_ipc_get_comp_data(sdev->ipc, scontrol, SOF_IPC_COMP_GET_VALUE,
-				  SOF_CTRL_TYPE_VALUE_CHAN_GET,
-				  SOF_CTRL_CMD_VOLUME);
-
-	/* read back each channel */
-	for (i = 0; i < channels; i++)
-		ucontrol->value.integer.value[i] =
-			ipc_to_mixer(cdata->chanv[i].value);
-
-	pm_runtime_mark_last_busy(sdev->dev);
-	pm_runtime_put_autosuspend(sdev->dev);
-	return 0;
-}
-
-int snd_sof_volume_put(struct snd_kcontrol *kcontrol,
-		       struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_mixer_control *sm =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_sof_control *scontrol = sm->dobj.private;
-	struct snd_sof_dev *sdev = scontrol->sdev;
-	struct sof_ipc_ctrl_data *cdata = scontrol->control_data;
-	unsigned int i, channels = scontrol->num_channels;
-
-	pm_runtime_get_sync(sdev->dev);
-
-	/* update each channel */
-	for (i = 0; i < channels; i++) {
-		cdata->chanv[i].value =
-			mixer_to_ipc(ucontrol->value.integer.value[i]);
-		cdata->chanv[i].channel = i;
-	}
-
-	/* notify DSP of mixer updates */
-	snd_sof_ipc_set_comp_data(sdev->ipc, scontrol, SOF_IPC_COMP_SET_VALUE,
-				  SOF_CTRL_TYPE_VALUE_CHAN_GET,
-				  SOF_CTRL_CMD_VOLUME);
-
-	pm_runtime_mark_last_busy(sdev->dev);
-	pm_runtime_put_autosuspend(sdev->dev);
-	return 0;
-}
-
-int snd_sof_enum_get(struct snd_kcontrol *kcontrol,
-		     struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_enum *se =
-		(struct soc_enum *)kcontrol->private_value;
-	struct snd_sof_control *scontrol = se->dobj.private;
-	struct snd_sof_dev *sdev = scontrol->sdev;
-	struct sof_ipc_ctrl_data *cdata = scontrol->control_data;
-	unsigned int i, channels = scontrol->num_channels;
-
-	pm_runtime_get_sync(sdev->dev);
-
-	/* get all the mixer data from DSP */
-	snd_sof_ipc_get_comp_data(sdev->ipc, scontrol, SOF_IPC_COMP_GET_VALUE,
-				  SOF_CTRL_TYPE_VALUE_CHAN_GET,
-				  SOF_CTRL_CMD_ENUM);
-
-	/* read back each channel */
-	for (i = 0; i < channels; i++)
-		ucontrol->value.integer.value[i] = cdata->chanv[i].value;
-
-	pm_runtime_mark_last_busy(sdev->dev);
-	pm_runtime_put_autosuspend(sdev->dev);
-	return 0;
-}
-
-int snd_sof_enum_put(struct snd_kcontrol *kcontrol,
-		     struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_enum *se =
-		(struct soc_enum *)kcontrol->private_value;
-	struct snd_sof_control *scontrol = se->dobj.private;
-	struct snd_sof_dev *sdev = scontrol->sdev;
-	struct sof_ipc_ctrl_data *cdata = scontrol->control_data;
-	unsigned int i, channels = scontrol->num_channels;
-
-	pm_runtime_get_sync(sdev->dev);
-
-	/* update each channel */
-	for (i = 0; i < channels; i++)
-		cdata->chanv[i].value = ucontrol->value.integer.value[i];
-
-	/* notify DSP of mixer updates */
-	snd_sof_ipc_set_comp_data(sdev->ipc, scontrol, SOF_IPC_COMP_SET_VALUE,
-				  SOF_CTRL_TYPE_VALUE_CHAN_SET,
-				  SOF_CTRL_CMD_ENUM);
-
-	pm_runtime_mark_last_busy(sdev->dev);
-	pm_runtime_put_autosuspend(sdev->dev);
-	return 0;
-}
-
-int snd_sof_bytes_get(struct snd_kcontrol *kcontrol,
-		      struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_bytes_ext *be =
-		(struct soc_bytes_ext *)kcontrol->private_value;
-	struct snd_sof_control *scontrol = be->dobj.private;
-	struct snd_sof_dev *sdev = scontrol->sdev;
-	//struct sof_ipc_ctrl_data *cdata = scontrol->control_data;
-	//unsigned int i, channels = scontrol->num_channels;
-
-	pm_runtime_get_sync(sdev->dev);
-
-	/* get all the mixer data from DSP */
-	snd_sof_ipc_get_comp_data(sdev->ipc, scontrol, SOF_IPC_COMP_GET_DATA,
-				  SOF_CTRL_TYPE_DATA_GET, scontrol->cmd);
-
-	/* TODO: copy back to userspace */
-
-	pm_runtime_mark_last_busy(sdev->dev);
-	pm_runtime_put_autosuspend(sdev->dev);
-	return 0;
-}
-
-int snd_sof_bytes_put(struct snd_kcontrol *kcontrol,
-		      struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_bytes_ext *be =
-		(struct soc_bytes_ext *)kcontrol->private_value;
-	struct snd_sof_control *scontrol = be->dobj.private;
-	struct snd_sof_dev *sdev = scontrol->sdev;
-	//struct sof_ipc_ctrl_data *cdata = scontrol->control_data;
-	//unsigned int i, channels = scontrol->num_channels;
-
-	pm_runtime_get_sync(sdev->dev);
-
-	/* TODO: copy from userspace */
-
-	/* notify DSP of mixer updates */
-	snd_sof_ipc_set_comp_data(sdev->ipc, scontrol, SOF_IPC_COMP_SET_DATA,
-				  SOF_CTRL_TYPE_DATA_SET, scontrol->cmd);
-
-	pm_runtime_mark_last_busy(sdev->dev);
-	pm_runtime_put_autosuspend(sdev->dev);
-	return 0;
-}
diff --git a/sound/soc/sof/debug.c b/sound/soc/sof/debug.c
deleted file mode 100644
index c1580a1..0000000
--- a/sound/soc/sof/debug.c
+++ /dev/null
@@ -1,137 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- *         Yan Wang <yan.wan@linux.intel.com>
- */
-
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <linux/pm.h>
-#include <linux/pm_runtime.h>
-#include <linux/debugfs.h>
-#include <linux/uaccess.h>
-#include <uapi/sound/sof-ipc.h>
-#include "sof-priv.h"
-#include "ops.h"
-
-static int sof_dfsentry_open(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-
-	return 0;
-}
-
-static ssize_t sof_dfsentry_read(struct file *file, char __user *buffer,
-				 size_t count, loff_t *ppos)
-{
-	struct snd_sof_dfsentry *dfse = file->private_data;
-	struct snd_sof_dev *sdev = dfse->sdev;
-	int size;
-	u32 *buf;
-	loff_t pos = *ppos;
-	size_t ret;
-
-	size = dfse->size;
-
-	if (pos < 0)
-		return -EINVAL;
-	if (pos >= size || !count)
-		return 0;
-	if (count > size - pos)
-		count = size - pos;
-
-	size = (count + 3) & ~3;
-	buf = kzalloc(size, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	pm_runtime_get(sdev->dev);
-	memcpy_fromio(buf,  dfse->buf + pos, size);
-	pm_runtime_put(sdev->dev);
-
-	ret = copy_to_user(buffer, buf, count);
-	kfree(buf);
-
-	if (ret == count)
-		return -EFAULT;
-	count -= ret;
-	*ppos = pos + count;
-
-	return count;
-}
-
-static const struct file_operations sof_dfs_fops = {
-	.open = sof_dfsentry_open,
-	.read = sof_dfsentry_read,
-	.llseek = default_llseek,
-};
-
-int snd_sof_debugfs_create_item(struct snd_sof_dev *sdev,
-				void __iomem *base, size_t size,
-				const char *name)
-{
-	struct snd_sof_dfsentry *dfse;
-
-	if (!sdev)
-		return -EINVAL;
-
-	dfse = kzalloc(sizeof(*dfse), GFP_KERNEL);
-	if (!dfse)
-		return -ENOMEM;
-
-	dfse->buf = base;
-	dfse->size = size;
-	dfse->sdev = sdev;
-
-	dfse->dfsentry = debugfs_create_file(name, 0444, sdev->debugfs_root,
-					     dfse, &sof_dfs_fops);
-	if (!dfse->dfsentry) {
-		dev_err(sdev->dev, "cannot create debugfs entry.\n");
-		kfree(dfse);
-		return -ENODEV;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(snd_sof_debugfs_create_item);
-
-int snd_sof_dbg_init(struct snd_sof_dev *sdev)
-{
-	const struct snd_sof_dsp_ops *ops = sdev->ops;
-	const struct snd_sof_debugfs_map *map;
-	int err = 0, i;
-
-	sdev->debugfs_root = debugfs_create_dir("sof", NULL);
-	if (IS_ERR_OR_NULL(sdev->debugfs_root)) {
-		dev_err(sdev->dev, "error: failed to create debugfs directory\n");
-		return -EINVAL;
-	}
-
-	for (i = 0; i < ops->debug_map_count; i++) {
-		map = &ops->debug_map[i];
-
-		err = snd_sof_debugfs_create_item(sdev, sdev->bar[map->bar] +
-						  map->offset, map->size,
-						  map->name);
-		if (err < 0)
-			dev_err(sdev->dev, "cannot create debugfs for %s\n",
-				map->name);
-	}
-
-	return err;
-}
-EXPORT_SYMBOL(snd_sof_dbg_init);
-
-void snd_sof_free_debug(struct snd_sof_dev *sdev)
-{
-	debugfs_remove_recursive(sdev->debugfs_root);
-}
-EXPORT_SYMBOL(snd_sof_free_debug);
diff --git a/sound/soc/sof/hw-apl.c b/sound/soc/sof/hw-apl.c
deleted file mode 100644
index 7375430..0000000
--- a/sound/soc/sof/hw-apl.c
+++ /dev/null
@@ -1,2647 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Authors: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- *	    Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
- *	    Jeeja KP <jeeja.kp@intel.com>
- *	    Rander Wang <rander.wang@intel.com>
- *          Keyon Jie <yang.jie@linux.intel.com>
- */
-
-/*
- * Hardware interface for audio DSP on Apollolake and Cannonlake.
- */
-
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-#include <linux/firmware.h>
-#include <linux/pci.h>
-#include <sound/hdaudio_ext.h>
-#include <sound/sof.h>
-#include <sound/pcm_params.h>
-#include <linux/pm_runtime.h>
-
-#include "sof-priv.h"
-#include "ops.h"
-#include "intel.h"
-
-#define APL_HDA_BAR			0
-#define APL_PP_BAR			1
-#define APL_SPIB_BAR			2
-#define APL_DRSM_BAR			3
-#define APL_DSP_BAR			4
-
-#define SRAM_WINDOW_OFFSET(x)		(0x80000 + x * 0x20000)
-
-#define APL_MBOX_OFFSET			SRAM_WINDOW_OFFSET(0)
-
-/* SRAM window 0 FW "registers" */
-#define APL_SRAM_REG_ROM_STATUS		(APL_MBOX_OFFSET + 0x0)
-#define APL_SRAM_REG_ROM_ERROR		(APL_MBOX_OFFSET + 0x4)
-/* FW and ROM share offset 4 */
-#define APL_SRAM_REG_FW_STATUS		(APL_MBOX_OFFSET + 0x4)
-#define APL_SRAM_REG_FW_TRACEP		(APL_MBOX_OFFSET + 0x8)
-#define APL_SRAM_REG_FW_END		(APL_MBOX_OFFSET + 0xc)
-
-#define APL_MBOX_UPLINK_OFFSET		0x81000
-
-#define APL_BDL_ARRAY_ADDR_L		0
-#define APL_BDL_ARRAY_ADDR_U		1
-#define APL_BDL_ARRAY_SIZE		2
-#define APL_BDL_ARRAY_IOC		3
-#define APL_BDL_SIZE			4096
-#define APL_MAX_BDL_ENTRIES		(APL_BDL_SIZE / 16)
-
-#define APL_STREAM_RESET_TIMEOUT	300
-#define APL_CL_TRIGGER_TIMEOUT		300
-
-#define APL_SPIB_ENABLE			1
-#define APL_SPIB_DISABLE		0
-
-#define SOF_HDA_MAX_BUFFER_SIZE		(32 * PAGE_SIZE)
-
-#define APL_STACK_DUMP_SIZE		32
-
-/* ROM  status/error values */
-#define APL_ROM_STS_MASK		0xf
-#define APL_ROM_INIT			0x1
-#define APL_ROM_FW_MANIFEST_LOADED      0x3
-#define APL_ROM_FW_FW_LOADED            0x4
-#define APL_ROM_FW_ENTERED              0x5
-#define APL_ROM_RFW_START		0xf
-#define APL_ROM_CSE_ERROR		40
-#define APL_ROM_CSE_WRONG_RESPONSE	41
-#define APL_ROM_IMR_TO_SMALL		42
-#define APL_ROM_BASE_FW_NOT_FOUND	43
-#define APL_ROM_CSE_VALIDATION_FAILED	44
-#define APL_ROM_IPC_FATAL_ERROR		45
-#define APL_ROM_L2_CACHE_ERROR		46
-#define APL_ROM_LOAD_OFFSET_TO_SMALL	47
-#define APL_ROM_API_PTR_INVALID		50
-#define APL_ROM_BASEFW_INCOMPAT		51
-#define APL_ROM_UNHANDLED_INTERRUPT	0xBEE00000
-#define APL_ROM_MEMORY_HOLE_ECC		0xECC00000
-#define APL_ROM_KERNEL_EXCEPTION	0xCAFE0000
-#define APL_ROM_USER_EXCEPTION		0xBEEF0000
-#define APL_ROM_UNEXPECTED_RESET	0xDECAF000
-#define APL_ROM_NULL_FW_ENTRY		0x4c4c4e55
-#define APL_IPC_PURGE_FW		0x01004000
-
-/* various timeout values */
-#define APL_DSP_PU_TIMEOUT		50
-#define APL_DSP_PD_TIMEOUT		50
-#define APL_DSP_RESET_TIMEOUT		50
-#define APL_BASEFW_TIMEOUT		3000
-#define APL_INIT_TIMEOUT		500
-#define APL_CTRL_RESET_TIMEOUT		100
-#define APL_WAIT_TIMEOUT		500	/* 500 msec */
-
-#define APL_ADSPIC_IPC			1
-#define APL_ADSPIS_IPC			1
-
-/* Intel HD Audio General DSP Registers */
-#define APL_DSP_GEN_BASE		0x0
-#define APL_DSP_REG_ADSPCS		(APL_DSP_GEN_BASE + 0x04)
-#define APL_DSP_REG_ADSPIC		(APL_DSP_GEN_BASE + 0x08)
-#define APL_DSP_REG_ADSPIS		(APL_DSP_GEN_BASE + 0x0C)
-#define APL_DSP_REG_ADSPIC2		(APL_DSP_GEN_BASE + 0x10)
-#define APL_DSP_REG_ADSPIS2		(APL_DSP_GEN_BASE + 0x14)
-
-/* Intel HD Audio Inter-Processor Communication Registers */
-#define APL_DSP_IPC_BASE		0x40
-#define APL_DSP_REG_HIPCT		(APL_DSP_IPC_BASE + 0x00)
-#define APL_DSP_REG_HIPCTE		(APL_DSP_IPC_BASE + 0x04)
-#define APL_DSP_REG_HIPCI		(APL_DSP_IPC_BASE + 0x08)
-#define APL_DSP_REG_HIPCIE		(APL_DSP_IPC_BASE + 0x0C)
-#define APL_DSP_REG_HIPCCTL		(APL_DSP_IPC_BASE + 0x10)
-
-/*  HIPCI */
-#define APL_DSP_REG_HIPCI_BUSY		BIT(31)
-#define APL_DSP_REG_HIPCI_MSG_MASK	0x7FFFFFFF
-
-/* HIPCIE */
-#define APL_DSP_REG_HIPCIE_DONE	BIT(30)
-#define APL_DSP_REG_HIPCIE_MSG_MASK	0x3FFFFFFF
-
-/* HIPCCTL */
-#define APL_DSP_REG_HIPCCTL_DONE	BIT(1)
-#define APL_DSP_REG_HIPCCTL_BUSY	BIT(0)
-
-/* HIPCT */
-#define APL_DSP_REG_HIPCT_BUSY		BIT(31)
-#define APL_DSP_REG_HIPCT_MSG_MASK	0x7FFFFFFF
-
-/* HIPCTE */
-#define APL_DSP_REG_HIPCTE_MSG_MASK	0x3FFFFFFF
-
-#define APL_ADSPIC_CL_DMA		0x2
-#define APL_ADSPIS_CL_DMA		0x2
-
-/* Delay before scheduling D0i3 entry */
-#define BXT_D0I3_DELAY 5000
-
-#define FW_CL_STREAM_NUMBER		0x1
-
-/* ADSPCS - Audio DSP Control & Status */
-
-/*
- * Core Reset - asserted high
- * CRST Mask for a given core mask pattern, cm
- */
-#define APL_ADSPCS_CRST_SHIFT		0
-#define APL_ADSPCS_CRST_MASK(cm)	((cm) << APL_ADSPCS_CRST_SHIFT)
-
-/*
- * Core run/stall - when set to '1' core is stalled
- * CSTALL Mask for a given core mask pattern, cm
- */
-#define APL_ADSPCS_CSTALL_SHIFT		8
-#define APL_ADSPCS_CSTALL_MASK(cm)	((cm) << APL_ADSPCS_CSTALL_SHIFT)
-
-/*
- * Set Power Active - when set to '1' turn cores on
- * SPA Mask for a given core mask pattern, cm
- */
-#define APL_ADSPCS_SPA_SHIFT		16
-#define APL_ADSPCS_SPA_MASK(cm)		((cm) << APL_ADSPCS_SPA_SHIFT)
-
-/*
- * Current Power Active - power status of cores, set by hardware
- * CPA Mask for a given core mask pattern, cm
- */
-#define APL_ADSPCS_CPA_SHIFT		24
-#define APL_ADSPCS_CPA_MASK(cm)		((cm) << APL_ADSPCS_CPA_SHIFT)
-
-#define APL_ADSPIC_CL_DMA		0x2
-#define APL_ADSPIS_CL_DMA		0x2
-
-/* Mask for a given core index, c = 0.. number of supported cores - 1 */
-#define APL_DSP_CORE_MASK(c)		BIT(c)
-
-/*
- * Mask for a given number of cores
- * nc = number of supported cores
- */
-#define SOF_DSP_CORES_MASK(nc)	GENMASK((nc - 1), 0)
-
-/* Intel HD Audio Inter-Processor Communication Registers for Cannonlake*/
-#define CNL_DSP_IPC_BASE		0xc0
-#define CNL_DSP_REG_HIPCTDR		(CNL_DSP_IPC_BASE + 0x00)
-#define CNL_DSP_REG_HIPCTDA		(CNL_DSP_IPC_BASE + 0x04)
-#define CNL_DSP_REG_HIPCTDD		(CNL_DSP_IPC_BASE + 0x08)
-#define CNL_DSP_REG_HIPCIDR		(CNL_DSP_IPC_BASE + 0x10)
-#define CNL_DSP_REG_HIPCIDA		(CNL_DSP_IPC_BASE + 0x14)
-#define CNL_DSP_REG_HIPCCTL		(CNL_DSP_IPC_BASE + 0x28)
-
-/*  HIPCI */
-#define CNL_DSP_REG_HIPCIDR_BUSY		BIT(31)
-#define CNL_DSP_REG_HIPCIDR_MSG_MASK	0x7FFFFFFF
-
-/* HIPCIE */
-#define CNL_DSP_REG_HIPCIDA_DONE	BIT(31)
-#define CNL_DSP_REG_HIPCIDA_MSG_MASK	0x7FFFFFFF
-
-/* HIPCCTL */
-#define CNL_DSP_REG_HIPCCTL_DONE	BIT(1)
-#define CNL_DSP_REG_HIPCCTL_BUSY	BIT(0)
-
-/* HIPCT */
-#define CNL_DSP_REG_HIPCTDR_BUSY		BIT(31)
-#define CNL_DSP_REG_HIPCTDR_MSG_MASK	0x7FFFFFFF
-
-/* HIPCTDA */
-#define CNL_DSP_REG_HIPCTDA_DONE	BIT(31)
-#define CNL_DSP_REG_HIPCTDA_MSG_MASK	0x7FFFFFFF
-
-/* HIPCTDD */
-#define CNL_DSP_REG_HIPCTDD_MSG_MASK	0x7FFFFFFF
-
-static bool is_apl_core_enable(struct snd_sof_dev *sdev,
-			       unsigned int core_mask);
-
-/*
- * Register IO
- */
-
-static void apl_write(struct snd_sof_dev *sdev, void __iomem *addr,
-		      u32 value)
-{
-	writel(value, addr);
-}
-
-static u32 apl_read(struct snd_sof_dev *sdev, void __iomem *addr)
-{
-	return readl(addr);
-}
-
-static void apl_write64(struct snd_sof_dev *sdev, void __iomem *addr,
-			u64 value)
-{
-	memcpy_toio(addr, &value, sizeof(value));
-}
-
-static u64 apl_read64(struct snd_sof_dev *sdev, void __iomem *addr)
-{
-	u64 val;
-
-	memcpy_fromio(&val, addr, sizeof(val));
-	return val;
-}
-
-/*
- * Memory copy.
- */
-
-static void apl_block_write(struct snd_sof_dev *sdev, u32 offset, void *src,
-			    size_t size)
-{
-	void __iomem *dest = sdev->bar[sdev->mmio_bar] + offset;
-	u32 tmp = 0;
-	int i, m, n;
-	const u8 *src_byte = src;
-
-	m = size / 4;
-	n = size % 4;
-
-	/* __iowrite32_copy use 32bit size values so divide by 4 */
-	__iowrite32_copy((void *)dest, src, m);
-
-	if (n) {
-		for (i = 0; i < n; i++)
-			tmp |= (u32)*(src_byte + m * 4 + i) << (i * 8);
-		__iowrite32_copy((void *)(dest + m * 4), &tmp, 1);
-	}
-}
-
-static void apl_block_read(struct snd_sof_dev *sdev, u32 offset, void *dest,
-			   size_t size)
-{
-	void __iomem *src = sdev->bar[sdev->mmio_bar] + offset;
-
-	memcpy_fromio(dest, src, size);
-}
-
-/*
- * Debug
- */
-
-struct apl_msg_code {
-	u32 code;
-	const char *msg;
-};
-
-static const struct apl_msg_code apl_rom_msg[] = {
-	{APL_ROM_FW_MANIFEST_LOADED, "status: manifest loaded"},
-	{APL_ROM_FW_FW_LOADED, "status: fw loaded"},
-	{APL_ROM_FW_ENTERED, "status: fw entered"},
-	{APL_ROM_CSE_ERROR, "error: cse error"},
-	{APL_ROM_CSE_WRONG_RESPONSE, "error: cse wrong response"},
-	{APL_ROM_IMR_TO_SMALL, "error: IMR too small"},
-	{APL_ROM_BASE_FW_NOT_FOUND, "error: base fw not found"},
-	{APL_ROM_CSE_VALIDATION_FAILED, "error: signature verification failed"},
-	{APL_ROM_IPC_FATAL_ERROR, "error: ipc fatal error"},
-	{APL_ROM_L2_CACHE_ERROR, "error: L2 cache error"},
-	{APL_ROM_LOAD_OFFSET_TO_SMALL, "error: load offset too small"},
-	{APL_ROM_API_PTR_INVALID, "error: API ptr invalid"},
-	{APL_ROM_BASEFW_INCOMPAT, "error: base fw incompatble"},
-	{APL_ROM_UNHANDLED_INTERRUPT, "error: unhandled interrupt"},
-	{APL_ROM_MEMORY_HOLE_ECC, "error: ECC memory hole"},
-	{APL_ROM_KERNEL_EXCEPTION, "error: kernel exception"},
-	{APL_ROM_USER_EXCEPTION, "error: user exception"},
-	{APL_ROM_UNEXPECTED_RESET, "error: unexpected reset"},
-	{APL_ROM_NULL_FW_ENTRY,	"error: null FW entry point"},
-};
-
-static const struct snd_sof_debugfs_map apl_debugfs[] = {
-	{"hda", APL_HDA_BAR, 0, 0x4000},
-	{"pp", APL_PP_BAR,  0, 0x1000},
-	{"dsp", APL_DSP_BAR,  0, 0x10000},
-};
-
-static void apl_get_status(struct snd_sof_dev *sdev)
-{
-	u32 status;
-	int i;
-
-	status = snd_sof_dsp_read(sdev, APL_DSP_BAR, APL_SRAM_REG_ROM_STATUS);
-
-	for (i = 0; i < ARRAY_SIZE(apl_rom_msg); i++) {
-		if (status == apl_rom_msg[i].code) {
-			dev_err(sdev->dev, "%s - code %8.8x\n",
-				apl_rom_msg[i].msg, status);
-			return;
-		}
-	}
-
-	/* not for us, must be generic sof message */
-	dev_dbg(sdev->dev, "unknown ROM status value %8.8x\n", status);
-}
-
-static void apl_get_registers(struct snd_sof_dev *sdev,
-			      struct sof_ipc_dsp_oops_xtensa *xoops,
-			      u32 *stack, size_t stack_words)
-{
-	/* first read regsisters */
-	apl_block_read(sdev, sdev->dsp_oops_offset, xoops, sizeof(*xoops));
-
-	/* the get the stack */
-	apl_block_read(sdev, sdev->dsp_oops_offset + sizeof(*xoops), stack,
-		       stack_words * sizeof(u32));
-}
-
-static void apl_dump(struct snd_sof_dev *sdev, u32 flags)
-{
-	struct sof_ipc_dsp_oops_xtensa xoops;
-	u32 stack[APL_STACK_DUMP_SIZE];
-	u32 status, panic;
-
-	/* try APL specific status message types first */
-	apl_get_status(sdev);
-
-	/* now try generic SOF status messages */
-	status = snd_sof_dsp_read(sdev, APL_DSP_BAR, APL_SRAM_REG_FW_STATUS);
-	panic = snd_sof_dsp_read(sdev, APL_DSP_BAR, APL_SRAM_REG_FW_TRACEP);
-	apl_get_registers(sdev, &xoops, stack, APL_STACK_DUMP_SIZE);
-	snd_sof_get_status(sdev, status, panic, &xoops, stack,
-			   APL_STACK_DUMP_SIZE);
-}
-
-/*
- * IPC Mailbox IO
- */
-
-static void apl_mailbox_write(struct snd_sof_dev *sdev, u32 offset,
-			      void *message, size_t bytes)
-{
-	void __iomem *dest = sdev->bar[sdev->mailbox_bar] + offset;
-
-	memcpy_toio(dest, message, bytes);
-}
-
-static void apl_mailbox_read(struct snd_sof_dev *sdev, u32 offset,
-			     void *message, size_t bytes)
-{
-	void __iomem *src = sdev->bar[sdev->mailbox_bar] + offset;
-
-	memcpy_fromio(message, src, bytes);
-}
-
-/*
- * Code loader
- */
-
-static int apl_spib_config(struct snd_sof_dev *sdev,
-			   struct snd_sof_hda_stream *stream,
-			   int enable, u32 size)
-{
-	u32 mask = 0;
-
-	if (!sdev->bar[APL_SPIB_BAR]) {
-		dev_err(sdev->dev, "error: address of spib capability is NULL\n");
-		return -EINVAL;
-	}
-
-	mask |= (1 << stream->index);
-
-	/* enable/disable SPIB for the stream */
-	snd_sof_dsp_update_bits(sdev, APL_SPIB_BAR,
-				SOF_HDA_ADSP_REG_CL_SPBFIFO_SPBFCCTL, mask,
-				enable << stream->index);
-
-	/* set the SPIB value */
-	apl_write(sdev, stream->spib_addr, size);
-
-	return 0;
-}
-
-static int apl_dsp_cleanup(struct snd_sof_dev *sdev,
-			   struct snd_dma_buffer *dmab,
-			   struct snd_sof_hda_stream *stream)
-{
-	int ret;
-
-	ret = apl_spib_config(sdev, stream, APL_SPIB_DISABLE, 0);
-
-	/* TODO: spin lock ?*/
-	stream->open = 0;
-	stream->running = 0;
-	stream->substream = NULL;
-
-	/* reset BDL address */
-	snd_sof_dsp_write(sdev, APL_HDA_BAR,
-			  stream->sd_offset + SOF_HDA_ADSP_REG_CL_SD_BDLPL, 0);
-	snd_sof_dsp_write(sdev, APL_HDA_BAR,
-			  stream->sd_offset + SOF_HDA_ADSP_REG_CL_SD_BDLPU, 0);
-
-	snd_sof_dsp_write(sdev, APL_HDA_BAR, stream->sd_offset, 0);
-	snd_dma_free_pages(dmab);
-	dmab->area = NULL;
-	stream->bufsize = 0;
-	stream->format_val = 0;
-
-	return ret;
-}
-
-static int apl_cl_trigger(struct snd_sof_dev *sdev,
-			  struct snd_sof_hda_stream *stream)
-{
-	wait_event_timeout(sdev->waitq, !sdev->code_loading,
-			   APL_CL_TRIGGER_TIMEOUT);
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, SOF_HDA_INTCTL,
-				1 << stream->index, 1 << stream->index);
-
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, stream->sd_offset,
-				SOF_HDA_SD_CTL_DMA_START |
-				SOF_HDA_CL_DMA_SD_INT_MASK,
-				SOF_HDA_SD_CTL_DMA_START |
-				SOF_HDA_CL_DMA_SD_INT_MASK);
-
-	stream->running = true;
-	return 0;
-}
-
-static int apl_trigger(struct snd_sof_dev *sdev,
-		       struct snd_sof_hda_stream *stream, int cmd)
-{
-	int ret = 0;
-
-	/* code loader is special case that reuses stream ops */
-	if (sdev->code_loading && cmd == SNDRV_PCM_TRIGGER_START)
-		return apl_cl_trigger(sdev, stream);
-
-	/* cmd must be for audio stream */
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-	case SNDRV_PCM_TRIGGER_START:
-		snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, SOF_HDA_INTCTL,
-					1 << stream->index,
-					1 << stream->index);
-
-		snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, stream->sd_offset,
-					SOF_HDA_SD_CTL_DMA_START |
-					SOF_HDA_CL_DMA_SD_INT_MASK,
-					SOF_HDA_SD_CTL_DMA_START |
-					SOF_HDA_CL_DMA_SD_INT_MASK);
-
-		stream->running = true;
-		break;
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-	case SNDRV_PCM_TRIGGER_STOP:
-		snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, stream->sd_offset,
-					SOF_HDA_SD_CTL_DMA_START |
-					SOF_HDA_CL_DMA_SD_INT_MASK, 0x0);
-
-		snd_sof_dsp_write(sdev, APL_HDA_BAR, stream->sd_offset +
-				  SOF_HDA_ADSP_REG_CL_SD_STS,
-				  SOF_HDA_CL_DMA_SD_INT_MASK);
-
-		stream->running = false;
-		snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, SOF_HDA_INTCTL,
-					1 << stream->index, 0x0);
-		break;
-	default:
-		dev_err(sdev->dev, "error: unknown command: %d\n", cmd);
-		ret = -EINVAL;
-		break;
-	}
-
-	return ret;
-}
-
-int apl_stream_trigger(struct snd_sof_dev *sdev,
-		       struct snd_pcm_substream *substream,
-		       int cmd)
-{
-	struct snd_sof_hda_stream *stream = substream->runtime->private_data;
-
-	return apl_trigger(sdev, stream, cmd);
-}
-
-static int apl_transfer_fw(struct snd_sof_dev *sdev, int stream_tag)
-{
-	struct snd_sof_hda_stream *stream = NULL;
-	struct snd_sof_hda_dev *hdev = &sdev->hda;
-	int ret, status, i;
-
-	/* get stream with stream_tag */
-	for (i = 0; i < hdev->num_playback; i++) {
-		if (hdev->pstream[i].stream_tag == stream_tag) {
-			stream = &hdev->pstream[i];
-			break;
-		}
-	}
-	if (!stream) {
-		dev_err(sdev->dev,
-			"error: could not get stream with stream tag%d\n",
-			stream_tag);
-		return -ENODEV;
-	}
-
-	ret = apl_trigger(sdev, stream, SNDRV_PCM_TRIGGER_START);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: DMA trigger start failed\n");
-		return ret;
-	}
-
-	status = snd_sof_dsp_register_poll(sdev, APL_DSP_BAR,
-					   APL_SRAM_REG_ROM_STATUS,
-					   APL_ROM_STS_MASK,
-					   APL_ROM_FW_ENTERED,
-					   APL_BASEFW_TIMEOUT);
-
-	ret = apl_trigger(sdev, stream, SNDRV_PCM_TRIGGER_STOP);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: DMA trigger stop failed\n");
-		return ret;
-	}
-
-	ret = apl_dsp_cleanup(sdev, &sdev->dmab, stream);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: DSP cleanup failed\n");
-		return ret;
-	}
-
-	return status;
-}
-
-/*
- * set up Buffer Descriptor List (BDL) for host memory transfer
- * BDL describes the location of the individual buffers and is little endian.
- */
-static int apl_stream_setup_bdl(struct snd_sof_dev *sdev,
-				struct snd_dma_buffer *dmab,
-				struct snd_sof_hda_stream *stream,
-				__le32 **bdlp, int size,
-				struct snd_pcm_hw_params *params)
-{
-	__le32 *bdl = *bdlp;
-	int offset = 0;
-	int chunk = PAGE_SIZE, entry_size;
-	dma_addr_t addr;
-
-	if (stream->substream && params) {
-		chunk = params_period_bytes(params);
-		dev_dbg(sdev->dev, "period_bytes:0x%x\n", chunk);
-	}
-
-	while (size > 0) {
-		if (stream->frags >= APL_MAX_BDL_ENTRIES) {
-			dev_err(sdev->dev, "error: stream frags exceeded\n");
-			return -EINVAL;
-		}
-
-		addr = snd_sgbuf_get_addr(dmab, offset);
-
-		/* program BDL addr */
-		bdl[APL_BDL_ARRAY_ADDR_L] = cpu_to_le32(lower_32_bits(addr));
-		bdl[APL_BDL_ARRAY_ADDR_U] = cpu_to_le32(upper_32_bits(addr));
-
-		entry_size = size > chunk ? chunk : size;
-
-		/* program BDL size */
-		entry_size = snd_sgbuf_get_chunk_size(dmab, offset, entry_size);
-
-		bdl[APL_BDL_ARRAY_SIZE] = cpu_to_le32(entry_size);
-
-		/* program the IOC to enable interrupt
-		 * when the whole fragment is processed
-		 */
-		size -= entry_size;
-		if (size)
-			bdl[APL_BDL_ARRAY_IOC] = 0;
-		else
-			bdl[APL_BDL_ARRAY_IOC] = cpu_to_le32(0x01);
-
-		bdl += 4;
-		stream->frags++;
-		offset += entry_size;
-
-		dev_vdbg(sdev->dev, "bdl, frags:%d, entry size:0x%x;\n",
-			 stream->frags, entry_size);
-	}
-
-	*bdlp = bdl;
-	return offset;
-}
-
-static struct snd_sof_hda_stream *
-apl_pstream_get(struct snd_sof_dev *sdev)
-{
-	struct snd_sof_hda_dev *hdev = &sdev->hda;
-	struct snd_sof_hda_stream *stream = NULL;
-	int i;
-
-	/* get an unused playback stream */
-	for (i = 0; i < hdev->num_playback; i++) {
-		if (!hdev->pstream[i].open) {
-			hdev->pstream[i].open = true;
-			stream = &hdev->pstream[i];
-			break;
-		}
-	}
-	return stream;
-}
-
-static struct snd_sof_hda_stream *
-apl_cstream_get(struct snd_sof_dev *sdev)
-{
-	struct snd_sof_hda_dev *hdev = &sdev->hda;
-	struct snd_sof_hda_stream *stream = NULL;
-	int i;
-
-	/* get an unused capture stream */
-	for (i = 0; i < hdev->num_capture; i++) {
-		if (!hdev->cstream[i].open) {
-			hdev->cstream[i].open = true;
-			stream = &hdev->cstream[i];
-			break;
-		}
-	}
-	return stream;
-}
-
-static int apl_pstream_put(struct snd_sof_dev *sdev, int stream_tag)
-{
-	struct snd_sof_hda_dev *hdev = &sdev->hda;
-	int i;
-
-	/* find used playback stream */
-	for (i = 0; i < hdev->num_playback; i++) {
-		if (hdev->pstream[i].open &&
-		    hdev->pstream[i].stream_tag == stream_tag) {
-			hdev->pstream[i].open = false;
-			return 0;
-		}
-	}
-
-	dev_dbg(sdev->dev, "stream_tag %d not opened!\n", stream_tag);
-	return -ENODEV;
-}
-
-static int apl_cstream_put(struct snd_sof_dev *sdev, int stream_tag)
-{
-	struct snd_sof_hda_dev *hdev = &sdev->hda;
-	int i;
-
-	/* find used capture stream */
-	for (i = 0; i < hdev->num_capture; i++) {
-		if (hdev->cstream[i].open &&
-		    hdev->cstream[i].stream_tag == stream_tag) {
-			hdev->cstream[i].open = false;
-			return 0;
-		}
-	}
-
-	dev_dbg(sdev->dev, "stream_tag %d not opened!\n", stream_tag);
-	return -ENODEV;
-}
-
-int apl_pcm_open(struct snd_sof_dev *sdev,
-		 struct snd_pcm_substream *substream)
-{
-	struct snd_sof_hda_stream *stream;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		stream = apl_pstream_get(sdev);
-	else
-		stream = apl_cstream_get(sdev);
-
-	if (!stream) {
-		dev_err(sdev->dev, "error: no stream available\n");
-		return -ENODEV;
-	}
-
-	/* binding pcm substream to hda stream */
-	substream->runtime->private_data = stream;
-	return 0;
-}
-
-int apl_pcm_close(struct snd_sof_dev *sdev,
-		  struct snd_pcm_substream *substream)
-{
-	struct snd_sof_hda_stream *stream = substream->runtime->private_data;
-	int ret;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		ret = apl_pstream_put(sdev, stream->stream_tag);
-	else
-		ret = apl_cstream_put(sdev, stream->stream_tag);
-
-	if (ret) {
-		dev_dbg(sdev->dev, "stream %s not opened!\n", substream->name);
-		return -ENODEV;
-	}
-
-	/* unbinding pcm substream to hda stream */
-	substream->runtime->private_data = NULL;
-	return 0;
-}
-
-/*
- * prepare for common hdac registers settings, for both code loader
- * and normal stream.
- */
-static int apl_hdac_prepare(struct snd_sof_dev *sdev,
-			    struct snd_sof_hda_stream *stream,
-			    struct snd_dma_buffer *dmab,
-			    struct snd_pcm_hw_params *params)
-{
-	struct snd_sof_hda_dev *hdev = &sdev->hda;
-	int ret, timeout = APL_STREAM_RESET_TIMEOUT;
-	u32 val, mask;
-	u32 *bdl;
-
-	if (!stream) {
-		dev_err(sdev->dev, "error: no stream available\n");
-		return -ENODEV;
-	}
-
-	/* decouple host and link DMA */
-	mask = 0x1 << stream->index;
-	snd_sof_dsp_update_bits(sdev, APL_PP_BAR, SOF_HDA_REG_PP_PPCTL,
-				mask, mask);
-
-	if (!dmab) {
-		dev_err(sdev->dev, "error: no dma buffer allocated!\n");
-		return -ENODEV;
-	}
-
-	/* clear stream status */
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, stream->sd_offset,
-				SOF_HDA_CL_DMA_SD_INT_MASK |
-				SOF_HDA_SD_CTL_DMA_START, 0);
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR,
-				stream->sd_offset + SOF_HDA_ADSP_REG_CL_SD_STS,
-				SOF_HDA_CL_DMA_SD_INT_MASK,
-				SOF_HDA_CL_DMA_SD_INT_MASK);
-
-	/* stream reset */
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, stream->sd_offset, 0x1, 0x1);
-	udelay(3);
-	do {
-		val = snd_sof_dsp_read(sdev, APL_HDA_BAR, stream->sd_offset);
-		if (val & 0x1)
-			break;
-	} while (--timeout);
-	if (timeout == 0) {
-		dev_err(sdev->dev, "error: stream reset failed\n");
-		return -ETIMEDOUT;
-	}
-
-	timeout = APL_STREAM_RESET_TIMEOUT;
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, stream->sd_offset, 0x1, 0x0);
-
-	/* wait for hardware to report that stream is out of reset */
-	udelay(3);
-	do {
-		val = snd_sof_dsp_read(sdev, APL_HDA_BAR, stream->sd_offset);
-		if ((val & 0x1) == 0)
-			break;
-	} while (--timeout);
-	if (timeout == 0) {
-		dev_err(sdev->dev, "error: timeout waiting for stream reset\n");
-		return -ETIMEDOUT;
-	}
-
-	if (stream->posbuf)
-		*stream->posbuf = 0;
-
-	/* reset BDL address */
-	snd_sof_dsp_write(sdev, APL_HDA_BAR,
-			  stream->sd_offset + SOF_HDA_ADSP_REG_CL_SD_BDLPL,
-			  0x0);
-	snd_sof_dsp_write(sdev, APL_HDA_BAR,
-			  stream->sd_offset + SOF_HDA_ADSP_REG_CL_SD_BDLPU,
-			  0x0);
-
-	/* clear stream status */
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, stream->sd_offset,
-				SOF_HDA_CL_DMA_SD_INT_MASK |
-				SOF_HDA_SD_CTL_DMA_START, 0);
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR,
-				stream->sd_offset + SOF_HDA_ADSP_REG_CL_SD_STS,
-				SOF_HDA_CL_DMA_SD_INT_MASK,
-				SOF_HDA_CL_DMA_SD_INT_MASK);
-
-	stream->frags = 0;
-
-	bdl = (u32 *)stream->bdl.area;
-	ret = apl_stream_setup_bdl(sdev, dmab, stream, &bdl,
-				   stream->bufsize, params);
-	if (ret < 0) {
-		dev_dbg(sdev->dev, "error: set up bdl fail\n");
-		return ret;
-	}
-
-	/* set up stream descriptor for DMA */
-	/* program stream tag */
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, stream->sd_offset,
-				SOF_HDA_CL_SD_CTL_STREAM_TAG_MASK,
-				stream->stream_tag <<
-				SOF_HDA_CL_SD_CTL_STREAM_TAG_SHIFT);
-
-	/* program cyclic buffer length */
-	snd_sof_dsp_write(sdev, APL_HDA_BAR,
-			  stream->sd_offset + SOF_HDA_ADSP_REG_CL_SD_CBL,
-			  stream->bufsize);
-
-	/* program stream format */
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR,
-				stream->sd_offset +
-				SOF_HDA_ADSP_REG_CL_SD_FORMAT,
-				0xffff, stream->format_val);
-
-	/* program last valid index */
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR,
-				stream->sd_offset + SOF_HDA_ADSP_REG_CL_SD_LVI,
-				0xffff, (stream->frags - 1));
-
-	/* program BDL address */
-	snd_sof_dsp_write(sdev, APL_HDA_BAR,
-			  stream->sd_offset + SOF_HDA_ADSP_REG_CL_SD_BDLPL,
-			  (u32)stream->bdl.addr);
-	snd_sof_dsp_write(sdev, APL_HDA_BAR,
-			  stream->sd_offset + SOF_HDA_ADSP_REG_CL_SD_BDLPU,
-			  upper_32_bits(stream->bdl.addr));
-
-	/* enable position buffer */
-	if (!(snd_sof_dsp_read(sdev, APL_HDA_BAR, SOF_HDA_ADSP_DPLBASE)
-				& SOF_HDA_ADSP_DPLBASE_ENABLE))
-		snd_sof_dsp_write(sdev, APL_HDA_BAR, SOF_HDA_ADSP_DPLBASE,
-				  (u32)hdev->posbuffer.addr |
-				  SOF_HDA_ADSP_DPLBASE_ENABLE);
-
-	/* set interrupt enable bits */
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, stream->sd_offset,
-				SOF_HDA_CL_DMA_SD_INT_MASK,
-				SOF_HDA_CL_DMA_SD_INT_MASK);
-
-	/* read FIFO size */
-	if (stream->direction == SNDRV_PCM_STREAM_PLAYBACK) {
-		stream->fifo_size =
-			snd_sof_dsp_read(sdev, APL_HDA_BAR,
-					 stream->sd_offset +
-					 SOF_HDA_ADSP_REG_CL_SD_FIFOSIZE)
-			& 0xffff;
-		stream->fifo_size += 1;
-	} else {
-		stream->fifo_size = 0;
-	}
-
-	return ret;
-}
-
-static int apl_trace_prepare(struct snd_sof_dev *sdev)
-{
-	struct snd_sof_hda_stream *stream = sdev->dtrace_stream;
-	struct snd_dma_buffer *dmab = &sdev->dmatb;
-	int ret;
-
-	stream->bufsize = sdev->dmatb.bytes;
-
-	ret = apl_hdac_prepare(sdev, stream, dmab, NULL);
-	if (ret < 0)
-		dev_err(sdev->dev, "error: hdac prepare failed: %x\n", ret);
-
-	return ret;
-}
-
-static int apl_trace_init(struct snd_sof_dev *sdev, u32 *stream_tag)
-{
-	sdev->dtrace_stream = apl_cstream_get(sdev);
-
-	if (!sdev->dtrace_stream) {
-		dev_err(sdev->dev,
-			"error: no available capture stream for DMA trace\n");
-		return -ENODEV;
-	}
-
-	*stream_tag = sdev->dtrace_stream->stream_tag;
-
-	/*
-	 * initialize capture stream, set BDL address and return corresponding
-	 * stream tag which will be sent to the firmware by IPC message.
-	 */
-	return apl_trace_prepare(sdev);
-}
-
-static int apl_trace_release(struct snd_sof_dev *sdev)
-{
-	if (sdev->dtrace_stream) {
-		sdev->dtrace_stream->open = false;
-		sdev->dtrace_stream = NULL;
-		return 0;
-	}
-
-	dev_dbg(sdev->dev, "DMA trace stream is not opened!\n");
-	return -ENODEV;
-}
-
-static int apl_trace_trigger(struct snd_sof_dev *sdev, int cmd)
-{
-	return apl_trigger(sdev, sdev->dtrace_stream, cmd);
-}
-
-static int apl_stream_prepare(struct snd_sof_dev *sdev,
-			      struct snd_pcm_substream *substream,
-			      struct snd_pcm_hw_params *params)
-{
-	struct snd_sof_hda_stream *stream = substream->runtime->private_data;
-	struct snd_dma_buffer *dmab;
-	int ret;
-	u32 size = params_buffer_bytes(params);
-
-	if (!stream) {
-		dev_err(sdev->dev, "error: no stream available\n");
-		return -ENODEV;
-	}
-
-	stream->substream = substream;
-
-	dmab = substream->runtime->dma_buffer_p;
-
-	stream->format_val = (get_sample_code(params_rate(params)) << 8) |
-		(get_bits_code(params_width(params)) << 4) |
-		(params_channels(params) - 1);
-	stream->bufsize = size;
-
-	ret = apl_hdac_prepare(sdev, stream, dmab, params);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: hdac prepare failed: %x\n", ret);
-		return ret;
-	}
-
-	/* disable SPIB, to enable buffer wrap for stream */
-	apl_spib_config(sdev, stream, APL_SPIB_DISABLE, 0);
-
-	return stream->stream_tag;
-}
-
-static int apl_cl_prepare(struct snd_sof_dev *sdev, unsigned int format,
-			  unsigned int size, struct snd_dma_buffer *dmab,
-			  int direction)
-{
-	struct snd_sof_hda_stream *stream = NULL;
-	struct pci_dev *pci = sdev->pci;
-	int ret;
-
-	if (direction == SNDRV_PCM_STREAM_PLAYBACK) {
-		stream = apl_pstream_get(sdev);
-	} else {
-		dev_err(sdev->dev, "error: code loading DMA is playback only\n");
-		return -EINVAL;
-	}
-
-	if (!stream) {
-		dev_err(sdev->dev, "error: no stream available\n");
-		return -ENODEV;
-	}
-
-	/* allocate DMA buffer */
-	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV_SG, &pci->dev, size, dmab);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: memory alloc failed: %x\n", ret);
-		return ret;
-	}
-
-	stream->format_val = format;
-	stream->bufsize = size;
-
-	ret = apl_hdac_prepare(sdev, stream, dmab, NULL);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: hdac prepare failed: %x\n", ret);
-		goto error;
-	}
-
-	apl_spib_config(sdev, stream, APL_SPIB_ENABLE, size);
-
-	return stream->stream_tag;
-
-error:
-	snd_dma_free_pages(dmab);
-	return ret;
-}
-
-/*
- * IPC Firmware ready.
- */
-
-static void apl_get_windows(struct snd_sof_dev *sdev)
-{
-	struct sof_ipc_window_elem *elem;
-	u32 outbox_offset = 0;
-	u32 stream_offset = 0;
-	u32 inbox_offset = 0;
-	u32 outbox_size = 0;
-	u32 stream_size = 0;
-	u32 inbox_size = 0;
-	int i;
-
-	if (!sdev->info_window) {
-		dev_err(sdev->dev, "error: have no window info\n");
-		return;
-	}
-
-	for (i = 0; i < sdev->info_window->num_windows; i++) {
-		elem = &sdev->info_window->window[i];
-
-		switch (elem->type) {
-		case SOF_IPC_REGION_UPBOX:
-			inbox_offset =
-				elem->offset + SRAM_WINDOW_OFFSET(elem->id);
-			inbox_size = elem->size;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[APL_DSP_BAR] +
-						    inbox_offset,
-						    elem->size, "inbox");
-			break;
-		case SOF_IPC_REGION_DOWNBOX:
-			outbox_offset =
-				elem->offset + SRAM_WINDOW_OFFSET(elem->id);
-			outbox_size = elem->size;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[APL_DSP_BAR] +
-						    outbox_offset,
-						    elem->size, "outbox");
-			break;
-		case SOF_IPC_REGION_TRACE:
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[APL_DSP_BAR] +
-						    elem->offset +
-						    SRAM_WINDOW_OFFSET
-						    (elem->id),
-						    elem->size, "etrace");
-			break;
-		case SOF_IPC_REGION_DEBUG:
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[APL_DSP_BAR] +
-						    elem->offset +
-						    SRAM_WINDOW_OFFSET
-						    (elem->id),
-						    elem->size, "debug");
-			break;
-		case SOF_IPC_REGION_STREAM:
-			stream_offset =
-				elem->offset + SRAM_WINDOW_OFFSET(elem->id);
-			stream_size = elem->size;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[APL_DSP_BAR] +
-						    elem->offset +
-						    SRAM_WINDOW_OFFSET
-						    (elem->id),
-						    elem->size, "stream");
-			break;
-		case SOF_IPC_REGION_REGS:
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[APL_DSP_BAR] +
-						    elem->offset +
-						    SRAM_WINDOW_OFFSET
-						    (elem->id),
-						    elem->size, "regs");
-			break;
-		case SOF_IPC_REGION_EXCEPTION:
-			sdev->dsp_oops_offset = elem->offset +
-						SRAM_WINDOW_OFFSET(elem->id);
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[APL_DSP_BAR] +
-						    elem->offset +
-						    SRAM_WINDOW_OFFSET
-						    (elem->id),
-						    elem->size, "exception");
-			break;
-		default:
-			dev_err(sdev->dev, "error: get illegal window info\n");
-			return;
-		}
-	}
-
-	if (outbox_size == 0 || inbox_size == 0) {
-		dev_err(sdev->dev, "error: get illegal mailbox window\n");
-		return;
-	}
-
-	snd_sof_dsp_mailbox_init(sdev, inbox_offset, inbox_size,
-				 outbox_offset, outbox_size);
-	sdev->stream_box.offset = stream_offset;
-	sdev->stream_box.size = stream_size;
-
-	dev_dbg(sdev->dev, " mailbox upstream 0x%x - size 0x%x\n",
-		inbox_offset, inbox_size);
-	dev_dbg(sdev->dev, " mailbox downstream 0x%x - size 0x%x\n",
-		outbox_offset, outbox_size);
-	dev_dbg(sdev->dev, " stream region 0x%x - size 0x%x\n",
-		stream_offset, stream_size);
-}
-
-static int apl_fw_ready(struct snd_sof_dev *sdev, u32 msg_id)
-{
-	struct sof_ipc_fw_ready *fw_ready = &sdev->fw_ready;
-	struct sof_ipc_fw_version *v = &fw_ready->version;
-	u32 offset;
-
-	/* mailbox must be on 4k boundary */
-	offset = APL_MBOX_UPLINK_OFFSET;
-
-	dev_dbg(sdev->dev, "ipc: DSP is ready 0x%8.8x offset 0x%x\n",
-		msg_id, offset);
-
-	/* copy data from the DSP FW ready offset */
-	apl_block_read(sdev, offset, fw_ready,	sizeof(*fw_ready));
-	dev_info(sdev->dev,
-		 " Firmware info: version %d.%d-%s build %d on %s:%s\n",
-		 v->major, v->minor, v->tag, v->build, v->date, v->time);
-
-	/* now check for extended data */
-	snd_sof_fw_parse_ext_data(sdev, APL_MBOX_UPLINK_OFFSET +
-				  sizeof(struct sof_ipc_fw_ready));
-
-	apl_get_windows(sdev);
-
-	return 0;
-}
-
-/*
- * IPC Doorbell IRQ handler and thread.
- */
-
-static irqreturn_t apl_irq_handler(int irq, void *context)
-{
-	struct snd_sof_dev *sdev = (struct snd_sof_dev *)context;
-	int ret = IRQ_NONE;
-
-	spin_lock(&sdev->hw_lock);
-
-	/* store status */
-	sdev->irq_status = snd_sof_dsp_read(sdev, APL_DSP_BAR,
-					    APL_DSP_REG_ADSPIS);
-
-	/* invalid message ? */
-	if (sdev->irq_status == 0xffffffff)
-		goto out;
-
-	/* IPC message ? */
-	if (sdev->irq_status & APL_ADSPIS_IPC) {
-		/* disable IPC interrupt */
-		snd_sof_dsp_update_bits_unlocked(sdev, APL_DSP_BAR,
-						 APL_DSP_REG_ADSPIC,
-						 APL_ADSPIC_IPC, 0);
-		ret = IRQ_WAKE_THREAD;
-	}
-
-out:
-	spin_unlock(&sdev->hw_lock);
-	return ret;
-}
-
-static irqreturn_t apl_irq_thread(int irq, void *context)
-{
-	struct snd_sof_dev *sdev = (struct snd_sof_dev *)context;
-	u32 hipci, hipcie, hipct, hipcte, msg = 0, msg_ext = 0;
-	irqreturn_t ret = IRQ_NONE;
-
-	/* here we handle IPC interrupts only */
-	if (!(sdev->irq_status & APL_ADSPIS_IPC))
-		return ret;
-
-	hipcie = snd_sof_dsp_read(sdev, APL_DSP_BAR, APL_DSP_REG_HIPCIE);
-	hipct = snd_sof_dsp_read(sdev, APL_DSP_BAR, APL_DSP_REG_HIPCT);
-
-	/* reply message from DSP */
-	if (hipcie & APL_DSP_REG_HIPCIE_DONE) {
-		hipci = snd_sof_dsp_read(sdev, APL_DSP_BAR, APL_DSP_REG_HIPCI);
-		msg = hipci & APL_DSP_REG_HIPCI_MSG_MASK;
-		msg_ext = hipcie & APL_DSP_REG_HIPCIE_MSG_MASK;
-
-		dev_vdbg(sdev->dev,
-			 "ipc: firmware response, msg:0x%x, msg_ext:0x%x\n",
-			 msg, msg_ext);
-
-		/* mask Done interrupt */
-		snd_sof_dsp_update_bits(sdev, APL_DSP_BAR,
-					APL_DSP_REG_HIPCCTL,
-					APL_DSP_REG_HIPCCTL_DONE, 0);
-
-		/* handle immediate reply from DSP core - ignore ROM messages */
-		if (msg != 0x1004000)
-			snd_sof_ipc_reply(sdev, msg);
-
-		/* clear DONE bit - tell DSP we have completed the operation */
-		snd_sof_dsp_update_bits_forced(sdev, APL_DSP_BAR,
-					       APL_DSP_REG_HIPCIE,
-					       APL_DSP_REG_HIPCIE_DONE,
-					       APL_DSP_REG_HIPCIE_DONE);
-
-		/* unmask Done interrupt */
-		snd_sof_dsp_update_bits(sdev, APL_DSP_BAR,
-					APL_DSP_REG_HIPCCTL,
-					APL_DSP_REG_HIPCCTL_DONE,
-					APL_DSP_REG_HIPCCTL_DONE);
-
-		ret = IRQ_HANDLED;
-	}
-
-	/* new message from DSP */
-	if (hipct & APL_DSP_REG_HIPCT_BUSY) {
-		hipcte = snd_sof_dsp_read(sdev, APL_DSP_BAR,
-					  APL_DSP_REG_HIPCTE);
-		msg = hipct & APL_DSP_REG_HIPCT_MSG_MASK;
-		msg_ext = hipcte & APL_DSP_REG_HIPCTE_MSG_MASK;
-
-		dev_vdbg(sdev->dev,
-			 "ipc: firmware initiated, msg:0x%x, msg_ext:0x%x\n",
-			 msg, msg_ext);
-
-		/* handle messages from DSP */
-		if ((hipct & SOF_IPC_PANIC_MAGIC_MASK) == SOF_IPC_PANIC_MAGIC) {
-			dev_err(sdev->dev, "error : DSP panic!\n");
-			snd_sof_dsp_cmd_done(sdev);
-			snd_sof_dsp_dbg_dump(sdev, SOF_DBG_REGS | SOF_DBG_MBOX);
-			snd_sof_trace_notify_for_error(sdev);
-		} else {
-			snd_sof_ipc_msgs_rx(sdev);
-		}
-
-		/* clear busy interrupt */
-		snd_sof_dsp_update_bits_forced(sdev, APL_DSP_BAR,
-					       APL_DSP_REG_HIPCT,
-					       APL_DSP_REG_HIPCT_BUSY,
-					       APL_DSP_REG_HIPCT_BUSY);
-
-		ret = IRQ_HANDLED;
-	}
-
-	if (ret == IRQ_HANDLED) {
-		/* reenable IPC interrupt */
-		snd_sof_dsp_update_bits(sdev, APL_DSP_BAR, APL_DSP_REG_ADSPIC,
-					APL_ADSPIC_IPC, APL_ADSPIC_IPC);
-
-		/* continue to send any remaining messages... */
-		snd_sof_ipc_msgs_tx(sdev);
-	}
-
-	if (sdev->code_loading)	{
-		sdev->code_loading = 0;
-		wake_up(&sdev->waitq);
-	}
-
-	return ret;
-}
-
-static irqreturn_t cnl_irq_thread(int irq, void *context)
-{
-	struct snd_sof_dev *sdev = (struct snd_sof_dev *)context;
-	u32 hipci, hipcida, hipctdr, hipctdd, msg = 0, msg_ext = 0;
-	irqreturn_t ret = IRQ_NONE;
-
-	/* here we handle IPC interrupts only */
-	if (!(sdev->irq_status & APL_ADSPIS_IPC))
-		return ret;
-
-	hipcida = snd_sof_dsp_read(sdev, APL_DSP_BAR, CNL_DSP_REG_HIPCIDA);
-	hipctdr = snd_sof_dsp_read(sdev, APL_DSP_BAR, CNL_DSP_REG_HIPCTDR);
-
-	/* reply message from DSP */
-	if (hipcida & CNL_DSP_REG_HIPCIDA_DONE) {
-		hipci = snd_sof_dsp_read(sdev, APL_DSP_BAR,
-					 CNL_DSP_REG_HIPCIDR);
-		msg_ext = hipci & CNL_DSP_REG_HIPCIDR_MSG_MASK;
-		msg = hipcida & CNL_DSP_REG_HIPCIDA_MSG_MASK;
-
-		dev_vdbg(sdev->dev,
-			 "ipc: firmware response, msg:0x%x, msg_ext:0x%x\n",
-			 msg, msg_ext);
-
-		/* mask Done interrupt */
-		snd_sof_dsp_update_bits(sdev, APL_DSP_BAR,
-					CNL_DSP_REG_HIPCCTL,
-					CNL_DSP_REG_HIPCCTL_DONE, 0);
-
-		/* handle immediate reply from DSP core */
-		snd_sof_ipc_reply(sdev, msg);
-
-		/* clear DONE bit - tell DSP we have completed the operation */
-		snd_sof_dsp_update_bits_forced(sdev, APL_DSP_BAR,
-					       CNL_DSP_REG_HIPCIDA,
-					       CNL_DSP_REG_HIPCIDA_DONE,
-					       CNL_DSP_REG_HIPCIDA_DONE);
-
-		/* unmask Done interrupt */
-		snd_sof_dsp_update_bits(sdev, APL_DSP_BAR,
-					CNL_DSP_REG_HIPCCTL,
-					CNL_DSP_REG_HIPCCTL_DONE,
-					CNL_DSP_REG_HIPCCTL_DONE);
-
-		ret = IRQ_HANDLED;
-	}
-
-	hipctdr = snd_sof_dsp_read(sdev, APL_DSP_BAR, CNL_DSP_REG_HIPCTDR);
-
-	/* new message from DSP */
-	if (hipctdr & CNL_DSP_REG_HIPCTDR_BUSY) {
-		hipctdd = snd_sof_dsp_read(sdev, APL_DSP_BAR,
-					   CNL_DSP_REG_HIPCTDD);
-		msg = hipctdr & CNL_DSP_REG_HIPCTDR_MSG_MASK;
-		msg_ext = hipctdd & CNL_DSP_REG_HIPCTDD_MSG_MASK;
-
-		dev_vdbg(sdev->dev,
-			 "ipc: firmware initiated, msg:0x%x, msg_ext:0x%x\n",
-			 msg, msg_ext);
-
-		/* handle messages from DSP */
-		if ((hipctdr & SOF_IPC_PANIC_MAGIC_MASK) ==
-		   SOF_IPC_PANIC_MAGIC) {
-			dev_err(sdev->dev, "error : DSP panic!\n");
-			snd_sof_dsp_cmd_done(sdev);
-			snd_sof_dsp_dbg_dump(sdev, SOF_DBG_REGS | SOF_DBG_MBOX);
-			snd_sof_trace_notify_for_error(sdev);
-		} else {
-			snd_sof_ipc_msgs_rx(sdev);
-		}
-
-		/* clear busy interrupt to tell dsp controller this */
-		/* interrupt has been accepted, not trigger it again */
-		snd_sof_dsp_update_bits_forced(sdev, APL_DSP_BAR,
-					       CNL_DSP_REG_HIPCTDR,
-					       CNL_DSP_REG_HIPCTDR_BUSY,
-					       CNL_DSP_REG_HIPCTDR_BUSY);
-
-		ret = IRQ_HANDLED;
-	}
-
-	if (ret == IRQ_HANDLED) {
-		/* reenable IPC interrupt */
-		snd_sof_dsp_update_bits(sdev, APL_DSP_BAR, APL_DSP_REG_ADSPIC,
-					APL_ADSPIC_IPC, APL_ADSPIC_IPC);
-
-		/* continue to send any remaining messages... */
-		snd_sof_ipc_msgs_tx(sdev);
-	}
-
-	if (sdev->code_loading)	{
-		sdev->code_loading = 0;
-		wake_up(&sdev->waitq);
-	}
-
-	return ret;
-}
-
-static int apl_cmd_done(struct snd_sof_dev *sdev)
-{
-	/* clear busy interrupt */
-	snd_sof_dsp_update_bits_forced(sdev, APL_DSP_BAR,
-				       APL_DSP_REG_HIPCT,
-				       APL_DSP_REG_HIPCT_BUSY,
-				       APL_DSP_REG_HIPCT_BUSY);
-
-	/* TODO: do we need to ack DSP ?? */
-
-	return 0;
-}
-
-static int cnl_cmd_done(struct snd_sof_dev *sdev)
-{
-	/* set done bit to ack dsp the msg has been processed */
-	snd_sof_dsp_update_bits_forced(sdev, APL_DSP_BAR,
-				       CNL_DSP_REG_HIPCTDA,
-				       CNL_DSP_REG_HIPCTDA_DONE,
-				       CNL_DSP_REG_HIPCTDA_DONE);
-
-	return 0;
-}
-
-static irqreturn_t skl_interrupt(int irq, void *context)
-{
-	struct snd_sof_dev *sdev = (struct snd_sof_dev *)context;
-	u32 status;
-
-	if (!pm_runtime_active(sdev->dev))
-		return IRQ_NONE;
-
-	status = snd_sof_dsp_read(sdev, APL_HDA_BAR, SOF_HDA_INTSTS);
-
-	if (status == 0 || status == 0xffffffff)
-		return IRQ_NONE;
-
-	return status ? IRQ_WAKE_THREAD : IRQ_HANDLED;
-}
-
-static irqreturn_t skl_threaded_handler(int irq, void *context)
-{
-	struct snd_sof_dev *sdev = (struct snd_sof_dev *)context;
-	struct snd_sof_hda_dev *hdev = &sdev->hda;
-	u32 status = snd_sof_dsp_read(sdev, APL_HDA_BAR, SOF_HDA_INTSTS);
-	u32 sd_status;
-	int i;
-
-	/* check playback streams */
-	for (i = 0; i < hdev->num_playback; i++) {
-		/* is IRQ for this stream ? */
-		if (status & (1 << hdev->pstream[i].index)) {
-			sd_status =
-				snd_sof_dsp_read(sdev, APL_HDA_BAR,
-						 hdev->pstream[i].sd_offset +
-						 SOF_HDA_ADSP_REG_CL_SD_STS) &
-						 0xff;
-
-			dev_dbg(sdev->dev, "pstream %d status 0x%x\n",
-				i, sd_status);
-
-			snd_sof_dsp_update_bits(sdev, APL_HDA_BAR,
-						hdev->pstream[i].sd_offset +
-						SOF_HDA_ADSP_REG_CL_SD_STS,
-						SOF_HDA_CL_DMA_SD_INT_MASK,
-						SOF_HDA_CL_DMA_SD_INT_MASK);
-
-			if (!hdev->pstream[i].substream ||
-			    !hdev->pstream[i].running ||
-			    (sd_status & SOF_HDA_CL_DMA_SD_INT_MASK) == 0)
-				continue;
-
-			/* update buffer position to ALSA */
-			snd_pcm_period_elapsed(hdev->pstream[i].substream);
-		}
-	}
-
-	/* check capture streams */
-	for (i = 0; i < hdev->num_capture; i++) {
-		/* is IRQ for this stream ? */
-		if (status & (1 << hdev->cstream[i].index)) {
-			sd_status =
-				snd_sof_dsp_read(sdev, APL_HDA_BAR,
-						 hdev->cstream[i].sd_offset +
-						 SOF_HDA_ADSP_REG_CL_SD_STS) &
-						 0xff;
-
-			dev_dbg(sdev->dev, "cstream %d status 0x%x\n",
-				i, sd_status);
-
-			snd_sof_dsp_update_bits(sdev, APL_HDA_BAR,
-						hdev->cstream[i].sd_offset +
-						SOF_HDA_ADSP_REG_CL_SD_STS,
-						SOF_HDA_CL_DMA_SD_INT_MASK,
-						SOF_HDA_CL_DMA_SD_INT_MASK);
-
-			if (!hdev->cstream[i].substream ||
-			    !hdev->cstream[i].running ||
-			    (sd_status & SOF_HDA_CL_DMA_SD_INT_MASK) == 0)
-				continue;
-
-			/* update buffer position to ALSA */
-			snd_pcm_period_elapsed(hdev->cstream[i].substream);
-		}
-	}
-
-	return IRQ_HANDLED;
-}
-
-/*
- * DSP control.
- */
-
-static int
-apl_dsp_core_reset_enter(struct snd_sof_dev *sdev, unsigned int core_mask)
-{
-	u32 adspcs;
-	int ret;
-
-	/* set reset bits for cores */
-	snd_sof_dsp_update_bits_unlocked(sdev, APL_DSP_BAR,
-					 APL_DSP_REG_ADSPCS,
-					 APL_ADSPCS_CRST_MASK(core_mask),
-					 APL_ADSPCS_CRST_MASK(core_mask));
-
-	/* poll with timeout to check if operation successful */
-	ret = snd_sof_dsp_register_poll(sdev, APL_DSP_BAR, APL_DSP_REG_ADSPCS,
-					APL_ADSPCS_CRST_MASK(core_mask),
-					APL_ADSPCS_CRST_MASK(core_mask),
-					APL_DSP_RESET_TIMEOUT);
-
-	adspcs = snd_sof_dsp_read(sdev, APL_DSP_BAR, APL_DSP_REG_ADSPCS);
-	if ((adspcs & APL_ADSPCS_CRST_MASK(core_mask)) !=
-		APL_ADSPCS_CRST_MASK(core_mask)) {
-		dev_err(sdev->dev,
-			"error: reset enter failed: core_mask %x adspcs 0x%x\n",
-			core_mask, adspcs);
-		ret = -EIO;
-	}
-
-	return ret;
-}
-
-static int apl_dsp_core_reset_leave(struct snd_sof_dev *sdev,
-				    unsigned int core_mask)
-{
-	u32 adspcs;
-	int ret;
-
-	/* clear reset bits for cores */
-	snd_sof_dsp_update_bits_unlocked(sdev, APL_DSP_BAR,
-					 APL_DSP_REG_ADSPCS,
-					 APL_ADSPCS_CRST_MASK(core_mask), 0);
-
-	/* poll with timeout to check if operation successful */
-	ret = snd_sof_dsp_register_poll(sdev, APL_DSP_BAR, APL_DSP_REG_ADSPCS,
-					APL_ADSPCS_CRST_MASK(core_mask), 0,
-					APL_DSP_RESET_TIMEOUT);
-
-	adspcs = snd_sof_dsp_read(sdev, APL_DSP_BAR, APL_DSP_REG_ADSPCS);
-	if ((adspcs & APL_ADSPCS_CRST_MASK(core_mask)) != 0) {
-		dev_err(sdev->dev,
-			"error: reset leave failed: core_mask %x adspcs 0x%x\n",
-			core_mask, adspcs);
-		ret = -EIO;
-	}
-
-	return ret;
-}
-
-static int apl_reset_core(struct snd_sof_dev *sdev, unsigned int core_mask)
-{
-	/* stall core */
-	snd_sof_dsp_update_bits_unlocked(sdev, APL_HDA_BAR,
-					 APL_DSP_REG_ADSPCS,
-					 APL_ADSPCS_CSTALL_MASK(core_mask),
-					 APL_ADSPCS_CSTALL_MASK(core_mask));
-
-	/* set reset state */
-	return apl_dsp_core_reset_enter(sdev, core_mask);
-}
-
-static int apl_run_core(struct snd_sof_dev *sdev, unsigned int core_mask)
-{
-	int ret;
-
-	/* leave reset state */
-	ret = apl_dsp_core_reset_leave(sdev, core_mask);
-	if (ret < 0)
-		return ret;
-
-	/* run core */
-	dev_dbg(sdev->dev, "unstall/run core: core_mask = %x\n", core_mask);
-	snd_sof_dsp_update_bits_unlocked(sdev, APL_DSP_BAR,
-					 APL_DSP_REG_ADSPCS,
-					 APL_ADSPCS_CSTALL_MASK(core_mask), 0);
-
-	if (!is_apl_core_enable(sdev, core_mask)) {
-		apl_reset_core(sdev, core_mask);
-		dev_err(sdev->dev, "error: DSP start core failed: core_mask %x\n",
-			core_mask);
-		ret = -EIO;
-	}
-
-	return ret;
-}
-
-/*
- * Power Management.
- */
-
-static int apl_core_power_up(struct snd_sof_dev *sdev, unsigned int core_mask)
-{
-	u32 adspcs;
-	int ret;
-
-	/* update bits */
-	snd_sof_dsp_update_bits(sdev, APL_DSP_BAR, APL_DSP_REG_ADSPCS,
-				APL_ADSPCS_SPA_MASK(core_mask),
-				APL_ADSPCS_SPA_MASK(core_mask));
-
-	/* poll with timeout to check if operation successful */
-	ret = snd_sof_dsp_register_poll(sdev, APL_DSP_BAR, APL_DSP_REG_ADSPCS,
-					APL_ADSPCS_CPA_MASK(core_mask),
-					APL_ADSPCS_CPA_MASK(core_mask),
-					APL_DSP_PU_TIMEOUT);
-	if (ret < 0)
-		dev_err(sdev->dev, "error: timeout on core powerup\n");
-
-	/* did core power up ? */
-	adspcs = snd_sof_dsp_read(sdev, APL_DSP_BAR, APL_DSP_REG_ADSPCS);
-	if ((adspcs & APL_ADSPCS_CPA_MASK(core_mask)) !=
-		APL_ADSPCS_CPA_MASK(core_mask)) {
-		dev_err(sdev->dev,
-			"error: power up core failed core_mask %xadspcs 0x%x\n",
-			core_mask, adspcs);
-		ret = -EIO;
-	}
-
-	return ret;
-}
-
-static int apl_core_power_down(struct snd_sof_dev *sdev, unsigned int core_mask)
-{
-	/* update bits */
-	snd_sof_dsp_update_bits_unlocked(sdev, APL_DSP_BAR,
-					 APL_DSP_REG_ADSPCS,
-					 APL_ADSPCS_SPA_MASK(core_mask), 0);
-
-	/* poll with timeout to check if operation successful */
-	return snd_sof_dsp_register_poll(sdev, APL_DSP_BAR,
-		APL_DSP_REG_ADSPCS, APL_ADSPCS_CPA_MASK(core_mask), 0,
-		APL_DSP_PD_TIMEOUT);
-}
-
-static bool is_apl_core_enable(struct snd_sof_dev *sdev,
-			       unsigned int core_mask)
-{
-	int val;
-	bool is_enable;
-
-	val = snd_sof_dsp_read(sdev, APL_DSP_BAR, APL_DSP_REG_ADSPCS);
-
-	is_enable = ((val & APL_ADSPCS_CPA_MASK(core_mask)) &&
-			(val & APL_ADSPCS_SPA_MASK(core_mask)) &&
-			!(val & APL_ADSPCS_CRST_MASK(core_mask)) &&
-			!(val & APL_ADSPCS_CSTALL_MASK(core_mask)));
-
-	dev_dbg(sdev->dev, "DSP core(s) enabled? %d : core_mask %x\n",
-		is_enable, core_mask);
-
-	return is_enable;
-}
-
-static int apl_disable_core(struct snd_sof_dev *sdev, unsigned int core_mask)
-{
-	int ret;
-
-	/* place core in reset prior to power doown */
-	ret = apl_reset_core(sdev, core_mask);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: dsp core reset failed: core_mask %x\n",
-			core_mask);
-		return ret;
-	}
-
-	/* power down core*/
-	ret = apl_core_power_down(sdev, core_mask);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: dsp core power down fail mask %x: %d\n",
-			core_mask, ret);
-		return ret;
-	}
-
-	/* make sure we are in OFF state */
-	if (is_apl_core_enable(sdev, core_mask)) {
-		dev_err(sdev->dev, "error: dsp core disable fail mask %x: %d\n",
-			core_mask, ret);
-		ret = -EIO;
-	}
-
-	return ret;
-}
-
-static int apl_is_ready(struct snd_sof_dev *sdev)
-{
-	u64 val;
-
-	val = snd_sof_dsp_read(sdev, APL_DSP_BAR, APL_DSP_REG_HIPCI);
-	if (val & APL_DSP_REG_HIPCI_BUSY)
-		return 0;
-
-	return 1;
-}
-
-static int apl_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)
-{
-	u32 cmd = msg->header;
-
-	/* send the message */
-	apl_mailbox_write(sdev, sdev->host_box.offset, msg->msg_data,
-			  msg->msg_size);
-	snd_sof_dsp_write(sdev, APL_DSP_BAR, APL_DSP_REG_HIPCI,
-			  cmd | APL_DSP_REG_HIPCI_BUSY);
-
-	return 0;
-}
-
-static int cnl_is_ready(struct snd_sof_dev *sdev)
-{
-	u64 val;
-
-	val = snd_sof_dsp_read(sdev, APL_DSP_BAR, CNL_DSP_REG_HIPCIDR);
-	if (val & CNL_DSP_REG_HIPCIDR_BUSY)
-		return 0;
-
-	return 1;
-}
-
-static int cnl_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)
-{
-	u32 cmd = msg->header;
-
-	/* send the message */
-	apl_mailbox_write(sdev, sdev->host_box.offset, msg->msg_data,
-			  msg->msg_size);
-	snd_sof_dsp_write(sdev, APL_DSP_BAR, CNL_DSP_REG_HIPCIDR,
-			  cmd | CNL_DSP_REG_HIPCIDR_BUSY);
-
-	return 0;
-}
-
-static int apl_get_reply(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)
-{
-	struct sof_ipc_reply reply;
-	int ret = 0;
-	u32 size;
-
-	/* get reply */
-	apl_mailbox_read(sdev, sdev->host_box.offset, &reply, sizeof(reply));
-	if (reply.error < 0) {
-		size = sizeof(reply);
-		ret = reply.error;
-	} else {
-		/* reply correct size ? */
-		if (reply.hdr.size != msg->reply_size) {
-			dev_err(sdev->dev, "error: reply expected 0x%lx got 0x%x bytes\n",
-				msg->reply_size, reply.hdr.size);
-			size = msg->reply_size;
-			ret = -EINVAL;
-		} else {
-			size = reply.hdr.size;
-		}
-	}
-
-	/* read the message */
-	if (msg->msg_data && size > 0)
-		apl_mailbox_read(sdev, sdev->host_box.offset,
-				 msg->reply_data, size);
-
-	return ret;
-}
-
-/*
- * HDA Operations.
- */
-
-static int apl_link_reset(struct snd_sof_dev *sdev)
-{
-	unsigned long timeout;
-	u32 gctl = 0;
-
-	/* reset the HDA controller */
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, SOF_HDA_GCTL,
-				SOF_HDA_GCTL_RESET, 0);
-
-	/* wait for reset */
-	timeout = jiffies + msecs_to_jiffies(APL_CTRL_RESET_TIMEOUT);
-	while (time_before(jiffies, timeout)) {
-		usleep_range(500, 1000);
-		gctl = snd_sof_dsp_read(sdev, APL_HDA_BAR, SOF_HDA_GCTL);
-		if ((gctl & SOF_HDA_GCTL_RESET) == 0)
-			goto clear;
-	}
-
-	/* reset failed */
-	dev_err(sdev->dev, "error: failed to reset HDA controller gctl 0x%x\n",
-		gctl);
-	return -EIO;
-
-clear:
-	/* delay for >= 100us for codec PLL to settle per spec
-	 * Rev 0.9 section 5.5.1
-	 */
-	usleep_range(500, 1000);
-
-	/* now take controller out of reset */
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, SOF_HDA_GCTL,
-				SOF_HDA_GCTL_RESET, SOF_HDA_GCTL_RESET);
-
-	/* wait for controller to be ready */
-	timeout = jiffies + msecs_to_jiffies(APL_CTRL_RESET_TIMEOUT);
-	while (time_before(jiffies, timeout)) {
-		gctl = snd_sof_dsp_read(sdev, APL_HDA_BAR, SOF_HDA_GCTL);
-		if ((gctl & SOF_HDA_GCTL_RESET) == 1)
-			return 0;
-		usleep_range(500, 1000);
-	}
-
-	/* reset failed */
-	dev_err(sdev->dev, "error: failed to ready HDA controller gctl 0x%x\n",
-		gctl);
-	return -EIO;
-}
-
-static int apl_get_caps(struct snd_sof_dev *sdev)
-{
-	u32 cap, offset, feature;
-	int ret = -ENODEV, count = 0;
-
-	offset = snd_sof_dsp_read(sdev, APL_HDA_BAR, SOF_HDA_LLCH);
-
-	do {
-		cap = snd_sof_dsp_read(sdev, APL_HDA_BAR, offset);
-
-		dev_dbg(sdev->dev, "checking for capabilities at offset 0x%x\n",
-			offset & SOF_HDA_CAP_NEXT_MASK);
-
-		feature = (cap & SOF_HDA_CAP_ID_MASK) >> SOF_HDA_CAP_ID_OFF;
-
-		switch (feature) {
-		case SOF_HDA_PP_CAP_ID:
-			dev_dbg(sdev->dev, "found DSP capability at 0x%x\n",
-				offset);
-			sdev->bar[APL_PP_BAR] = sdev->bar[APL_HDA_BAR] +
-				offset;
-			ret = 0;
-			break;
-		case SOF_HDA_SPIB_CAP_ID:
-			dev_dbg(sdev->dev, "found SPIB capability at 0x%x\n",
-				offset);
-			sdev->bar[APL_SPIB_BAR] = sdev->bar[APL_HDA_BAR] +
-				offset;
-			break;
-		case SOF_HDA_DRSM_CAP_ID:
-			dev_dbg(sdev->dev, "found DRSM capability at 0x%x\n",
-				offset);
-			sdev->bar[APL_DRSM_BAR] = sdev->bar[APL_HDA_BAR] +
-				offset;
-			break;
-		default:
-			dev_vdbg(sdev->dev, "found capability %d at 0x%x\n",
-				 feature, offset);
-			break;
-		}
-
-		offset = cap & SOF_HDA_CAP_NEXT_MASK;
-	} while (count++ <= SOF_HDA_MAX_CAPS && offset);
-
-	return ret;
-}
-
-static int apl_stream_init(struct snd_sof_dev *sdev)
-{
-	struct snd_sof_hda_dev *hdev = &sdev->hda;
-	struct snd_sof_hda_stream *stream;
-	struct pci_dev *pci = sdev->pci;
-	int i, num_playback, num_capture, num_total, ret;
-	u32 gcap;
-
-	gcap = snd_sof_dsp_read(sdev, APL_HDA_BAR, SOF_HDA_GCAP);
-	dev_dbg(sdev->dev, "hda global caps = 0x%x\n", gcap);
-
-	/* get stream count from GCAP */
-	num_capture = (gcap >> 8) & 0x0f;
-	num_playback = (gcap >> 12) & 0x0f;
-	num_total = num_playback + num_capture;
-
-	hdev->num_capture = num_capture;
-	hdev->num_playback = num_playback;
-
-	dev_dbg(sdev->dev, "detected %d playback and %d capture streams\n",
-		num_playback, num_capture);
-
-	if (num_playback >= SOF_HDA_PLAYBACK_STREAMS) {
-		dev_err(sdev->dev, "error: too many playback streams %d\n",
-			num_playback);
-		return -EINVAL;
-	}
-
-	if (num_capture >= SOF_HDA_CAPTURE_STREAMS) {
-		dev_err(sdev->dev, "error: too many capture streams %d\n",
-			num_playback);
-		return -EINVAL;
-	}
-
-	/* mem alloc for the position buffer */
-	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &pci->dev, 8,
-				  &hdev->posbuffer);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: posbuffer dma alloc failed\n");
-		return -ENOMEM;
-	}
-
-	/* mem alloc for ring buffer */
-	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &pci->dev,
-				  PAGE_SIZE, &hdev->ringbuffer);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: ringbuffer dma alloc failed\n");
-		return -ENOMEM;
-	}
-
-	/* create capture streams */
-	for (i = 0; i < num_capture; i++) {
-		stream = &hdev->cstream[i];
-
-		stream->pphc_addr = sdev->bar[APL_PP_BAR] + SOF_HDA_PPHC_BASE +
-			SOF_HDA_PPHC_INTERVAL * i;
-
-		stream->pplc_addr = sdev->bar[APL_PP_BAR] + SOF_HDA_PPLC_BASE +
-			SOF_HDA_PPLC_MULTI * num_total +
-			SOF_HDA_PPLC_INTERVAL * i;
-
-		/* do we support SPIB */
-		if (sdev->bar[APL_SPIB_BAR]) {
-			stream->spib_addr = sdev->bar[APL_SPIB_BAR] +
-				SOF_HDA_SPIB_BASE + SOF_HDA_SPIB_INTERVAL * i +
-				SOF_HDA_SPIB_SPIB;
-
-			stream->fifo_addr = sdev->bar[APL_SPIB_BAR] +
-				SOF_HDA_SPIB_BASE + SOF_HDA_SPIB_INTERVAL * i +
-				SOF_HDA_SPIB_MAXFIFO;
-		}
-
-		/* do we support DRSM */
-		if (sdev->bar[APL_DRSM_BAR])
-			stream->drsm_addr = sdev->bar[APL_DRSM_BAR] +
-				SOF_HDA_DRSM_BASE + SOF_HDA_DRSM_INTERVAL * i;
-
-		stream->sd_offset = 0x20 * i + SOF_HDA_ADSP_LOADER_BASE;
-		stream->sd_addr = sdev->bar[APL_HDA_BAR] +
-					stream->sd_offset;
-
-		stream->stream_tag = i + 1;
-		stream->open = false;
-		stream->running = false;
-		stream->direction = SNDRV_PCM_STREAM_CAPTURE;
-		stream->index = i;
-
-		/* memory alloc for stream BDL */
-		ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &pci->dev,
-					  APL_BDL_SIZE, &stream->bdl);
-		if (ret < 0) {
-			dev_err(sdev->dev, "error: stream bdl dma alloc failed\n");
-			return -ENOMEM;
-		}
-		stream->posbuf = (__le32 *)(hdev->posbuffer.area +
-			(stream->index) * 8);
-	}
-
-	/* create playback streams */
-	for (i = num_capture; i < num_total; i++) {
-		stream = &hdev->pstream[i - num_capture];
-
-		/* we always have DSP support */
-		stream->pphc_addr = sdev->bar[APL_PP_BAR] + SOF_HDA_PPHC_BASE +
-			SOF_HDA_PPHC_INTERVAL * i;
-
-		stream->pplc_addr = sdev->bar[APL_PP_BAR] + SOF_HDA_PPLC_BASE +
-			SOF_HDA_PPLC_MULTI * num_total +
-			SOF_HDA_PPLC_INTERVAL * i;
-
-		/* do we support SPIB */
-		if (sdev->bar[APL_SPIB_BAR]) {
-			stream->spib_addr = sdev->bar[APL_SPIB_BAR] +
-				SOF_HDA_SPIB_BASE + SOF_HDA_SPIB_INTERVAL * i +
-				SOF_HDA_SPIB_SPIB;
-
-			stream->fifo_addr = sdev->bar[APL_SPIB_BAR] +
-				SOF_HDA_SPIB_BASE + SOF_HDA_SPIB_INTERVAL * i +
-				SOF_HDA_SPIB_MAXFIFO;
-		}
-
-		/* do we support DRSM */
-		if (sdev->bar[APL_DRSM_BAR])
-			stream->drsm_addr = sdev->bar[APL_DRSM_BAR] +
-				SOF_HDA_DRSM_BASE + SOF_HDA_DRSM_INTERVAL * i;
-
-		stream->sd_offset = 0x20 * i + SOF_HDA_ADSP_LOADER_BASE;
-		stream->sd_addr = sdev->bar[APL_HDA_BAR] +
-					stream->sd_offset;
-		stream->stream_tag = i - num_capture + 1;
-		stream->open = false;
-		stream->running = false;
-		stream->direction = SNDRV_PCM_STREAM_PLAYBACK;
-		stream->index = i;
-
-		/* mem alloc for stream BDL */
-		ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &pci->dev,
-					  APL_BDL_SIZE, &stream->bdl);
-		if (ret < 0) {
-			dev_err(sdev->dev, "error: stream bdl dma alloc failed\n");
-			return -ENOMEM;
-		}
-
-		stream->posbuf = (__le32 *)(hdev->posbuffer.area +
-			(stream->index) * 8);
-	}
-
-	return 0;
-}
-
-static int apl_stream_reset(struct snd_sof_dev *sdev)
-{
-	struct snd_sof_hda_dev *hdev = &sdev->hda;
-	struct snd_sof_hda_stream *stream;
-	int i;
-
-	if (hdev->posbuffer.area)
-		/* free position buffer */
-		snd_dma_free_pages(&hdev->posbuffer);
-
-	if (hdev->ringbuffer.area)
-		/* free ring buffer */
-		snd_dma_free_pages(&hdev->ringbuffer);
-
-	/* free capture streams */
-	for (i = 0; i < hdev->num_capture; i++) {
-		stream = &hdev->cstream[i];
-
-		if (stream->bdl.area)
-			/* free bdl buffer */
-			snd_dma_free_pages(&stream->bdl);
-	}
-
-	/* free playback streams */
-	for (i = 0; i < hdev->num_playback; i++) {
-		stream = &hdev->pstream[i];
-
-		if (stream->bdl.area)
-			/* free bdl buffer */
-			snd_dma_free_pages(&stream->bdl);
-	}
-
-	return 0;
-}
-
-static const struct snd_sof_chip_info chip_info[] = {
-{
-	.id = 0x5a98,
-	.cores_num = 2,
-	.cores_mask = APL_DSP_CORE_MASK(0) | APL_DSP_CORE_MASK(1),
-	.ipc_req = APL_DSP_REG_HIPCI,
-	.ipc_req_mask = APL_DSP_REG_HIPCI_BUSY,
-	.ipc_ack = APL_DSP_REG_HIPCIE,
-	.ipc_ack_mask = APL_DSP_REG_HIPCIE_DONE,
-	.ipc_ctl = APL_DSP_REG_HIPCCTL,
-	.irq_thread = apl_irq_thread
-},
-{
-	.id = 0x1a98,
-	.cores_num = 2,
-	.cores_mask = APL_DSP_CORE_MASK(0) | APL_DSP_CORE_MASK(1),
-	.ipc_req = APL_DSP_REG_HIPCI,
-	.ipc_req_mask = APL_DSP_REG_HIPCI_BUSY,
-	.ipc_ack = APL_DSP_REG_HIPCIE,
-	.ipc_ack_mask = APL_DSP_REG_HIPCIE_DONE,
-	.ipc_ctl = APL_DSP_REG_HIPCCTL,
-	.irq_thread = apl_irq_thread
-},
-{
-	.id = 0x9dc8,
-	.cores_num = 4,
-	.cores_mask = APL_DSP_CORE_MASK(0) |
-				APL_DSP_CORE_MASK(1) |
-				APL_DSP_CORE_MASK(2) |
-				APL_DSP_CORE_MASK(3),
-	.ipc_req = CNL_DSP_REG_HIPCIDR,
-	.ipc_req_mask = CNL_DSP_REG_HIPCIDR_BUSY,
-	.ipc_ack = CNL_DSP_REG_HIPCIDA,
-	.ipc_ack_mask = CNL_DSP_REG_HIPCIDA_DONE,
-	.ipc_ctl = CNL_DSP_REG_HIPCCTL,
-	.irq_thread = cnl_irq_thread
-},
-};
-
-const struct snd_sof_chip_info *sof_get_chip_info(int pci_id)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(chip_info); i++) {
-		if (chip_info[i].id == pci_id)
-			return &chip_info[i];
-	}
-
-	return NULL;
-}
-
-/*
- * first boot sequence has some extra steps. core 0 waits for power
- * status on core 1, so power up core 1 also momentarily, keep it in
- * reset/stall and then turn it off
- */
-static int apl_init(struct snd_sof_dev *sdev,
-		    const void *fwdata, u32 fwsize)
-{
-	int stream_tag, ret, i;
-	u32 hipcie;
-	const struct snd_sof_chip_info *chip;
-
-	chip = sof_get_chip_info(sdev->pci->device);
-	if (!chip) {
-		dev_err(sdev->dev, "no such device supported, chip id:%x\n",
-			sdev->pci->device);
-		ret = -EIO;
-		goto err;
-	}
-
-	/* prepare DMA for code loader stream */
-	stream_tag = apl_cl_prepare(sdev, 0x40, fwsize, &sdev->dmab,
-				    SNDRV_PCM_STREAM_PLAYBACK);
-
-	if (stream_tag <= 0) {
-		dev_err(sdev->dev, "error: dma prepare for fw loading err: %x\n",
-			stream_tag);
-		return stream_tag;
-	}
-
-	memcpy(sdev->dmab.area, fwdata, fwsize);
-
-	/* step 1: power up corex */
-	ret = apl_core_power_up(sdev, chip->cores_mask);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: dsp core 0/1 power up failed\n");
-		goto err;
-	}
-
-	/* step 2: purge FW request */
-	snd_sof_dsp_write(sdev, APL_DSP_BAR, chip->ipc_req,
-			  chip->ipc_req_mask | (APL_IPC_PURGE_FW |
-			  ((stream_tag - 1) << 9)));
-
-	/* step 3: unset core 0 reset state & unstall/run core 0 */
-	ret = apl_run_core(sdev, APL_DSP_CORE_MASK(0));
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: dsp core start failed %d\n", ret);
-		ret = -EIO;
-		goto err;
-	}
-
-	/* step 4: wait for IPC DONE bit from ROM */
-	for (i = APL_INIT_TIMEOUT; i > 0; i--) {
-		hipcie = snd_sof_dsp_read(sdev, APL_DSP_BAR,
-					  chip->ipc_ack);
-
-		if (hipcie & chip->ipc_ack_mask) {
-			snd_sof_dsp_update_bits(sdev, APL_DSP_BAR,
-						chip->ipc_ack,
-						chip->ipc_ack_mask,
-						chip->ipc_ack_mask);
-			goto step5;
-		}
-		mdelay(1);
-	}
-
-	dev_err(sdev->dev, "error: waiting for HIPCIE done, reg: 0x%x\n",
-		hipcie);
-	goto err;
-
-step5:
-	/* step 5: power down corex */
-	ret = apl_core_power_down(sdev,
-				  chip->cores_mask & ~(APL_DSP_CORE_MASK(0)));
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: dsp core x power down failed\n");
-		goto err;
-	}
-
-	/* step 6: enable interrupt */
-	snd_sof_dsp_update_bits(sdev, APL_DSP_BAR, APL_DSP_REG_ADSPIC,
-				APL_ADSPIC_IPC, APL_ADSPIC_IPC);
-
-	/* enable IPC DONE interrupt */
-	snd_sof_dsp_update_bits(sdev, APL_DSP_BAR, chip->ipc_ctl,
-				APL_DSP_REG_HIPCCTL_DONE,
-				APL_DSP_REG_HIPCCTL_DONE);
-
-	/* enable IPC BUSY interrupt */
-	snd_sof_dsp_update_bits(sdev, APL_DSP_BAR, chip->ipc_ctl,
-				APL_DSP_REG_HIPCCTL_BUSY,
-				APL_DSP_REG_HIPCCTL_BUSY);
-
-	/* step 7: wait for ROM init */
-	ret = snd_sof_dsp_register_poll(sdev, APL_DSP_BAR,
-					APL_SRAM_REG_ROM_STATUS,
-					APL_ROM_STS_MASK, APL_ROM_INIT,
-					APL_INIT_TIMEOUT);
-	if (ret >= 0)
-		goto out;
-
-	ret = -EIO;
-
-err:
-	apl_dump(sdev, SOF_DBG_REGS | SOF_DBG_PCI | SOF_DBG_MBOX);
-	//sdev->dsp_ops.cleanup(sdev->dev, &sdev->dmab, stream_tag);
-	apl_disable_core(sdev, APL_DSP_CORE_MASK(0) | APL_DSP_CORE_MASK(1));
-	return ret;
-
-out:
-	return stream_tag;
-}
-
-/*
- *DMA Code Loader for BXT/APL
- */
-
-int apl_load_firmware(struct snd_sof_dev *sdev,
-		      const struct firmware *fw)
-{
-	struct snd_sof_pdata *plat_data = dev_get_platdata(sdev->dev);
-	int ret;
-
-	/* set code loading condition to true */
-	sdev->code_loading = 1;
-
-	ret = request_firmware(&plat_data->fw,
-			       plat_data->machine->sof_fw_filename, sdev->dev);
-
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: request firmware failed err: %d\n",
-			ret);
-		return -EINVAL;
-	}
-
-	if (!plat_data->fw)
-		return -EINVAL;
-
-	return ret;
-}
-
-/*
- *firmware download and run for BXT/APL
- */
-
-int apl_run_firmware(struct snd_sof_dev *sdev)
-{
-	struct snd_sof_pdata *plat_data = dev_get_platdata(sdev->dev);
-	struct firmware stripped_firmware;
-	int ret, stream_tag;
-
-	stripped_firmware.data = plat_data->fw->data;
-	stripped_firmware.size = plat_data->fw->size;
-
-	stream_tag = apl_init(sdev, stripped_firmware.data,
-			      stripped_firmware.size);
-
-	/* retry enabling core and ROM load. seemed to help */
-	if (stream_tag < 0) {
-		stream_tag = apl_init(sdev, stripped_firmware.data,
-				      stripped_firmware.size);
-		if (stream_tag <= 0) {
-			dev_err(sdev->dev, "Error code=0x%x: FW status=0x%x\n",
-				snd_sof_dsp_read(sdev, APL_DSP_BAR,
-						 APL_SRAM_REG_ROM_ERROR),
-				snd_sof_dsp_read(sdev, APL_DSP_BAR,
-						 APL_SRAM_REG_ROM_STATUS));
-			dev_err(sdev->dev, "Core En/ROM load fail:%d\n",
-				stream_tag);
-			ret = stream_tag;
-			goto irq_err;
-		}
-	}
-
-	/* init for booting wait */
-	init_waitqueue_head(&sdev->boot_wait);
-	sdev->boot_complete = false;
-
-	/* at this point DSP ROM has been initialized and should be ready for
-	 * code loading and firmware boot
-	 */
-	ret = apl_transfer_fw(sdev, stream_tag);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: load fw failed err: %d\n", ret);
-		goto irq_err;
-	}
-
-	dev_dbg(sdev->dev, "Firmware download successful, booting...\n");
-
-	return ret;
-
-irq_err:
-	apl_dump(sdev, SOF_DBG_REGS | SOF_DBG_PCI | SOF_DBG_MBOX);
-	free_irq(sdev->ipc_irq, sdev);
-
-	/* disable DSP */
-	snd_sof_dsp_update_bits(sdev, APL_PP_BAR, SOF_HDA_REG_PP_PPCTL,
-				SOF_HDA_PPCTL_GPROCEN, 0);
-	dev_err(sdev->dev, "error: load fw failed err: %d\n", ret);
-	return ret;
-}
-
-/*
- * Probe and remove.
- */
-
-/*
- * We don't need to do a full HDA codec probe as external HDA codec mode is
- * considered legacy and will not be supported under SOF. HDMI/DP HDA will
- * be supported in the DSP.
- */
-static int apl_probe(struct snd_sof_dev *sdev)
-{
-	struct pci_dev *pci = sdev->pci;
-	int ret = 0, i;
-	struct snd_sof_hda_dev *hdev = &sdev->hda;
-	struct snd_sof_hda_stream *stream;
-	const struct snd_sof_chip_info *chip;
-
-	chip = sof_get_chip_info(sdev->pci->device);
-	if (!chip) {
-		dev_err(sdev->dev, "no such device supported, chip id:%x\n",
-			sdev->pci->device);
-		ret = -EIO;
-		goto err;
-	}
-
-	/* HDA base */
-	sdev->bar[APL_HDA_BAR] = pci_ioremap_bar(pci, APL_HDA_BAR);
-	if (!sdev->bar[APL_HDA_BAR]) {
-		dev_err(&pci->dev, "error: ioremap error\n");
-		return -ENXIO;
-	}
-
-	/* DSP base */
-	sdev->bar[APL_DSP_BAR] = pci_ioremap_bar(pci, APL_DSP_BAR);
-	if (!sdev->bar[APL_DSP_BAR]) {
-		dev_err(&pci->dev, "error: ioremap error\n");
-		ret = -ENXIO;
-		goto err;
-	}
-
-	/* TODO: add base offsets for each SRAM window */
-	sdev->mmio_bar = APL_DSP_BAR;
-	sdev->mailbox_bar = APL_DSP_BAR;
-
-	pci_set_master(pci);
-	synchronize_irq(pci->irq);
-
-	/* allow 64bit DMA address if supported by H/W */
-	if (!dma_set_mask(&pci->dev, DMA_BIT_MASK(64))) {
-		dev_dbg(&pci->dev, "64 bit\n");
-		dma_set_coherent_mask(&pci->dev, DMA_BIT_MASK(64));
-	} else {
-		dev_dbg(&pci->dev, "32 bit\n");
-		dma_set_mask(&pci->dev, DMA_BIT_MASK(32));
-		dma_set_coherent_mask(&pci->dev, DMA_BIT_MASK(32));
-	}
-
-	/* get controller capabilities */
-	ret = apl_get_caps(sdev);
-	if (ret < 0) {
-		dev_err(&pci->dev, "error: failed to find DSP capability\n");
-		goto err;
-	}
-
-	/* init streams */
-	ret = apl_stream_init(sdev);
-	if (ret < 0) {
-		dev_err(&pci->dev, "error: failed to init streams\n");
-		goto err;
-	}
-
-	/*
-	 * clear bits 0-2 of PCI register TCSEL (at offset 0x44)
-	 * TCSEL == Traffic Class Select Register, which sets PCI express QOS
-	 * Ensuring these bits are 0 clears playback static on some HD Audio
-	 * codecs. PCI register TCSEL is defined in the Intel manuals.
-	 */
-	snd_sof_pci_update_bits(sdev, PCI_TCSEL, 0x07, 0);
-
-	/*
-	 * while performing reset, controller may not come back properly causing
-	 * issues, so recommendation is to set CGCTL.MISCBDCGE to 0 then do
-	 * reset (init chip) and then again set CGCTL.MISCBDCGE to 1
-	 */
-	snd_sof_pci_update_bits(sdev, PCI_CGCTL,
-				PCI_CGCTL_MISCBDCGE_MASK, 0);
-
-	/* clear WAKESTS */
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, SOF_HDA_WAKESTS,
-				SOF_HDA_WAKESTS_INT_MASK,
-				SOF_HDA_WAKESTS_INT_MASK);
-
-	/* reset HDA controller */
-	ret = apl_link_reset(sdev);
-	if (ret < 0) {
-		dev_err(&pci->dev, "error: failed to reset HDA controller\n");
-		goto err;
-	}
-
-	/* clear stream status */
-	for (i = 0 ; i < hdev->num_capture ; i++) {
-		stream = &hdev->cstream[i];
-		if (stream)
-			snd_sof_dsp_update_bits(sdev, APL_HDA_BAR,
-						stream->sd_offset +
-						SOF_HDA_ADSP_REG_CL_SD_STS,
-						SOF_HDA_CL_DMA_SD_INT_MASK,
-						SOF_HDA_CL_DMA_SD_INT_MASK);
-	}
-
-	for (i = 0 ; i < hdev->num_playback ; i++) {
-		stream = &hdev->pstream[i];
-		if (stream)
-			snd_sof_dsp_update_bits(sdev, APL_HDA_BAR,
-						stream->sd_offset +
-						SOF_HDA_ADSP_REG_CL_SD_STS,
-						SOF_HDA_CL_DMA_SD_INT_MASK,
-						SOF_HDA_CL_DMA_SD_INT_MASK);
-	}
-
-	/* clear WAKESTS */
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, SOF_HDA_WAKESTS,
-				SOF_HDA_WAKESTS_INT_MASK,
-				SOF_HDA_WAKESTS_INT_MASK);
-
-	/* clear interrupt status register */
-	snd_sof_dsp_write(sdev, APL_HDA_BAR, SOF_HDA_INTSTS,
-			  SOF_HDA_INT_CTRL_EN | SOF_HDA_INT_ALL_STREAM);
-
-	/* enable CIE and GIE interrupts */
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, SOF_HDA_INTCTL,
-				SOF_HDA_INT_CTRL_EN | SOF_HDA_INT_GLOBAL_EN,
-				SOF_HDA_INT_CTRL_EN | SOF_HDA_INT_GLOBAL_EN);
-
-	dev_dbg(sdev->dev, "using PCI IRQ %d\n", sdev->pci->irq);
-
-	/* register our IRQ */
-	ret = request_threaded_irq(sdev->pci->irq, skl_interrupt,
-				   skl_threaded_handler, IRQF_SHARED,
-				   "AudioHDA", sdev);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to register HDA IRQ %d\n",
-			sdev->ipc_irq);
-		goto err;
-	}
-	sdev->hda.irq = pci->irq;
-
-	sdev->ipc_irq = pci->irq;
-	dev_dbg(sdev->dev, "using IPC IRQ %d\n", sdev->ipc_irq);
-	ret = request_threaded_irq(sdev->ipc_irq, apl_irq_handler,
-				   chip->irq_thread, IRQF_SHARED, "AudioDSP",
-				   sdev);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to register PCI IRQ %d\n",
-			sdev->ipc_irq);
-		goto irq_err;
-	}
-
-	/* re-enable CGCTL.MISCBDCGE after rest */
-	snd_sof_pci_update_bits(sdev, PCI_CGCTL,
-				PCI_CGCTL_MISCBDCGE_MASK,
-				PCI_CGCTL_MISCBDCGE_MASK);
-
-	device_disable_async_suspend(&pci->dev);
-
-	/* enable DSP features */
-	snd_sof_dsp_update_bits(sdev, APL_PP_BAR, SOF_HDA_REG_PP_PPCTL,
-				SOF_HDA_PPCTL_GPROCEN, SOF_HDA_PPCTL_GPROCEN);
-
-	/* enable DSP IRQ */
-	snd_sof_dsp_update_bits(sdev, APL_PP_BAR, SOF_HDA_REG_PP_PPCTL,
-				SOF_HDA_PPCTL_PIE, SOF_HDA_PPCTL_PIE);
-
-	/* initialize waitq for code loading */
-	init_waitqueue_head(&sdev->waitq);
-
-	/* set default mailbox offset for FW ready message */
-	sdev->dsp_box.offset = APL_MBOX_UPLINK_OFFSET;
-
-	return 0;
-
-irq_err:
-	free_irq(sdev->pci->irq, sdev);
-err:
-	/* disable DSP */
-	snd_sof_dsp_update_bits(sdev, APL_PP_BAR, SOF_HDA_REG_PP_PPCTL,
-				SOF_HDA_PPCTL_GPROCEN, 0);
-	return ret;
-}
-
-static int apl_remove(struct snd_sof_dev *sdev)
-{
-	const struct snd_sof_chip_info *chip =
-		sof_get_chip_info(sdev->pci->device);
-
-	/* disable DSP IRQ */
-	snd_sof_dsp_update_bits(sdev, APL_PP_BAR, SOF_HDA_REG_PP_PPCTL,
-				SOF_HDA_PPCTL_PIE, 0);
-
-	/* disable CIE and GIE interrupts */
-	snd_sof_dsp_update_bits(sdev, APL_HDA_BAR, SOF_HDA_INTCTL,
-				SOF_HDA_INT_CTRL_EN | SOF_HDA_INT_GLOBAL_EN, 0);
-
-	/* disable cores */
-	if (chip)
-		apl_disable_core(sdev, chip->cores_mask);
-
-	/* disable DSP */
-	snd_sof_dsp_update_bits(sdev, APL_PP_BAR, SOF_HDA_REG_PP_PPCTL,
-				SOF_HDA_PPCTL_GPROCEN, 0);
-
-	free_irq(sdev->ipc_irq, sdev);
-	free_irq(sdev->pci->irq, sdev);
-
-	return apl_stream_reset(sdev);
-}
-
-/* appololake ops */
-struct snd_sof_dsp_ops snd_sof_apl_ops = {
-	/* probe and remove */
-	.probe		= apl_probe,
-	.remove		= apl_remove,
-
-	/* Register IO */
-	.write		= apl_write,
-	.read		= apl_read,
-	.write64	= apl_write64,
-	.read64		= apl_read64,
-
-	/* Block IO */
-	.block_read	= apl_block_read,
-	.block_write	= apl_block_write,
-
-	/* doorbell */
-	.irq_handler	= apl_irq_handler,
-	.irq_thread	= apl_irq_thread,
-
-	/* mailbox */
-	.mailbox_read	= apl_mailbox_read,
-	.mailbox_write	= apl_mailbox_write,
-
-	/* ipc */
-	.send_msg	= apl_send_msg,
-	.get_reply	= apl_get_reply,
-	.fw_ready	= apl_fw_ready,
-	.is_ready	= apl_is_ready,
-	.cmd_done	= apl_cmd_done,
-
-	/* debug */
-	.debug_map	= apl_debugfs,
-	.debug_map_count	= ARRAY_SIZE(apl_debugfs),
-	.dbg_dump	= apl_dump,
-
-	/* stream callbacks */
-	.host_stream_open = apl_pcm_open,
-	.host_stream_close = apl_pcm_close,
-	.host_stream_prepare = apl_stream_prepare,
-	.host_stream_trigger = apl_stream_trigger,
-
-	/* firmware loading */
-	.load_firmware = apl_load_firmware,
-
-	/* firmware run */
-	.run = apl_run_firmware,
-
-	/* trace callback */
-	.trace_init = apl_trace_init,
-	.trace_release = apl_trace_release,
-	.trace_trigger = apl_trace_trigger,
-};
-EXPORT_SYMBOL(snd_sof_apl_ops);
-
-/* cannonlake ops */
-struct snd_sof_dsp_ops snd_sof_cnl_ops = {
-	/* probe and remove */
-	.probe		= apl_probe,
-	.remove		= apl_remove,
-
-	/* Register IO */
-	.write		= apl_write,
-	.read		= apl_read,
-	.write64	= apl_write64,
-	.read64		= apl_read64,
-
-	/* Block IO */
-	.block_read	= apl_block_read,
-	.block_write	= apl_block_write,
-
-	/* doorbell */
-	.irq_handler	= apl_irq_handler,
-	.irq_thread	= cnl_irq_thread,
-
-	/* mailbox */
-	.mailbox_read	= apl_mailbox_read,
-	.mailbox_write	= apl_mailbox_write,
-
-	/* ipc */
-	.send_msg	= cnl_send_msg,
-	.get_reply	= apl_get_reply,
-	.fw_ready	= apl_fw_ready,
-	.is_ready	= cnl_is_ready,
-	.cmd_done	= cnl_cmd_done,
-
-	/* debug */
-	.debug_map	= apl_debugfs,
-	.debug_map_count	= ARRAY_SIZE(apl_debugfs),
-	.dbg_dump	= apl_dump,
-
-	/* stream callbacks */
-	.host_stream_open = apl_pcm_open,
-	.host_stream_close = apl_pcm_close,
-	.host_stream_prepare = apl_stream_prepare,
-	.host_stream_trigger = apl_stream_trigger,
-
-	/* firmware loading */
-	.load_firmware = apl_load_firmware,
-
-	/* firmware run */
-	.run = apl_run_firmware,
-
-	/* trace callback */
-	.trace_init = apl_trace_init,
-	.trace_release = apl_trace_release,
-	.trace_trigger = apl_trace_trigger,
-};
-EXPORT_SYMBOL(snd_sof_cnl_ops);
-
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/sound/soc/sof/hw-bdw.c b/sound/soc/sof/hw-bdw.c
deleted file mode 100644
index 1e51323..0000000
--- a/sound/soc/sof/hw-bdw.c
+++ /dev/null
@@ -1,757 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-/*
- * Hardwre interface for audio DSP on Haswell and Broadwell
- */
-
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-#include <linux/platform_device.h>
-#include <linux/firmware.h>
-
-#include <trace/events/hswadsp.h>
-#include <sound/sof.h>
-#include "sof-priv.h"
-#include "ops.h"
-#include "intel.h"
-
-/* BARs */
-#define BDW_DSP_BAR 0
-#define BDW_PCI_BAR 1
-
-/*
- * Debug
- */
-
-/* DSP memories for BDW */
-#define IRAM_OFFSET     0xA0000
-#define BDW_IRAM_SIZE       (10 * 32 * 1024)
-#define DRAM_OFFSET     0x00000
-#define BDW_DRAM_SIZE       (20 * 32 * 1024)
-#define SHIM_OFFSET     0xFB000
-#define SHIM_SIZE       0x100
-#define MBOX_OFFSET     0x9E000
-#define MBOX_SIZE       0x1000
-#define MBOX_DUMP_SIZE 0x30
-#define EXCEPT_OFFSET	0x800
-
-/* DSP peripherals */
-#define DMAC0_OFFSET    0xFE000
-#define DMAC1_OFFSET    0xFF000
-#define DMAC_SIZE       0x420
-#define SSP0_OFFSET     0xFC000
-#define SSP1_OFFSET     0xFD000
-#define SSP_SIZE	0x100
-
-#define BDW_STACK_DUMP_SIZE	32
-
-static const struct snd_sof_debugfs_map bdw_debugfs[] = {
-	{"dmac0", BDW_DSP_BAR, DMAC0_OFFSET, DMAC_SIZE},
-	{"dmac1", BDW_DSP_BAR, DMAC1_OFFSET, DMAC_SIZE},
-	{"ssp0", BDW_DSP_BAR, SSP0_OFFSET, SSP_SIZE},
-	{"ssp1", BDW_DSP_BAR, SSP1_OFFSET, SSP_SIZE},
-	{"iram", BDW_DSP_BAR, IRAM_OFFSET, BDW_IRAM_SIZE},
-	{"dram", BDW_DSP_BAR, DRAM_OFFSET, BDW_DRAM_SIZE},
-	{"shim", BDW_DSP_BAR, SHIM_OFFSET, SHIM_SIZE},
-};
-
-/*
- * Memory copy.
- */
-
-/* write has to deal with copying non 32 bit sized data */
-static void bdw_block_write(struct snd_sof_dev *sdev, u32 offset, void *src,
-			    size_t size)
-{
-	void __iomem *dest = sdev->bar[sdev->mmio_bar] + offset;
-	u32 tmp = 0;
-	int i, m, n;
-	const u8 *src_byte = src;
-
-	m = size / 4;
-	n = size % 4;
-
-	/* __iowrite32_copy use 32bit size values so divide by 4 */
-	__iowrite32_copy((void *)dest, src, m);
-
-	if (n) {
-		for (i = 0; i < n; i++)
-			tmp |= (u32)*(src_byte + m * 4 + i) << (i * 8);
-		__iowrite32_copy((void *)(dest + m * 4), &tmp, 1);
-	}
-}
-
-static void bdw_block_read(struct snd_sof_dev *sdev, u32 offset, void *dest,
-			   size_t size)
-{
-	void __iomem *src = sdev->bar[sdev->mmio_bar] + offset;
-
-	memcpy_fromio(dest, src, size);
-}
-
-static void bdw_mailbox_write(struct snd_sof_dev *sdev, u32 offset,
-			      void *message, size_t bytes)
-{
-	void __iomem *dest = sdev->bar[sdev->mailbox_bar] + offset;
-
-	memcpy_toio(dest, message, bytes);
-}
-
-static void bdw_mailbox_read(struct snd_sof_dev *sdev, u32 offset,
-			     void *message, size_t bytes)
-{
-	void __iomem *src = sdev->bar[sdev->mailbox_bar] + offset;
-
-	memcpy_fromio(message, src, bytes);
-}
-
-/*
- * Register IO
- */
-
-static void bdw_write(struct snd_sof_dev *sdev, void __iomem *addr,
-		      u32 value)
-{
-	writel(value, addr);
-}
-
-static u32 bdw_read(struct snd_sof_dev *sdev, void __iomem *addr)
-{
-	return readl(addr);
-}
-
-static void bdw_write64(struct snd_sof_dev *sdev, void __iomem *addr,
-			u64 value)
-{
-	memcpy_toio(addr, &value, sizeof(value));
-}
-
-static u64 bdw_read64(struct snd_sof_dev *sdev, void __iomem *addr)
-{
-	u64 val;
-
-	memcpy_fromio(&val, addr, sizeof(val));
-	return val;
-}
-
-/*
- * DSP Control.
- */
-
-static int bdw_run(struct snd_sof_dev *sdev)
-{
-	/* set oportunistic mode on engine 0,1 for all channels */
-	snd_sof_dsp_update_bits(sdev, BDW_DSP_BAR, SHIM_HMDC,
-				SHIM_HMDC_HDDA_E0_ALLCH |
-				SHIM_HMDC_HDDA_E1_ALLCH, 0);
-
-	/* set DSP to RUN */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_CSR,
-					 SHIM_CSR_STALL, 0x0);
-
-	return 0; //TODO: Fix return value
-}
-
-static int bdw_reset(struct snd_sof_dev *sdev)
-{
-	/* put DSP into reset and stall */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_CSR,
-					 SHIM_CSR_RST | SHIM_CSR_STALL,
-					 SHIM_CSR_RST | SHIM_CSR_STALL);
-
-	/* keep in reset for 10ms */
-	mdelay(10);
-
-	/* take DSP out of reset and keep stalled for FW loading */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_CSR,
-					 SHIM_CSR_RST | SHIM_CSR_STALL,
-					 SHIM_CSR_STALL);
-
-	return 0; //TODO: Fix return value
-}
-
-static int bdw_set_dsp_D0(struct snd_sof_dev *sdev)
-{
-	int tries = 10;
-	u32 reg;
-
-	/* Disable core clock gating (VDRTCTL2.DCLCGE = 0) */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_PCI_BAR, PCI_VDRTCTL2,
-					 PCI_VDRTCL2_DCLCGE |
-					 PCI_VDRTCL2_DTCGE, 0);
-
-	/* Disable D3PG (VDRTCTL0.D3PGD = 1) */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_PCI_BAR, PCI_VDRTCTL0,
-					 PCI_VDRTCL0_D3PGD, PCI_VDRTCL0_D3PGD);
-
-	/* Set D0 state */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_PCI_BAR, PCI_PMCS,
-					 PCI_PMCS_PS_MASK, 0);
-
-	/* check that ADSP shim is enabled */
-	while (tries--) {
-		reg = readl(sdev->bar[BDW_PCI_BAR] + PCI_PMCS)
-			& PCI_PMCS_PS_MASK;
-		if (reg == 0)
-			goto finish;
-
-		msleep(20);
-	}
-
-	return -ENODEV;
-
-finish:
-	/*
-	 * select SSP1 19.2MHz base clock, SSP clock 0,
-	 * turn off Low Power Clock
-	 */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_CSR,
-					 SHIM_CSR_S1IOCS | SHIM_CSR_SBCS1 |
-					 SHIM_CSR_LPCS, 0x0);
-
-	/* stall DSP core, set clk to 192/96Mhz */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR,
-					 SHIM_CSR, SHIM_CSR_STALL |
-					 SHIM_CSR_DCS_MASK,
-					 SHIM_CSR_STALL |
-					 SHIM_CSR_DCS(4));
-
-	/* Set 24MHz MCLK, prevent local clock gating, enable SSP0 clock */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_CLKCTL,
-					 SHIM_CLKCTL_MASK |
-					 SHIM_CLKCTL_DCPLCG |
-					 SHIM_CLKCTL_SCOE0,
-					 SHIM_CLKCTL_MASK |
-					 SHIM_CLKCTL_DCPLCG |
-					 SHIM_CLKCTL_SCOE0);
-
-	/* Stall and reset core, set CSR */
-	bdw_reset(sdev);
-
-	/* Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_PCI_BAR, PCI_VDRTCTL2,
-					 PCI_VDRTCL2_DCLCGE |
-					 PCI_VDRTCL2_DTCGE,
-					 PCI_VDRTCL2_DCLCGE |
-					 PCI_VDRTCL2_DTCGE);
-
-	usleep_range(50, 55);
-
-	/* switch on audio PLL */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_PCI_BAR, PCI_VDRTCTL2,
-					 PCI_VDRTCL2_APLLSE_MASK, 0);
-
-	/*
-	 * set default power gating control, enable power gating control for
-	 * all blocks. that is, can't be accessed, please enable each block
-	 * before accessing.
-	 */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_PCI_BAR, PCI_VDRTCTL0,
-					 0xfffffffC, 0x0);
-
-	/* disable DMA finish function for SSP0 & SSP1 */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR,  SHIM_CSR2,
-					 SHIM_CSR2_SDFD_SSP1,
-					 SHIM_CSR2_SDFD_SSP1);
-
-	/* set on-demond mode on engine 0,1 for all channels */
-	snd_sof_dsp_update_bits(sdev, BDW_DSP_BAR, SHIM_HMDC,
-				SHIM_HMDC_HDDA_E0_ALLCH |
-				SHIM_HMDC_HDDA_E1_ALLCH,
-				SHIM_HMDC_HDDA_E0_ALLCH |
-				SHIM_HMDC_HDDA_E1_ALLCH);
-
-	/* Enable Interrupt from both sides */
-	snd_sof_dsp_update_bits(sdev, BDW_DSP_BAR, SHIM_IMRX,
-				(SHIM_IMRX_BUSY | SHIM_IMRX_DONE), 0x0);
-	snd_sof_dsp_update_bits(sdev, BDW_DSP_BAR, SHIM_IMRD,
-				(SHIM_IMRD_DONE | SHIM_IMRD_BUSY |
-				SHIM_IMRD_SSP0 | SHIM_IMRD_DMAC), 0x0);
-
-	/* clear IPC registers */
-	snd_sof_dsp_write(sdev, BDW_DSP_BAR, SHIM_IPCX, 0x0);
-	snd_sof_dsp_write(sdev, BDW_DSP_BAR, SHIM_IPCD, 0x0);
-	snd_sof_dsp_write(sdev, BDW_DSP_BAR, 0x80, 0x6);
-	snd_sof_dsp_write(sdev, BDW_DSP_BAR, 0xe0, 0x300a);
-
-	return 0;
-}
-
-
-static void bdw_get_registers(struct snd_sof_dev *sdev,
-			      struct sof_ipc_dsp_oops_xtensa *xoops,
-			      u32 *stack, size_t stack_words)
-{
-	/* first read regsisters */
-	bdw_mailbox_read(sdev, sdev->dsp_oops_offset, xoops, sizeof(*xoops));
-
-	/* the get the stack */
-	bdw_mailbox_read(sdev, sdev->dsp_oops_offset + sizeof(*xoops), stack,
-			 stack_words * sizeof(u32));
-}
-
-static void bdw_dump(struct snd_sof_dev *sdev, u32 flags)
-{
-	struct sof_ipc_dsp_oops_xtensa xoops;
-	u32 stack[BDW_STACK_DUMP_SIZE];
-	u32 status, panic;
-
-	/* now try generic SOF status messages */
-	status = snd_sof_dsp_read(sdev, BDW_DSP_BAR, SHIM_IPCD);
-	panic = snd_sof_dsp_read(sdev, BDW_DSP_BAR, SHIM_IPCX);
-	bdw_get_registers(sdev, &xoops, stack, BDW_STACK_DUMP_SIZE);
-	snd_sof_get_status(sdev, status, panic, &xoops, stack,
-			   BDW_STACK_DUMP_SIZE);
-}
-
-/*
- * IPC Doorbell IRQ handler and thread.
- */
-
-static irqreturn_t bdw_irq_handler(int irq, void *context)
-{
-	struct snd_sof_dev *sdev = (struct snd_sof_dev *)context;
-	u32 isr;
-	int ret = IRQ_NONE;
-
-	/* Interrupt arrived, check src */
-	isr = snd_sof_dsp_read(sdev, BDW_DSP_BAR, SHIM_ISRX);
-	if (isr & SHIM_ISRX_DONE) {
-		/* Mask Done interrupt before return */
-		snd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR,
-						 SHIM_IMRX, SHIM_IMRX_DONE,
-						 SHIM_IMRX_DONE);
-		ret = IRQ_WAKE_THREAD;
-	}
-
-	if (isr & SHIM_ISRX_BUSY) {
-		/* Mask Busy interrupt before return */
-		snd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR,
-						 SHIM_IMRX, SHIM_IMRX_BUSY,
-						 SHIM_IMRX_BUSY);
-		ret = IRQ_WAKE_THREAD;
-	}
-
-	return ret;
-}
-
-static irqreturn_t bdw_irq_thread(int irq, void *context)
-{
-	struct snd_sof_dev *sdev = (struct snd_sof_dev *)context;
-	u32 ipcx, ipcd, hdr;
-
-	ipcx = snd_sof_dsp_read(sdev, BDW_DSP_BAR, SHIM_IPCX);
-
-	/* reply message from DSP */
-	if (ipcx & SHIM_IPCX_DONE) {
-		/* Handle Immediate reply from DSP Core */
-		bdw_mailbox_read(sdev, sdev->host_box.offset, &hdr,
-				 sizeof(hdr));
-		snd_sof_ipc_reply(sdev, hdr);
-
-		/* clear DONE bit - tell DSP we have completed */
-		snd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_IPCX,
-						 SHIM_IPCX_DONE, 0);
-
-		/* unmask Done interrupt */
-		snd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_IMRX,
-						 SHIM_IMRX_DONE, 0);
-	}
-
-	ipcd = snd_sof_dsp_read(sdev, BDW_DSP_BAR, SHIM_IPCD);
-
-	/* new message from DSP */
-	if (ipcd & SHIM_IPCD_BUSY) {
-		/* Handle messages from DSP Core */
-		if ((ipcd & SOF_IPC_PANIC_MAGIC_MASK) == SOF_IPC_PANIC_MAGIC) {
-			dev_err(sdev->dev, "error : DSP panic!\n");
-			snd_sof_dsp_cmd_done(sdev);
-			snd_sof_dsp_dbg_dump(sdev, SOF_DBG_REGS | SOF_DBG_MBOX);
-			snd_sof_trace_notify_for_error(sdev);
-		} else {
-			snd_sof_ipc_msgs_rx(sdev);
-		}
-	}
-
-	/* continue to send any remaining messages... */
-	snd_sof_ipc_msgs_tx(sdev);
-
-	return IRQ_HANDLED;
-}
-
-/*
- * IPC Firmware ready.
- */
-static void bdw_get_windows(struct snd_sof_dev *sdev)
-{
-	struct sof_ipc_window_elem *elem;
-	u32 outbox_offset = 0;
-	u32 stream_offset = 0;
-	u32 inbox_offset = 0;
-	u32 outbox_size = 0;
-	u32 stream_size = 0;
-	u32 inbox_size = 0;
-	int i;
-
-	if (!sdev->info_window) {
-		dev_err(sdev->dev, "error: have no window info\n");
-		return;
-	}
-
-	for (i = 0; i < sdev->info_window->num_windows; i++) {
-		elem = &sdev->info_window->window[i];
-
-		switch (elem->type) {
-		case SOF_IPC_REGION_UPBOX:
-			inbox_offset = elem->offset + MBOX_OFFSET;
-			inbox_size = elem->size;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[BDW_DSP_BAR] +
-						    inbox_offset,
-						    elem->size, "inbox");
-			break;
-		case SOF_IPC_REGION_DOWNBOX:
-			outbox_offset = elem->offset + MBOX_OFFSET;
-			outbox_size = elem->size;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[BDW_DSP_BAR] +
-						    outbox_offset,
-						    elem->size, "outbox");
-			break;
-		case SOF_IPC_REGION_TRACE:
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[BDW_DSP_BAR] +
-						    elem->offset + MBOX_OFFSET,
-						    elem->size, "etrace");
-			break;
-		case SOF_IPC_REGION_DEBUG:
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[BDW_DSP_BAR] +
-						    elem->offset + MBOX_OFFSET,
-						    elem->size, "debug");
-			break;
-		case SOF_IPC_REGION_STREAM:
-			stream_offset = elem->offset + MBOX_OFFSET;
-			stream_size = elem->size;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[BDW_DSP_BAR] +
-						    stream_offset,
-						    elem->size, "stream");
-			break;
-		case SOF_IPC_REGION_REGS:
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[BDW_DSP_BAR] +
-						    elem->offset + MBOX_OFFSET,
-						    elem->size, "regs");
-			break;
-		case SOF_IPC_REGION_EXCEPTION:
-			sdev->dsp_oops_offset = elem->offset + MBOX_OFFSET;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[BDW_DSP_BAR] +
-						    elem->offset + MBOX_OFFSET,
-						    elem->size, "exception");
-			break;
-		default:
-			dev_err(sdev->dev, "error: get illegal window info\n");
-			return;
-		}
-	}
-
-	if (outbox_size == 0 || inbox_size == 0) {
-		dev_err(sdev->dev, "error: get illegal mailbox window\n");
-		return;
-	}
-
-	snd_sof_dsp_mailbox_init(sdev, inbox_offset, inbox_size,
-				 outbox_offset, outbox_size);
-	sdev->stream_box.offset = stream_offset;
-	sdev->stream_box.size = stream_size;
-
-	dev_dbg(sdev->dev, " mailbox upstream 0x%x - size 0x%x\n",
-		inbox_offset, inbox_size);
-	dev_dbg(sdev->dev, " mailbox downstream 0x%x - size 0x%x\n",
-		outbox_offset, outbox_size);
-	dev_dbg(sdev->dev, " stream region 0x%x - size 0x%x\n",
-		stream_offset, stream_size);
-}
-
-static int bdw_fw_ready(struct snd_sof_dev *sdev, u32 msg_id)
-{
-	struct sof_ipc_fw_ready *fw_ready = &sdev->fw_ready;
-	struct sof_ipc_fw_version *v = &fw_ready->version;
-	u32 offset;
-
-	/* mailbox must be on 4k boundary */
-	offset = MBOX_OFFSET;
-
-	dev_dbg(sdev->dev, "ipc: DSP is ready 0x%8.8x offset %d\n",
-		msg_id, offset);
-
-	/* copy data from the DSP FW ready offset */
-	bdw_block_read(sdev, offset, fw_ready, sizeof(*fw_ready));
-
-	snd_sof_dsp_mailbox_init(sdev, fw_ready->dspbox_offset,
-				 fw_ready->dspbox_size,
-				 fw_ready->hostbox_offset,
-				 fw_ready->hostbox_size);
-
-	dev_info(sdev->dev,
-		 " Firmware info: version %d:%d-%s build %d on %s:%s\n",
-		 v->major, v->minor, v->tag, v->build, v->date, v->time);
-
-	/* now check for extended data */
-	snd_sof_fw_parse_ext_data(sdev, MBOX_OFFSET +
-				  sizeof(struct sof_ipc_fw_ready));
-
-	bdw_get_windows(sdev);
-
-	return 0;
-}
-
-/*
- * IPC Mailbox IO
- */
-
-static int bdw_is_ready(struct snd_sof_dev *sdev)
-{
-	u32 val;
-
-	val = snd_sof_dsp_read(sdev, BDW_DSP_BAR, SHIM_IPCX);
-	if (val & SHIM_IPCX_BUSY)
-		return 0;
-
-	return 1;
-}
-
-static int bdw_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)
-{
-	/* send the message */
-	bdw_mailbox_write(sdev, sdev->host_box.offset, msg->msg_data,
-			  msg->msg_size);
-	snd_sof_dsp_write(sdev, BDW_DSP_BAR, SHIM_IPCX, SHIM_IPCX_BUSY);
-
-	return 0;
-}
-
-static int bdw_get_reply(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)
-{
-	struct sof_ipc_reply reply;
-	int ret = 0;
-	u32 size;
-
-	/* get reply */
-	bdw_mailbox_read(sdev, sdev->host_box.offset, &reply, sizeof(reply));
-	if (reply.error < 0) {
-		size = sizeof(reply);
-		ret = reply.error;
-	} else {
-		/* reply correct size ? */
-		if (reply.hdr.size != msg->reply_size) {
-			dev_err(sdev->dev, "error: reply expected 0x%lx got 0x%x bytes\n",
-				msg->reply_size, reply.hdr.size);
-			size = msg->reply_size;
-			ret = -EINVAL;
-		} else {
-			size = reply.hdr.size;
-		}
-	}
-
-	/* read the message */
-	if (msg->msg_data && size > 0)
-		bdw_mailbox_read(sdev, sdev->host_box.offset, msg->reply_data,
-				 size);
-
-	return ret;
-}
-
-static int bdw_cmd_done(struct snd_sof_dev *sdev)
-{
-	/* clear BUSY bit and set DONE bit - accept new messages */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_IPCD,
-					 SHIM_IPCD_BUSY | SHIM_IPCD_DONE,
-					 SHIM_IPCD_DONE);
-
-	/* unmask busy interrupt */
-	snd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_IMRX,
-					 SHIM_IMRX_BUSY, 0);
-
-	return 0;
-}
-
-/*
- * Probe and remove.
- */
-static int bdw_probe(struct snd_sof_dev *sdev)
-{
-	struct snd_sof_pdata *pdata = sdev->pdata;
-	const struct sof_dev_desc *desc = pdata->desc;
-	struct platform_device *pdev =
-		container_of(sdev->parent, struct platform_device, dev);
-	struct resource *mmio;
-	u32 base, size;
-	int ret = 0;
-
-	/* LPE base */
-	mmio = platform_get_resource(pdev, IORESOURCE_MEM,
-				     desc->resindex_lpe_base);
-	if (mmio) {
-		base = mmio->start;
-		size = resource_size(mmio);
-	} else {
-		dev_err(sdev->dev, "error: failed to get LPE base at idx %d\n",
-			desc->resindex_lpe_base);
-		return -EINVAL;
-	}
-
-	dev_dbg(sdev->dev, "LPE PHY base at 0x%x size 0x%x", base, size);
-	sdev->bar[BDW_DSP_BAR] = ioremap(base, size);
-	if (!sdev->bar[BDW_DSP_BAR]) {
-		dev_err(sdev->dev,
-			"error: failed to ioremap LPE base 0x%x size 0x%x\n",
-			base, size);
-		return -ENODEV;
-	}
-	dev_dbg(sdev->dev, "LPE VADDR %p\n", sdev->bar[BDW_DSP_BAR]);
-
-	/* TODO: add offsets */
-	sdev->mmio_bar = BDW_DSP_BAR;
-	sdev->mailbox_bar = BDW_DSP_BAR;
-
-	/* PCI base */
-	mmio = platform_get_resource(pdev, IORESOURCE_MEM,
-				     desc->resindex_pcicfg_base);
-	if (mmio) {
-		base = mmio->start;
-		size = resource_size(mmio);
-	} else {
-		dev_err(sdev->dev, "error: failed to get PCI base at idx %d\n",
-			desc->resindex_pcicfg_base);
-		ret = -ENODEV;
-		goto pci_err;
-	}
-
-	dev_dbg(sdev->dev, "PCI base at 0x%x size 0x%x", base, size);
-	sdev->bar[BDW_PCI_BAR] = ioremap(base, size);
-	if (!sdev->bar[BDW_PCI_BAR]) {
-		dev_err(sdev->dev,
-			"error: failed to ioremap PCI base 0x%x size 0x%x\n",
-			base, size);
-		ret = -ENODEV;
-		goto pci_err;
-	}
-	dev_dbg(sdev->dev, "PCI VADDR %p\n", sdev->bar[BDW_PCI_BAR]);
-
-	/* register our IRQ */
-	sdev->ipc_irq = platform_get_irq(pdev, desc->irqindex_host_ipc);
-	if (sdev->ipc_irq < 0) {
-		dev_err(sdev->dev, "error: failed to get IRQ at index %d\n",
-			desc->irqindex_host_ipc);
-		ret = sdev->ipc_irq;
-		goto irq_err;
-	}
-
-	dev_dbg(sdev->dev, "using IRQ %d\n", sdev->ipc_irq);
-	ret = request_threaded_irq(sdev->ipc_irq, bdw_irq_handler,
-				   bdw_irq_thread, IRQF_SHARED, "AudioDSP",
-				   sdev);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to register IRQ %d\n",
-			sdev->ipc_irq);
-		goto irq_err;
-	}
-
-	/* enable the DSP SHIM */
-	ret = bdw_set_dsp_D0(sdev);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to set DSP D0\n");
-		return ret;
-	}
-
-	/* DSP DMA can only access low 31 bits of host memory */
-	ret = dma_coerce_mask_and_coherent(sdev->dev, DMA_BIT_MASK(31));
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to set DMA mask %d\n", ret);
-		return ret;
-	}
-
-	/* set BARS */
-	sdev->cl_bar = BDW_DSP_BAR;
-
-	/* set default mailbox */
-	snd_sof_dsp_mailbox_init(sdev, MBOX_OFFSET, MBOX_SIZE, 0, 0);
-
-	return ret;
-
-irq_err:
-	iounmap(sdev->bar[BDW_DSP_BAR]);
-pci_err:
-	iounmap(sdev->bar[BDW_PCI_BAR]);
-	return ret;
-}
-
-static int bdw_remove(struct snd_sof_dev *sdev)
-{
-	iounmap(sdev->bar[BDW_DSP_BAR]);
-	iounmap(sdev->bar[BDW_PCI_BAR]);
-	free_irq(sdev->ipc_irq, sdev);
-	return 0;
-}
-
-/* broadwell ops */
-struct snd_sof_dsp_ops snd_sof_bdw_ops = {
-	/*Device init */
-	.probe          = bdw_probe,
-	.remove         = bdw_remove,
-
-	/* DSP Core Control */
-	.run            = bdw_run,
-	.reset          = bdw_reset,
-
-	/* Register IO */
-	.read           = bdw_read,
-	.write          = bdw_write,
-	.read64         = bdw_read64,
-	.write64        = bdw_write64,
-
-	/* Block IO */
-	.block_read     = bdw_block_read,
-	.block_write    = bdw_block_write,
-
-	/* mailbox */
-	.mailbox_read   = bdw_mailbox_read,
-	.mailbox_write  = bdw_mailbox_write,
-
-	/* ipc */
-	.send_msg	= bdw_send_msg,
-	.get_reply	= bdw_get_reply,
-	.fw_ready	= bdw_fw_ready,
-	.is_ready	= bdw_is_ready,
-	.cmd_done	= bdw_cmd_done,
-
-	/* debug */
-	.debug_map  = bdw_debugfs,
-	.debug_map_count    = ARRAY_SIZE(bdw_debugfs),
-	.dbg_dump   = bdw_dump,
-
-	/* Module loading */
-	.load_module    = snd_sof_parse_module_memcpy,
-
-	/*Firmware loading */
-	.load_firmware	= snd_sof_load_firmware_memcpy,
-};
-EXPORT_SYMBOL(snd_sof_bdw_ops);
-
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/sound/soc/sof/hw-byt.c b/sound/soc/sof/hw-byt.c
deleted file mode 100644
index b1ea5f9..0000000
--- a/sound/soc/sof/hw-byt.c
+++ /dev/null
@@ -1,849 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-/*
- * Hardware interface for audio DSP on Baytrail, Braswell and Cherrytrail.
- */
-
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-#include <linux/firmware.h>
-#include <linux/device.h>
-#include <sound/sof.h>
-#include <uapi/sound/sof-fw.h>
-
-#include "sof-priv.h"
-#include "ops.h"
-#include "intel.h"
-
-/* DSP memories */
-#define IRAM_OFFSET		0x0C0000
-#define IRAM_SIZE		(80 * 1024)
-#define DRAM_OFFSET		0x100000
-#define DRAM_SIZE		(160 * 1024)
-#define SHIM_OFFSET		0x140000
-#define SHIM_SIZE		0x100
-#define MBOX_OFFSET		0x144000
-#define MBOX_SIZE		0x1000
-#define EXCEPT_OFFSET		0x800
-
-/* DSP peripherals */
-#define DMAC0_OFFSET		0x098000
-#define DMAC1_OFFSET		0x09c000
-#define DMAC2_OFFSET		0x094000
-#define DMAC_SIZE		0x420
-#define SSP0_OFFSET		0x0a0000
-#define SSP1_OFFSET		0x0a1000
-#define SSP2_OFFSET		0x0a2000
-#define SSP3_OFFSET		0x0a4000
-#define SSP4_OFFSET		0x0a5000
-#define SSP5_OFFSET		0x0a6000
-#define SSP_SIZE		0x100
-
-#define BYT_STACK_DUMP_SIZE	32
-
-#define BYT_PCI_BAR_SIZE	0x200000
-
-/*
- * Debug
- */
-
-#define MBOX_DUMP_SIZE	0x30
-
-/* BARs */
-#define BYT_DSP_BAR		0
-#define BYT_PCI_BAR		1
-#define BYT_IMR_BAR		2
-
-static const struct snd_sof_debugfs_map byt_debugfs[] = {
-	{"dmac0", BYT_DSP_BAR, DMAC0_OFFSET, DMAC_SIZE},
-	{"dmac1", BYT_DSP_BAR,  DMAC1_OFFSET, DMAC_SIZE},
-	{"ssp0",  BYT_DSP_BAR, SSP0_OFFSET, SSP_SIZE},
-	{"ssp1", BYT_DSP_BAR, SSP1_OFFSET, SSP_SIZE},
-	{"ssp2", BYT_DSP_BAR, SSP2_OFFSET, SSP_SIZE},
-	{"iram", BYT_DSP_BAR, IRAM_OFFSET, IRAM_SIZE},
-	{"dram", BYT_DSP_BAR, DRAM_OFFSET, DRAM_SIZE},
-	{"shim", BYT_DSP_BAR, SHIM_OFFSET, SHIM_SIZE},
-};
-
-static const struct snd_sof_debugfs_map cht_debugfs[] = {
-	{"dmac0", BYT_DSP_BAR, DMAC0_OFFSET, DMAC_SIZE},
-	{"dmac1", BYT_DSP_BAR,  DMAC1_OFFSET, DMAC_SIZE},
-	{"dmac2", BYT_DSP_BAR,  DMAC2_OFFSET, DMAC_SIZE},
-	{"ssp0",  BYT_DSP_BAR, SSP0_OFFSET, SSP_SIZE},
-	{"ssp1", BYT_DSP_BAR, SSP1_OFFSET, SSP_SIZE},
-	{"ssp2", BYT_DSP_BAR, SSP2_OFFSET, SSP_SIZE},
-	{"ssp3", BYT_DSP_BAR, SSP3_OFFSET, SSP_SIZE},
-	{"ssp4", BYT_DSP_BAR, SSP4_OFFSET, SSP_SIZE},
-	{"ssp5", BYT_DSP_BAR, SSP5_OFFSET, SSP_SIZE},
-	{"iram", BYT_DSP_BAR, IRAM_OFFSET, IRAM_SIZE},
-	{"dram", BYT_DSP_BAR, DRAM_OFFSET, DRAM_SIZE},
-	{"shim", BYT_DSP_BAR, SHIM_OFFSET, SHIM_SIZE},
-};
-
-/*
- * Register IO
- */
-
-static void byt_write(struct snd_sof_dev *sdev, void __iomem *addr,
-		      u32 value)
-{
-	writel(value, addr);
-}
-
-static u32 byt_read(struct snd_sof_dev *sdev, void __iomem *addr)
-{
-	return readl(addr);
-}
-
-static void byt_write64(struct snd_sof_dev *sdev, void __iomem *addr,
-			u64 value)
-{
-	memcpy_toio(addr, &value, sizeof(value));
-}
-
-static u64 byt_read64(struct snd_sof_dev *sdev, void __iomem *addr)
-{
-	u64 val;
-
-	memcpy_fromio(&val, addr, sizeof(val));
-	return val;
-}
-
-/*
- * Memory copy.
- */
-
-static void byt_block_write(struct snd_sof_dev *sdev, u32 offset, void *src,
-			    size_t size)
-{
-	void __iomem *dest = sdev->bar[sdev->mmio_bar] + offset;
-	u32 tmp = 0;
-	int i, m, n;
-	const u8 *src_byte = src;
-
-	m = size / 4;
-	n = size % 4;
-
-	/* __iowrite32_copy use 32bit size values so divide by 4 */
-	__iowrite32_copy((void *)dest, src, m);
-
-	if (n) {
-		for (i = 0; i < n; i++)
-			tmp |= (u32)*(src_byte + m * 4 + i) << (i * 8);
-		__iowrite32_copy((void *)(dest + m * 4), &tmp, 1);
-	}
-}
-
-static void byt_block_read(struct snd_sof_dev *sdev, u32 offset, void *dest,
-			   size_t size)
-{
-	void __iomem *src = sdev->bar[sdev->mmio_bar] + offset;
-
-	memcpy_fromio(dest, src, size);
-}
-
-/*
- * IPC Firmware ready.
- */
-static void byt_get_windows(struct snd_sof_dev *sdev)
-{
-	struct sof_ipc_window_elem *elem;
-	u32 outbox_offset = 0;
-	u32 stream_offset = 0;
-	u32 inbox_offset = 0;
-	u32 outbox_size = 0;
-	u32 stream_size = 0;
-	u32 inbox_size = 0;
-	int i;
-
-	if (!sdev->info_window) {
-		dev_err(sdev->dev, "error: have no window info\n");
-		return;
-	}
-
-	for (i = 0; i < sdev->info_window->num_windows; i++) {
-		elem = &sdev->info_window->window[i];
-
-		switch (elem->type) {
-		case SOF_IPC_REGION_UPBOX:
-			inbox_offset = elem->offset + MBOX_OFFSET;
-			inbox_size = elem->size;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[BYT_DSP_BAR] +
-						    inbox_offset,
-						    elem->size, "inbox");
-			break;
-		case SOF_IPC_REGION_DOWNBOX:
-			outbox_offset = elem->offset + MBOX_OFFSET;
-			outbox_size = elem->size;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[BYT_DSP_BAR] +
-						    outbox_offset,
-						    elem->size, "outbox");
-			break;
-		case SOF_IPC_REGION_TRACE:
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[BYT_DSP_BAR] +
-						    elem->offset + MBOX_OFFSET,
-						    elem->size, "etrace");
-			break;
-		case SOF_IPC_REGION_DEBUG:
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[BYT_DSP_BAR] +
-						    elem->offset + MBOX_OFFSET,
-						    elem->size, "debug");
-			break;
-		case SOF_IPC_REGION_STREAM:
-			stream_offset = elem->offset + MBOX_OFFSET;
-			stream_size = elem->size;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[BYT_DSP_BAR] +
-						    stream_offset,
-						    elem->size, "stream");
-			break;
-		case SOF_IPC_REGION_REGS:
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[BYT_DSP_BAR] +
-						    elem->offset + MBOX_OFFSET,
-						    elem->size, "regs");
-			break;
-		case SOF_IPC_REGION_EXCEPTION:
-			sdev->dsp_oops_offset = elem->offset + MBOX_OFFSET;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[BYT_DSP_BAR] +
-						    elem->offset + MBOX_OFFSET,
-						    elem->size, "exception");
-			break;
-		default:
-			dev_err(sdev->dev, "error: get illegal window info\n");
-			return;
-		}
-	}
-
-	if (outbox_size == 0 || inbox_size == 0) {
-		dev_err(sdev->dev, "error: get illegal mailbox window\n");
-		return;
-	}
-
-	snd_sof_dsp_mailbox_init(sdev, inbox_offset, inbox_size,
-				 outbox_offset, outbox_size);
-	sdev->stream_box.offset = stream_offset;
-	sdev->stream_box.size = stream_size;
-
-	dev_dbg(sdev->dev, " mailbox upstream 0x%x - size 0x%x\n",
-		inbox_offset, inbox_size);
-	dev_dbg(sdev->dev, " mailbox downstream 0x%x - size 0x%x\n",
-		outbox_offset, outbox_size);
-	dev_dbg(sdev->dev, " stream region 0x%x - size 0x%x\n",
-		stream_offset, stream_size);
-}
-
-static int byt_fw_ready(struct snd_sof_dev *sdev, u32 msg_id)
-{
-	struct sof_ipc_fw_ready *fw_ready = &sdev->fw_ready;
-	struct sof_ipc_fw_version *v = &fw_ready->version;
-	u32 offset;
-
-	/* mailbox must be on 4k boundary */
-	offset = MBOX_OFFSET;
-
-	dev_dbg(sdev->dev, "ipc: DSP is ready 0x%8.8x offset 0x%x\n",
-		msg_id, offset);
-
-	/* copy data from the DSP FW ready offset */
-	byt_block_read(sdev, offset, fw_ready, sizeof(*fw_ready));
-
-	snd_sof_dsp_mailbox_init(sdev, fw_ready->dspbox_offset,
-				 fw_ready->dspbox_size,
-				 fw_ready->hostbox_offset,
-				 fw_ready->hostbox_size);
-
-	dev_info(sdev->dev,
-		 " Firmware info: version %d:%d-%s build %d on %s:%s\n",
-		 v->major, v->minor, v->tag, v->build, v->date, v->time);
-
-	/* now check for extended data */
-	snd_sof_fw_parse_ext_data(sdev, MBOX_OFFSET +
-				  sizeof(struct sof_ipc_fw_ready));
-
-	byt_get_windows(sdev);
-
-	return 0;
-}
-
-/*
- * IPC Mailbox IO
- */
-
-static void byt_mailbox_write(struct snd_sof_dev *sdev, u32 offset,
-			      void *message, size_t bytes)
-{
-	void __iomem *dest = sdev->bar[sdev->mailbox_bar] + offset;
-
-	memcpy_toio(dest, message, bytes);
-}
-
-static void byt_mailbox_read(struct snd_sof_dev *sdev, u32 offset,
-			     void *message, size_t bytes)
-{
-	void __iomem *src = sdev->bar[sdev->mailbox_bar] + offset;
-
-	memcpy_fromio(message, src, bytes);
-}
-
-/*
- * Debug
- */
-
-static void byt_get_registers(struct snd_sof_dev *sdev,
-			      struct sof_ipc_dsp_oops_xtensa *xoops,
-			      u32 *stack, size_t stack_words)
-{
-	/* first read regsisters */
-	byt_mailbox_read(sdev, sdev->dsp_oops_offset, xoops, sizeof(*xoops));
-
-	/* the get the stack */
-	byt_mailbox_read(sdev, sdev->dsp_oops_offset + sizeof(*xoops), stack,
-			 stack_words * sizeof(u32));
-}
-
-static void byt_dump(struct snd_sof_dev *sdev, u32 flags)
-{
-	struct sof_ipc_dsp_oops_xtensa xoops;
-	u32 stack[BYT_STACK_DUMP_SIZE];
-	u32 status, panic;
-
-	/* now try generic SOF status messages */
-	status = snd_sof_dsp_read(sdev, BYT_DSP_BAR, SHIM_IPCD);
-	panic = snd_sof_dsp_read(sdev, BYT_DSP_BAR, SHIM_IPCX);
-	byt_get_registers(sdev, &xoops, stack, BYT_STACK_DUMP_SIZE);
-	snd_sof_get_status(sdev, status, panic, &xoops, stack,
-			   BYT_STACK_DUMP_SIZE);
-}
-
-/*
- * IPC Doorbell IRQ handler and thread.
- */
-
-static irqreturn_t byt_irq_handler(int irq, void *context)
-{
-	struct snd_sof_dev *sdev = (struct snd_sof_dev *)context;
-	u64 isr;
-	int ret = IRQ_NONE;
-
-	/* Interrupt arrived, check src */
-	isr = snd_sof_dsp_read64(sdev, BYT_DSP_BAR, SHIM_ISRX);
-	if (isr & SHIM_ISRX_DONE) {
-		/* Mask Done interrupt before return */
-		snd_sof_dsp_update_bits64_unlocked(sdev, BYT_DSP_BAR, SHIM_IMRX,
-						   SHIM_IMRX_DONE,
-						   SHIM_IMRX_DONE);
-		ret = IRQ_WAKE_THREAD;
-	}
-
-	if (isr & SHIM_ISRX_BUSY) {
-		/* Mask Busy interrupt before return */
-		snd_sof_dsp_update_bits64_unlocked(sdev, BYT_DSP_BAR, SHIM_IMRX,
-						   SHIM_IMRX_BUSY,
-						   SHIM_IMRX_BUSY);
-		ret = IRQ_WAKE_THREAD;
-	}
-
-	return ret;
-}
-
-static irqreturn_t byt_irq_thread(int irq, void *context)
-{
-	struct snd_sof_dev *sdev = (struct snd_sof_dev *)context;
-	u64 ipcx, ipcd;
-
-	ipcx = snd_sof_dsp_read64(sdev, BYT_DSP_BAR, SHIM_IPCX);
-
-	/* reply message from DSP */
-	if (ipcx & SHIM_BYT_IPCX_DONE) {
-		/* Handle Immediate reply from DSP Core */
-		snd_sof_ipc_reply(sdev, ipcx);
-
-		/* clear DONE bit - tell DSP we have completed */
-		snd_sof_dsp_update_bits64_unlocked(sdev, BYT_DSP_BAR, SHIM_IPCX,
-						   SHIM_BYT_IPCX_DONE, 0);
-
-		/* unmask Done interrupt */
-		snd_sof_dsp_update_bits64_unlocked(sdev, BYT_DSP_BAR, SHIM_IMRX,
-						   SHIM_IMRX_DONE, 0);
-	}
-
-	/* new message from DSP */
-	ipcd = snd_sof_dsp_read64(sdev, BYT_DSP_BAR, SHIM_IPCD);
-	if (ipcd & SHIM_BYT_IPCD_BUSY) {
-		/* Handle messages from DSP Core */
-		if ((ipcd & SOF_IPC_PANIC_MAGIC_MASK) == SOF_IPC_PANIC_MAGIC) {
-			dev_err(sdev->dev, "error : DSP panic!\n");
-			snd_sof_dsp_cmd_done(sdev);
-			snd_sof_dsp_dbg_dump(sdev, SOF_DBG_REGS | SOF_DBG_MBOX);
-			snd_sof_trace_notify_for_error(sdev);
-		} else {
-			snd_sof_ipc_msgs_rx(sdev);
-		}
-	}
-
-	/* continue to send any remaining messages... */
-	snd_sof_ipc_msgs_tx(sdev);
-
-	return IRQ_HANDLED;
-}
-
-static int byt_is_ready(struct snd_sof_dev *sdev)
-{
-	u64 imrx;
-
-	imrx = snd_sof_dsp_read64(sdev, BYT_DSP_BAR, SHIM_IMRX);
-	if (imrx & SHIM_IMRX_DONE)
-		return 0;
-
-	return 1;
-}
-
-static int byt_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)
-{
-	u64 cmd = msg->header;
-
-	/* send the message */
-	byt_mailbox_write(sdev, sdev->host_box.offset, msg->msg_data,
-			  msg->msg_size);
-	snd_sof_dsp_write64(sdev, BYT_DSP_BAR, SHIM_IPCX,
-			    cmd | SHIM_BYT_IPCX_BUSY);
-
-	return 0;
-}
-
-static int byt_get_reply(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)
-{
-	struct sof_ipc_reply reply;
-	int ret = 0;
-	u32 size;
-
-	/* get reply */
-	byt_mailbox_read(sdev, sdev->host_box.offset, &reply, sizeof(reply));
-	if (reply.error < 0) {
-		size = sizeof(reply);
-		ret = reply.error;
-	} else {
-		/* reply correct size ? */
-		if (reply.hdr.size != msg->reply_size) {
-			dev_err(sdev->dev, "error: reply expected 0x%lx got 0x%x bytes\n",
-				msg->reply_size, reply.hdr.size);
-			size = msg->reply_size;
-			ret = -EINVAL;
-		} else {
-			size = reply.hdr.size;
-		}
-	}
-
-	/* read the message */
-	if (msg->msg_data && size > 0)
-		byt_mailbox_read(sdev, sdev->host_box.offset, msg->reply_data,
-				 size);
-
-	return ret;
-}
-
-static int byt_cmd_done(struct snd_sof_dev *sdev)
-{
-	/* clear BUSY bit and set DONE bit - accept new messages */
-	snd_sof_dsp_update_bits64_unlocked(sdev, BYT_DSP_BAR, SHIM_IPCD,
-					   SHIM_BYT_IPCD_BUSY |
-					   SHIM_BYT_IPCD_DONE,
-					   SHIM_BYT_IPCD_DONE);
-
-	/* unmask busy interrupt */
-	snd_sof_dsp_update_bits64_unlocked(sdev, BYT_DSP_BAR, SHIM_IMRX,
-					   SHIM_IMRX_BUSY, 0);
-
-	return 0;
-}
-
-/*
- * DSP control.
- */
-
-static int byt_run(struct snd_sof_dev *sdev)
-{
-	int tries = 10;
-
-	/* release stall and wait to unstall */
-	snd_sof_dsp_update_bits64(sdev, BYT_DSP_BAR, SHIM_CSR,
-				  SHIM_BYT_CSR_STALL, 0x0);
-	while (tries--) {
-		if (!(snd_sof_dsp_read64(sdev, BYT_DSP_BAR, SHIM_CSR) &
-		      SHIM_BYT_CSR_PWAITMODE))
-			break;
-		msleep(100);
-	}
-	if (tries < 0) {
-		dev_err(sdev->dev, "error:  unable to run DSP firmware\n");
-		byt_dump(sdev, SOF_DBG_REGS | SOF_DBG_MBOX);
-		return -ENODEV;
-	}
-
-	return 0;
-}
-
-static int byt_reset(struct snd_sof_dev *sdev)
-{
-	/* put DSP into reset, set reset vector and stall */
-	snd_sof_dsp_update_bits64(sdev, BYT_DSP_BAR, SHIM_CSR,
-				  SHIM_BYT_CSR_RST | SHIM_BYT_CSR_VECTOR_SEL |
-				  SHIM_BYT_CSR_STALL,
-				  SHIM_BYT_CSR_RST | SHIM_BYT_CSR_VECTOR_SEL |
-				  SHIM_BYT_CSR_STALL);
-
-	usleep_range(10, 15);
-
-	/* take DSP out of reset and keep stalled for FW loading */
-	snd_sof_dsp_update_bits64(sdev, BYT_DSP_BAR, SHIM_CSR,
-				  SHIM_BYT_CSR_RST, 0);
-
-	return 0;
-}
-
-/*
- * Probe and remove.
- */
-
-static int byt_acpi_probe(struct snd_sof_dev *sdev)
-{
-	struct snd_sof_pdata *pdata = sdev->pdata;
-	const struct sof_dev_desc *desc = pdata->desc;
-	struct platform_device *pdev =
-		container_of(sdev->parent, struct platform_device, dev);
-	struct resource *mmio;
-	u32 base, size;
-	int ret = 0;
-
-	/* DSP DMA can only access low 31 bits of host memory */
-	ret = dma_coerce_mask_and_coherent(sdev->dev, DMA_BIT_MASK(31));
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to set DMA mask %d\n", ret);
-		return ret;
-	}
-
-	/* LPE base */
-	mmio = platform_get_resource(pdev, IORESOURCE_MEM,
-				     desc->resindex_lpe_base);
-	if (mmio) {
-		base = mmio->start;
-		size = resource_size(mmio);
-	} else {
-		dev_err(sdev->dev, "error: failed to get LPE base at idx %d\n",
-			desc->resindex_lpe_base);
-		return -EINVAL;
-	}
-
-	dev_dbg(sdev->dev, "LPE PHY base at 0x%x size 0x%x", base, size);
-	sdev->bar[BYT_DSP_BAR] = ioremap(base, size);
-	if (!sdev->bar[BYT_DSP_BAR]) {
-		dev_err(sdev->dev, "error: failed to ioremap LPE base 0x%x size 0x%x\n",
-			base, size);
-		return -ENODEV;
-	}
-	dev_dbg(sdev->dev, "LPE VADDR %p\n", sdev->bar[BYT_DSP_BAR]);
-
-	/* TODO: add offsets */
-	sdev->mmio_bar = BYT_DSP_BAR;
-	sdev->mailbox_bar = BYT_DSP_BAR;
-
-	/* IMR base - optional */
-	if (desc->resindex_imr_base == -1)
-		goto irq;
-
-	mmio = platform_get_resource(pdev, IORESOURCE_MEM,
-				     desc->resindex_imr_base);
-	if (mmio) {
-		base = mmio->start;
-		size = resource_size(mmio);
-	} else {
-		dev_err(sdev->dev, "error: failed to get IMR base at idx %d\n",
-			desc->resindex_imr_base);
-		ret = -ENODEV;
-		goto imr_err;
-	}
-
-	/* some BIOSes don't map IMR */
-	if (base == 0x55aa55aa || base == 0x0) {
-		dev_info(sdev->dev, "IMR not set by BIOS. Ignoring\n");
-		goto irq;
-	}
-
-	dev_dbg(sdev->dev, "IMR base at 0x%x size 0x%x", base, size);
-	sdev->bar[BYT_IMR_BAR] = ioremap(base, size);
-	if (!sdev->bar[BYT_IMR_BAR]) {
-		dev_err(sdev->dev, "error: failed to ioremap IMR base 0x%x size 0x%x\n",
-			base, size);
-		ret = -ENODEV;
-		goto imr_err;
-	}
-	dev_dbg(sdev->dev, "IMR VADDR %p\n", sdev->bar[BYT_IMR_BAR]);
-
-irq:
-	/* register our IRQ */
-	sdev->ipc_irq = platform_get_irq(pdev, desc->irqindex_host_ipc);
-	if (sdev->ipc_irq < 0) {
-		dev_err(sdev->dev, "error: failed to get IRQ at index %d\n",
-			desc->irqindex_host_ipc);
-		ret = sdev->ipc_irq;
-		goto irq_err;
-	}
-
-	dev_dbg(sdev->dev, "using IRQ %d\n", sdev->ipc_irq);
-	ret = request_threaded_irq(sdev->ipc_irq, byt_irq_handler,
-				   byt_irq_thread, IRQF_SHARED, "AudioDSP",
-				   sdev);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to register IRQ %d\n",
-			sdev->ipc_irq);
-		goto irq_err;
-	}
-
-	/* enable Interrupt from both sides */
-	snd_sof_dsp_update_bits64(sdev, BYT_DSP_BAR, SHIM_IMRX, 0x3, 0x0);
-	snd_sof_dsp_update_bits64(sdev, BYT_DSP_BAR, SHIM_IMRD, 0x3, 0x0);
-
-	/* set BARS */
-	sdev->cl_bar = BYT_DSP_BAR;
-
-	/* set default mailbox offset for FW ready message */
-	sdev->dsp_box.offset = MBOX_OFFSET;
-
-	return ret;
-
-irq_err:
-	iounmap(sdev->bar[BYT_IMR_BAR]);
-imr_err:
-	iounmap(sdev->bar[BYT_DSP_BAR]);
-	return ret;
-}
-
-static int byt_pci_probe(struct snd_sof_dev *sdev)
-{
-	struct snd_sof_pdata *pdata = sdev->pdata;
-	const struct sof_dev_desc *desc = pdata->desc;
-	struct pci_dev *pci = sdev->pci;
-	u32 base, size;
-	int ret = 0;
-
-	/* DSP DMA can only access low 31 bits of host memory */
-	ret = dma_coerce_mask_and_coherent(&pci->dev, DMA_BIT_MASK(31));
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to set DMA mask %d\n", ret);
-		return ret;
-	}
-
-	/* LPE base */
-	base = pci_resource_start(pci, desc->resindex_lpe_base) - IRAM_OFFSET;
-	size = BYT_PCI_BAR_SIZE;
-
-	dev_dbg(sdev->dev, "LPE PHY base at 0x%x size 0x%x", base, size);
-	sdev->bar[BYT_DSP_BAR] = ioremap(base, size);
-	if (!sdev->bar[BYT_DSP_BAR]) {
-		dev_err(sdev->dev, "error: failed to ioremap LPE base 0x%x size 0x%x\n",
-			base, size);
-		return -ENODEV;
-	}
-	dev_dbg(sdev->dev, "LPE VADDR %p\n", sdev->bar[BYT_DSP_BAR]);
-
-	/* IMR base - optional */
-	if (desc->resindex_imr_base == -1)
-		goto irq;
-
-	base = pci_resource_start(pci, desc->resindex_imr_base);
-	size = pci_resource_len(pci, desc->resindex_imr_base);
-
-	/* some BIOSes don't map IMR */
-	if (base == 0x55aa55aa || base == 0x0) {
-		dev_info(sdev->dev, "IMR not set by BIOS. Ignoring\n");
-		goto irq;
-	}
-
-	dev_dbg(sdev->dev, "IMR base at 0x%x size 0x%x", base, size);
-	sdev->bar[BYT_IMR_BAR] = ioremap(base, size);
-	if (!sdev->bar[BYT_IMR_BAR]) {
-		dev_err(sdev->dev, "error: failed to ioremap IMR base 0x%x size 0x%x\n",
-			base, size);
-		ret = -ENODEV;
-		goto imr_err;
-	}
-	dev_dbg(sdev->dev, "IMR VADDR %p\n", sdev->bar[BYT_IMR_BAR]);
-
-irq:
-	/* register our IRQ */
-	sdev->ipc_irq = pci->irq;
-	dev_dbg(sdev->dev, "using IRQ %d\n", sdev->ipc_irq);
-	ret = request_threaded_irq(sdev->ipc_irq, byt_irq_handler,
-				   byt_irq_thread, 0, "AudioDSP", sdev);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to register IRQ %d\n",
-			sdev->ipc_irq);
-		goto irq_err;
-	}
-
-	/* enable Interrupt from both sides */
-	snd_sof_dsp_update_bits64(sdev, BYT_DSP_BAR, SHIM_IMRX, 0x3, 0x0);
-	snd_sof_dsp_update_bits64(sdev, BYT_DSP_BAR, SHIM_IMRD, 0x3, 0x0);
-
-	/* set BARS */
-	sdev->cl_bar = BYT_DSP_BAR;
-
-	/* set default mailbox offset for FW ready message */
-	sdev->dsp_box.offset = MBOX_OFFSET;
-
-	return ret;
-
-irq_err:
-	iounmap(sdev->bar[BYT_IMR_BAR]);
-imr_err:
-	iounmap(sdev->bar[BYT_DSP_BAR]);
-	return ret;
-}
-
-static int byt_probe(struct snd_sof_dev *sdev)
-{
-	if (sdev->pci)
-		return byt_pci_probe(sdev);
-	else
-		return byt_acpi_probe(sdev);
-}
-
-static int byt_acpi_remove(struct snd_sof_dev *sdev)
-{
-	iounmap(sdev->bar[BYT_DSP_BAR]);
-	iounmap(sdev->bar[BYT_PCI_BAR]);
-	iounmap(sdev->bar[BYT_IMR_BAR]);
-	free_irq(sdev->ipc_irq, sdev);
-	return 0;
-}
-
-static int byt_pci_remove(struct snd_sof_dev *sdev)
-{
-	free_irq(sdev->ipc_irq, sdev);
-	return 0;
-}
-
-static int byt_remove(struct snd_sof_dev *sdev)
-{
-	if (sdev->pci)
-		return byt_pci_remove(sdev);
-	else
-		return byt_acpi_remove(sdev);
-}
-
-/* baytrail ops */
-struct snd_sof_dsp_ops snd_sof_byt_ops = {
-	/* device init */
-	.probe		= byt_probe,
-	.remove		= byt_remove,
-
-	/* DSP core boot / reset */
-	.run		= byt_run,
-	.reset		= byt_reset,
-
-	/* Register IO */
-	.write		= byt_write,
-	.read		= byt_read,
-	.write64	= byt_write64,
-	.read64		= byt_read64,
-
-	/* Block IO */
-	.block_read	= byt_block_read,
-	.block_write	= byt_block_write,
-
-	/* doorbell */
-	.irq_handler	= byt_irq_handler,
-	.irq_thread	= byt_irq_thread,
-
-	/* mailbox */
-	.mailbox_read	= byt_mailbox_read,
-	.mailbox_write	= byt_mailbox_write,
-
-	/* ipc */
-	.send_msg	= byt_send_msg,
-	.get_reply	= byt_get_reply,
-	.fw_ready	= byt_fw_ready,
-	.is_ready	= byt_is_ready,
-	.cmd_done	= byt_cmd_done,
-
-	/* debug */
-	.debug_map	= byt_debugfs,
-	.debug_map_count	= ARRAY_SIZE(byt_debugfs),
-	.dbg_dump	= byt_dump,
-
-	/* module loading */
-	.load_module	= snd_sof_parse_module_memcpy,
-
-	/*Firmware loading */
-	.load_firmware	= snd_sof_load_firmware_memcpy,
-};
-EXPORT_SYMBOL(snd_sof_byt_ops);
-
-/* cherrytrail and braswell ops */
-struct snd_sof_dsp_ops snd_sof_cht_ops = {
-	/* device init */
-	.probe		= byt_probe,
-	.remove		= byt_remove,
-
-	/* DSP core boot / reset */
-	.run		= byt_run,
-	.reset		= byt_reset,
-
-	/* Register IO */
-	.write		= byt_write,
-	.read		= byt_read,
-	.write64	= byt_write64,
-	.read64		= byt_read64,
-
-	/* Block IO */
-	.block_read	= byt_block_read,
-	.block_write	= byt_block_write,
-
-	/* doorbell */
-	.irq_handler	= byt_irq_handler,
-	.irq_thread	= byt_irq_thread,
-
-	/* mailbox */
-	.mailbox_read	= byt_mailbox_read,
-	.mailbox_write	= byt_mailbox_write,
-
-	/* ipc */
-	.send_msg	= byt_send_msg,
-	.get_reply	= byt_get_reply,
-	.fw_ready	= byt_fw_ready,
-	.is_ready	= byt_is_ready,
-	.cmd_done	= byt_cmd_done,
-
-	/* debug */
-	.debug_map	= cht_debugfs,
-	.debug_map_count	= ARRAY_SIZE(cht_debugfs),
-	.dbg_dump	= byt_dump,
-
-	/* module loading */
-	.load_module	= snd_sof_parse_module_memcpy,
-
-	/*Firmware loading */
-	.load_firmware	= snd_sof_load_firmware_memcpy,
-};
-EXPORT_SYMBOL(snd_sof_cht_ops);
-
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/sound/soc/sof/hw-hsw.c b/sound/soc/sof/hw-hsw.c
deleted file mode 100644
index a5b8f2d..0000000
--- a/sound/soc/sof/hw-hsw.c
+++ /dev/null
@@ -1,756 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-/*
- * Hardwre interface for audio DSP on Haswell
- */
-
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-#include <linux/platform_device.h>
-#include <linux/firmware.h>
-
-#include <trace/events/hswadsp.h>
-#include <sound/sof.h>
-#include "sof-priv.h"
-#include "ops.h"
-#include "intel.h"
-
-/* BARs */
-#define HSW_DSP_BAR 0
-#define HSW_PCI_BAR 1
-
-/*
- * Debug
- */
-
-/* DSP memories for HSW */
-#define IRAM_OFFSET     0x80000
-#define HSW_IRAM_SIZE       (10 * 32 * 1024)
-#define DRAM_OFFSET     0x00000
-#define HSW_DRAM_SIZE       (16 * 32 * 1024)
-#define SHIM_OFFSET     0xE7000
-#define SHIM_SIZE       0x100
-#define MBOX_OFFSET     0x7E000
-#define MBOX_SIZE       0x1000
-#define MBOX_DUMP_SIZE 0x30
-#define EXCEPT_OFFSET	0x800
-
-/* DSP peripherals */
-#define DMAC0_OFFSET    0xFE000
-#define DMAC1_OFFSET    0xFF000
-#define DMAC_SIZE       0x420
-#define SSP0_OFFSET     0xFC000
-#define SSP1_OFFSET     0xFD000
-#define SSP_SIZE	0x100
-
-#define HSW_STACK_DUMP_SIZE	32
-
-static const struct snd_sof_debugfs_map hsw_debugfs[] = {
-	{"dmac0", HSW_DSP_BAR, DMAC0_OFFSET, DMAC_SIZE},
-	{"dmac1", HSW_DSP_BAR, DMAC1_OFFSET, DMAC_SIZE},
-	{"ssp0", HSW_DSP_BAR, SSP0_OFFSET, SSP_SIZE},
-	{"ssp1", HSW_DSP_BAR, SSP1_OFFSET, SSP_SIZE},
-	{"iram", HSW_DSP_BAR, IRAM_OFFSET, HSW_IRAM_SIZE},
-	{"dram", HSW_DSP_BAR, DRAM_OFFSET, HSW_DRAM_SIZE},
-	{"shim", HSW_DSP_BAR, SHIM_OFFSET, SHIM_SIZE},
-};
-
-/*
- * Memory copy.
- */
-
-/* write has to deal with copying non 32 bit sized data */
-static void hsw_block_write(struct snd_sof_dev *sdev, u32 offset, void *src,
-			    size_t size)
-{
-	void __iomem *dest = sdev->bar[sdev->mmio_bar] + offset;
-	u32 tmp = 0;
-	int i, m, n;
-	const u8 *src_byte = src;
-
-	m = size / 4;
-	n = size % 4;
-
-	/* __iowrite32_copy use 32bit size values so divide by 4 */
-	__iowrite32_copy((void *)dest, src, m);
-
-	if (n) {
-		for (i = 0; i < n; i++)
-			tmp |= (u32)*(src_byte + m * 4 + i) << (i * 8);
-		__iowrite32_copy((void *)(dest + m * 4), &tmp, 1);
-	}
-}
-
-static void hsw_block_read(struct snd_sof_dev *sdev, u32 offset, void *dest,
-			   size_t size)
-{
-	void __iomem *src = sdev->bar[sdev->mmio_bar] + offset;
-
-	memcpy_fromio(dest, src, size);
-}
-
-static void hsw_mailbox_write(struct snd_sof_dev *sdev, u32 offset,
-			      void *message, size_t bytes)
-{
-	void __iomem *dest = sdev->bar[sdev->mailbox_bar] + offset;
-
-	memcpy_toio(dest, message, bytes);
-}
-
-static void hsw_mailbox_read(struct snd_sof_dev *sdev, u32 offset,
-			     void *message, size_t bytes)
-{
-	void __iomem *src = sdev->bar[sdev->mailbox_bar] + offset;
-
-	memcpy_fromio(message, src, bytes);
-}
-
-/*
- * Register IO
- */
-
-static void hsw_write(struct snd_sof_dev *sdev, void __iomem *addr,
-		      u32 value)
-{
-	writel(value, addr);
-}
-
-static u32 hsw_read(struct snd_sof_dev *sdev, void __iomem *addr)
-{
-	return readl(addr);
-}
-
-static void hsw_write64(struct snd_sof_dev *sdev, void __iomem *addr,
-			u64 value)
-{
-	memcpy_toio(addr, &value, sizeof(value));
-}
-
-static u64 hsw_read64(struct snd_sof_dev *sdev, void __iomem *addr)
-{
-	u64 val;
-
-	memcpy_fromio(&val, addr, sizeof(val));
-	return val;
-}
-
-/*
- * DSP Control.
- */
-
-static int hsw_run(struct snd_sof_dev *sdev)
-{
-	/* set oportunistic mode on engine 0,1 for all channels */
-	snd_sof_dsp_update_bits(sdev, HSW_DSP_BAR, SHIM_HMDC,
-				SHIM_HMDC_HDDA_E0_ALLCH |
-				SHIM_HMDC_HDDA_E1_ALLCH, 0);
-
-	/* set DSP to RUN */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_DSP_BAR, SHIM_CSR,
-					 SHIM_CSR_STALL, 0x0);
-
-	return 0; //TODO: Fix return value
-}
-
-static int hsw_reset(struct snd_sof_dev *sdev)
-{
-	/* put DSP into reset and stall */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_DSP_BAR, SHIM_CSR,
-					 SHIM_CSR_RST | SHIM_CSR_STALL,
-					 SHIM_CSR_RST | SHIM_CSR_STALL);
-
-	/* keep in reset for 10ms */
-	mdelay(10);
-
-	/* take DSP out of reset and keep stalled for FW loading */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_DSP_BAR, SHIM_CSR,
-					 SHIM_CSR_RST | SHIM_CSR_STALL,
-					 SHIM_CSR_STALL);
-
-	return 0; //TODO: Fix return value
-}
-
-static int hsw_set_dsp_D0(struct snd_sof_dev *sdev)
-{
-	int tries = 10;
-	u32 reg;
-
-	/* Disable core clock gating (VDRTCTL2.DCLCGE = 0) */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_PCI_BAR, PCI_VDRTCTL2,
-					 PCI_VDRTCL2_DCLCGE | PCI_VDRTCL2_DTCGE,
-					 0);
-
-	/* Disable D3PG (VDRTCTL0.D3PGD = 1) */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_PCI_BAR, PCI_VDRTCTL0,
-					 PCI_VDRTCL0_D3PGD, PCI_VDRTCL0_D3PGD);
-
-	/* Set D0 state */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_PCI_BAR, PCI_PMCS,
-					 PCI_PMCS_PS_MASK, 0);
-
-	/* check that ADSP shim is enabled */
-	while (tries--) {
-		reg = readl(sdev->bar[HSW_PCI_BAR] + PCI_PMCS)
-			& PCI_PMCS_PS_MASK;
-		if (reg == 0)
-			goto finish;
-
-		msleep(20);
-	}
-
-	return -ENODEV;
-
-finish:
-	/*
-	 * select SSP1 19.2MHz base clock, SSP clock 0,
-	 * turn off Low Power Clock
-	 */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_DSP_BAR, SHIM_CSR,
-					 SHIM_CSR_S1IOCS | SHIM_CSR_SBCS1 |
-					 SHIM_CSR_LPCS, 0x0);
-
-	/* stall DSP core, set clk to 192/96Mhz */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_DSP_BAR,
-					 SHIM_CSR, SHIM_CSR_STALL |
-					 SHIM_CSR_DCS_MASK,
-					 SHIM_CSR_STALL | SHIM_CSR_DCS(4));
-
-	/* Set 24MHz MCLK, prevent local clock gating, enable SSP0 clock */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_DSP_BAR, SHIM_CLKCTL,
-					 SHIM_CLKCTL_MASK | SHIM_CLKCTL_DCPLCG |
-					 SHIM_CLKCTL_SCOE0,
-					 SHIM_CLKCTL_MASK | SHIM_CLKCTL_DCPLCG |
-					 SHIM_CLKCTL_SCOE0);
-
-	/* Stall and reset core, set CSR */
-	hsw_reset(sdev);
-
-	/* Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_PCI_BAR, PCI_VDRTCTL2,
-					 PCI_VDRTCL2_DCLCGE |
-					 PCI_VDRTCL2_DTCGE,
-					 PCI_VDRTCL2_DCLCGE |
-					 PCI_VDRTCL2_DTCGE);
-
-	usleep_range(50, 55);
-
-	/* switch on audio PLL */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_PCI_BAR, PCI_VDRTCTL2,
-					 PCI_VDRTCL2_APLLSE_MASK, 0);
-
-	/*
-	 * set default power gating control, enable power gating control for
-	 * all blocks. that is, can't be accessed, please enable each block
-	 * before accessing.
-	 */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_PCI_BAR, PCI_VDRTCTL0,
-					 PCI_VDRTCL0_DSRAMPGE_MASK |
-					 PCI_VDRTCL0_ISRAMPGE_MASK, 0);
-
-	/* disable DMA finish function for SSP0 & SSP1 */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_DSP_BAR,  SHIM_CSR2,
-					 SHIM_CSR2_SDFD_SSP1,
-					 SHIM_CSR2_SDFD_SSP1);
-
-	/* set on-demond mode on engine 0,1 for all channels */
-	snd_sof_dsp_update_bits(sdev, HSW_DSP_BAR, SHIM_HMDC,
-				SHIM_HMDC_HDDA_E0_ALLCH |
-				SHIM_HMDC_HDDA_E1_ALLCH,
-				SHIM_HMDC_HDDA_E0_ALLCH |
-				SHIM_HMDC_HDDA_E1_ALLCH);
-
-	/* Enable Interrupt from both sides */
-	snd_sof_dsp_update_bits(sdev, HSW_DSP_BAR, SHIM_IMRX,
-				(SHIM_IMRX_BUSY | SHIM_IMRX_DONE), 0x0);
-	snd_sof_dsp_update_bits(sdev, HSW_DSP_BAR, SHIM_IMRD,
-				(SHIM_IMRD_DONE | SHIM_IMRD_BUSY |
-				SHIM_IMRD_SSP0 | SHIM_IMRD_DMAC), 0x0);
-
-	/* clear IPC registers */
-	snd_sof_dsp_write(sdev, HSW_DSP_BAR, SHIM_IPCX, 0x0);
-	snd_sof_dsp_write(sdev, HSW_DSP_BAR, SHIM_IPCD, 0x0);
-	snd_sof_dsp_write(sdev, HSW_DSP_BAR, 0x80, 0x6);
-	snd_sof_dsp_write(sdev, HSW_DSP_BAR, 0xe0, 0x300a);
-
-	return 0;
-}
-
-static void hsw_get_registers(struct snd_sof_dev *sdev,
-			      struct sof_ipc_dsp_oops_xtensa *xoops,
-			      u32 *stack, size_t stack_words)
-{
-	/* first read regsisters */
-	hsw_mailbox_read(sdev, sdev->dsp_oops_offset, xoops, sizeof(*xoops));
-
-	/* the get the stack */
-	hsw_mailbox_read(sdev, sdev->dsp_oops_offset + sizeof(*xoops), stack,
-			 stack_words * sizeof(u32));
-}
-
-static void hsw_dump(struct snd_sof_dev *sdev, u32 flags)
-{
-	struct sof_ipc_dsp_oops_xtensa xoops;
-	u32 stack[HSW_STACK_DUMP_SIZE];
-	u32 status, panic;
-
-	/* now try generic SOF status messages */
-	status = snd_sof_dsp_read(sdev, HSW_DSP_BAR, SHIM_IPCD);
-	panic = snd_sof_dsp_read(sdev, HSW_DSP_BAR, SHIM_IPCX);
-	hsw_get_registers(sdev, &xoops, stack, HSW_STACK_DUMP_SIZE);
-	snd_sof_get_status(sdev, status, panic, &xoops, stack,
-			   HSW_STACK_DUMP_SIZE);
-}
-
-/*
- * IPC Doorbell IRQ handler and thread.
- */
-
-static irqreturn_t hsw_irq_handler(int irq, void *context)
-{
-	struct snd_sof_dev *sdev = (struct snd_sof_dev *)context;
-	u32 isr;
-	int ret = IRQ_NONE;
-
-	spin_lock(&sdev->hw_lock);
-
-	/* Interrupt arrived, check src */
-	isr = snd_sof_dsp_read(sdev, HSW_DSP_BAR, SHIM_ISRX);
-	if (isr & SHIM_ISRX_DONE) {
-		/* Mask Done interrupt before return */
-		snd_sof_dsp_update_bits_unlocked(sdev, HSW_DSP_BAR, SHIM_IMRX,
-						 SHIM_IMRX_DONE,
-						 SHIM_IMRX_DONE);
-		ret = IRQ_WAKE_THREAD;
-	}
-
-	if (isr & SHIM_ISRX_BUSY) {
-		/* Mask Busy interrupt before return */
-		snd_sof_dsp_update_bits_unlocked(sdev, HSW_DSP_BAR, SHIM_IMRX,
-						 SHIM_IMRX_BUSY,
-						 SHIM_IMRX_BUSY);
-		ret = IRQ_WAKE_THREAD;
-	}
-
-	spin_unlock(&sdev->hw_lock);
-	return ret;
-}
-
-static irqreturn_t hsw_irq_thread(int irq, void *context)
-{
-	struct snd_sof_dev *sdev = (struct snd_sof_dev *)context;
-	u32 ipcx, ipcd, hdr;
-
-	ipcx = snd_sof_dsp_read(sdev, HSW_DSP_BAR, SHIM_IPCX);
-
-	/* reply message from DSP */
-	if (ipcx & SHIM_IPCX_DONE) {
-		/* Handle Immediate reply from DSP Core */
-		hsw_mailbox_read(sdev, sdev->host_box.offset, &hdr,
-				 sizeof(hdr));
-		snd_sof_ipc_reply(sdev, hdr);
-
-		/* clear DONE bit - tell DSP we have completed */
-		snd_sof_dsp_update_bits_unlocked(sdev, HSW_DSP_BAR, SHIM_IPCX,
-						 SHIM_IPCX_DONE, 0);
-
-		/* unmask Done interrupt */
-		snd_sof_dsp_update_bits_unlocked(sdev, HSW_DSP_BAR, SHIM_IMRX,
-						 SHIM_IMRX_DONE, 0);
-	}
-
-	ipcd = snd_sof_dsp_read(sdev, HSW_DSP_BAR, SHIM_IPCD);
-
-	/* new message from DSP */
-	if (ipcd & SHIM_IPCD_BUSY) {
-		/* Handle messages from DSP Core */
-		if ((ipcd & SOF_IPC_PANIC_MAGIC_MASK) == SOF_IPC_PANIC_MAGIC) {
-			dev_err(sdev->dev, "error : DSP panic!\n");
-			snd_sof_dsp_cmd_done(sdev);
-			snd_sof_dsp_dbg_dump(sdev, SOF_DBG_REGS | SOF_DBG_MBOX);
-			snd_sof_trace_notify_for_error(sdev);
-		} else {
-			snd_sof_ipc_msgs_rx(sdev);
-		}
-	}
-
-	/* continue to send any remaining messages... */
-	snd_sof_ipc_msgs_tx(sdev);
-
-	return IRQ_HANDLED;
-}
-
-/*
- * IPC Firmware ready.
- */
-static void hsw_get_windows(struct snd_sof_dev *sdev)
-{
-	struct sof_ipc_window_elem *elem;
-	u32 outbox_offset = 0;
-	u32 stream_offset = 0;
-	u32 inbox_offset = 0;
-	u32 outbox_size = 0;
-	u32 stream_size = 0;
-	u32 inbox_size = 0;
-	int i;
-
-	if (!sdev->info_window) {
-		dev_err(sdev->dev, "error: have no window info\n");
-		return;
-	}
-
-	for (i = 0; i < sdev->info_window->num_windows; i++) {
-		elem = &sdev->info_window->window[i];
-
-		switch (elem->type) {
-		case SOF_IPC_REGION_UPBOX:
-			inbox_offset = elem->offset + MBOX_OFFSET;
-			inbox_size = elem->size;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[HSW_DSP_BAR] +
-						    inbox_offset,
-						    elem->size, "inbox");
-			break;
-		case SOF_IPC_REGION_DOWNBOX:
-			outbox_offset = elem->offset + MBOX_OFFSET;
-			outbox_size = elem->size;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[HSW_DSP_BAR] +
-						    outbox_offset,
-						    elem->size, "outbox");
-			break;
-		case SOF_IPC_REGION_TRACE:
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[HSW_DSP_BAR] +
-						    elem->offset + MBOX_OFFSET,
-						    elem->size, "etrace");
-			break;
-		case SOF_IPC_REGION_DEBUG:
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[HSW_DSP_BAR] +
-						    elem->offset + MBOX_OFFSET,
-						    elem->size, "debug");
-			break;
-		case SOF_IPC_REGION_STREAM:
-			stream_offset = elem->offset + MBOX_OFFSET;
-			stream_size = elem->size;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[HSW_DSP_BAR] +
-						    stream_offset,
-						    elem->size, "stream");
-			break;
-		case SOF_IPC_REGION_REGS:
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[HSW_DSP_BAR] +
-						    elem->offset + MBOX_OFFSET,
-						    elem->size, "regs");
-			break;
-		case SOF_IPC_REGION_EXCEPTION:
-			sdev->dsp_oops_offset = elem->offset + MBOX_OFFSET;
-			snd_sof_debugfs_create_item(sdev,
-						    sdev->bar[HSW_DSP_BAR] +
-						    elem->offset + MBOX_OFFSET,
-						    elem->size, "exception");
-			break;
-		default:
-			dev_err(sdev->dev, "error: get illegal window info\n");
-			return;
-		}
-	}
-
-	if (outbox_size == 0 || inbox_size == 0) {
-		dev_err(sdev->dev, "error: get illegal mailbox window\n");
-		return;
-	}
-
-	snd_sof_dsp_mailbox_init(sdev, inbox_offset, inbox_size,
-				 outbox_offset, outbox_size);
-	sdev->stream_box.offset = stream_offset;
-	sdev->stream_box.size = stream_size;
-
-	dev_dbg(sdev->dev, " mailbox upstream 0x%x - size 0x%x\n",
-		inbox_offset, inbox_size);
-	dev_dbg(sdev->dev, " mailbox downstream 0x%x - size 0x%x\n",
-		outbox_offset, outbox_size);
-	dev_dbg(sdev->dev, " stream region 0x%x - size 0x%x\n",
-		stream_offset, stream_size);
-}
-
-static int hsw_fw_ready(struct snd_sof_dev *sdev, u32 msg_id)
-{
-	struct sof_ipc_fw_ready *fw_ready = &sdev->fw_ready;
-	struct sof_ipc_fw_version *v = &fw_ready->version;
-	u32 offset;
-
-	/* mailbox must be on 4k boundary */
-	offset = MBOX_OFFSET;
-
-	dev_dbg(sdev->dev, "ipc: DSP is ready 0x%8.8x offset %d\n",
-		msg_id, offset);
-
-	/* copy data from the DSP FW ready offset */
-	hsw_block_read(sdev, offset, fw_ready, sizeof(*fw_ready));
-
-	snd_sof_dsp_mailbox_init(sdev, fw_ready->dspbox_offset,
-				 fw_ready->dspbox_size,
-				 fw_ready->hostbox_offset,
-				 fw_ready->hostbox_size);
-
-	dev_info(sdev->dev,
-		 " Firmware info: version %d:%d-%s build %d on %s:%s\n",
-		 v->major, v->minor, v->tag, v->build, v->date, v->time);
-
-	/* now check for extended data */
-	snd_sof_fw_parse_ext_data(sdev, MBOX_OFFSET +
-				  sizeof(struct sof_ipc_fw_ready));
-
-	hsw_get_windows(sdev);
-
-	return 0;
-}
-
-/*
- * IPC Mailbox IO
- */
-
-static int hsw_is_ready(struct snd_sof_dev *sdev)
-{
-	u32 val;
-
-	val = snd_sof_dsp_read(sdev, HSW_DSP_BAR, SHIM_IPCX);
-	if (val & SHIM_IPCX_BUSY)
-		return 0;
-
-	return 1;
-}
-
-static int hsw_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)
-{
-	/* send the message */
-	hsw_mailbox_write(sdev, sdev->host_box.offset, msg->msg_data,
-			  msg->msg_size);
-	snd_sof_dsp_write(sdev, HSW_DSP_BAR, SHIM_IPCX, SHIM_IPCX_BUSY);
-
-	return 0;
-}
-
-static int hsw_get_reply(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)
-{
-	struct sof_ipc_reply reply;
-	int ret = 0;
-	u32 size;
-
-	/* get reply */
-	hsw_mailbox_read(sdev, sdev->host_box.offset, &reply, sizeof(reply));
-	if (reply.error < 0) {
-		size = sizeof(reply);
-		ret = reply.error;
-	} else {
-		/* reply correct size ? */
-		if (reply.hdr.size != msg->reply_size) {
-			dev_err(sdev->dev, "error: reply expected 0x%lx got 0x%x bytes\n",
-				msg->reply_size, reply.hdr.size);
-			size = msg->reply_size;
-			ret = -EINVAL;
-		} else {
-			size = reply.hdr.size;
-		}
-	}
-
-	/* read the message */
-	if (msg->msg_data && size > 0)
-		hsw_mailbox_read(sdev, sdev->host_box.offset, msg->reply_data,
-				 size);
-	return ret;
-}
-
-static int hsw_cmd_done(struct snd_sof_dev *sdev)
-{
-	/* clear BUSY bit and set DONE bit - accept new messages */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_DSP_BAR, SHIM_IPCD,
-					 SHIM_IPCD_BUSY | SHIM_IPCD_DONE,
-					 SHIM_IPCD_DONE);
-
-	/* unmask busy interrupt */
-	snd_sof_dsp_update_bits_unlocked(sdev, HSW_DSP_BAR, SHIM_IMRX,
-					 SHIM_IMRX_BUSY, 0);
-
-	return 0;
-}
-
-/*
- * Probe and remove.
- */
-static int hsw_probe(struct snd_sof_dev *sdev)
-{
-	struct snd_sof_pdata *pdata = sdev->pdata;
-	const struct sof_dev_desc *desc = pdata->desc;
-	struct platform_device *pdev =
-		container_of(sdev->parent, struct platform_device, dev);
-	struct resource *mmio;
-	u32 base, size;
-	int ret = 0;
-
-	/* LPE base */
-	mmio = platform_get_resource(pdev, IORESOURCE_MEM,
-				     desc->resindex_lpe_base);
-	if (mmio) {
-		base = mmio->start;
-		size = resource_size(mmio);
-	} else {
-		dev_err(sdev->dev, "error: failed to get LPE base at idx %d\n",
-			desc->resindex_lpe_base);
-		return -EINVAL;
-	}
-
-	dev_dbg(sdev->dev, "LPE PHY base at 0x%x size 0x%x", base, size);
-	sdev->bar[HSW_DSP_BAR] = ioremap(base, size);
-	if (!sdev->bar[HSW_DSP_BAR]) {
-		dev_err(sdev->dev,
-			"error: failed to ioremap LPE base 0x%x size 0x%x\n",
-			base, size);
-		return -ENODEV;
-	}
-	dev_dbg(sdev->dev, "LPE VADDR %p\n", sdev->bar[HSW_DSP_BAR]);
-
-	/* TODO: add offsets */
-	sdev->mmio_bar = HSW_DSP_BAR;
-	sdev->mailbox_bar = HSW_DSP_BAR;
-
-	/* PCI base */
-	mmio = platform_get_resource(pdev, IORESOURCE_MEM,
-				     desc->resindex_pcicfg_base);
-	if (mmio) {
-		base = mmio->start;
-		size = resource_size(mmio);
-	} else {
-		dev_err(sdev->dev, "error: failed to get PCI base at idx %d\n",
-			desc->resindex_pcicfg_base);
-		ret = -ENODEV;
-		goto pci_err;
-	}
-
-	dev_dbg(sdev->dev, "PCI base at 0x%x size 0x%x", base, size);
-	sdev->bar[HSW_PCI_BAR] = ioremap(base, size);
-	if (!sdev->bar[HSW_PCI_BAR]) {
-		dev_err(sdev->dev,
-			"error: failed to ioremap PCI base 0x%x size 0x%x\n",
-			base, size);
-		ret = -ENODEV;
-		goto pci_err;
-	}
-	dev_dbg(sdev->dev, "PCI VADDR %p\n", sdev->bar[HSW_PCI_BAR]);
-
-	/* register our IRQ */
-	sdev->ipc_irq = platform_get_irq(pdev, desc->irqindex_host_ipc);
-	if (sdev->ipc_irq < 0) {
-		dev_err(sdev->dev, "error: failed to get IRQ at index %d\n",
-			desc->irqindex_host_ipc);
-		ret = sdev->ipc_irq;
-		goto irq_err;
-	}
-
-	dev_dbg(sdev->dev, "using IRQ %d\n", sdev->ipc_irq);
-	ret = request_threaded_irq(sdev->ipc_irq, hsw_irq_handler,
-				   hsw_irq_thread, 0, "AudioDSP", sdev);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to register IRQ %d\n",
-			sdev->ipc_irq);
-		goto irq_err;
-	}
-
-	/* enable the DSP SHIM */
-	ret = hsw_set_dsp_D0(sdev);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to set DSP D0\n");
-		return ret;
-	}
-
-	/* DSP DMA can only access low 31 bits of host memory */
-	ret = dma_coerce_mask_and_coherent(sdev->dev, DMA_BIT_MASK(31));
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to set DMA mask %d\n", ret);
-		return ret;
-	}
-
-	/* set BARS */
-	sdev->cl_bar = HSW_DSP_BAR;
-
-	/* set default mailbox */
-	snd_sof_dsp_mailbox_init(sdev, MBOX_OFFSET, MBOX_SIZE, 0, 0);
-
-	return ret;
-
-irq_err:
-	iounmap(sdev->bar[HSW_DSP_BAR]);
-pci_err:
-	iounmap(sdev->bar[HSW_PCI_BAR]);
-	return ret;
-}
-
-static int hsw_remove(struct snd_sof_dev *sdev)
-{
-	iounmap(sdev->bar[HSW_DSP_BAR]);
-	iounmap(sdev->bar[HSW_PCI_BAR]);
-	free_irq(sdev->ipc_irq, sdev);
-	return 0;
-}
-
-/* haswell ops */
-struct snd_sof_dsp_ops snd_sof_hsw_ops = {
-	/*Device init */
-	.probe          = hsw_probe,
-	.remove         = hsw_remove,
-
-	/* DSP Core Control */
-	.run            = hsw_run,
-	.reset          = hsw_reset,
-
-	/* Register IO */
-	.read           = hsw_read,
-	.write          = hsw_write,
-	.read64         = hsw_read64,
-	.write64        = hsw_write64,
-
-	/* Block IO */
-	.block_read     = hsw_block_read,
-	.block_write    = hsw_block_write,
-
-	/* mailbox */
-	.mailbox_read   = hsw_mailbox_read,
-	.mailbox_write  = hsw_mailbox_write,
-
-	/* ipc */
-	.send_msg	= hsw_send_msg,
-	.get_reply	= hsw_get_reply,
-	.fw_ready	= hsw_fw_ready,
-	.is_ready	= hsw_is_ready,
-	.cmd_done	= hsw_cmd_done,
-
-	/* debug */
-	.debug_map  = hsw_debugfs,
-	.debug_map_count    = ARRAY_SIZE(hsw_debugfs),
-	.dbg_dump   = hsw_dump,
-
-	/* Module loading */
-	.load_module    = snd_sof_parse_module_memcpy,
-
-	/*Firmware loading */
-	.load_firmware	= snd_sof_load_firmware_memcpy,
-
-};
-EXPORT_SYMBOL(snd_sof_hsw_ops);
-
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/sound/soc/sof/hw-spi.c b/sound/soc/sof/hw-spi.c
deleted file mode 100644
index d6ba29f..0000000
--- a/sound/soc/sof/hw-spi.c
+++ /dev/null
@@ -1,253 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-/*
- * Hardware interface for audio DSPs via SPI
- */
-
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-#include <linux/firmware.h>
-#include <linux/spi/spi.h>
-#include <linux/of_device.h>
-
-#include <linux/device.h>
-#include <sound/sof.h>
-#include <uapi/sound/sof-fw.h>
-
-#include "sof-priv.h"
-#include "ops.h"
-#include "intel.h"
-
-/*
- * Memory copy.
- */
-
-static void spi_block_write(struct snd_sof_dev *sdev, u32 offset, void *src,
-			    size_t size)
-{
-	// use spi_write() to copy data to DSP
-}
-
-static void spi_block_read(struct snd_sof_dev *sdev, u32 offset, void *dest,
-			   size_t size)
-{
-	// use spi_read() to copy data from DSP
-}
-
-/*
- * IPC Firmware ready.
- */
-static int spi_fw_ready(struct snd_sof_dev *sdev, u32 msg_id)
-{
-	struct sof_ipc_fw_ready *fw_ready = &sdev->fw_ready;
-	struct sof_ipc_fw_version *v = &fw_ready->version;
-
-	dev_dbg(sdev->dev, "ipc: DSP is ready 0x%8.8x\n", msg_id);
-
-	// read local buffer with SPI data
-
-	dev_info(sdev->dev, " Firmware info: version %d:%d-%s build %d on %s:%s\n",
-		 v->major, v->minor, v->tag, v->build, v->date, v->time);
-
-	return 0;
-}
-
-/*
- * IPC Mailbox IO
- */
-
-static void spi_mailbox_write(struct snd_sof_dev *sdev, u32 offset,
-			      void *message, size_t bytes)
-{
-	void __iomem *dest = sdev->bar[sdev->mailbox_bar] + offset;
-
-	//memcpy_toio(dest, message, bytes);
-	/*
-	 * this will copy to a local memory buffer that will be sent to DSP via
-	 * SPI at next IPC
-	 */
-}
-
-static void spi_mailbox_read(struct snd_sof_dev *sdev, u32 offset,
-			     void *message, size_t bytes)
-{
-	void __iomem *src = sdev->bar[sdev->mailbox_bar] + offset;
-
-	//memcpy_fromio(message, src, bytes);
-	/*
-	 * this will copy from a local memory buffer that will be received from
-	 * DSP via SPI at last IPC
-	 */
-}
-
-/*
- * IPC Doorbell IRQ handler and thread.
- */
-
-static irqreturn_t spi_irq_handler(int irq, void *context)
-{
-	struct snd_sof_dev *sdev = (struct snd_sof_dev *)context;
-	int ret = IRQ_NONE;
-
-	// on SPI based devices this will likely come via a SoC GPIO IRQ
-
-	// check if GPIO is assetred and if so run thread.
-
-	return ret;
-}
-
-static irqreturn_t spi_irq_thread(int irq, void *context)
-{
-	struct snd_sof_dev *sdev = (struct snd_sof_dev *)context;
-
-	// read SPI data into local buffer and determine IPC cmd or reply
-
-	/*
-	 * if reply. Handle Immediate reply from DSP Core and set DSP
-	 * state to ready
-	 */
-	//snd_sof_ipc_reply(sdev, ipcx);
-
-	/* if cmd, Handle messages from DSP Core */
-	//snd_sof_ipc_msgs_rx(sdev);
-
-	/* continue to send any remaining messages... */
-	snd_sof_ipc_msgs_tx(sdev);
-
-	return IRQ_HANDLED;
-}
-
-static int spi_is_ready(struct snd_sof_dev *sdev)
-{
-	// use local variable to store DSP command state. either DSP is ready
-	// for new cmd or still processing current cmd.
-
-	return 1;
-}
-
-static int spi_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)
-{
-	u64 cmd = msg->header;
-
-	/* send the message */
-	spi_mailbox_write(sdev, sdev->host_box.offset, msg->msg_data,
-			  msg->msg_size);
-
-	return 0;
-}
-
-static int spi_get_reply(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)
-{
-	struct sof_ipc_reply reply;
-	int ret = 0;
-	u32 size;
-
-	/* get reply */
-	spi_mailbox_read(sdev, sdev->host_box.offset, &reply, sizeof(reply));
-	if (reply.error < 0) {
-		size = sizeof(reply);
-		ret = reply.error;
-	} else {
-		/* reply correct size ? */
-		if (reply.hdr.size != msg->reply_size) {
-			dev_err(sdev->dev, "error: reply expected 0x%lx got 0x%x bytes\n",
-				msg->reply_size, reply.hdr.size);
-			size = msg->reply_size;
-			ret = -EINVAL;
-		} else {
-			size = reply.hdr.size;
-		}
-	}
-
-	/* read the message */
-	if (msg->msg_data && size > 0)
-		spi_mailbox_read(sdev, sdev->host_box.offset, msg->reply_data,
-				 size);
-
-	return ret;
-}
-
-/*
- * Probe and remove.
- */
-
-static int spi_sof_probe(struct snd_sof_dev *sdev)
-{
-	struct snd_sof_pdata *pdata = sdev->pdata;
-	const struct sof_dev_desc *desc = pdata->desc;
-	struct platform_device *pdev =
-		container_of(sdev->parent, struct platform_device, dev);
-	int ret = 0;
-
-	/* get IRQ from Device tree or ACPI - register our IRQ */
-	dev_dbg(sdev->dev, "using IRQ %d\n", sdev->ipc_irq);
-	ret = request_threaded_irq(sdev->ipc_irq, spi_irq_handler,
-				   spi_irq_thread, IRQF_SHARED, "AudioDSP",
-				   sdev);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to register IRQ %d\n",
-			sdev->ipc_irq);
-		goto irq_err;
-	}
-
-	return ret;
-}
-
-static int spi_sof_remove(struct snd_sof_dev *sdev)
-{
-	free_irq(sdev->ipc_irq, sdev);
-	return 0;
-}
-
-/* baytrail ops */
-struct snd_sof_dsp_ops snd_sof_spi_ops = {
-	/* device init */
-	.probe		= spi_sof_probe,
-	.remove		= spi_sof_remove,
-
-	/* Block IO */
-	.block_read	= spi_block_read,
-	.block_write	= spi_block_write,
-
-	/* doorbell */
-	.irq_handler	= spi_irq_handler,
-	.irq_thread	= spi_irq_thread,
-
-	/* mailbox */
-	.mailbox_read	= spi_mailbox_read,
-	.mailbox_write	= spi_mailbox_write,
-
-	/* ipc */
-	.send_msg	= spi_send_msg,
-	.get_reply	= spi_get_reply,
-	.fw_ready	= spi_fw_ready,
-	.is_ready	= spi_is_ready,
-	.cmd_done	= spi_cmd_done,
-
-	/* debug */
-	.debug_map	= spi_debugfs,
-	.debug_map_count	= ARRAY_SIZE(spi_debugfs),
-	.dbg_dump	= spi_dump,
-
-	/* module loading */
-	.load_module	= snd_sof_parse_module_memcpy,
-
-	/*Firmware loading */
-	.load_firmware	= snd_sof_load_firmware_memcpy,
-};
-EXPORT_SYMBOL(snd_sof_spi_ops);
-
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/sound/soc/sof/intel.h b/sound/soc/sof/intel.h
deleted file mode 100644
index 4bcf7870..0000000
--- a/sound/soc/sof/intel.h
+++ /dev/null
@@ -1,322 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause) */
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-#ifndef __SOF_INTEL_H
-#define __SOF_INTEL_H
-
-/*
- * SHIM registers for BYT, BSW, CHT HSW, BDW
- */
-
-#define SHIM_CSR		(SHIM_OFFSET + 0x00)
-#define SHIM_PISR		(SHIM_OFFSET + 0x08)
-#define SHIM_PIMR		(SHIM_OFFSET + 0x10)
-#define SHIM_ISRX		(SHIM_OFFSET + 0x18)
-#define SHIM_ISRD		(SHIM_OFFSET + 0x20)
-#define SHIM_IMRX		(SHIM_OFFSET + 0x28)
-#define SHIM_IMRD		(SHIM_OFFSET + 0x30)
-#define SHIM_IPCX		(SHIM_OFFSET + 0x38)
-#define SHIM_IPCD		(SHIM_OFFSET + 0x40)
-#define SHIM_ISRSC		(SHIM_OFFSET + 0x48)
-#define SHIM_ISRLPESC		(SHIM_OFFSET + 0x50)
-#define SHIM_IMRSC		(SHIM_OFFSET + 0x58)
-#define SHIM_IMRLPESC		(SHIM_OFFSET + 0x60)
-#define SHIM_IPCSC		(SHIM_OFFSET + 0x68)
-#define SHIM_IPCLPESC		(SHIM_OFFSET + 0x70)
-#define SHIM_CLKCTL		(SHIM_OFFSET + 0x78)
-#define SHIM_CSR2		(SHIM_OFFSET + 0x80)
-#define SHIM_LTRC		(SHIM_OFFSET + 0xE0)
-#define SHIM_HMDC		(SHIM_OFFSET + 0xE8)
-
-#define SHIM_PWMCTRL		0x1000
-
-/*
- * SST SHIM register bits for BYT, BSW, CHT HSW, BDW
- * Register bit naming and functionaility can differ between devices.
- */
-
-/* CSR / CS */
-#define SHIM_CSR_RST		(0x1 << 1)
-#define SHIM_CSR_SBCS0		(0x1 << 2)
-#define SHIM_CSR_SBCS1		(0x1 << 3)
-#define SHIM_CSR_DCS(x)		(x << 4)
-#define SHIM_CSR_DCS_MASK	(0x7 << 4)
-#define SHIM_CSR_STALL		(0x1 << 10)
-#define SHIM_CSR_S0IOCS		(0x1 << 21)
-#define SHIM_CSR_S1IOCS		(0x1 << 23)
-#define SHIM_CSR_LPCS		(0x1 << 31)
-#define SHIM_CSR_24MHZ_LPCS \
-	(SHIM_CSR_SBCS0 | SHIM_CSR_SBCS1 | SHIM_CSR_LPCS)
-#define SHIM_CSR_24MHZ_NO_LPCS	(SHIM_CSR_SBCS0 | SHIM_CSR_SBCS1)
-#define SHIM_BYT_CSR_RST	(0x1 << 0)
-#define SHIM_BYT_CSR_VECTOR_SEL	(0x1 << 1)
-#define SHIM_BYT_CSR_STALL	(0x1 << 2)
-#define SHIM_BYT_CSR_PWAITMODE	(0x1 << 3)
-
-/*  ISRX / ISC */
-#define SHIM_ISRX_BUSY		(0x1 << 1)
-#define SHIM_ISRX_DONE		(0x1 << 0)
-#define SHIM_BYT_ISRX_REQUEST	(0x1 << 1)
-
-/*  ISRD / ISD */
-#define SHIM_ISRD_BUSY		(0x1 << 1)
-#define SHIM_ISRD_DONE		(0x1 << 0)
-
-/* IMRX / IMC */
-#define SHIM_IMRX_BUSY		(0x1 << 1)
-#define SHIM_IMRX_DONE		(0x1 << 0)
-#define SHIM_BYT_IMRX_REQUEST	(0x1 << 1)
-
-/* IMRD / IMD */
-#define SHIM_IMRD_DONE		(0x1 << 0)
-#define SHIM_IMRD_BUSY		(0x1 << 1)
-#define SHIM_IMRD_SSP0		(0x1 << 16)
-#define SHIM_IMRD_DMAC0		(0x1 << 21)
-#define SHIM_IMRD_DMAC1		(0x1 << 22)
-#define SHIM_IMRD_DMAC		(SHIM_IMRD_DMAC0 | SHIM_IMRD_DMAC1)
-
-/*  IPCX / IPCC */
-#define	SHIM_IPCX_DONE		(0x1 << 30)
-#define	SHIM_IPCX_BUSY		(0x1 << 31)
-#define SHIM_BYT_IPCX_DONE	((u64)0x1 << 62)
-#define SHIM_BYT_IPCX_BUSY	((u64)0x1 << 63)
-
-/*  IPCD */
-#define	SHIM_IPCD_DONE		(0x1 << 30)
-#define	SHIM_IPCD_BUSY		(0x1 << 31)
-#define SHIM_BYT_IPCD_DONE	((u64)0x1 << 62)
-#define SHIM_BYT_IPCD_BUSY	((u64)0x1 << 63)
-
-/* CLKCTL */
-#define SHIM_CLKCTL_SMOS(x)	(x << 24)
-#define SHIM_CLKCTL_MASK	(3 << 24)
-#define SHIM_CLKCTL_DCPLCG	BIT(18)
-#define SHIM_CLKCTL_SCOE1	BIT(17)
-#define SHIM_CLKCTL_SCOE0	BIT(16)
-
-/* CSR2 / CS2 */
-#define SHIM_CSR2_SDFD_SSP0	BIT(1)
-#define SHIM_CSR2_SDFD_SSP1	BIT(2)
-
-/* LTRC */
-#define SHIM_LTRC_VAL(x)	(x << 0)
-
-/* HMDC */
-#define SHIM_HMDC_HDDA0(x)	(x << 0)
-#define SHIM_HMDC_HDDA1(x)	(x << 7)
-#define SHIM_HMDC_HDDA_E0_CH0	1
-#define SHIM_HMDC_HDDA_E0_CH1	2
-#define SHIM_HMDC_HDDA_E0_CH2	4
-#define SHIM_HMDC_HDDA_E0_CH3	8
-#define SHIM_HMDC_HDDA_E1_CH0	SHIM_HMDC_HDDA1(SHIM_HMDC_HDDA_E0_CH0)
-#define SHIM_HMDC_HDDA_E1_CH1	SHIM_HMDC_HDDA1(SHIM_HMDC_HDDA_E0_CH1)
-#define SHIM_HMDC_HDDA_E1_CH2	SHIM_HMDC_HDDA1(SHIM_HMDC_HDDA_E0_CH2)
-#define SHIM_HMDC_HDDA_E1_CH3	SHIM_HMDC_HDDA1(SHIM_HMDC_HDDA_E0_CH3)
-#define SHIM_HMDC_HDDA_E0_ALLCH	\
-	(SHIM_HMDC_HDDA_E0_CH0 | SHIM_HMDC_HDDA_E0_CH1 | \
-	 SHIM_HMDC_HDDA_E0_CH2 | SHIM_HMDC_HDDA_E0_CH3)
-#define SHIM_HMDC_HDDA_E1_ALLCH	\
-	(SHIM_HMDC_HDDA_E1_CH0 | SHIM_HMDC_HDDA_E1_CH1 | \
-	 SHIM_HMDC_HDDA_E1_CH2 | SHIM_HMDC_HDDA_E1_CH3)
-
-/* Audio DSP PCI registers */
-#define PCI_VDRTCTL0		0xa0
-#define PCI_VDRTCTL1		0xa4
-#define PCI_VDRTCTL2		0xa8
-#define PCI_VDRTCTL3		0xaC
-
-/* VDRTCTL0 */
-#define PCI_VDRTCL0_D3PGD		BIT(0)
-#define PCI_VDRTCL0_D3SRAMPGD		BIT(1)
-#define PCI_VDRTCL0_DSRAMPGE_SHIFT	12
-#define PCI_VDRTCL0_DSRAMPGE_MASK	(0xfffff << PCI_VDRTCL0_DSRAMPGE_SHIFT)
-#define PCI_VDRTCL0_ISRAMPGE_SHIFT	2
-#define PCI_VDRTCL0_ISRAMPGE_MASK	(0x3ff << PCI_VDRTCL0_ISRAMPGE_SHIFT)
-
-/* VDRTCTL2 */
-#define PCI_VDRTCL2_DCLCGE		BIT(1)
-#define PCI_VDRTCL2_DTCGE		BIT(10)
-#define PCI_VDRTCL2_APLLSE_MASK		BIT(31)
-
-/* PMCS */
-#define PCI_PMCS		0x84
-#define PCI_PMCS_PS_MASK	0x3
-
-/* PCI registers */
-#define PCI_TCSEL			0x44
-#define PCI_CGCTL			0x48
-
-/* PCI_CGCTL bits */
-#define PCI_CGCTL_MISCBDCGE_MASK	BIT(6)
-
-/* Legacy HDA registers and bits used - widths are variable */
-#define SOF_HDA_GCAP			0x0
-#define SOF_HDA_GCTL			0x8
-/* accept unsol. response enable */
-#define SOF_HDA_GCTL_UNSOL		BIT(8)
-#define SOF_HDA_LLCH			0x14
-#define SOF_HDA_INTCTL			0x20
-#define SOF_HDA_INTSTS			0x24
-#define SOF_HDA_WAKESTS			0x0E
-#define SOF_HDA_WAKESTS_INT_MASK	((1 << 8) - 1)
-
-/* SOF_HDA_GCTL register bist */
-#define SOF_HDA_GCTL_RESET		BIT(0)
-
-/* SOF_HDA_INCTL and SOF_HDA_INTSTS regs */
-#define SOF_HDA_INT_GLOBAL_EN		BIT(31)
-#define SOF_HDA_INT_CTRL_EN		BIT(30)
-#define SOF_HDA_INT_ALL_STREAM		0xff
-
-#define SOF_HDA_MAX_CAPS		10
-#define SOF_HDA_CAP_ID_OFF		16
-#define SOF_HDA_CAP_ID_MASK		(0xFFF << SOF_HDA_CAP_ID_OFF)
-#define SOF_HDA_CAP_NEXT_MASK		0xFFFF
-
-#define SOF_HDA_PP_CAP_ID		0x3
-#define SOF_HDA_REG_PP_PPCH		0x10
-#define SOF_HDA_REG_PP_PPCTL		0x04
-#define SOF_HDA_PPCTL_PIE		BIT(31)
-#define SOF_HDA_PPCTL_GPROCEN		BIT(30)
-
-#define SOF_HDA_SPIB_CAP_ID		0x4
-#define SOF_HDA_DRSM_CAP_ID		0x5
-
-#define SOF_HDA_SPIB_BASE		0x08
-#define SOF_HDA_SPIB_INTERVAL		0x08
-#define SOF_HDA_SPIB_SPIB		0x00
-#define SOF_HDA_SPIB_MAXFIFO		0x04
-
-#define SOF_HDA_PPHC_BASE		0x10
-#define SOF_HDA_PPHC_INTERVAL		0x10
-
-#define SOF_HDA_PPLC_BASE		0x10
-#define SOF_HDA_PPLC_MULTI		0x10
-#define SOF_HDA_PPLC_INTERVAL		0x10
-
-#define SOF_HDA_DRSM_BASE		0x08
-#define SOF_HDA_DRSM_INTERVAL		0x08
-
-/* Descriptor error interrupt */
-#define SOF_HDA_CL_DMA_SD_INT_DESC_ERR		0x10
-
-/* FIFO error interrupt */
-#define SOF_HDA_CL_DMA_SD_INT_FIFO_ERR		0x08
-
-/* Buffer completion interrupt */
-#define SOF_HDA_CL_DMA_SD_INT_COMPLETE		0x04
-
-#define SOF_HDA_CL_DMA_SD_INT_MASK \
-	(SOF_HDA_CL_DMA_SD_INT_DESC_ERR | \
-	SOF_HDA_CL_DMA_SD_INT_FIFO_ERR | \
-	SOF_HDA_CL_DMA_SD_INT_COMPLETE)
-#define SOF_HDA_SD_CTL_DMA_START		0x02 /* Stream DMA start bit */
-
-/* Intel HD Audio Code Loader DMA Registers */
-#define SOF_HDA_ADSP_LOADER_BASE		0x80
-#define SOF_HDA_ADSP_DPLBASE			0x70
-#define SOF_HDA_ADSP_DPUBASE			0x74
-#define SOF_HDA_ADSP_DPLBASE_ENABLE		0x01
-
-/* Stream Registers */
-#define SOF_HDA_ADSP_REG_CL_SD_CTL		0x00
-#define SOF_HDA_ADSP_REG_CL_SD_STS		0x03
-#define SOF_HDA_ADSP_REG_CL_SD_LPIB		0x04
-#define SOF_HDA_ADSP_REG_CL_SD_CBL		0x08
-#define SOF_HDA_ADSP_REG_CL_SD_LVI		0x0C
-#define SOF_HDA_ADSP_REG_CL_SD_FIFOW		0x0E
-#define SOF_HDA_ADSP_REG_CL_SD_FIFOSIZE		0x10
-#define SOF_HDA_ADSP_REG_CL_SD_FORMAT		0x12
-#define SOF_HDA_ADSP_REG_CL_SD_FIFOL		0x14
-#define SOF_HDA_ADSP_REG_CL_SD_BDLPL		0x18
-#define SOF_HDA_ADSP_REG_CL_SD_BDLPU		0x1C
-
-/* CL: Software Position Based FIFO Capability Registers */
-#define SOF_DSP_REG_CL_SPBFIFO \
-	(SOF_HDA_ADSP_LOADER_BASE + 0x20)
-#define SOF_HDA_ADSP_REG_CL_SPBFIFO_SPBFCH	0x0
-#define SOF_HDA_ADSP_REG_CL_SPBFIFO_SPBFCCTL	0x4
-#define SOF_HDA_ADSP_REG_CL_SPBFIFO_SPIB	0x8
-#define SOF_HDA_ADSP_REG_CL_SPBFIFO_MAXFIFOS	0xc
-
-/* Stream Number */
-#define SOF_HDA_CL_SD_CTL_STREAM_TAG_SHIFT	20
-#define SOF_HDA_CL_SD_CTL_STREAM_TAG_MASK \
-	(0xf << SOF_HDA_CL_SD_CTL_STREAM_TAG_SHIFT)
-
-enum skl_cl_dma_wake_states {
-	APL_CL_DMA_STATUS_NONE = 0,
-	APL_CL_DMA_BUF_COMPLETE,
-	APL_CL_DMA_ERR,	/* TODO: Expand the error states */
-};
-
-struct stream_sample_format {
-	u32 sample_rate;
-	u8 code;
-};
-
-static struct stream_sample_format sample_format[] = {
-	{8000, 0x5},
-	{9600, 0x4},
-	{11025, 0x43},
-	{16000, 0x2},
-	{22050, 0x41},
-	{24000, 0x1},
-	{32000, 0xa},
-	{44100, 0x40},
-	{48000, 0x0},
-	{88200, 0x48},
-	{96000, 0x8},
-	{144000, 0x10},
-	{176400, 0x58},
-	{192000, 0x18},
-};
-
-static inline uint8_t get_sample_code(uint32_t sample_rate)
-{
-	int i;
-
-	for (i = 0; i < sizeof(sample_format)
-		/ sizeof(struct stream_sample_format); i++) {
-		if (sample_format[i].sample_rate == sample_rate)
-			return sample_format[i].code;
-	}
-
-	return 0; /* use 48KHz if not found */
-}
-
-struct stream_bits_format {
-	u32 bits;
-	u8 code;
-};
-
-static struct stream_bits_format bits_format[] = {
-	{8, 0x0},
-	{16, 0x1},
-	{20, 0x2},
-	{24, 0x3},
-	{32, 0x4},
-};
-
-/* get code for BITS(Bits per Sample) */
-static inline uint8_t get_bits_code(uint32_t bits)
-{
-	int i;
-
-	for (i = 0; i < sizeof(bits_format)
-		/ sizeof(struct stream_bits_format); i++) {
-		if (bits_format[i].bits == bits)
-			return bits_format[i].code;
-	}
-
-	return 1; /* use 16bits format if not found */
-}
-
-#endif
diff --git a/sound/soc/sof/ipc.c b/sound/soc/sof/ipc.c
deleted file mode 100644
index 60287e3..0000000
--- a/sound/soc/sof/ipc.c
+++ /dev/null
@@ -1,605 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/list.h>
-#include <linux/device.h>
-#include <linux/wait.h>
-#include <linux/spinlock.h>
-#include <linux/workqueue.h>
-#include <linux/export.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/sched.h>
-#include <linux/platform_device.h>
-#include <linux/kthread.h>
-#include <linux/firmware.h>
-#include <linux/dma-mapping.h>
-#include <linux/debugfs.h>
-#include <linux/pm_runtime.h>
-#include <sound/asound.h>
-#include <sound/sof.h>
-#include <uapi/sound/sof-ipc.h>
-#include "sof-priv.h"
-#include "ops.h"
-
-/* IPC message timeout (msecs) */
-#define IPC_TIMEOUT_MSECS	300
-
-#define IPC_EMPTY_LIST_SIZE	8
-
-/* SOF generic IPC data */
-struct snd_sof_ipc {
-	struct snd_sof_dev *sdev;
-
-	/* TX message work and status */
-	wait_queue_head_t wait_txq;
-	struct work_struct tx_kwork;
-	bool msg_pending;
-
-	/* Rx Message work and status */
-	struct work_struct rx_kwork;
-
-	/* lists */
-	struct list_head tx_list;
-	struct list_head reply_list;
-	struct list_head empty_list;
-};
-
-/* locks held by caller */
-static struct snd_sof_ipc_msg *msg_get_empty(struct snd_sof_ipc *ipc)
-{
-	struct snd_sof_ipc_msg *msg = NULL;
-
-	if (!list_empty(&ipc->empty_list)) {
-		msg = list_first_entry(&ipc->empty_list, struct snd_sof_ipc_msg,
-				       list);
-		list_del(&msg->list);
-	}
-
-	return msg;
-}
-
-static int tx_wait_done(struct snd_sof_ipc *ipc, struct snd_sof_ipc_msg *msg,
-			void *reply_data)
-{
-	struct snd_sof_dev *sdev = ipc->sdev;
-	struct sof_ipc_hdr *hdr = (struct sof_ipc_hdr *)msg->msg_data;
-	unsigned long flags;
-	int ret;
-
-	/* wait for DSP IPC completion */
-	ret = wait_event_timeout(msg->waitq, msg->complete,
-				 msecs_to_jiffies(IPC_TIMEOUT_MSECS));
-
-	spin_lock_irqsave(&sdev->ipc_lock, flags);
-
-	if (ret == 0) {
-		dev_err(sdev->dev, "error: ipc timed out for 0x%x size 0x%x\n",
-			hdr->cmd, hdr->size);
-		snd_sof_dsp_dbg_dump(ipc->sdev, SOF_DBG_REGS | SOF_DBG_MBOX);
-		snd_sof_trace_notify_for_error(ipc->sdev);
-		ret = -ETIMEDOUT;
-	} else {
-		/* copy the data returned from DSP */
-		ret = snd_sof_dsp_get_reply(sdev, msg);
-		if (msg->reply_size)
-			memcpy(reply_data, msg->reply_data, msg->reply_size);
-		if (ret < 0)
-			dev_err(sdev->dev, "error: ipc error for 0x%x size 0x%lx\n",
-				hdr->cmd, msg->reply_size);
-		else
-			dev_dbg(sdev->dev, "ipc: 0x%x succeeded\n", hdr->cmd);
-	}
-
-	/* return message body to empty list */
-	list_move(&msg->list, &ipc->empty_list);
-
-	spin_unlock_irqrestore(&sdev->ipc_lock, flags);
-	return ret;
-}
-
-int sof_ipc_tx_message(struct snd_sof_ipc *ipc, u32 header,
-		       void *msg_data, size_t msg_bytes, void *reply_data,
-		       size_t reply_bytes)
-{
-	struct snd_sof_dev *sdev = ipc->sdev;
-	struct snd_sof_ipc_msg *msg;
-	unsigned long flags;
-
-	spin_lock_irqsave(&sdev->ipc_lock, flags);
-
-	msg = msg_get_empty(ipc);
-	if (!msg) {
-		spin_unlock_irqrestore(&sdev->ipc_lock, flags);
-		return -EBUSY;
-	}
-
-	msg->header = header;
-	msg->msg_size = msg_bytes;
-	msg->reply_size = reply_bytes;
-	msg->complete = false;
-
-	if (msg_bytes)
-		memcpy(msg->msg_data, msg_data, msg_bytes);
-
-	list_add_tail(&msg->list, &ipc->tx_list);
-
-	/* schedule the messgae if not busy */
-	if (snd_sof_dsp_is_ready(sdev))
-		schedule_work(&ipc->tx_kwork);
-
-	spin_unlock_irqrestore(&sdev->ipc_lock, flags);
-
-	return tx_wait_done(ipc, msg, reply_data);
-}
-EXPORT_SYMBOL(sof_ipc_tx_message);
-
-static void ipc_tx_next_msg(struct work_struct *work)
-{
-	struct snd_sof_ipc *ipc =
-		container_of(work, struct snd_sof_ipc, tx_kwork);
-	struct snd_sof_dev *sdev = ipc->sdev;
-	struct snd_sof_ipc_msg *msg;
-
-	spin_lock_irq(&sdev->ipc_lock);
-
-	if (list_empty(&ipc->tx_list))
-		goto out;
-
-	msg = list_first_entry(&ipc->tx_list, struct snd_sof_ipc_msg, list);
-	list_move(&msg->list, &ipc->reply_list);
-
-	snd_sof_dsp_send_msg(sdev, msg);
-	dev_dbg(sdev->dev, "ipc: send 0x%x\n", msg->header);
-
-out:
-	spin_unlock_irq(&sdev->ipc_lock);
-}
-
-struct snd_sof_ipc_msg *sof_ipc_reply_find_msg(struct snd_sof_ipc *ipc,
-					       u32 header)
-{
-	struct snd_sof_dev *sdev = ipc->sdev;
-	struct snd_sof_ipc_msg *msg;
-
-	header = SOF_IPC_MESSAGE_ID(header);
-
-	if (list_empty(&ipc->reply_list))
-		goto err;
-
-	list_for_each_entry(msg, &ipc->reply_list, list) {
-		if (SOF_IPC_MESSAGE_ID(msg->header) == header)
-			return msg;
-	}
-
-err:
-	dev_err(sdev->dev, "error: rx list empty but received 0x%x\n",
-		header);
-	return NULL;
-}
-EXPORT_SYMBOL(sof_ipc_reply_find_msg);
-
-/* locks held by caller */
-void sof_ipc_tx_msg_reply_complete(struct snd_sof_ipc *ipc,
-				   struct snd_sof_ipc_msg *msg)
-{
-	msg->complete = true;
-	wake_up(&msg->waitq);
-}
-
-void sof_ipc_drop_all(struct snd_sof_ipc *ipc)
-{
-	struct snd_sof_dev *sdev = ipc->sdev;
-	struct snd_sof_ipc_msg *msg, *tmp;
-	unsigned long flags;
-
-	/* drop all TX and Rx messages before we stall + reset DSP */
-	spin_lock_irqsave(&sdev->ipc_lock, flags);
-
-	list_for_each_entry_safe(msg, tmp, &ipc->tx_list, list) {
-		list_move(&msg->list, &ipc->empty_list);
-		dev_err(sdev->dev, "error: dropped msg %d\n", msg->header);
-	}
-
-	list_for_each_entry_safe(msg, tmp, &ipc->reply_list, list) {
-		list_move(&msg->list, &ipc->empty_list);
-		dev_err(sdev->dev, "error: dropped reply %d\n", msg->header);
-	}
-
-	spin_unlock_irqrestore(&sdev->ipc_lock, flags);
-}
-EXPORT_SYMBOL(sof_ipc_drop_all);
-
-void snd_sof_ipc_reply(struct snd_sof_dev *sdev, u32 msg_id)
-{
-	struct snd_sof_ipc_msg *msg;
-
-	msg = sof_ipc_reply_find_msg(sdev->ipc, msg_id);
-	if (!msg) {
-		dev_err(sdev->dev, "error: can't find message header 0x%x",
-			msg_id);
-		return;
-	}
-
-	/* wake up and return the error if we have waiters on this message ? */
-	sof_ipc_tx_msg_reply_complete(sdev->ipc, msg);
-}
-EXPORT_SYMBOL(snd_sof_ipc_reply);
-
-int snd_sof_dsp_mailbox_init(struct snd_sof_dev *sdev, u32 dspbox,
-			     size_t dspbox_size, u32 hostbox,
-			     size_t hostbox_size)
-{
-	sdev->dsp_box.offset = dspbox;
-	sdev->dsp_box.size = dspbox_size;
-	sdev->host_box.offset = hostbox;
-	sdev->host_box.size = hostbox_size;
-	return 0;
-}
-EXPORT_SYMBOL(snd_sof_dsp_mailbox_init);
-
-static void ipc_period_elapsed(struct snd_sof_dev *sdev, u32 msg_id)
-{
-	struct sof_ipc_stream_posn posn;
-	struct snd_sof_pcm *spcm;
-	u32 posn_offset;
-	int direction;
-
-	/* check if we have stream box */
-	if (sdev->stream_box.size == 0) {
-		/* read back full message */
-		snd_sof_dsp_mailbox_read(sdev, sdev->dsp_box.offset, &posn,
-					 sizeof(posn));
-
-		spcm = snd_sof_find_spcm_comp(sdev, posn.comp_id, &direction);
-	} else {
-		spcm = snd_sof_find_spcm_comp(sdev, msg_id, &direction);
-	}
-
-	if (!spcm) {
-		dev_err(sdev->dev,
-			"period elapsed for unknown stream, msg_id %d\n",
-			msg_id);
-		return;
-	}
-
-	/* have stream box read from stream box */
-	if (sdev->stream_box.size != 0) {
-		posn_offset = spcm->posn_offset[direction];
-		snd_sof_dsp_mailbox_read(sdev, posn_offset, &posn,
-					 sizeof(posn));
-
-		dev_dbg(sdev->dev, "posn mailbox: posn offset is 0x%x",
-			posn_offset);
-	}
-
-	dev_dbg(sdev->dev, "posn : host 0x%llx dai 0x%llx wall 0x%llx\n",
-		posn.host_posn, posn.dai_posn, posn.wallclock);
-
-	memcpy(&spcm->stream[direction].posn, &posn, sizeof(posn));
-	snd_pcm_period_elapsed(spcm->stream[direction].substream);
-}
-
-static void ipc_xrun(struct snd_sof_dev *sdev, u32 msg_id)
-{
-	struct sof_ipc_stream_posn posn;
-	struct snd_sof_pcm *spcm;
-	u32 posn_offset;
-	int direction;
-
-	/* check if we have stream box */
-	if (sdev->stream_box.size == 0) {
-		/* read back full message */
-		snd_sof_dsp_mailbox_read(sdev, sdev->dsp_box.offset, &posn,
-					 sizeof(posn));
-
-		spcm = snd_sof_find_spcm_comp(sdev, posn.comp_id, &direction);
-	} else {
-		spcm = snd_sof_find_spcm_comp(sdev, msg_id, &direction);
-	}
-
-	if (!spcm) {
-		dev_err(sdev->dev, "XRUN for unknown stream, msg_id %d\n",
-			msg_id);
-		return;
-	}
-
-	/* have stream box read from stream box */
-	if (sdev->stream_box.size != 0) {
-		posn_offset = spcm->posn_offset[direction];
-		snd_sof_dsp_mailbox_read(sdev, posn_offset, &posn,
-					 sizeof(posn));
-
-		dev_dbg(sdev->dev, "posn mailbox: posn offset is 0x%x",
-			posn_offset);
-	}
-
-	dev_dbg(sdev->dev,  "posn XRUN: host %llx comp %d size %d\n",
-		posn.host_posn, posn.xrun_comp_id, posn.xrun_size);
-
-	return; /* TODO: don't do anything yet until preload is working */
-
-	memcpy(&spcm->stream[direction].posn, &posn, sizeof(posn));
-	snd_pcm_stop_xrun(spcm->stream[direction].substream);
-}
-
-static void ipc_stream_message(struct snd_sof_dev *sdev, u32 msg_cmd)
-{
-	/* get msg cmd type and msd id */
-	u32 msg_type = msg_cmd & SOF_CMD_TYPE_MASK;
-	u32 msg_id = SOF_IPC_MESSAGE_ID(msg_cmd);
-
-	switch (msg_type) {
-	case SOF_IPC_STREAM_POSITION:
-		ipc_period_elapsed(sdev, msg_id);
-		break;
-	case SOF_IPC_STREAM_TRIG_XRUN:
-		ipc_xrun(sdev, msg_id);
-		break;
-	default:
-		dev_err(sdev->dev, "error: unhandled stream message %x\n",
-			msg_id);
-		break;
-	}
-}
-
-static void ipc_trace_message(struct snd_sof_dev *sdev, u32 msg_id)
-{
-	struct sof_ipc_dma_trace_posn posn;
-
-	switch (msg_id) {
-	case SOF_IPC_TRACE_DMA_POSITION:
-		/* read back full message */
-		snd_sof_dsp_mailbox_read(sdev, sdev->dsp_box.offset, &posn,
-					 sizeof(posn));
-		snd_sof_trace_update_pos(sdev, &posn);
-		break;
-	default:
-		dev_err(sdev->dev, "error: unhandled trace message %x\n",
-			msg_id);
-		break;
-	}
-}
-
-/* DSP firmware has sent host a message  */
-static void ipc_msgs_rx(struct work_struct *work)
-{
-	struct snd_sof_ipc *ipc =
-		container_of(work, struct snd_sof_ipc, rx_kwork);
-	struct snd_sof_dev *sdev = ipc->sdev;
-	struct sof_ipc_hdr hdr;
-	u32 cmd, type;
-	int err = -EINVAL;
-
-	/* read back header */
-	snd_sof_dsp_mailbox_read(sdev, sdev->dsp_box.offset, &hdr, sizeof(hdr));
-
-	cmd = hdr.cmd & SOF_GLB_TYPE_MASK;
-	type = hdr.cmd & SOF_CMD_TYPE_MASK;
-
-	switch (cmd) {
-	case SOF_IPC_GLB_REPLY:
-		dev_err(sdev->dev, "error: ipc reply unknown\n");
-		break;
-	case SOF_IPC_FW_READY:
-		/* check for FW boot completion */
-		if (!sdev->boot_complete) {
-			if (sdev->ops->fw_ready)
-				err = sdev->ops->fw_ready(sdev, cmd);
-			if (err < 0) {
-				dev_err(sdev->dev, "DSP firmware boot timeout %d\n",
-					err);
-			} else {
-				/* firmware boot completed OK */
-				sdev->boot_complete = true;
-				dev_dbg(sdev->dev, "booting DSP firmware completed\n");
-				wake_up(&sdev->boot_wait);
-			}
-		}
-		break;
-	case SOF_IPC_GLB_COMPOUND:
-	case SOF_IPC_GLB_TPLG_MSG:
-	case SOF_IPC_GLB_PM_MSG:
-	case SOF_IPC_GLB_COMP_MSG:
-		break;
-	case SOF_IPC_GLB_STREAM_MSG:
-		/* need to pass msg id into the function */
-		ipc_stream_message(sdev, hdr.cmd);
-		break;
-	case SOF_IPC_GLB_TRACE_MSG:
-		ipc_trace_message(sdev, type);
-		break;
-	default:
-		dev_err(sdev->dev, "unknown DSP message 0x%x\n", cmd);
-		break;
-	}
-
-	dev_dbg(sdev->dev, "ipc rx: 0x%x done\n", hdr.cmd);
-
-	snd_sof_dsp_cmd_done(sdev);
-}
-
-void snd_sof_ipc_msgs_tx(struct snd_sof_dev *sdev)
-{
-	schedule_work(&sdev->ipc->tx_kwork);
-}
-EXPORT_SYMBOL(snd_sof_ipc_msgs_tx);
-
-void snd_sof_ipc_msgs_rx(struct snd_sof_dev *sdev)
-{
-	schedule_work(&sdev->ipc->rx_kwork);
-}
-EXPORT_SYMBOL(snd_sof_ipc_msgs_rx);
-
-struct snd_sof_ipc *snd_sof_ipc_init(struct snd_sof_dev *sdev)
-{
-	struct snd_sof_ipc *ipc;
-	struct snd_sof_ipc_msg *msg;
-	int i;
-
-	ipc = devm_kzalloc(sdev->dev, sizeof(*ipc), GFP_KERNEL);
-	if (!ipc)
-		return NULL;
-
-	INIT_LIST_HEAD(&ipc->tx_list);
-	INIT_LIST_HEAD(&ipc->reply_list);
-	INIT_LIST_HEAD(&ipc->empty_list);
-	init_waitqueue_head(&ipc->wait_txq);
-	INIT_WORK(&ipc->tx_kwork, ipc_tx_next_msg);
-	INIT_WORK(&ipc->rx_kwork, ipc_msgs_rx);
-	ipc->sdev = sdev;
-
-	/* pre-allocate messages */
-	dev_dbg(sdev->dev, "pre-allocate %d IPC messages\n",
-		IPC_EMPTY_LIST_SIZE);
-	msg = devm_kzalloc(sdev->dev, sizeof(struct snd_sof_ipc_msg) *
-			   IPC_EMPTY_LIST_SIZE, GFP_KERNEL);
-	if (!msg)
-		return NULL;
-
-	/* pre-allocate message data */
-	for (i = 0; i < IPC_EMPTY_LIST_SIZE; i++) {
-		msg->msg_data = devm_kzalloc(sdev->dev, PAGE_SIZE, GFP_KERNEL);
-		if (!msg->msg_data)
-			return NULL;
-
-		msg->reply_data = devm_kzalloc(sdev->dev, PAGE_SIZE,
-					       GFP_KERNEL);
-		if (!msg->reply_data)
-			return NULL;
-
-		init_waitqueue_head(&msg->waitq);
-		list_add(&msg->list, &ipc->empty_list);
-		msg++;
-	}
-
-	return ipc;
-}
-EXPORT_SYMBOL(snd_sof_ipc_init);
-
-void snd_sof_ipc_free(struct snd_sof_dev *sdev)
-{
-	/* TODO: send IPC to prepare DSP for shutdown */
-	cancel_work_sync(&sdev->ipc->tx_kwork);
-	cancel_work_sync(&sdev->ipc->rx_kwork);
-}
-EXPORT_SYMBOL(snd_sof_ipc_free);
-
-int snd_sof_ipc_stream_posn(struct snd_sof_dev *sdev,
-			    struct snd_sof_pcm *spcm, int direction,
-			    struct sof_ipc_stream_posn *posn)
-{
-	struct sof_ipc_stream stream;
-	int err;
-
-	/* read position via slower IPC */
-	stream.hdr.size = sizeof(stream);
-	stream.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | SOF_IPC_STREAM_POSITION;
-	stream.comp_id = spcm->stream[direction].comp_id;
-
-	/* send IPC to the DSP */
-	err = sof_ipc_tx_message(sdev->ipc,
-				 stream.hdr.cmd, &stream, sizeof(stream), &posn,
-				 sizeof(*posn));
-	if (err < 0) {
-		dev_err(sdev->dev, "error: failed to get stream %d position\n",
-			stream.comp_id);
-		return err;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(snd_sof_ipc_stream_posn);
-
-int snd_sof_ipc_set_comp_data(struct snd_sof_ipc *ipc,
-			      struct snd_sof_control *scontrol, u32 ipc_cmd,
-			      enum sof_ipc_ctrl_type ctrl_type,
-			      enum sof_ipc_ctrl_cmd ctrl_cmd)
-{
-	struct snd_sof_dev *sdev = ipc->sdev;
-	struct sof_ipc_ctrl_data *cdata = scontrol->control_data;
-	int err;
-
-	/* read firmware volume */
-	if (scontrol->readback_offset != 0) {
-		/* we can read value header via mmaped region */
-		snd_sof_dsp_block_write(sdev, scontrol->readback_offset,
-					cdata->chanv,
-					sizeof(struct sof_ipc_ctrl_value_chan) *
-					cdata->num_elems);
-
-	} else {
-		/* write value via slower IPC */
-		cdata->rhdr.hdr.cmd = SOF_IPC_GLB_COMP_MSG | ipc_cmd;
-		cdata->cmd = ctrl_cmd;
-		cdata->type = ctrl_type;
-		cdata->rhdr.hdr.size = scontrol->size;
-		cdata->comp_id = scontrol->comp_id;
-		cdata->num_elems = scontrol->num_channels;
-
-		/* send IPC to the DSP */
-		err = sof_ipc_tx_message(sdev->ipc,
-					 cdata->rhdr.hdr.cmd, cdata,
-					 cdata->rhdr.hdr.size,
-					 cdata, cdata->rhdr.hdr.size);
-		if (err < 0) {
-			dev_err(sdev->dev, "error: failed to set control %d values\n",
-				cdata->comp_id);
-			return err;
-		}
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(snd_sof_ipc_set_comp_data);
-
-int snd_sof_ipc_get_comp_data(struct snd_sof_ipc *ipc,
-			      struct snd_sof_control *scontrol, u32 ipc_cmd,
-			      enum sof_ipc_ctrl_type ctrl_type,
-			      enum sof_ipc_ctrl_cmd ctrl_cmd)
-{
-	struct snd_sof_dev *sdev = ipc->sdev;
-	struct sof_ipc_ctrl_data *cdata = scontrol->control_data;
-	int err;
-
-	/* read firmware byte counters */
-	if (scontrol->readback_offset != 0) {
-		/* we can read values via mmaped region */
-		snd_sof_dsp_block_read(sdev, scontrol->readback_offset,
-				       cdata->chanv,
-				       sizeof(struct sof_ipc_ctrl_value_chan) *
-				       cdata->num_elems);
-
-	} else {
-		/* read position via slower IPC */
-		cdata->rhdr.hdr.cmd = SOF_IPC_GLB_COMP_MSG | ipc_cmd;
-		cdata->cmd = ctrl_cmd;
-		cdata->type = ctrl_type;
-		cdata->rhdr.hdr.size = scontrol->size;
-		cdata->comp_id = scontrol->comp_id;
-		cdata->num_elems = scontrol->num_channels;
-
-		/* send IPC to the DSP */
-		err = sof_ipc_tx_message(sdev->ipc,
-					 cdata->rhdr.hdr.cmd, cdata,
-					 cdata->rhdr.hdr.size,
-					 cdata, cdata->rhdr.hdr.size);
-		if (err < 0) {
-			dev_err(sdev->dev, "error: failed to get control %d values\n",
-				cdata->comp_id);
-			return err;
-		}
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(snd_sof_ipc_get_comp_data);
diff --git a/sound/soc/sof/loader.c b/sound/soc/sof/loader.c
deleted file mode 100644
index 9fa0b94..0000000
--- a/sound/soc/sof/loader.c
+++ /dev/null
@@ -1,283 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-#include <linux/platform_device.h>
-#include <linux/firmware.h>
-#include <uapi/sound/sof-fw.h>
-#include "sof-priv.h"
-#include "ops.h"
-
-static int get_ext_windows(struct snd_sof_dev *sdev,
-			   struct sof_ipc_ext_data_hdr *ext_hdr)
-{
-	struct sof_ipc_window *w = (struct sof_ipc_window *)ext_hdr;
-
-	int ret = 0;
-	size_t size;
-
-	if (w->num_windows == 0 || w->num_windows > SOF_IPC_MAX_ELEMS)
-		return -EINVAL;
-
-	size = sizeof(*w) + sizeof(struct sof_ipc_window_elem) * w->num_windows;
-
-	/* keep a local copy of the data */
-	sdev->info_window = kmemdup(w, size, GFP_KERNEL);
-	if (!sdev->info_window)
-		return -ENOMEM;
-
-	return ret;
-}
-
-int snd_sof_fw_parse_ext_data(struct snd_sof_dev *sdev, u32 offset)
-{
-	struct sof_ipc_ext_data_hdr *ext_hdr;
-	void *ext_data;
-	int ret = 0;
-
-	ext_data = kzalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!ext_data)
-		return -ENOMEM;
-
-	/* get first header */
-	snd_sof_dsp_block_read(sdev, offset, ext_data, sizeof(*ext_hdr));
-	ext_hdr = (struct sof_ipc_ext_data_hdr *)ext_data;
-
-	while (ext_hdr->hdr.cmd == SOF_IPC_FW_READY) {
-		/* read in ext structure */
-		offset += sizeof(*ext_hdr);
-		snd_sof_dsp_block_read(sdev, offset,
-				       ext_data + sizeof(*ext_hdr),
-				       ext_hdr->hdr.size - sizeof(*ext_hdr));
-
-		dev_dbg(sdev->dev, "found ext header type %d size 0x%x\n",
-			ext_hdr->type, ext_hdr->hdr.size);
-
-		/* process structure data */
-		switch (ext_hdr->type) {
-		case SOF_IPC_EXT_DMA_BUFFER:
-			break;
-		case SOF_IPC_EXT_WINDOW:
-			ret = get_ext_windows(sdev, ext_hdr);
-			break;
-		default:
-			break;
-		}
-
-		if (ret < 0) {
-			dev_err(sdev->dev, "error: failed to parse ext data type %d\n",
-				ext_hdr->type);
-		}
-
-		/* move to next header */
-		offset += ext_hdr->hdr.size;
-		snd_sof_dsp_block_read(sdev, offset, ext_data,
-				       sizeof(*ext_hdr));
-		ext_hdr = (struct sof_ipc_ext_data_hdr *)ext_data;
-	}
-
-	kfree(ext_data);
-	return ret;
-}
-EXPORT_SYMBOL(snd_sof_fw_parse_ext_data);
-
-/* generic module parser for mmaped DSPs */
-int snd_sof_parse_module_memcpy(struct snd_sof_dev *sdev,
-				struct snd_sof_mod_hdr *module)
-{
-	struct snd_sof_blk_hdr *block;
-	int count;
-	u32 offset;
-
-	dev_dbg(sdev->dev, "new module size 0x%x blocks 0x%x type 0x%x\n",
-		module->size, module->num_blocks, module->type);
-
-	block = (void *)module + sizeof(*module);
-
-	for (count = 0; count < module->num_blocks; count++) {
-		if (block->size == 0) {
-			dev_warn(sdev->dev,
-				 "warning: block %d size zero\n", count);
-			dev_warn(sdev->dev, " type 0x%x offset 0x%x\n",
-				 block->type, block->offset);
-			continue;
-		}
-
-		switch (block->type) {
-		case SOF_BLK_IMAGE:
-		case SOF_BLK_CACHE:
-		case SOF_BLK_REGS:
-		case SOF_BLK_SIG:
-		case SOF_BLK_ROM:
-			continue;	/* not handled atm */
-		case SOF_BLK_TEXT:
-		case SOF_BLK_DATA:
-			offset = block->offset;
-			break;
-		default:
-			dev_err(sdev->dev, "error: bad type 0x%x for block 0x%x\n",
-				block->type, count);
-			return -EINVAL;
-		}
-
-		dev_dbg(sdev->dev,
-			"block %d type 0x%x size 0x%x ==>  offset 0x%x\n",
-			count, block->type, block->size, offset);
-
-		snd_sof_dsp_block_write(sdev, offset,
-					(void *)block + sizeof(*block),
-					block->size);
-
-		/* next block */
-		block = (void *)block + sizeof(*block) + block->size;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(snd_sof_parse_module_memcpy);
-
-static int check_header(struct snd_sof_dev *sdev, const struct firmware *fw)
-{
-	struct snd_sof_fw_header *header;
-
-	/* Read the header information from the data pointer */
-	header = (struct snd_sof_fw_header *)fw->data;
-
-	/* verify FW sig */
-	if (strncmp(header->sig, SND_SOF_FW_SIG, SND_SOF_FW_SIG_SIZE) != 0) {
-		dev_err(sdev->dev, "error: invalid firmware signature\n");
-		return -EINVAL;
-	}
-
-	/* check size is valid */
-	if (fw->size != header->file_size + sizeof(*header)) {
-		dev_err(sdev->dev, "error: invalid filesize mismatch got 0x%lx expected 0x%lx\n",
-			fw->size, header->file_size + sizeof(*header));
-		return -EINVAL;
-	}
-
-	dev_dbg(sdev->dev, "header size=0x%x modules=0x%x abi=0x%x size=%zu\n",
-		header->file_size, header->num_modules,
-		header->abi, sizeof(*header));
-
-	return 0;
-}
-
-static int load_modules(struct snd_sof_dev *sdev, const struct firmware *fw)
-{
-	struct snd_sof_fw_header *header;
-	struct snd_sof_mod_hdr *module;
-	int (*load_module)(struct snd_sof_dev *sof_dev,
-			   struct snd_sof_mod_hdr *hdr);
-	int ret, count;
-
-	header = (struct snd_sof_fw_header *)fw->data;
-	load_module = sdev->ops->load_module;
-	if (!load_module)
-		return -EINVAL;
-
-	/* parse each module */
-	module = (void *)fw->data + sizeof(*header);
-	for (count = 0; count < header->num_modules; count++) {
-		/* module */
-		ret = load_module(sdev, module);
-		if (ret < 0) {
-			dev_err(sdev->dev, "error: invalid module %d\n", count);
-			return ret;
-		}
-		module = (void *)module + sizeof(*module) + module->size;
-	}
-
-	return 0;
-}
-
-int snd_sof_load_firmware_memcpy(struct snd_sof_dev *sdev,
-				 const struct firmware *fw)
-{
-	int ret;
-
-	/* make sure the FW header and file is valid */
-	ret = check_header(sdev, fw);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: invalid FW header\n");
-		return ret;
-	}
-
-	/* prepare the DSP for FW loading */
-	ret = snd_sof_dsp_reset(sdev);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to reset DSP\n");
-		return ret;
-	}
-
-	/* parse and load firmware modules to DSP */
-	ret = load_modules(sdev, fw);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: invalid FW modules\n");
-		return ret;
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL(snd_sof_load_firmware_memcpy);
-
-int snd_sof_load_firmware(struct snd_sof_dev *sdev,
-			  const struct firmware *fw)
-{
-	dev_dbg(sdev->dev, "loading firmware\n");
-
-	if (sdev->ops->load_firmware)
-		return sdev->ops->load_firmware(sdev, fw);
-	return 0;
-}
-EXPORT_SYMBOL(snd_sof_load_firmware);
-
-int snd_sof_run_firmware(struct snd_sof_dev *sdev)
-{
-	int ret;
-
-	init_waitqueue_head(&sdev->boot_wait);
-	sdev->boot_complete = false;
-
-	dev_dbg(sdev->dev, "booting DSP firmware\n");
-
-	/* boot the firmware on the DSP */
-	ret = snd_sof_dsp_run(sdev);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to reset DSP\n");
-		return ret;
-	}
-
-	/* now wait for the DSP to boot */
-	ret = wait_event_timeout(sdev->boot_wait, sdev->boot_complete,
-				 msecs_to_jiffies(sdev->boot_timeout));
-	if (ret == 0) {
-		dev_err(sdev->dev, "error: firmware boot timeout\n");
-		snd_sof_dsp_dbg_dump(sdev, SOF_DBG_REGS | SOF_DBG_MBOX |
-			SOF_DBG_TEXT | SOF_DBG_PCI);
-		return -EIO;
-	}
-
-	dev_info(sdev->dev, "firmware boot complete\n");
-
-	return 0;
-}
-EXPORT_SYMBOL(snd_sof_run_firmware);
-
-void snd_sof_fw_unload(struct snd_sof_dev *sdev)
-{
-}
-EXPORT_SYMBOL(snd_sof_fw_unload);
diff --git a/sound/soc/sof/nocodec.c b/sound/soc/sof/nocodec.c
deleted file mode 100644
index 0685d29..0000000
--- a/sound/soc/sof/nocodec.c
+++ /dev/null
@@ -1,114 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/acpi.h>
-#include <linux/device.h>
-#include <linux/dmi.h>
-#include <linux/slab.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/jack.h>
-#include <sound/sof.h>
-
-int sof_nocodec_setup(struct device *dev,
-		      struct snd_sof_pdata *sof_pdata,
-		      struct snd_soc_acpi_mach *mach,
-		      const struct sof_dev_desc *desc)
-{
-	if (!mach)
-		return -EINVAL;
-
-	sof_pdata->drv_name = "sof-nocodec";
-
-	mach->drv_name = "sof-nocodec";
-	mach->sof_fw_filename = desc->nocodec_fw_filename;
-	mach->sof_tplg_filename = desc->nocodec_tplg_filename;
-
-	return 0;
-}
-EXPORT_SYMBOL(sof_nocodec_setup);
-
-static int sof_nocodec_codec_fixup(struct snd_soc_pcm_runtime *rtd,
-				   struct snd_pcm_hw_params *params)
-{
-	// TODO: read this from topology
-	return 0;
-}
-
-static struct snd_soc_ops sof_nocodec_ops = {};
-
-static int nocodec_rtd_init(struct snd_soc_pcm_runtime *rtd)
-{
-	snd_soc_set_dmi_name(rtd->card, NULL);
-
-	return 0;
-}
-
-/* we just set some BEs - FE provided by topology */
-static struct snd_soc_dai_link sof_nocodec_dais[] = {
-	/* Back End DAI links */
-	{
-		/* SSP0 - Codec */
-		.name = "NoCodec",
-		.id = 0,
-		.init = nocodec_rtd_init,
-		.cpu_dai_name = "sof-audio",
-		.platform_name = "sof-audio",
-		.no_pcm = 1,
-		.codec_dai_name = "snd-soc-dummy-dai",
-		.codec_name = "snd-soc-dummy",
-		.ops = &sof_nocodec_ops,
-		.dai_fmt = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_NB_NF |
-			SND_SOC_DAIFMT_CBS_CFS,
-		.ignore_suspend = 1,
-		.be_hw_params_fixup = sof_nocodec_codec_fixup,
-		.dpcm_playback = 1,
-		.dpcm_capture = 1,
-	},
-};
-
-static struct snd_soc_card sof_nocodec_card = {
-	.name = "sof-nocodec",
-	.dai_link = sof_nocodec_dais,
-	.num_links = ARRAY_SIZE(sof_nocodec_dais),
-};
-
-static int sof_nocodec_probe(struct platform_device *pdev)
-{
-	struct snd_soc_card *card = &sof_nocodec_card;
-
-	card->dev = &pdev->dev;
-
-	return devm_snd_soc_register_card(&pdev->dev, card);
-}
-
-static int sof_nocodec_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static struct platform_driver sof_nocodec_audio = {
-	.probe = sof_nocodec_probe,
-	.remove = sof_nocodec_remove,
-	.driver = {
-		.name = "sof-nocodec",
-		.pm = &snd_soc_pm_ops,
-	},
-};
-module_platform_driver(sof_nocodec_audio)
-
-MODULE_DESCRIPTION("ASoC sof nocodec");
-MODULE_AUTHOR("Liam Girdwood");
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("platform:sof-nocodec");
diff --git a/sound/soc/sof/ops.c b/sound/soc/sof/ops.c
deleted file mode 100644
index 9ac69e8..0000000
--- a/sound/soc/sof/ops.c
+++ /dev/null
@@ -1,190 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/interrupt.h>
-#include <linux/device.h>
-#include <linux/pci.h>
-#include <linux/delay.h>
-#include <uapi/sound/sof-ipc.h>
-#include "ops.h"
-#include "sof-priv.h"
-
-int snd_sof_pci_update_bits_unlocked(struct snd_sof_dev *sdev, u32 offset,
-				     u32 mask, u32 value)
-{
-	bool change;
-	unsigned int old, new;
-	u32 ret;
-
-	pci_read_config_dword(sdev->pci, offset, &ret);
-	dev_dbg(sdev->dev, "Debug PCIR: %8.8x at  %8.8x\n",
-		pci_read_config_dword(sdev->pci, offset, &ret), offset);
-
-	old = ret;
-	new = (old & (~mask)) | (value & mask);
-
-	change = (old != new);
-	if (change) {
-		pci_write_config_dword(sdev->pci, offset, new);
-		dev_dbg(sdev->dev, "Debug PCIW: %8.8x at  %8.8x\n", value,
-			offset);
-	}
-
-	return change;
-}
-EXPORT_SYMBOL(snd_sof_pci_update_bits_unlocked);
-
-int snd_sof_pci_update_bits(struct snd_sof_dev *sdev, u32 offset,
-			    u32 mask, u32 value)
-{
-	unsigned long flags;
-	bool change;
-
-	spin_lock_irqsave(&sdev->hw_lock, flags);
-	change = snd_sof_pci_update_bits_unlocked(sdev, offset, mask, value);
-	spin_unlock_irqrestore(&sdev->hw_lock, flags);
-	return change;
-}
-EXPORT_SYMBOL(snd_sof_pci_update_bits);
-
-int snd_sof_dsp_update_bits_unlocked(struct snd_sof_dev *sdev, u32 bar,
-				     u32 offset, u32 mask, u32 value)
-{
-	bool change;
-	unsigned int old, new;
-	u32 ret;
-
-	ret = snd_sof_dsp_read(sdev, bar, offset);
-
-	old = ret;
-	new = (old & (~mask)) | (value & mask);
-
-	change = (old != new);
-	if (change)
-		snd_sof_dsp_write(sdev, bar, offset, new);
-
-	return change;
-}
-EXPORT_SYMBOL(snd_sof_dsp_update_bits_unlocked);
-
-int snd_sof_dsp_update_bits64_unlocked(struct snd_sof_dev *sdev, u32 bar,
-				       u32 offset, u64 mask, u64 value)
-{
-	bool change;
-	u64 old, new;
-
-	old = snd_sof_dsp_read64(sdev, bar, offset);
-
-	new = (old & (~mask)) | (value & mask);
-
-	change = (old != new);
-	if (change)
-		snd_sof_dsp_write64(sdev, bar, offset, new);
-
-	return change;
-}
-EXPORT_SYMBOL(snd_sof_dsp_update_bits64_unlocked);
-
-/* This is for registers bits with attribute RWC */
-void snd_sof_dsp_update_bits_forced_unlocked(struct snd_sof_dev *sdev, u32 bar,
-					     u32 offset, u32 mask, u32 value)
-{
-	unsigned int old, new;
-	u32 ret;
-
-	ret = snd_sof_dsp_read(sdev, bar, offset);
-
-	old = ret;
-	new = (old & (~mask)) | (value & mask);
-
-	snd_sof_dsp_write(sdev, bar, offset, new);
-}
-EXPORT_SYMBOL(snd_sof_dsp_update_bits_forced_unlocked);
-
-int snd_sof_dsp_update_bits(struct snd_sof_dev *sdev, u32 bar, u32 offset,
-			    u32 mask, u32 value)
-{
-	unsigned long flags;
-	bool change;
-
-	spin_lock_irqsave(&sdev->hw_lock, flags);
-	change = snd_sof_dsp_update_bits_unlocked(sdev, bar, offset, mask,
-						  value);
-	spin_unlock_irqrestore(&sdev->hw_lock, flags);
-	return change;
-}
-EXPORT_SYMBOL(snd_sof_dsp_update_bits);
-
-int snd_sof_dsp_update_bits64(struct snd_sof_dev *sdev, u32 bar, u32 offset,
-			      u64 mask, u64 value)
-{
-	unsigned long flags;
-	bool change;
-
-	spin_lock_irqsave(&sdev->hw_lock, flags);
-	change = snd_sof_dsp_update_bits64_unlocked(sdev, bar, offset, mask,
-						    value);
-	spin_unlock_irqrestore(&sdev->hw_lock, flags);
-	return change;
-}
-EXPORT_SYMBOL(snd_sof_dsp_update_bits64);
-
-/* This is for registers bits with attribute RWC */
-void snd_sof_dsp_update_bits_forced(struct snd_sof_dev *sdev, u32 bar,
-				    u32 offset, u32 mask, u32 value)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&sdev->hw_lock, flags);
-	snd_sof_dsp_update_bits_forced_unlocked(sdev, bar, offset, mask, value);
-	spin_unlock_irqrestore(&sdev->hw_lock, flags);
-}
-EXPORT_SYMBOL(snd_sof_dsp_update_bits_forced);
-
-int snd_sof_dsp_register_poll(struct snd_sof_dev *sdev, u32 bar, u32 offset,
-			      u32 mask, u32 target, u32 timeout)
-{
-	int time, ret;
-	bool done = false;
-
-	/*
-	 * we will poll for couple of ms using mdelay, if not successful
-	 * then go to longer sleep using usleep_range
-	 */
-
-	/* check if set state successful */
-	for (time = 0; time < 5; time++) {
-		if ((snd_sof_dsp_read(sdev, bar, offset) & mask) == target) {
-			done = true;
-			break;
-		}
-		msleep(20);
-	}
-
-	if (!done) {
-		/* sleeping in 10ms steps so adjust timeout value */
-		timeout /= 10;
-
-		for (time = 0; time < timeout; time++) {
-			if ((snd_sof_dsp_read(sdev, bar, offset) & mask) ==
-				target)
-				break;
-
-			usleep_range(5000, 10000);
-		}
-	}
-
-	ret = time < timeout ? 0 : -ETIME;
-
-	return ret;
-}
-EXPORT_SYMBOL(snd_sof_dsp_register_poll);
diff --git a/sound/soc/sof/ops.h b/sound/soc/sof/ops.h
deleted file mode 100644
index d28a55c..0000000
--- a/sound/soc/sof/ops.h
+++ /dev/null
@@ -1,251 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause) */
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-#ifndef __SOUND_SOC_SOF_IO_H
-#define __SOUND_SOC_SOF_IO_H
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/interrupt.h>
-#include <linux/device.h>
-#include <uapi/sound/sof-ipc.h>
-#include "sof-priv.h"
-
-/* init */
-static inline int snd_sof_probe(struct snd_sof_dev *sdev)
-{
-	if (sdev->ops->probe)
-		return sdev->ops->probe(sdev);
-	else
-		return 0;
-}
-
-static inline int snd_sof_remove(struct snd_sof_dev *sdev)
-{
-	if (sdev->ops->remove)
-		return sdev->ops->remove(sdev);
-	else
-		return 0;
-}
-
-/* control */
-static inline int snd_sof_dsp_run(struct snd_sof_dev *sdev)
-{
-	if (sdev->ops->run)
-		return sdev->ops->run(sdev);
-	else
-		return 0;
-}
-
-static inline int snd_sof_dsp_stall(struct snd_sof_dev *sdev)
-{
-	if (sdev->ops->stall)
-		return sdev->ops->stall(sdev);
-	else
-		return 0;
-}
-
-static inline int snd_sof_dsp_reset(struct snd_sof_dev *sdev)
-{
-	if (sdev->ops->reset)
-		return sdev->ops->reset(sdev);
-	else
-		return 0;
-}
-
-/* power management */
-static inline int snd_sof_dsp_resume(struct snd_sof_dev *sdev)
-{
-	if (sdev->ops->resume)
-		return sdev->ops->resume(sdev);
-	else
-		return 0;
-}
-
-static inline int snd_sof_dsp_suspend(struct snd_sof_dev *sdev, int state)
-{
-	if (sdev->ops->suspend)
-		return sdev->ops->suspend(sdev, state);
-	else
-		return 0;
-}
-
-static inline int snd_sof_dsp_set_clk(struct snd_sof_dev *sdev, u32 freq)
-{
-	if (sdev->ops->set_clk)
-		return sdev->ops->set_clk(sdev, freq);
-	else
-		return 0;
-}
-
-/* debug */
-static inline void snd_sof_dsp_dbg_dump(struct snd_sof_dev *sdev, u32 flags)
-{
-	if (sdev->ops->dbg_dump)
-		return sdev->ops->dbg_dump(sdev, flags);
-}
-
-/* register IO */
-static inline void snd_sof_dsp_write(struct snd_sof_dev *sdev, u32 bar,
-				     u32 offset, u32 value)
-{
-	if (sdev->ops->write)
-		sdev->ops->write(sdev, sdev->bar[bar] + offset, value);
-}
-
-static inline void snd_sof_dsp_write64(struct snd_sof_dev *sdev, u32 bar,
-				       u32 offset, u64 value)
-{
-	if (sdev->ops->write64)
-		sdev->ops->write64(sdev,
-			sdev->bar[bar] + offset, value);
-}
-
-static inline u32 snd_sof_dsp_read(struct snd_sof_dev *sdev, u32 bar,
-				   u32 offset)
-{
-	if (sdev->ops->read)
-		return sdev->ops->read(sdev, sdev->bar[bar] + offset);
-	else
-		return 0;
-}
-
-static inline u64 snd_sof_dsp_read64(struct snd_sof_dev *sdev, u32 bar,
-				     u32 offset)
-{
-	if (sdev->ops->read64)
-		return sdev->ops->read64(sdev, sdev->bar[bar] + offset);
-	else
-		return 0;
-}
-
-/* block IO */
-static inline void snd_sof_dsp_block_read(struct snd_sof_dev *sdev,
-					  u32 offset, void *dest, size_t bytes)
-{
-	if (sdev->ops->block_read)
-		sdev->ops->block_read(sdev, offset, dest, bytes);
-}
-
-static inline void snd_sof_dsp_block_write(struct snd_sof_dev *sdev,
-					   u32 offset, void *src, size_t bytes)
-{
-	if (sdev->ops->block_write)
-		sdev->ops->block_write(sdev, offset, src, bytes);
-}
-
-/* mailbox */
-static inline void snd_sof_dsp_mailbox_read(struct snd_sof_dev *sdev,
-					    u32 offset, void *message,
-					    size_t bytes)
-{
-	if (sdev->ops->mailbox_read)
-		sdev->ops->mailbox_read(sdev, offset, message, bytes);
-}
-
-static inline void snd_sof_dsp_mailbox_write(struct snd_sof_dev *sdev,
-					     u32 offset, void *message,
-					     size_t bytes)
-{
-	if (sdev->ops->mailbox_write)
-		sdev->ops->mailbox_write(sdev, offset, message, bytes);
-}
-
-/* ipc */
-static inline int snd_sof_dsp_send_msg(struct snd_sof_dev *sdev,
-				       struct snd_sof_ipc_msg *msg)
-{
-	if (sdev->ops->send_msg)
-		return sdev->ops->send_msg(sdev, msg);
-	else
-		return 0;
-}
-
-static inline int snd_sof_dsp_get_reply(struct snd_sof_dev *sdev,
-					struct snd_sof_ipc_msg *msg)
-{
-	if (sdev->ops->get_reply)
-		return sdev->ops->get_reply(sdev, msg);
-	else
-		return 0;
-}
-
-static inline int snd_sof_dsp_is_ready(struct snd_sof_dev *sdev)
-{
-	if (sdev->ops->is_ready)
-		return sdev->ops->is_ready(sdev);
-	else
-		return 0;
-}
-
-static inline int snd_sof_dsp_cmd_done(struct snd_sof_dev *sdev)
-{
-	if (sdev->ops->cmd_done)
-		return sdev->ops->cmd_done(sdev);
-	else
-		return 0;
-}
-
-/* host DMA trace */
-static inline int snd_sof_dma_trace_init(struct snd_sof_dev *sdev,
-					 u32 *stream_tag)
-{
-	if (sdev->ops->trace_init)
-		return sdev->ops->trace_init(sdev, stream_tag);
-	else
-		return 0;
-}
-
-static inline int snd_sof_dma_trace_release(struct snd_sof_dev *sdev)
-{
-	if (sdev->ops->trace_release)
-		return sdev->ops->trace_release(sdev);
-	else
-		return 0;
-}
-
-static inline int snd_sof_dma_trace_trigger(struct snd_sof_dev *sdev, int cmd)
-{
-	if (sdev->ops->trace_trigger)
-		return sdev->ops->trace_trigger(sdev, cmd);
-	else
-		return 0;
-}
-
-int snd_sof_dsp_update_bits_unlocked(struct snd_sof_dev *sdev, u32 bar,
-				     u32 offset, u32 mask, u32 value);
-
-int snd_sof_dsp_update_bits64_unlocked(struct snd_sof_dev *sdev, u32 bar,
-				       u32 offset, u64 mask, u64 value);
-
-/* This is for registers bits with attribute RWC */
-void snd_sof_dsp_update_bits_forced_unlocked(struct snd_sof_dev *sdev, u32 bar,
-					     u32 offset, u32 mask, u32 value);
-
-int snd_sof_dsp_update_bits(struct snd_sof_dev *sdev, u32 bar, u32 offset,
-			    u32 mask, u32 value);
-
-int snd_sof_dsp_update_bits64(struct snd_sof_dev *sdev, u32 bar,
-			      u32 offset, u64 mask, u64 value);
-
-/* This is for registers bits with attribute RWC */
-void snd_sof_dsp_update_bits_forced(struct snd_sof_dev *sdev, u32 bar,
-				    u32 offset, u32 mask, u32 value);
-
-int snd_sof_pci_update_bits_unlocked(struct snd_sof_dev *sdev, u32 offset,
-				     u32 mask, u32 value);
-
-int snd_sof_pci_update_bits(struct snd_sof_dev *sdev, u32 offset,
-			    u32 mask, u32 value);
-
-int snd_sof_dsp_register_poll(struct snd_sof_dev *sdev, u32 bar, u32 offset,
-			      u32 mask, u32 target, u32 timeout);
-
-#endif
diff --git a/sound/soc/sof/pcm.c b/sound/soc/sof/pcm.c
deleted file mode 100644
index 8671dc1..0000000
--- a/sound/soc/sof/pcm.c
+++ /dev/null
@@ -1,632 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/pm_runtime.h>
-#include <asm/page.h>
-#include <asm/pgtable.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/dmaengine_pcm.h>
-#include <sound/soc.h>
-#include <sound/tlv.h>
-#include <sound/compress_driver.h>
-#include <sound/sof.h>
-#include <uapi/sound/sof-ipc.h>
-#include "sof-priv.h"
-
-/* Create DMA buffer page table for DSP */
-static int create_page_table(struct snd_pcm_substream *substream,
-			     unsigned char *dma_area, size_t size)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct snd_sof_pcm *spcm = rtd->sof;
-	struct snd_dma_buffer *dmab = snd_pcm_get_dma_buf(substream);
-	int stream = substream->stream;
-
-	return snd_sof_create_page_table(sdev, dmab,
-		spcm->stream[stream].page_table.area, size);
-}
-
-/* this may get called several times by oss emulation */
-static int sof_pcm_hw_params(struct snd_pcm_substream *substream,
-			     struct snd_pcm_hw_params *params)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	const struct snd_sof_dsp_ops *ops = sdev->ops;
-	struct snd_sof_pcm *spcm = rtd->sof;
-	struct sof_ipc_pcm_params pcm;
-	struct sof_ipc_pcm_params_reply ipc_params_reply;
-	int posn_offset;
-	int ret;
-
-	/* nothing todo for BE */
-	if (rtd->dai_link->no_pcm)
-		return 0;
-
-	dev_dbg(sdev->dev, "pcm: hw params stream %d dir %d\n",
-		spcm->pcm.pcm_id, substream->stream);
-
-	memset(&pcm, 0, sizeof(pcm));
-
-	/* allocate audio buffer pages */
-	ret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: could not allocate %d bytes for PCM %d\n",
-			params_buffer_bytes(params), ret);
-		return ret;
-	}
-
-	/* craete compressed page table for audio firmware */
-	ret = create_page_table(substream, runtime->dma_area,
-				runtime->dma_bytes);
-	if (ret < 0)
-		return ret;
-
-	/* number of pages should be rounded up */
-	if (runtime->dma_bytes % PAGE_SIZE)
-		pcm.params.buffer.pages = (runtime->dma_bytes / PAGE_SIZE) + 1;
-	else
-		pcm.params.buffer.pages = runtime->dma_bytes / PAGE_SIZE;
-
-	/* set IPC PCM parameters */
-	pcm.hdr.size = sizeof(pcm);
-	pcm.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | SOF_IPC_STREAM_PCM_PARAMS;
-	pcm.comp_id = spcm->stream[substream->stream].comp_id;
-	pcm.params.buffer.phy_addr =
-		spcm->stream[substream->stream].page_table.addr;
-	pcm.params.buffer.size = runtime->dma_bytes;
-	pcm.params.buffer.offset = 0;
-	pcm.params.direction = substream->stream;
-	pcm.params.sample_valid_bytes = params_width(params) >> 3;
-	pcm.params.buffer_fmt = SOF_IPC_BUFFER_INTERLEAVED;
-	pcm.params.rate = params_rate(params);
-	pcm.params.channels = params_channels(params);
-	pcm.params.host_period_bytes = params_period_bytes(params);
-
-	/* container size */
-	switch (params_width(params)) {
-	case 16:
-		pcm.params.sample_container_bytes = 2;
-		break;
-	case 24:
-		pcm.params.sample_container_bytes = 4;
-		break;
-	case 32:
-		pcm.params.sample_container_bytes = 4;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* format */
-	switch (params_format(params)) {
-	case SNDRV_PCM_FORMAT_S16:
-		pcm.params.frame_fmt = SOF_IPC_FRAME_S16_LE;
-		break;
-	case SNDRV_PCM_FORMAT_S24:
-		pcm.params.frame_fmt = SOF_IPC_FRAME_S24_4LE;
-		break;
-	case SNDRV_PCM_FORMAT_S32:
-		pcm.params.frame_fmt = SOF_IPC_FRAME_S32_LE;
-		break;
-	case SNDRV_PCM_FORMAT_FLOAT:
-		pcm.params.frame_fmt = SOF_IPC_FRAME_FLOAT;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* firmware already configured host stream */
-	if (ops && ops->host_stream_prepare) {
-		pcm.params.stream_tag =
-			ops->host_stream_prepare(sdev, substream, params);
-		dev_dbg(sdev->dev, "stream_tag %d", pcm.params.stream_tag);
-	}
-
-	/* send IPC to the DSP */
-	ret = sof_ipc_tx_message(sdev->ipc,
-				 pcm.hdr.cmd, &pcm, sizeof(pcm),
-				 &ipc_params_reply, sizeof(ipc_params_reply));
-
-	/* validate offset */
-	posn_offset = ipc_params_reply.posn_offset;
-	/* check if offset is overflow or it is not aligned */
-	if (posn_offset > sdev->stream_box.size ||
-	    posn_offset % sizeof(struct sof_ipc_stream_posn) != 0) {
-		dev_err(sdev->dev, "error: got wrong posn offset 0x%x for PCM %d\n",
-			posn_offset, ret);
-		return ret;
-	}
-	spcm->posn_offset[substream->stream] =
-		sdev->stream_box.offset + posn_offset;
-
-	return ret;
-}
-
-static int sof_pcm_hw_free(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct snd_sof_pcm *spcm = rtd->sof;
-	struct sof_ipc_stream stream;
-	struct sof_ipc_reply reply;
-	int ret;
-
-	/* nothing todo for BE */
-	if (rtd->dai_link->no_pcm)
-		return 0;
-
-	dev_dbg(sdev->dev, "pcm: free stream %d dir %d\n", spcm->pcm.pcm_id,
-		substream->stream);
-
-	stream.hdr.size = sizeof(stream);
-	stream.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | SOF_IPC_STREAM_PCM_FREE;
-	stream.comp_id = spcm->stream[substream->stream].comp_id;
-
-	/* send IPC to the DSP */
-	ret = sof_ipc_tx_message(sdev->ipc, stream.hdr.cmd, &stream,
-				 sizeof(stream), &reply, sizeof(reply));
-
-	snd_pcm_lib_free_pages(substream);
-	return ret;
-}
-
-static int sof_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct snd_sof_pcm *spcm = rtd->sof;
-	struct sof_ipc_stream stream;
-	struct sof_ipc_reply reply;
-	const struct snd_sof_dsp_ops *ops = sdev->ops;
-	int ret = 0;
-
-	/* nothing todo for BE */
-	if (rtd->dai_link->no_pcm)
-		return 0;
-
-	dev_dbg(sdev->dev, "pcm: trigger stream %d dir %d cmd %d\n",
-		spcm->pcm.pcm_id, substream->stream, cmd);
-
-	stream.hdr.size = sizeof(stream);
-	stream.hdr.cmd = SOF_IPC_GLB_STREAM_MSG;
-	stream.comp_id = spcm->stream[substream->stream].comp_id;
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-		stream.hdr.cmd |= SOF_IPC_STREAM_TRIG_START;
-		break;
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		stream.hdr.cmd |= SOF_IPC_STREAM_TRIG_RELEASE;
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-		stream.hdr.cmd |= SOF_IPC_STREAM_TRIG_STOP;
-		break;
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		stream.hdr.cmd |= SOF_IPC_STREAM_TRIG_PAUSE;
-		break;
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-		break;
-	default:
-		dev_err(sdev->dev, "error: unhandled trigger cmd %d\n", cmd);
-		return -EINVAL;
-	}
-
-	/* send IPC to the DSP */
-	ret = sof_ipc_tx_message(sdev->ipc, stream.hdr.cmd, &stream,
-				 sizeof(stream), &reply, sizeof(reply));
-
-	if (ops && ops->host_stream_trigger)
-		ret = ops->host_stream_trigger(sdev, substream, cmd);
-
-	return ret;
-}
-
-static snd_pcm_uframes_t sof_pcm_pointer(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct snd_sof_pcm *spcm = rtd->sof;
-	snd_pcm_uframes_t host = 0, dai = 0;
-
-	/* nothing todo for BE */
-	if (rtd->dai_link->no_pcm)
-		return 0;
-
-	/* TODO: call HW position callback */
-	host = bytes_to_frames(substream->runtime,
-			       spcm->stream[substream->stream].posn.host_posn);
-	dai = bytes_to_frames(substream->runtime,
-			      spcm->stream[substream->stream].posn.dai_posn);
-
-	dev_dbg(sdev->dev, "PCM: stream %d dir %d DMA position %lu DAI position %lu\n",
-		spcm->pcm.pcm_id, substream->stream, host, dai);
-
-	return host;
-}
-
-static int sof_pcm_open(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct snd_sof_pcm *spcm = rtd->sof;
-	struct snd_soc_tplg_stream_caps *caps =
-		&spcm->pcm.caps[substream->stream];
-	const struct snd_sof_dsp_ops *ops = sdev->ops;
-
-	/* nothing todo for BE */
-	if (rtd->dai_link->no_pcm)
-		return 0;
-
-	dev_dbg(sdev->dev, "pcm: open stream %d dir %d\n", spcm->pcm.pcm_id,
-		substream->stream);
-
-	mutex_lock(&spcm->mutex);
-
-	pm_runtime_get_sync(sdev->dev);
-
-	/* set any runtime constraints based on topology */
-	snd_pcm_hw_constraint_step(substream->runtime, 0,
-				   SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
-				   caps->period_size_min);
-	snd_pcm_hw_constraint_step(substream->runtime, 0,
-				   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
-				   caps->period_size_min);
-
-	/* set runtime config */
-	runtime->hw.info = SNDRV_PCM_INFO_MMAP |
-			  SNDRV_PCM_INFO_MMAP_VALID |
-			  SNDRV_PCM_INFO_INTERLEAVED |
-			  SNDRV_PCM_INFO_PAUSE |
-			  SNDRV_PCM_INFO_RESUME |
-			  SNDRV_PCM_INFO_NO_PERIOD_WAKEUP;
-	runtime->hw.formats = caps->formats;
-	runtime->hw.period_bytes_min = caps->period_size_min;
-	runtime->hw.period_bytes_max = caps->period_size_max;
-	runtime->hw.periods_min = caps->periods_min;
-	runtime->hw.periods_max = caps->periods_max;
-	runtime->hw.buffer_bytes_max = caps->buffer_size_max;
-
-	dev_dbg(sdev->dev, "period min %ld max %ld bytes\n",
-		runtime->hw.period_bytes_min,
-		runtime->hw.period_bytes_max);
-	dev_dbg(sdev->dev, "period count %d max %d\n",
-		runtime->hw.periods_min,
-		runtime->hw.periods_max);
-	dev_dbg(sdev->dev, "buffer max %ld bytes\n",
-		runtime->hw.buffer_bytes_max);
-
-	// TODO: create IPC to get this from DSP pipeline
-	//runtime->hw.fifo_size = hw->fifo_size;
-
-	/* set wait time - TODO: come from topology */
-	snd_pcm_wait_time(substream, 500);
-
-	spcm->stream[substream->stream].posn.host_posn = 0;
-	spcm->stream[substream->stream].posn.dai_posn = 0;
-	spcm->stream[substream->stream].substream = substream;
-
-	if (ops && ops->host_stream_open)
-		ops->host_stream_open(sdev, substream);
-
-	mutex_unlock(&spcm->mutex);
-	return 0;
-}
-
-static int sof_pcm_close(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct snd_sof_pcm *spcm = rtd->sof;
-	const struct snd_sof_dsp_ops *ops = sdev->ops;
-
-	/* nothing todo for BE */
-	if (rtd->dai_link->no_pcm)
-		return 0;
-
-	dev_dbg(sdev->dev, "pcm: close stream %d dir %d\n", spcm->pcm.pcm_id,
-		substream->stream);
-
-	if (ops && ops->host_stream_close)
-		ops->host_stream_close(sdev, substream);
-
-	mutex_lock(&spcm->mutex);
-	pm_runtime_mark_last_busy(sdev->dev);
-	pm_runtime_put_autosuspend(sdev->dev);
-	mutex_unlock(&spcm->mutex);
-	return 0;
-}
-
-static struct snd_pcm_ops sof_pcm_ops = {
-	.open		= sof_pcm_open,
-	.close		= sof_pcm_close,
-	.ioctl		= snd_pcm_lib_ioctl,
-	.hw_params	= sof_pcm_hw_params,
-	.hw_free	= sof_pcm_hw_free,
-	.trigger	= sof_pcm_trigger,
-	.pointer	= sof_pcm_pointer,
-	.page		= snd_pcm_sgbuf_ops_page,
-};
-
-static int sof_pcm_new(struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct snd_sof_pcm *spcm;
-	struct snd_pcm *pcm = rtd->pcm;
-	struct snd_soc_tplg_stream_caps *caps;
-	int ret = 0, stream = SNDRV_PCM_STREAM_PLAYBACK;
-
-	spcm = snd_sof_find_spcm_dai(sdev, rtd);
-
-	if (!spcm) {
-		dev_warn(sdev->dev, "warn: can't find PCM with DAI ID %d\n",
-			 rtd->dai_link->id);
-		return 0;
-	}
-	rtd->sof = spcm;
-
-	dev_dbg(sdev->dev, "creating new PCM %s\n", spcm->pcm.pcm_name);
-
-	/* do we need to allocate playback PCM DMA pages */
-	if (!spcm->pcm.playback)
-		goto capture;
-
-	caps = &spcm->pcm.caps[stream];
-
-	/* pre-allocate playback audio buffer pages */
-	dev_dbg(sdev->dev, "spcm: allocate %s playback DMA buffer size 0x%x max 0x%x\n",
-		caps->name, caps->buffer_size_min, caps->buffer_size_max);
-
-	ret = snd_pcm_lib_preallocate_pages(pcm->streams[stream].substream,
-					    SNDRV_DMA_TYPE_DEV_SG, sdev->parent,
-					    caps->buffer_size_min,
-					    caps->buffer_size_max);
-	if (ret) {
-		dev_err(sdev->dev, "error: can't alloc DMA buffer size 0x%x/0x%x for %s %d\n",
-			caps->buffer_size_min, caps->buffer_size_max,
-			caps->name, ret);
-		return ret;
-	}
-
-	/* allocate playback page table buffer */
-	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, sdev->parent,
-				  PAGE_SIZE, &spcm->stream[stream].page_table);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: can't alloc page table for %s %d\n",
-			caps->name, ret);
-		return ret;
-	}
-
-capture:
-	stream = SNDRV_PCM_STREAM_CAPTURE;
-
-	/* do we need to allocate capture PCM DMA pages */
-	if (!spcm->pcm.capture)
-		return ret;
-
-	caps = &spcm->pcm.caps[stream];
-
-	/* pre-allocate capture audio buffer pages */
-	dev_dbg(sdev->dev, "spcm: allocate %s capture DMA buffer size 0x%x max 0x%x\n",
-		caps->name, caps->buffer_size_min, caps->buffer_size_max);
-
-	ret = snd_pcm_lib_preallocate_pages(pcm->streams[stream].substream,
-					    SNDRV_DMA_TYPE_DEV_SG, sdev->parent,
-					    caps->buffer_size_min,
-					    caps->buffer_size_max);
-	if (ret) {
-		dev_err(sdev->dev, "error: can't alloc DMA buffer size 0x%x/0x%x for %s %d\n",
-			caps->buffer_size_min, caps->buffer_size_max,
-			caps->name, ret);
-		snd_dma_free_pages(&spcm->stream[stream].page_table);
-		return ret;
-	}
-
-	/* allocate capture page table buffer */
-	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, sdev->parent,
-				  PAGE_SIZE, &spcm->stream[stream].page_table);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: can't alloc page table for %s %d\n",
-			caps->name, ret);
-		snd_dma_free_pages(&spcm->stream[stream].page_table);
-		return ret;
-	}
-
-	/* TODO: assign channel maps from topology */
-
-	return ret;
-}
-
-static void sof_pcm_free(struct snd_pcm *pcm)
-{
-	struct snd_sof_pcm *spcm;
-	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-
-	spcm = snd_sof_find_spcm_dai(sdev, rtd);
-	if (!spcm) {
-		dev_warn(sdev->dev, "warn: can't find PCM with DAI ID %d\n",
-			 rtd->dai_link->id);
-		return;
-	}
-
-	if (spcm->pcm.playback)
-		snd_dma_free_pages(&spcm->stream[SNDRV_PCM_STREAM_PLAYBACK].page_table);
-
-	if (spcm->pcm.capture)
-		snd_dma_free_pages(&spcm->stream[SNDRV_PCM_STREAM_CAPTURE].page_table);
-
-	snd_sof_free_topology(sdev);
-}
-
-static int sof_pcm_dai_link_fixup(struct snd_soc_pcm_runtime *rtd,
-				  struct snd_pcm_hw_params *params)
-{
-	struct snd_interval *rate = hw_param_interval(params,
-			SNDRV_PCM_HW_PARAM_RATE);
-	struct snd_interval *channels = hw_param_interval(params,
-						SNDRV_PCM_HW_PARAM_CHANNELS);
-	struct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct snd_sof_dai *dai =
-		snd_sof_find_dai(sdev, (char *)rtd->dai_link->name);
-
-	if (!dai) {
-		dev_err(sdev->dev, "No DAI is found!\n");
-
-		/*  set 48k, stereo, 16bits by default */
-		rate->min = 48000;
-		rate->max = 48000;
-
-		channels->min = 2;
-		channels->max = 2;
-
-		snd_mask_none(fmt);
-		snd_mask_set(fmt, SNDRV_PCM_FORMAT_S16_LE);
-
-		return -EINVAL;
-	}
-
-	/* read format from topology */
-	snd_mask_none(fmt);
-
-	switch (dai->comp_dai.config.frame_fmt) {
-	case SOF_IPC_FRAME_S16_LE:
-		snd_mask_set(fmt, SNDRV_PCM_FORMAT_S16_LE);
-		break;
-	case SOF_IPC_FRAME_S24_4LE:
-		snd_mask_set(fmt, SNDRV_PCM_FORMAT_S24_LE);
-		break;
-	case SOF_IPC_FRAME_S32_LE:
-		snd_mask_set(fmt, SNDRV_PCM_FORMAT_S32_LE);
-		break;
-	default:
-		dev_err(sdev->dev, "No available DAI format!\n");
-		return -EINVAL;
-	}
-
-	/* read rate and channels from topology */
-	rate->min = dai->dai_config.fclk;
-	rate->max = dai->dai_config.fclk;
-	channels->min = dai->dai_config.num_slots;
-	channels->max = dai->dai_config.num_slots;
-
-	dev_dbg(sdev->dev,
-		"rate_min: %d rate_max: %d\n", rate->min, rate->max);
-	dev_dbg(sdev->dev,
-		"channels_min: %d channels_max: %d\n",
-		channels->min, channels->max);
-
-	return 0;
-}
-
-static int sof_pcm_probe(struct snd_soc_platform *platform)
-{
-	struct snd_sof_dev *sdev =
-		snd_soc_platform_get_drvdata(platform);
-	struct snd_sof_pdata *plat_data = dev_get_platdata(platform->dev);
-	int ret;
-
-	/* load the default topology */
-	sdev->component = &platform->component;
-	ret = snd_sof_load_topology(sdev,
-				    plat_data->machine->sof_tplg_filename);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to load DSP topology %d\n",
-			ret);
-		goto err;
-	}
-
-	/* enable runtime PM with auto suspend */
-	pm_runtime_set_autosuspend_delay(platform->dev,
-					 SND_SOF_SUSPEND_DELAY);
-	pm_runtime_use_autosuspend(platform->dev);
-	pm_runtime_enable(platform->dev);
-	pm_runtime_idle(platform->dev);
-
-err:
-	return ret;
-}
-
-static int sof_pcm_remove(struct snd_soc_platform *platform)
-{
-	pm_runtime_disable(platform->dev);
-
-	return 0;
-}
-
-void snd_sof_new_platform_drv(struct snd_sof_dev *sdev)
-{
-	struct snd_soc_platform_driver *pd = &sdev->plat_drv;
-	struct snd_sof_pdata *plat_data = sdev->pdata;
-
-	dev_dbg(sdev->dev, "using platform alias %s\n",
-		plat_data->machine->asoc_plat_name);
-
-	pd->probe = sof_pcm_probe;
-	pd->remove = sof_pcm_remove;
-	pd->ops	= &sof_pcm_ops;
-	pd->compr_ops = &sof_compressed_ops;
-	pd->pcm_new = sof_pcm_new;
-	pd->pcm_free = sof_pcm_free;
-	pd->ignore_machine = plat_data->machine->drv_name;
-	pd->be_hw_params_fixup = sof_pcm_dai_link_fixup;
-	pd->be_pcm_base = SOF_BE_PCM_BASE;
-	pd->use_dai_pcm_id = true;
-	pd->topology_name_prefix = "sof";
-}
-
-static const struct snd_soc_dai_ops sof_dai_ops = {
-};
-
-static const struct snd_soc_component_driver sof_dai_component = {
-	.name		= "sof-dai",
-};
-
-#define SOF_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | \
-	SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_FLOAT)
-
-void snd_sof_new_dai_drv(struct snd_sof_dev *sdev)
-{
-	struct snd_soc_dai_driver *dd = &sdev->dai_drv;
-	//struct snd_sof_pdata *plat_data = sdev->pdata;
-
-	sdev->cmpnt_drv = &sof_dai_component;
-	dd->playback.channels_min = 1;
-	dd->playback.channels_max = 16;
-	dd->playback.rates = SNDRV_PCM_RATE_8000_192000;
-	dd->playback.formats = SOF_FORMATS;
-	dd->capture.channels_min = 1;
-	dd->capture.channels_max = 16;
-	dd->capture.rates = SNDRV_PCM_RATE_8000_192000;
-	dd->capture.formats = SOF_FORMATS;
-	dd->ops = &sof_dai_ops;
-	sdev->num_dai = 1;
-}
diff --git a/sound/soc/sof/pm.c b/sound/soc/sof/pm.c
deleted file mode 100644
index d825ff4..0000000
--- a/sound/soc/sof/pm.c
+++ /dev/null
@@ -1,48 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <asm/page.h>
-#include <asm/pgtable.h>
-#include <sound/core.h>
-#include <sound/soc.h>
-#include "sof-priv.h"
-
-int snd_sof_runtime_suspend(struct device *dev)
-{
-	return 0;
-}
-EXPORT_SYMBOL(snd_sof_runtime_suspend);
-
-int snd_sof_runtime_resume(struct device *dev)
-{
-	return 0;
-}
-EXPORT_SYMBOL(snd_sof_runtime_resume);
-
-int snd_sof_resume(struct device *dev)
-{
-	return 0;
-}
-EXPORT_SYMBOL(snd_sof_resume);
-
-int snd_sof_suspend(struct device *dev)
-{
-	return 0;
-}
-EXPORT_SYMBOL(snd_sof_suspend);
-
-int snd_sof_suspend_late(struct device *dev)
-{
-	return 0;
-}
-EXPORT_SYMBOL(snd_sof_suspend_late);
diff --git a/sound/soc/sof/sof-acpi-dev.c b/sound/soc/sof/sof-acpi-dev.c
deleted file mode 100644
index 9afaf5b..0000000
--- a/sound/soc/sof/sof-acpi-dev.c
+++ /dev/null
@@ -1,353 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-#include <linux/module.h>
-#include <linux/pci.h>
-#include <linux/pm_runtime.h>
-#include <linux/platform_device.h>
-#include <linux/firmware.h>
-#include <sound/pcm.h>
-#include <sound/soc-acpi.h>
-#include <sound/soc-acpi-intel-match.h>
-#include <sound/sof.h>
-#include <linux/acpi.h>
-#include <acpi/acpi_bus.h>
-#include <asm/cpu_device_id.h>
-#include <asm/iosf_mbi.h>
-#include "sof-priv.h"
-
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_HASWELL)
-static struct sof_dev_desc sof_acpi_haswell_desc = {
-	.machines = snd_soc_acpi_intel_haswell_machines,
-	.resindex_lpe_base = 0,
-	.resindex_pcicfg_base = 1,
-	.resindex_imr_base = -1,
-	.irqindex_host_ipc = 0,
-	.nocodec_fw_filename = "intel/reef-hsw.ri",
-	.nocodec_tplg_filename = "intel/reef-hsw-nocodec.tplg"
-};
-#endif
-
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_BROADWELL)
-static struct sof_dev_desc sof_acpi_broadwell_desc = {
-	.machines = snd_soc_acpi_intel_broadwell_machines,
-	.resindex_lpe_base = 0,
-	.resindex_pcicfg_base = 1,
-	.resindex_imr_base = -1,
-	.irqindex_host_ipc = 0,
-	.nocodec_fw_filename = "intel/reef-bdw.ri",
-	.nocodec_tplg_filename = "intel/reef-bdw-nocodec.tplg"
-};
-#endif
-
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_BAYTRAIL)
-
-/* BYTCR uses different IRQ index */
-static struct sof_dev_desc sof_acpi_baytrailcr_desc = {
-	.machines = snd_soc_acpi_intel_baytrail_machines,
-	.resindex_lpe_base = 0,
-	.resindex_pcicfg_base = 1,
-	.resindex_imr_base = 2,
-	.irqindex_host_ipc = 0,
-	.nocodec_fw_filename = "intel/reef-byt.ri",
-	.nocodec_tplg_filename = "intel/reef-byt-nocodec.tplg"
-};
-
-static struct sof_dev_desc sof_acpi_baytrail_desc = {
-	.machines = snd_soc_acpi_intel_baytrail_machines,
-	.resindex_lpe_base = 0,
-	.resindex_pcicfg_base = 1,
-	.resindex_imr_base = 2,
-	.irqindex_host_ipc = 5,
-	.nocodec_fw_filename = "intel/reef-byt.ri",
-	.nocodec_tplg_filename = "intel/reef-byt-nocodec.tplg"
-};
-
-static int is_byt_cr(struct device *dev)
-{
-	u32 bios_status;
-	int status;
-
-	if (!IS_ENABLED(CONFIG_IOSF_MBI) || !iosf_mbi_available()) {
-		dev_info(dev, "IOSF_MBI not enabled - can't determine CPU variant\n");
-		return -EIO;
-	}
-
-	status = iosf_mbi_read(BT_MBI_UNIT_PMC, /* 0x04 PUNIT */
-			       MBI_REG_READ, /* 0x10 */
-			       0x006, /* BIOS_CONFIG */
-			       &bios_status);
-
-	if (status) {
-		dev_err(dev, "error: could not read PUNIT BIOS_CONFIG\n");
-		return -EIO;
-	}
-
-	/* bits 26:27 mirror PMIC options */
-	bios_status = (bios_status >> 26) & 3;
-
-	if (bios_status == 1 || bios_status == 3) {
-		dev_info(dev, "BYT-CR detected\n");
-		return 1;
-	}
-
-	dev_info(dev, "BYT-CR not detected\n");
-	return 0;
-}
-
-static struct sof_dev_desc sof_acpi_cherrytrail_desc = {
-	.machines = snd_soc_acpi_intel_cherrytrail_machines,
-	.resindex_lpe_base = 0,
-	.resindex_pcicfg_base = 1,
-	.resindex_imr_base = 2,
-	.irqindex_host_ipc = 5,
-	.nocodec_fw_filename = "intel/reef-cht.ri",
-	.nocodec_tplg_filename = "intel/reef-cht-nocodec.tplg"
-};
-#endif
-
-static struct platform_device *
-	mfld_new_mach_data(struct snd_sof_pdata *sof_pdata)
-{
-	struct snd_soc_acpi_mach pmach;
-	struct device *dev = &sof_pdata->pdev->dev;
-	const struct snd_soc_acpi_mach *mach = sof_pdata->machine;
-	struct platform_device *pdev = NULL;
-
-	memset(&pmach, 0, sizeof(pmach));
-	memcpy((void *)pmach.id, mach->id, ACPI_ID_LEN);
-	pmach.drv_name = mach->drv_name;
-
-	pdev = platform_device_register_data(dev, mach->drv_name, -1,
-					     &pmach, sizeof(pmach));
-	return pdev;
-}
-
-struct sof_acpi_priv {
-	struct snd_sof_pdata *sof_pdata;
-	struct platform_device *pdev_pcm;
-};
-
-static void sof_acpi_fw_cb(const struct firmware *fw, void *context)
-{
-	struct sof_acpi_priv *priv = context;
-	struct snd_sof_pdata *sof_pdata = priv->sof_pdata;
-	const struct snd_soc_acpi_mach *mach = sof_pdata->machine;
-	struct device *dev = &sof_pdata->pdev->dev;
-
-	sof_pdata->fw = fw;
-	if (!fw) {
-		dev_err(dev, "Cannot load firmware %s\n",
-			mach->sof_fw_filename);
-		return;
-	}
-
-	/* register PCM and DAI driver */
-	priv->pdev_pcm =
-		platform_device_register_data(dev, "sof-audio", -1,
-					      sof_pdata, sizeof(*sof_pdata));
-	if (IS_ERR(priv->pdev_pcm)) {
-		dev_err(dev, "Cannot register device sof-audio. Error %d\n",
-			(int)PTR_ERR(priv->pdev_pcm));
-	}
-}
-
-static const struct dev_pm_ops sof_acpi_pm = {
-	SET_SYSTEM_SLEEP_PM_OPS(snd_sof_suspend, snd_sof_resume)
-	SET_RUNTIME_PM_OPS(snd_sof_runtime_suspend, snd_sof_runtime_resume,
-			   NULL)
-	.suspend_late = snd_sof_suspend_late,
-};
-
-static const struct sof_ops_table mach_ops[] = {
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_HASWELL)
-	{&sof_acpi_haswell_desc, &snd_sof_hsw_ops},
-#endif
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_BROADWELL)
-	{&sof_acpi_broadwell_desc, &snd_sof_bdw_ops},
-#endif
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_BAYTRAIL)
-	{&sof_acpi_baytrail_desc, &snd_sof_byt_ops, mfld_new_mach_data},
-	{&sof_acpi_baytrailcr_desc, &snd_sof_byt_ops, mfld_new_mach_data},
-	{&sof_acpi_cherrytrail_desc, &snd_sof_cht_ops, mfld_new_mach_data},
-#endif
-};
-
-static struct snd_sof_dsp_ops *
-	sof_acpi_get_ops(const struct sof_dev_desc *d,
-			 struct platform_device *(**new_mach_data)
-			 (struct snd_sof_pdata *))
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(mach_ops); i++) {
-		if (d == mach_ops[i].desc) {
-			*new_mach_data = mach_ops[i].new_data;
-			return mach_ops[i].ops;
-		}
-	}
-
-	/* not found */
-	return NULL;
-}
-
-static int sof_acpi_probe(struct platform_device *pdev)
-{
-	const struct acpi_device_id *id;
-	struct device *dev = &pdev->dev;
-	const struct sof_dev_desc *desc;
-	struct snd_soc_acpi_mach *mach;
-	struct snd_sof_pdata *sof_pdata;
-	struct sof_acpi_priv *priv;
-	struct snd_sof_dsp_ops *ops;
-	struct platform_device *(*new_mach_data)(struct snd_sof_pdata *pdata);
-	int ret = 0;
-
-	dev_dbg(&pdev->dev, "ACPI DSP detected");
-
-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	sof_pdata = devm_kzalloc(dev, sizeof(*sof_pdata), GFP_KERNEL);
-	if (!sof_pdata)
-		return -ENOMEM;
-
-	id = acpi_match_device(dev->driver->acpi_match_table, dev);
-	if (!id)
-		return -ENODEV;
-
-	desc = (const struct sof_dev_desc *)id->driver_data;
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_BAYTRAIL)
-	if (desc == &sof_acpi_baytrail_desc && is_byt_cr(dev))
-		desc = &sof_acpi_baytrailcr_desc;
-#endif
-
-	/* get ops for platform */
-	new_mach_data = NULL;
-	ops = sof_acpi_get_ops(desc, &new_mach_data);
-	if (!ops) {
-		dev_err(dev, "error: no matching ACPI descriptor ops\n");
-		return -ENODEV;
-	}
-
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_FORCE_NOCODEC_MODE)
-	/* force nocodec mode */
-	dev_warn(dev, "Force to use nocodec mode\n");
-	mach = devm_kzalloc(dev, sizeof(*mach), GFP_KERNEL);
-	ret = sof_nocodec_setup(dev, sof_pdata, mach, desc);
-	if (ret < 0)
-		return ret;
-#else
-	/* find machine */
-	mach = snd_soc_acpi_find_machine(desc->machines);
-	if (!mach) {
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC)
-		/* fallback to nocodec mode */
-		dev_warn(dev, "No matching ASoC machine driver found - using nocodec\n");
-		mach = devm_kzalloc(dev, sizeof(*mach), GFP_KERNEL);
-		ret = sof_nocodec_setup(dev, sof_pdata, mach, desc);
-		if (ret < 0)
-			return ret;
-#else
-		dev_err(dev, "No matching ASoC machine driver found - aborting probe\n");
-		return -ENODEV;
-#endif
-	}
-#endif
-
-	mach->pdata = ops;
-	mach->new_mach_data = (struct platform_device *
-				(*)(void *pdata)) new_mach_data;
-
-	sof_pdata->machine = mach;
-	/*
-	 * FIXME, this can't work for baytrail cr:
-	 * sof_pdata->desc = (struct sof_dev_desc*) id->driver_data;
-	 */
-	sof_pdata->desc = desc;
-	priv->sof_pdata = sof_pdata;
-	sof_pdata->pdev = pdev;
-	dev_set_drvdata(&pdev->dev, priv);
-
-	/* do we need to generate any machine plat data ? */
-	if (mach->new_mach_data)
-		sof_pdata->pdev_mach = mach->new_mach_data(sof_pdata);
-	else
-		/* register machine driver, pass machine info as pdata */
-		sof_pdata->pdev_mach =
-			platform_device_register_data(dev, mach->drv_name, -1,
-						      (const void *)mach,
-						      sizeof(*mach));
-	if (IS_ERR(sof_pdata->pdev_mach))
-		return PTR_ERR(sof_pdata->pdev_mach);
-	dev_dbg(dev, "created machine %s\n",
-		dev_name(&sof_pdata->pdev_mach->dev));
-
-	/* continue SST probing after firmware is loaded */
-	dev_info(dev, "info: loading firmware %s\n", mach->sof_fw_filename);
-	ret = request_firmware_nowait(THIS_MODULE, true, mach->sof_fw_filename,
-				      dev, GFP_KERNEL, priv, sof_acpi_fw_cb);
-	if (ret) {
-		platform_device_unregister(sof_pdata->pdev_mach);
-		dev_err(dev, "error: failed to load firmware %s\n",
-			mach->sof_fw_filename);
-	}
-
-	return ret;
-}
-
-static void sof_acpi_shutdown(struct platform_device *pdev)
-{
-	snd_sof_shutdown(&pdev->dev);
-}
-
-static int sof_acpi_remove(struct platform_device *pdev)
-{
-	struct sof_acpi_priv *priv = dev_get_drvdata(&pdev->dev);
-	struct snd_sof_pdata *sof_pdata = priv->sof_pdata;
-
-	platform_device_unregister(sof_pdata->pdev_mach);
-	if (!IS_ERR_OR_NULL(priv->pdev_pcm))
-		platform_device_unregister(priv->pdev_pcm);
-	release_firmware(sof_pdata->fw);
-
-	return 0;
-}
-
-static const struct acpi_device_id sof_acpi_match[] = {
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_HASWELL)
-	{ "INT33C8", (unsigned long)&sof_acpi_haswell_desc },
-#endif
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_BROADWELL)
-	{ "INT3438", (unsigned long)&sof_acpi_broadwell_desc },
-#endif
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_BAYTRAIL)
-	{ "80860F28", (unsigned long)&sof_acpi_baytrail_desc },
-	{ "808622A8", (unsigned long)&sof_acpi_cherrytrail_desc },
-#endif
-	{ }
-};
-MODULE_DEVICE_TABLE(acpi, sof_acpi_match);
-
-/* acpi_driver definition */
-static struct platform_driver snd_sof_acpi_driver = {
-	.probe = sof_acpi_probe,
-	.remove = sof_acpi_remove,
-	.shutdown = sof_acpi_shutdown,
-	.driver = {
-		.name = "sof-audio-acpi",
-		.pm = &sof_acpi_pm,
-		.acpi_match_table = ACPI_PTR(sof_acpi_match),
-	},
-};
-module_platform_driver(snd_sof_acpi_driver);
-
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/sound/soc/sof/sof-pci-dev.c b/sound/soc/sof/sof-pci-dev.c
deleted file mode 100644
index ddb8b94..0000000
--- a/sound/soc/sof/sof-pci-dev.c
+++ /dev/null
@@ -1,307 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-#include <linux/module.h>
-#include <linux/pci.h>
-#include <linux/pm_runtime.h>
-#include <linux/platform_device.h>
-#include <linux/firmware.h>
-#include <sound/pcm.h>
-#include <sound/sof.h>
-#include <linux/pci.h>
-#include <linux/acpi.h>
-#include "sof-priv.h"
-
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_APOLLOLAKE)
-static struct snd_soc_acpi_mach sof_bxt_machines[] = {
-	{
-		.id = "DLGS7219",
-		.drv_name = "bxt_da7219_max98357a_i2s",
-		.sof_fw_filename = "intel/reef-apl.ri",
-		.sof_tplg_filename = "intel/reef-apl.tplg",
-		.asoc_plat_name = "0000:00:0e.0",
-	},
-	{
-		.id = "INT34C3",
-		.drv_name = "bxt_tdf8532",
-		.sof_fw_filename = "intel/reef-apl.ri",
-		.sof_tplg_filename = "intel/reef-apl.tplg",
-		.asoc_plat_name = "0000:00:0e.0",
-	},
-};
-
-static struct sof_dev_desc bxt_desc = {
-	.machines		= sof_bxt_machines,
-	.resindex_lpe_base	= 0,
-	.resindex_pcicfg_base	= -1,
-	.resindex_imr_base	= -1,
-	.irqindex_host_ipc	= -1,
-	.resindex_dma_base	= -1,
-	.nocodec_fw_filename = "intel/reef-apl.ri",
-	.nocodec_tplg_filename = "intel/reef-apl-nocodec.tplg"
-};
-#endif
-
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_BAYTRAIL)
-static struct snd_soc_acpi_mach sof_byt_machines[] = {
-	{
-		.id = "INT343A",
-		.drv_name = "edison",
-		.sof_fw_filename = "intel/reef-byt.ri",
-		.sof_tplg_filename = "intel/reef-byt.tplg",
-		.asoc_plat_name = "baytrail-pcm-audio",
-	},
-	{}
-};
-
-static const struct sof_dev_desc byt_desc = {
-	.machines		= sof_byt_machines,
-	.resindex_lpe_base	= 3,	/* IRAM, but subtract IRAM offset */
-	.resindex_pcicfg_base	= -1,
-	.resindex_imr_base	= 0,
-	.irqindex_host_ipc	= -1,
-	.resindex_dma_base	= -1,
-	.nocodec_fw_filename = "intel/reef-byt.ri",
-	.nocodec_tplg_filename = "intel/reef-byt.tplg"
-};
-#endif
-
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_CANNONLAKE)
-static struct snd_soc_acpi_mach sof_cnl_machines[] = {
-	{
-		.id = "INT34C2",
-		.drv_name = "cnl_alc700_i2s",
-		.sof_fw_filename = "intel/reef-cnl.ri",
-		.sof_tplg_filename = "intel/reef-cnl.tplg",
-		.asoc_plat_name = "0000:00:0e.0",
-	},
-	{}
-};
-
-static const struct sof_dev_desc cnl_desc = {
-	.machines		= sof_cnl_machines,
-	.resindex_lpe_base	= 0,
-	.resindex_pcicfg_base	= -1,
-	.resindex_imr_base	= -1,
-	.irqindex_host_ipc	= -1,
-	.resindex_dma_base	= -1,
-	.nocodec_fw_filename = "intel/reef-cnl.ri",
-	.nocodec_tplg_filename = "intel/reef-cnl.tplg"
-};
-#endif
-
-struct sof_pci_priv {
-	struct snd_sof_pdata *sof_pdata;
-	struct platform_device *pdev_pcm;
-};
-
-static void sof_pci_fw_cb(const struct firmware *fw, void *context)
-{
-	struct sof_pci_priv *priv = context;
-	struct snd_sof_pdata *sof_pdata = priv->sof_pdata;
-	const struct snd_soc_acpi_mach *mach = sof_pdata->machine;
-	struct device *dev = sof_pdata->dev;
-
-	sof_pdata->fw = fw;
-	if (!fw) {
-		dev_err(dev, "Cannot load firmware %s\n",
-			mach->sof_fw_filename);
-		return;
-	}
-
-	/* register PCM and DAI driver */
-	priv->pdev_pcm =
-		platform_device_register_data(dev, "sof-audio", -1,
-					      sof_pdata, sizeof(*sof_pdata));
-	if (IS_ERR(priv->pdev_pcm)) {
-		dev_err(dev, "Cannot register device sof-audio. Error %d\n",
-			(int)PTR_ERR(priv->pdev_pcm));
-	}
-}
-
-static const struct dev_pm_ops sof_pci_pm = {
-	SET_SYSTEM_SLEEP_PM_OPS(snd_sof_suspend, snd_sof_resume)
-	SET_RUNTIME_PM_OPS(snd_sof_runtime_suspend, snd_sof_runtime_resume,
-			   NULL)
-	.suspend_late = snd_sof_suspend_late,
-};
-
-static const struct sof_ops_table mach_ops[] = {
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_APOLLOLAKE)
-	{&bxt_desc, &snd_sof_apl_ops},
-#endif
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_BAYTRAIL)
-	{&byt_desc, &snd_sof_byt_ops},
-#endif
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_CANNONLAKE)
-	{&cnl_desc, &snd_sof_cnl_ops},
-#endif
-};
-
-static struct snd_sof_dsp_ops *sof_pci_get_ops(const struct sof_dev_desc *d)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(mach_ops); i++) {
-		if (d == mach_ops[i].desc)
-			return mach_ops[i].ops;
-	}
-
-	/* not found */
-	return NULL;
-}
-
-static int sof_pci_probe(struct pci_dev *pci,
-			 const struct pci_device_id *pci_id)
-{
-	struct device *dev = &pci->dev;
-	const struct sof_dev_desc *desc =
-		(const struct sof_dev_desc *)pci_id->driver_data;
-	struct snd_soc_acpi_mach *mach;
-	struct snd_sof_pdata *sof_pdata;
-	struct sof_pci_priv *priv;
-	struct snd_sof_dsp_ops *ops;
-	int ret = 0;
-
-	dev_dbg(&pci->dev, "PCI DSP detected");
-
-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-	pci_set_drvdata(pci, priv);
-
-	sof_pdata = devm_kzalloc(dev, sizeof(*sof_pdata), GFP_KERNEL);
-	if (!sof_pdata)
-		return -ENOMEM;
-
-	ret = pci_enable_device(pci);
-	if (ret < 0)
-		return ret;
-
-	ret = pci_request_regions(pci, "Audio DSP");
-	if (ret < 0)
-		return ret;
-
-	/* get ops for platform */
-	ops = sof_pci_get_ops(desc);
-	if (!ops) {
-		dev_err(dev, "error: no matching PCI descriptor ops\n");
-		return -ENODEV;
-	}
-
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_FORCE_NOCODEC_MODE)
-	/* force nocodec mode */
-	dev_warn(dev, "Force to use nocodec mode\n");
-	mach = devm_kzalloc(dev, sizeof(*mach), GFP_KERNEL);
-	ret = sof_nocodec_setup(dev, sof_pdata, mach, desc);
-	if (ret < 0)
-		return ret;
-#else
-	/* find machine */
-	mach = snd_soc_acpi_find_machine(desc->machines);
-	if (!mach) {
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC)
-		/* fallback to nocodec mode */
-		dev_warn(dev, "No matching ASoC machine driver found - using nocodec\n");
-		mach = devm_kzalloc(dev, sizeof(*mach), GFP_KERNEL);
-		ret = sof_nocodec_setup(dev, sof_pdata, mach, desc);
-		if (ret < 0)
-			return ret;
-#else
-		dev_err(dev, "No matching ASoC machine driver found - aborting probe\n");
-		return -ENODEV;
-#endif
-	}
-#endif
-
-	mach->pdata = ops;
-
-	sof_pdata->id = pci_id->device;
-	sof_pdata->name = pci_name(pci);
-	sof_pdata->machine = mach;
-	sof_pdata->desc = (struct sof_dev_desc *)pci_id->driver_data;
-	priv->sof_pdata = sof_pdata;
-	sof_pdata->pci = pci;
-	sof_pdata->dev = &pci->dev;
-
-	/* register machine driver */
-	sof_pdata->pdev_mach =
-		platform_device_register_data(dev, mach->drv_name, -1,
-					      sof_pdata, sizeof(*sof_pdata));
-	if (IS_ERR(sof_pdata->pdev_mach))
-		return PTR_ERR(sof_pdata->pdev_mach);
-	dev_dbg(dev, "created machine %s\n",
-		dev_name(&sof_pdata->pdev_mach->dev));
-
-	/* continue probing after firmware is loaded */
-	dev_info(dev, "info: loading firmware %s\n", mach->sof_fw_filename);
-	ret = request_firmware_nowait(THIS_MODULE, true, mach->sof_fw_filename,
-				      dev, GFP_KERNEL, priv, sof_pci_fw_cb);
-	if (ret) {
-		platform_device_unregister(sof_pdata->pdev_mach);
-		dev_err(dev, "error: failed to load firmware %s\n",
-			mach->sof_fw_filename);
-	}
-
-	return ret;
-}
-
-static void sof_pci_shutdown(struct pci_dev *pci)
-{
-	snd_sof_shutdown(&pci->dev);
-}
-
-static void sof_pci_remove(struct pci_dev *pci)
-{
-	struct sof_pci_priv *priv = pci_get_drvdata(pci);
-	struct snd_sof_pdata *sof_pdata = priv->sof_pdata;
-
-	platform_device_unregister(sof_pdata->pdev_mach);
-	if (!IS_ERR_OR_NULL(priv->pdev_pcm))
-		platform_device_unregister(priv->pdev_pcm);
-	release_firmware(sof_pdata->fw);
-	pci_release_regions(pci);
-}
-
-/* PCI IDs */
-static const struct pci_device_id sof_pci_ids[] = {
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_APOLLOLAKE)
-	/* BXT-P & Apollolake */
-	{ PCI_DEVICE(0x8086, 0x5a98),
-		.driver_data = (unsigned long)&bxt_desc},
-	{ PCI_DEVICE(0x8086, 0x1a98),
-		.driver_data = (unsigned long)&bxt_desc},
-#endif
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_BAYTRAIL)
-	{ PCI_DEVICE(0x8086, 0x119a),
-		.driver_data = (unsigned long)&byt_desc},
-#endif
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_CANNONLAKE)
-	{ PCI_DEVICE(0x8086, 0x9dc8),
-		.driver_data = (unsigned long)&cnl_desc},
-#endif
-	{ 0, }
-};
-MODULE_DEVICE_TABLE(pci, sof_pci_ids);
-
-/* pci_driver definition */
-static struct pci_driver snd_sof_pci_driver = {
-	.name = "sof-audio-pci",
-	.id_table = sof_pci_ids,
-	.probe = sof_pci_probe,
-	.remove = sof_pci_remove,
-	.shutdown = sof_pci_shutdown,
-	.driver = {
-		.pm = &sof_pci_pm,
-	},
-};
-module_pci_driver(snd_sof_pci_driver);
-
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/sound/soc/sof/sof-priv.h b/sound/soc/sof/sof-priv.h
index e7e1b7b..5a9f19b 100644
--- a/sound/soc/sof/sof-priv.h
+++ b/sound/soc/sof/sof-priv.h
@@ -128,10 +128,6 @@ struct snd_sof_dsp_ops {
 			   struct snd_sof_mod_hdr *hdr);
 	int (*fw_ready)(struct snd_sof_dev *sdev, u32 msg_id);
 
-	/* host DMA trace initialization */
-	int (*trace_init)(struct snd_sof_dev *sdev, u32 *stream_tag);
-	int (*trace_release)(struct snd_sof_dev *sdev);
-	int (*trace_trigger)(struct snd_sof_dev *sdev, int cmd);
 };
 
 struct snd_sof_pdata;
@@ -343,7 +339,6 @@ struct snd_sof_dev {
 	void __iomem *bar[SND_SOF_BARS];	/* DSP base address */
 	int mmio_bar;
 	int mailbox_bar;
-	size_t dsp_oops_offset;
 
 	/* debug */
 	struct dentry *debugfs_root;
@@ -376,7 +371,6 @@ struct snd_sof_dev {
 	/* DMA for Trace */
 	struct snd_dma_buffer dmatb;
 	struct snd_dma_buffer dmatp;
-	struct snd_sof_hda_stream *dtrace_stream;
 	int dma_trace_pages;
 	wait_queue_head_t trace_sleep;
 	u32 host_offset;
diff --git a/sound/soc/sof/sof-spi-dev.c b/sound/soc/sof/sof-spi-dev.c
deleted file mode 100644
index f5b17d0..0000000
--- a/sound/soc/sof/sof-spi-dev.c
+++ /dev/null
@@ -1,167 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-#include <linux/module.h>
-#include <linux/pci.h>
-#include <linux/pm_runtime.h>
-#include <linux/platform_device.h>
-#include <linux/firmware.h>
-#include <sound/pcm.h>
-#include <sound/sof.h>
-#include <linux/spi/spi.h>
-#include <linux/of_device.h>
-#include "sof-priv.h"
-
-struct sof_spi_priv {
-	struct snd_sof_pdata *sof_pdata;
-	struct platform_device *pdev_pcm;
-};
-
-static void sof_spi_fw_cb(const struct firmware *fw, void *context)
-{
-	struct sof_spi_priv *priv = context;
-	struct snd_sof_pdata *sof_pdata = priv->sof_pdata;
-	const struct snd_sof_machine *mach = sof_pdata->machine;
-	struct device *dev = sof_pdata->dev;
-
-	sof_pdata->fw = fw;
-	if (!fw) {
-		dev_err(dev, "Cannot load firmware %s\n",
-			mach->sof_fw_filename);
-		return;
-	}
-
-	/* register PCM and DAI driver */
-	priv->pdev_pcm =
-		platform_device_register_data(dev, "sof-audio", -1,
-					      sof_pdata, sizeof(*sof_pdata));
-	if (IS_ERR(priv->pdev_pcm)) {
-		dev_err(dev, "Cannot register device sof-audio. Error %d\n",
-			(int)PTR_ERR(priv->pdev_pcm));
-	}
-}
-
-static const struct dev_pm_ops sof_spi_pm = {
-	SET_SYSTEM_SLEEP_PM_OPS(snd_sof_suspend, snd_sof_resume)
-	SET_RUNTIME_PM_OPS(snd_sof_runtime_suspend, snd_sof_runtime_resume,
-			   NULL)
-	.suspend_late = snd_sof_suspend_late,
-};
-
-static int sof_spi_probe(struct spi_device *spi)
-{
-	struct device *dev = &spi->dev;
-	const struct snd_sof_machine *mach;
-	struct snd_sof_machine *m;
-	struct snd_sof_pdata *sof_pdata;
-	struct sof_spi_priv *priv;
-	int ret = 0;
-
-	dev_dbg(&spi->dev, "SPI DSP detected");
-
-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-	spi_set_drvdata(spi, priv);
-
-	sof_pdata = devm_kzalloc(dev, sizeof(*sof_pdata), GFP_KERNEL);
-	if (!sof_pdata)
-		return -ENOMEM;
-
-	/* use nocodec machine atm */
-	dev_err(dev, "No matching ASoC machine driver found - using nocodec\n");
-	sof_pdata->drv_name = "sof-nocodec";
-	m = devm_kzalloc(dev, sizeof(*mach), GFP_KERNEL);
-	if (!m)
-		return -ENOMEM;
-
-	m->drv_name = "sof-nocodec";
-	m->sof_fw_filename = desc->nocodec_fw_filename;
-	m->sof_tplg_filename = desc->nocodec_tplg_filename;
-	m->ops = desc->machines[0].ops;
-	m->asoc_plat_name = "sof-platform";
-	mach = m;
-
-	sof_pdata->id = pci_id->device;
-	sof_pdata->name = spi_name(spi);
-	sof_pdata->machine = mach;
-	sof_pdata->desc = (struct sof_dev_desc *)pci_id->driver_data;
-	priv->sof_pdata = sof_pdata;
-	sof_pdata->spi = spi;
-	sof_pdata->dev = dev;
-
-	/* register machine driver */
-	sof_pdata->pdev_mach =
-		platform_device_register_data(dev, mach->drv_name, -1,
-					      sof_pdata, sizeof(*sof_pdata));
-	if (IS_ERR(sof_pdata->pdev_mach))
-		return PTR_ERR(sof_pdata->pdev_mach);
-	dev_dbg(dev, "created machine %s\n",
-		dev_name(&sof_pdata->pdev_mach->dev));
-
-	/* continue probing after firmware is loaded */
-	ret = request_firmware_nowait(THIS_MODULE, true, mach->sof_fw_filename,
-				      dev, GFP_KERNEL, priv, sof_spi_fw_cb);
-	if (ret)
-		platform_device_unregister(sof_pdata->pdev_mach);
-
-	return ret;
-}
-
-static int sof_spi_remove(struct spi_device *spi)
-{
-	struct sof_spi_priv *priv = spi_get_drvdata(spi);
-	struct snd_sof_pdata *sof_pdata = priv->sof_pdata;
-
-	platform_device_unregister(sof_pdata->pdev_mach);
-	if (!IS_ERR_OR_NULL(priv->pdev_pcm))
-		platform_device_unregister(priv->pdev_pcm);
-	release_firmware(sof_pdata->fw);
-}
-
-static struct spi_driver wm8731_spi_driver = {
-	.driver = {
-		.name	= "sof-spi-dev",
-		.of_match_table = sof_of_match,
-	},
-	.probe		= sof_spi_probe,
-	.remove		= sof_spi_remove,
-};
-
-static const struct snd_sof_machine sof_spi_machines[] = {
-	{ "INT343A", "bxt_alc298s_i2s", "intel/reef-spi.ri",
-		"intel/reef-spi.tplg", "0000:00:0e.0", &snd_sof_spi_ops },
-};
-
-static const struct sof_dev_desc spi_desc = {
-	.machines		= sof_spi_machines,
-	.nocodec_fw_filename = "intel/reef-spi.ri",
-	.nocodec_tplg_filename = "intel/reef-spi.tplg"
-};
-
-static int __init sof_spi_modinit(void)
-{
-	int ret;
-
-	ret = spi_register_driver(&sof_spi_driver);
-	if (ret != 0)
-		pr_err("Failed to register SOF SPI driver: %d\n", ret);
-
-	return ret;
-}
-module_init(sof_spi_modinit);
-
-static void __exit sof_spi_modexit(void)
-{
-	spi_unregister_driver(&sof_spi_driver);
-}
-module_exit(sof_spi_modexit);
-
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/sound/soc/sof/topology.c b/sound/soc/sof/topology.c
deleted file mode 100644
index d068c37..0000000
--- a/sound/soc/sof/topology.c
+++ /dev/null
@@ -1,1532 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-#include <linux/platform_device.h>
-#include <linux/firmware.h>
-#include <linux/string.h>
-#include <sound/soc-topology.h>
-#include <sound/soc.h>
-#include <uapi/sound/sof-ipc.h>
-#include <uapi/sound/sof-topology.h>
-#include "sof-priv.h"
-
-#define COMP_ID_UNASSIGNED		0xffffffff
-
-struct sof_dai_types {
-	const char *name;
-	enum sof_ipc_dai_type type;
-};
-
-static const struct sof_dai_types sof_dais[] = {
-	{"SSP", SOF_DAI_INTEL_SSP},
-	{"HDA", SOF_DAI_INTEL_HDA},
-	{"DMIC", SOF_DAI_INTEL_DMIC},
-};
-
-static enum sof_ipc_dai_type find_dai(const char *name)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(sof_dais); i++) {
-		if (strcmp(name, sof_dais[i].name) == 0)
-			return sof_dais[i].type;
-	}
-
-	return SOF_DAI_INTEL_NONE;
-}
-
-struct sof_frame_types {
-	const char *name;
-	enum sof_ipc_frame frame;
-};
-
-static const struct sof_frame_types sof_frames[] = {
-	{"s16le", SOF_IPC_FRAME_S16_LE},
-	{"s24le", SOF_IPC_FRAME_S24_4LE},
-	{"s32le", SOF_IPC_FRAME_S32_LE},
-	{"float", SOF_IPC_FRAME_FLOAT},
-};
-
-static enum sof_ipc_dai_type find_format(const char *name)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(sof_frames); i++) {
-		if (strcmp(name, sof_frames[i].name) == 0)
-			return sof_frames[i].frame;
-	}
-
-	/* use s32le if nothing is specified */
-	return SOF_IPC_FRAME_S32_LE;
-}
-
-/*
- * Standard Kcontrols.
- */
-
-static int sof_control_load_volume(struct snd_soc_component *scomp,
-				   struct snd_sof_control *scontrol,
-				   struct snd_kcontrol_new *kc,
-				   struct snd_soc_tplg_ctl_hdr *hdr)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_tplg_mixer_control *mc =
-		(struct snd_soc_tplg_mixer_control *)hdr;
-	struct sof_ipc_ctrl_data *cdata;
-
-	/* validate topology data */
-	if (mc->num_channels >= SND_SOC_TPLG_MAX_CHAN)
-		return -EINVAL;
-
-	/* init the volume get/put data */
-	scontrol->size = sizeof(struct sof_ipc_ctrl_data) +
-		sizeof(struct sof_ipc_ctrl_value_chan) * mc->num_channels;
-	scontrol->control_data = kzalloc(scontrol->size, GFP_KERNEL);
-	cdata = scontrol->control_data;
-	if (!scontrol->control_data)
-		return -ENOMEM;
-
-	scontrol->comp_id = sdev->next_comp_id;
-	scontrol->num_channels = mc->num_channels;
-
-	dev_dbg(sdev->dev, "tplg: load kcontrol index %d chans %d\n",
-		scontrol->comp_id, scontrol->num_channels);
-
-	return 0;
-	/* configure channel IDs */
-	//for (i = 0; i < mc->num_channels; i++) {
-	//	v.pcm.chmap[i] = mc->channel[i].id;
-	//}
-}
-
-struct sof_topology_token {
-	u32 token;
-	u32 type;
-	int (*get_token)(void *elem, void *object, u32 offset, u32 size);
-	u32 offset;
-	u32 size;
-};
-
-static int get_token_u32(void *elem, void *object, u32 offset, u32 size)
-{
-	struct snd_soc_tplg_vendor_value_elem *velem = elem;
-	u32 *val = object + offset;
-
-	*val = velem->value;
-	return 0;
-}
-
-static int get_token_comp_format(void *elem, void *object, u32 offset, u32 size)
-{
-	struct snd_soc_tplg_vendor_string_elem *velem = elem;
-	u32 *val = object + offset;
-
-	*val = find_format(velem->string);
-	return 0;
-}
-
-static int get_token_dai_type(void *elem, void *object, u32 offset, u32 size)
-{
-	struct snd_soc_tplg_vendor_string_elem *velem = elem;
-	u32 *val = object + offset;
-
-	*val = find_dai(velem->string);
-	return 0;
-}
-
-/* Buffers */
-static const struct sof_topology_token buffer_tokens[] = {
-	{SOF_TKN_BUF_SIZE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_buffer, size), 0},
-	{SOF_TKN_BUF_CAPS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_buffer, caps), 0},
-};
-
-/* DAI */
-static const struct sof_topology_token dai_tokens[] = {
-	{SOF_TKN_DAI_DMAC, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_comp_dai, dmac_id), 0},
-	{SOF_TKN_DAI_DMAC_CHAN, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_comp_dai, dmac_chan), 0},
-	{SOF_TKN_DAI_DMAC_CONFIG, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_comp_dai, dmac_config), 0},
-	{SOF_TKN_DAI_TYPE, SND_SOC_TPLG_TUPLE_TYPE_STRING, get_token_dai_type,
-		offsetof(struct sof_ipc_comp_dai, type), 0},
-	{SOF_TKN_DAI_INDEX, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_comp_dai, index), 0},
-};
-
-/* BE DAI link */
-static const struct sof_topology_token dai_link_tokens[] = {
-	{SOF_TKN_DAI_TYPE, SND_SOC_TPLG_TUPLE_TYPE_STRING, get_token_dai_type,
-		offsetof(struct sof_ipc_dai_config, type), 0},
-	{SOF_TKN_DAI_SAMPLE_BITS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_dai_config, sample_valid_bits), 0},
-};
-
-/* scheduling */
-static const struct sof_topology_token sched_tokens[] = {
-	{SOF_TKN_SCHED_DEADLINE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_pipe_new, deadline), 0},
-	{SOF_TKN_SCHED_PRIORITY, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_pipe_new, priority), 0},
-	{SOF_TKN_SCHED_MIPS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_pipe_new, mips), 0},
-	{SOF_TKN_SCHED_CORE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_pipe_new, core), 0},
-	{SOF_TKN_SCHED_FRAMES, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_pipe_new, frames_per_sched), 0},
-	{SOF_TKN_SCHED_TIMER, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_pipe_new, timer), 0},
-};
-
-/* volume */
-static const struct sof_topology_token volume_tokens[] = {
-	{SOF_TKN_VOLUME_RAMP_STEP_TYPE, SND_SOC_TPLG_TUPLE_TYPE_WORD,
-		get_token_u32, offsetof(struct sof_ipc_comp_volume, ramp), 0},
-	{SOF_TKN_VOLUME_RAMP_STEP_MS,
-		SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_comp_volume, initial_ramp), 0},
-};
-
-/* SRC */
-static const struct sof_topology_token src_tokens[] = {
-	{SOF_TKN_SRC_RATE_IN, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_comp_src, source_rate), 0},
-	{SOF_TKN_SRC_RATE_OUT, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_comp_src, sink_rate), 0},
-};
-
-/* Tone */
-static const struct sof_topology_token tone_tokens[] = {
-};
-
-/* PCM */
-static const struct sof_topology_token pcm_tokens[] = {
-	{SOF_TKN_PCM_DMAC, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_comp_host, dmac_id), 0},
-	{SOF_TKN_PCM_DMAC_CHAN, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_comp_host, dmac_chan), 0},
-	{SOF_TKN_PCM_DMAC_CONFIG, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_comp_host, dmac_config), 0},
-};
-
-/* Generic components */
-static const struct sof_topology_token comp_tokens[] = {
-	{SOF_TKN_COMP_PERIOD_SINK_COUNT,
-		SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_comp_config, periods_sink), 0},
-	{SOF_TKN_COMP_PERIOD_SOURCE_COUNT,
-		SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_comp_config, periods_source), 0},
-	{SOF_TKN_COMP_FORMAT,
-		SND_SOC_TPLG_TUPLE_TYPE_STRING, get_token_comp_format,
-		offsetof(struct sof_ipc_comp_config, frame_fmt), 0},
-	{SOF_TKN_COMP_PRELOAD_COUNT,
-		SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
-		offsetof(struct sof_ipc_comp_config, preload_count), 0},
-};
-
-/* SSP */
-static const struct sof_topology_token ssp_tokens[] = {
-};
-
-/* DMIC */
-static const struct sof_topology_token dmic_tokens[] = {
-};
-
-/* HDA */
-static const struct sof_topology_token hda_tokens[] = {
-};
-
-static void sof_parse_uuid_tokens(struct snd_soc_component *scomp,
-				  void *object,
-				  const struct sof_topology_token *tokens,
-				  int count,
-				  struct snd_soc_tplg_vendor_array *array)
-{
-	struct snd_soc_tplg_vendor_uuid_elem *elem;
-	int i, j;
-
-	/* parse element by element */
-	for (i = 0; i < array->num_elems; i++) {
-		elem = &array->uuid[i];
-
-		/* search for token */
-		for (j = 0; j < count; j++) {
-			/* match token type */
-			if (tokens[j].type != SND_SOC_TPLG_TUPLE_TYPE_UUID)
-				continue;
-
-			/* match token id */
-			if (tokens[j].token != elem->token)
-				continue;
-
-			/* matched - now load token */
-			tokens[j].get_token(elem, object, tokens[j].offset,
-					    tokens[j].size);
-		}
-	}
-}
-
-static void sof_parse_string_tokens(struct snd_soc_component *scomp,
-				    void *object,
-				    const struct sof_topology_token *tokens,
-				    int count,
-				    struct snd_soc_tplg_vendor_array *array)
-{
-	struct snd_soc_tplg_vendor_string_elem *elem;
-	int i, j;
-
-	/* parse element by element */
-	for (i = 0; i < array->num_elems; i++) {
-		elem = &array->string[i];
-
-		/* search for token */
-		for (j = 0; j < count; j++) {
-			/* match token type */
-			if (tokens[j].type != SND_SOC_TPLG_TUPLE_TYPE_STRING)
-				continue;
-
-			/* match token id */
-			if (tokens[j].token != elem->token)
-				continue;
-
-			/* matched - now load token */
-			tokens[j].get_token(elem, object, tokens[j].offset,
-					    tokens[j].size);
-		}
-	}
-}
-
-static void sof_parse_word_tokens(struct snd_soc_component *scomp,
-				  void *object,
-				  const struct sof_topology_token *tokens,
-				  int count,
-				  struct snd_soc_tplg_vendor_array *array)
-{
-	struct snd_soc_tplg_vendor_value_elem *elem;
-	int i, j;
-
-	/* parse element by element */
-	for (i = 0; i < array->num_elems; i++) {
-		elem = &array->value[i];
-
-		/* search for token */
-		for (j = 0; j < count; j++) {
-			/* match token type */
-			if (tokens[j].type != SND_SOC_TPLG_TUPLE_TYPE_WORD)
-				continue;
-
-			/* match token id */
-			if (tokens[j].token != elem->token)
-				continue;
-
-			/* matched - now load token */
-			tokens[j].get_token(elem, object, tokens[j].offset,
-					    tokens[j].size);
-		}
-	}
-}
-
-static void sof_parse_tokens(struct snd_soc_component *scomp,
-			     void *object,
-			     const struct sof_topology_token *tokens,
-			     int count,
-			     struct snd_soc_tplg_vendor_array *array,
-			     int priv_size)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	int asize;
-
-	while (priv_size > 0) {
-		asize = array->size;
-
-		if (asize < 0) {
-			dev_err(sdev->dev, "error: invalid array size 0x%x\n",
-				asize);
-			return;
-		}
-
-		/* call correct parser depending on type */
-		switch (array->type) {
-		case SND_SOC_TPLG_TUPLE_TYPE_UUID:
-			sof_parse_uuid_tokens(scomp, object, tokens, count,
-					      array);
-			break;
-		case SND_SOC_TPLG_TUPLE_TYPE_STRING:
-			sof_parse_string_tokens(scomp, object, tokens, count,
-						array);
-			break;
-		case SND_SOC_TPLG_TUPLE_TYPE_BOOL:
-		case SND_SOC_TPLG_TUPLE_TYPE_BYTE:
-		case SND_SOC_TPLG_TUPLE_TYPE_WORD:
-		case SND_SOC_TPLG_TUPLE_TYPE_SHORT:
-			sof_parse_word_tokens(scomp, object, tokens, count,
-					      array);
-			break;
-		default:
-			dev_err(sdev->dev, "error: unknown token type %d\n",
-				array->type);
-			break;
-		}
-
-		/* next array */
-		array = (void *)array + asize;
-		/* update and validate remained size */
-		priv_size -= asize;
-	}
-}
-
-static void sof_dbg_comp_config(struct snd_soc_component *scomp,
-				struct sof_ipc_comp_config *config)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-
-	dev_dbg(sdev->dev, " config: periods snk %d src %d fmt %d\n",
-		config->periods_sink, config->periods_source,
-		config->frame_fmt);
-}
-
-/* external kcontrol init - used for any driver specific init */
-static int sof_control_load(struct snd_soc_component *scomp, int index,
-			    struct snd_kcontrol_new *kc,
-			    struct snd_soc_tplg_ctl_hdr *hdr)
-{
-	struct soc_mixer_control *sm;
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_dobj *dobj = NULL;
-	struct snd_sof_control *scontrol;
-	int ret = -EINVAL;
-
-	dev_dbg(sdev->dev, "tplg: load control type %d name : %s\n",
-		hdr->type, hdr->name);
-
-	scontrol = kzalloc(sizeof(*scontrol), GFP_KERNEL);
-	if (!scontrol)
-		return -ENOMEM;
-
-	scontrol->sdev = sdev;
-	mutex_init(&scontrol->mutex);
-
-	switch (hdr->ops.info) {
-	case SND_SOC_TPLG_CTL_VOLSW:
-	case SND_SOC_TPLG_CTL_VOLSW_SX:
-	case SND_SOC_TPLG_CTL_VOLSW_XR_SX:
-		sm = (struct soc_mixer_control *)kc->private_value;
-		dobj = &sm->dobj;
-		ret = sof_control_load_volume(scomp, scontrol, kc, hdr);
-		break;
-	case SND_SOC_TPLG_CTL_ENUM:
-	case SND_SOC_TPLG_CTL_BYTES:
-	case SND_SOC_TPLG_CTL_ENUM_VALUE:
-	case SND_SOC_TPLG_CTL_RANGE:
-	case SND_SOC_TPLG_CTL_STROBE:
-	case SND_SOC_TPLG_DAPM_CTL_VOLSW:
-	case SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:
-	case SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:
-	case SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE:
-	case SND_SOC_TPLG_DAPM_CTL_PIN:
-	default:
-		dev_warn(sdev->dev, "control type not supported %d:%d:%d\n",
-			 hdr->ops.get, hdr->ops.put, hdr->ops.info);
-		return 0;
-	}
-
-	dobj->private = scontrol;
-	list_add(&scontrol->list, &sdev->kcontrol_list);
-	return ret;
-}
-
-static int sof_control_unload(struct snd_soc_component *scomp,
-			      struct snd_soc_dobj *dobj)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct sof_ipc_free fcomp;
-	struct snd_sof_control *scontrol = dobj->private;
-
-	dev_dbg(sdev->dev, "tplg: unload control name : %s\n", scomp->name);
-
-	fcomp.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_COMP_FREE;
-	fcomp.hdr.size = sizeof(fcomp);
-	fcomp.id = scontrol->comp_id;
-
-	/* send IPC to the DSP */
-	return sof_ipc_tx_message(sdev->ipc,
-				  fcomp.hdr.cmd, &fcomp, sizeof(fcomp),
-				  NULL, 0);
-}
-
-/*
- * DAI Topology
- */
-
-static int sof_connect_dai_widget(struct snd_soc_component *scomp,
-				  struct snd_soc_dapm_widget *w,
-				  struct snd_soc_tplg_dapm_widget *tw,
-				  struct snd_sof_dai *dai)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_card *card = scomp->card;
-	struct snd_soc_pcm_runtime *rtd;
-
-	list_for_each_entry(rtd, &card->rtd_list, list) {
-		dev_dbg(sdev->dev, "tplg: check widget: %s stream: %s dai stream: %s\n",
-			w->name,  w->sname, rtd->dai_link->stream_name);
-
-		if (!w->sname || !rtd->dai_link->stream_name)
-			continue;
-
-		/* does stream match DAI link ? */
-		if (strcmp(w->sname, rtd->dai_link->stream_name))
-			continue;
-
-		switch (w->id) {
-		case snd_soc_dapm_dai_out:
-			rtd->cpu_dai->capture_widget = w;
-			if (dai)
-				dai->name = rtd->dai_link->name;
-			dev_dbg(sdev->dev, "tplg: connected widget %s -> DAI link %s\n",
-				w->name, rtd->dai_link->name);
-			break;
-		case snd_soc_dapm_dai_in:
-			rtd->cpu_dai->playback_widget = w;
-			if (dai)
-				dai->name = rtd->dai_link->name;
-			dev_dbg(sdev->dev, "tplg: connected widget %s -> DAI link %s\n",
-				w->name, rtd->dai_link->name);
-			break;
-		default:
-			break;
-		}
-	}
-
-	/* check we have a connection */
-	if (!dai->name) {
-		dev_err(sdev->dev, "error: can't connect DAI %s stream %s\n",
-			w->name, w->sname);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int sof_widget_load_dai(struct snd_soc_component *scomp, int index,
-			       struct snd_sof_widget *swidget,
-			       struct snd_soc_tplg_dapm_widget *tw,
-			       struct sof_ipc_comp_reply *r,
-			       struct snd_sof_dai *dai)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_tplg_private *private = &tw->priv;
-	struct sof_ipc_comp_dai comp_dai;
-	int ret;
-
-	/* configure dai IPC message */
-	memset(&comp_dai, 0, sizeof(comp_dai));
-	comp_dai.comp.hdr.size = sizeof(comp_dai);
-	comp_dai.comp.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_COMP_NEW;
-	comp_dai.comp.id = swidget->comp_id;
-	comp_dai.comp.type = SOF_COMP_DAI;
-	comp_dai.comp.pipeline_id = index;
-
-	sof_parse_tokens(scomp, &comp_dai, dai_tokens,
-			 ARRAY_SIZE(dai_tokens), private->array,
-			 private->size);
-	sof_parse_tokens(scomp, &comp_dai.config, comp_tokens,
-			 ARRAY_SIZE(comp_tokens), private->array,
-			 private->size);
-
-	dev_dbg(sdev->dev, "dai %s: dmac %d chan %d type %d index %d\n",
-		swidget->widget->name, comp_dai.dmac_id, comp_dai.dmac_chan,
-		comp_dai.type, comp_dai.index);
-	sof_dbg_comp_config(scomp, &comp_dai.config);
-
-	ret = sof_ipc_tx_message(sdev->ipc, comp_dai.comp.hdr.cmd,
-				 &comp_dai, sizeof(comp_dai), r, sizeof(*r));
-
-	if (ret == 0 && dai) {
-		dai->sdev = sdev;
-		memcpy(&dai->comp_dai, &comp_dai, sizeof(comp_dai));
-	}
-
-	return ret;
-}
-
-/*
- * Buffer topology
- */
-
-static int sof_widget_load_buffer(struct snd_soc_component *scomp, int index,
-				  struct snd_sof_widget *swidget,
-				  struct snd_soc_tplg_dapm_widget *tw,
-				  struct sof_ipc_comp_reply *r)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_tplg_private *private = &tw->priv;
-	struct sof_ipc_buffer buffer;
-
-	/* configure dai IPC message */
-	memset(&buffer, 0, sizeof(buffer));
-	buffer.comp.hdr.size = sizeof(buffer);
-	buffer.comp.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_BUFFER_NEW;
-	buffer.comp.id = swidget->comp_id;
-	buffer.comp.type = SOF_COMP_BUFFER;
-	buffer.comp.pipeline_id = index;
-
-	sof_parse_tokens(scomp, &buffer, buffer_tokens,
-			 ARRAY_SIZE(buffer_tokens), private->array,
-			 private->size);
-
-	dev_dbg(sdev->dev, "buffer %s: size %d caps 0x%x\n",
-		swidget->widget->name, buffer.size, buffer.caps);
-
-	return sof_ipc_tx_message(sdev->ipc,
-				  buffer.comp.hdr.cmd, &buffer, sizeof(buffer),
-				  r, sizeof(*r));
-}
-
-/*
- * PCM Topology
- */
-
-static int sof_widget_load_pcm(struct snd_soc_component *scomp, int index,
-			       struct snd_sof_widget *swidget,
-			       enum sof_ipc_stream_direction dir,
-			       struct snd_soc_tplg_dapm_widget *tw,
-			       struct sof_ipc_comp_reply *r)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_tplg_private *private = &tw->priv;
-	struct sof_ipc_comp_host host;
-
-	/* configure mixer IPC message */
-	memset(&host, 0, sizeof(host));
-	host.comp.hdr.size = sizeof(host);
-	host.comp.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_COMP_NEW;
-	host.comp.id = swidget->comp_id;
-	host.comp.type = SOF_COMP_HOST;
-	host.comp.pipeline_id = index;
-	host.direction = dir;
-
-	sof_parse_tokens(scomp, &host, pcm_tokens,
-			 ARRAY_SIZE(pcm_tokens), private->array, private->size);
-	sof_parse_tokens(scomp, &host.config, comp_tokens,
-			 ARRAY_SIZE(comp_tokens), private->array,
-			 private->size);
-
-	dev_dbg(sdev->dev, "host %s: dmac %d chan %d\n",
-		swidget->widget->name, host.dmac_id, host.dmac_chan);
-	sof_dbg_comp_config(scomp, &host.config);
-
-	return sof_ipc_tx_message(sdev->ipc,
-				  host.comp.hdr.cmd, &host, sizeof(host), r,
-				  sizeof(*r));
-}
-
-/*
- * Pipeline Topology
- */
-
-static int sof_widget_load_pipeline(struct snd_soc_component *scomp,
-				    int index, struct snd_sof_widget *swidget,
-				    struct snd_soc_tplg_dapm_widget *tw,
-				    struct sof_ipc_comp_reply *r)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_tplg_private *private = &tw->priv;
-	struct sof_ipc_pipe_new pipeline;
-	struct snd_sof_widget *comp_swidget;
-
-	/* configure dai IPC message */
-	memset(&pipeline, 0, sizeof(pipeline));
-	pipeline.hdr.size = sizeof(pipeline);
-	pipeline.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_PIPE_NEW;
-	pipeline.pipeline_id = index;
-	pipeline.comp_id = swidget->comp_id;
-
-	/* component at start of pipeline is our stream id */
-	comp_swidget = snd_sof_find_swidget(sdev, tw->sname);
-	if (!comp_swidget) {
-		dev_err(sdev->dev, "error: widget %s refers to non existent widget %s\n",
-			tw->name, tw->sname);
-		return -EINVAL;
-	}
-
-	pipeline.sched_id = comp_swidget->comp_id;
-
-	dev_dbg(sdev->dev, "tplg: pipeline id %d comp %d scheduling comp id %d\n",
-		pipeline.pipeline_id, pipeline.comp_id, pipeline.sched_id);
-
-	sof_parse_tokens(scomp, &pipeline, sched_tokens,
-			 ARRAY_SIZE(sched_tokens), private->array,
-			 private->size);
-
-	dev_dbg(sdev->dev, "pipeline %s: deadline %d pri %d mips %d core %d frames %d\n",
-		swidget->widget->name, pipeline.deadline, pipeline.priority,
-		pipeline.mips, pipeline.core, pipeline.frames_per_sched);
-
-	return sof_ipc_tx_message(sdev->ipc,
-				  pipeline.hdr.cmd, &pipeline, sizeof(pipeline),
-				  r, sizeof(*r));
-}
-
-/*
- * Mixer topology
- */
-
-static int sof_widget_load_mixer(struct snd_soc_component *scomp, int index,
-				 struct snd_sof_widget *swidget,
-				 struct snd_soc_tplg_dapm_widget *tw,
-				 struct sof_ipc_comp_reply *r)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_tplg_private *private = &tw->priv;
-	struct sof_ipc_comp_mixer mixer;
-
-	/* configure mixer IPC message */
-	memset(&mixer, 0, sizeof(mixer));
-	mixer.comp.hdr.size = sizeof(mixer);
-	mixer.comp.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_COMP_NEW;
-	mixer.comp.id = swidget->comp_id;
-	mixer.comp.type = SOF_COMP_MIXER;
-	mixer.comp.pipeline_id = index;
-
-	//sof_parse_tokens(scomp, &mixer, comp_tokens,
-	//	ARRAY_SIZE(comp_tokens), private->array, private->size);
-	sof_parse_tokens(scomp, &mixer.config, comp_tokens,
-			 ARRAY_SIZE(comp_tokens), private->array,
-			 private->size);
-
-	sof_dbg_comp_config(scomp, &mixer.config);
-	return sof_ipc_tx_message(sdev->ipc,
-				  mixer.comp.hdr.cmd, &mixer, sizeof(mixer), r,
-				  sizeof(*r));
-}
-
-/*
- * PGA Topology
- */
-
-static int sof_widget_load_pga(struct snd_soc_component *scomp, int index,
-			       struct snd_sof_widget *swidget,
-			       struct snd_soc_tplg_dapm_widget *tw,
-			       struct sof_ipc_comp_reply *r)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_tplg_private *private = &tw->priv;
-	struct sof_ipc_comp_volume volume;
-
-	if (tw->num_kcontrols != 1) {
-		dev_err(sdev->dev, "error: invalid kcontrol count %d for volume\n",
-			tw->num_kcontrols);
-		return -EINVAL;
-	}
-
-	/* configure dai IPC message */
-	memset(&volume, 0, sizeof(volume));
-	volume.comp.hdr.size = sizeof(volume);
-	volume.comp.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_COMP_NEW;
-	volume.comp.id = swidget->comp_id;
-	volume.comp.type = SOF_COMP_VOLUME;
-	volume.comp.pipeline_id = index;
-
-	sof_parse_tokens(scomp, &volume, volume_tokens,
-			 ARRAY_SIZE(volume_tokens), private->array,
-			 private->size);
-	sof_parse_tokens(scomp, &volume.config, comp_tokens,
-			 ARRAY_SIZE(comp_tokens), private->array,
-			 private->size);
-	sof_dbg_comp_config(scomp, &volume.config);
-
-	return sof_ipc_tx_message(sdev->ipc,
-				  volume.comp.hdr.cmd, &volume, sizeof(volume),
-				  r, sizeof(*r));
-}
-
-/*
- * SRC Topology
- */
-
-static int sof_widget_load_src(struct snd_soc_component *scomp, int index,
-			       struct snd_sof_widget *swidget,
-			       struct snd_soc_tplg_dapm_widget *tw,
-			       struct sof_ipc_comp_reply *r)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_tplg_private *private = &tw->priv;
-	struct sof_ipc_comp_src src;
-
-	/* configure mixer IPC message */
-	memset(&src, 0, sizeof(src));
-	src.comp.hdr.size = sizeof(src);
-	src.comp.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_COMP_NEW;
-	src.comp.id = swidget->comp_id;
-	src.comp.type = SOF_COMP_SRC;
-	src.comp.pipeline_id = index;
-
-	sof_parse_tokens(scomp, &src, src_tokens,
-			 ARRAY_SIZE(src_tokens), private->array, private->size);
-	sof_parse_tokens(scomp, &src.config, comp_tokens,
-			 ARRAY_SIZE(comp_tokens), private->array,
-			 private->size);
-
-	dev_dbg(sdev->dev, "src %s: source rate %d sink rate %d\n",
-		swidget->widget->name, src.source_rate, src.sink_rate);
-	sof_dbg_comp_config(scomp, &src.config);
-
-	return sof_ipc_tx_message(sdev->ipc,
-				  src.comp.hdr.cmd, &src, sizeof(src), r,
-				  sizeof(*r));
-}
-
-/*
- * Signal Generator Topology
- */
-
-static int sof_widget_load_siggen(struct snd_soc_component *scomp, int index,
-				  struct snd_sof_widget *swidget,
-				  struct snd_soc_tplg_dapm_widget *tw,
-				  struct sof_ipc_comp_reply *r)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_tplg_private *private = &tw->priv;
-	struct sof_ipc_comp_tone tone;
-
-	/* configure mixer IPC message */
-	memset(&tone, 0, sizeof(tone));
-	tone.comp.hdr.size = sizeof(tone);
-	tone.comp.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_COMP_NEW;
-	tone.comp.id = swidget->comp_id;
-	tone.comp.type = SOF_COMP_TONE;
-	tone.comp.pipeline_id = index;
-
-	sof_parse_tokens(scomp, &tone, tone_tokens,
-			 ARRAY_SIZE(tone_tokens), private->array,
-			 private->size);
-	sof_parse_tokens(scomp, &tone.config, comp_tokens,
-			 ARRAY_SIZE(comp_tokens), private->array,
-			 private->size);
-
-	dev_dbg(sdev->dev, "tone %s: frequency %d amplitude %d\n",
-		swidget->widget->name, tone.frequency, tone.amplitude);
-	sof_dbg_comp_config(scomp, &tone.config);
-
-	return sof_ipc_tx_message(sdev->ipc,
-				  tone.comp.hdr.cmd, &tone, sizeof(tone), r,
-				  sizeof(*r));
-}
-
-/*
- * Generic widget loader.
- */
-
-static int sof_widget_load(struct snd_soc_component *scomp, int index,
-			   struct snd_soc_dapm_widget *w,
-			   struct snd_soc_tplg_dapm_widget *tw)
-{
-	return 0;
-}
-
-/* external widget init - used for any driver specific init */
-static int sof_widget_ready(struct snd_soc_component *scomp, int index,
-			    struct snd_soc_dapm_widget *w,
-			    struct snd_soc_tplg_dapm_widget *tw)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_sof_widget *swidget;
-	struct snd_sof_dai *dai;
-	struct sof_ipc_comp_reply reply;
-	struct snd_sof_control *scontrol = NULL;
-	int ret = 0;
-
-	swidget = kzalloc(sizeof(*swidget), GFP_KERNEL);
-	if (!swidget)
-		return -ENOMEM;
-
-	swidget->sdev = sdev;
-	swidget->widget = w;
-	swidget->comp_id = sdev->next_comp_id++;
-	swidget->complete = 0;
-	swidget->id = w->id;
-	swidget->pipeline_id = index;
-	swidget->private = NULL;
-	memset(&reply, 0, sizeof(reply));
-
-	dev_dbg(sdev->dev, "tplg: ready widget id %d pipe %d type %d name : %s stream %s\n",
-		swidget->comp_id, index, tw->id, tw->name,
-		tw->sname ? tw->sname : "none");
-
-	/* handle any special case widgets */
-	switch (w->id) {
-	case snd_soc_dapm_dai_in:
-	case snd_soc_dapm_dai_out:
-		dai = kzalloc(sizeof(*dai), GFP_KERNEL);
-		if (!dai)
-			return -ENOMEM;
-
-		ret = sof_widget_load_dai(scomp, index, swidget, tw, &reply,
-					  dai);
-		if (ret == 0) {
-			sof_connect_dai_widget(scomp, w, tw, dai);
-			list_add(&dai->list, &sdev->dai_list);
-			swidget->private = dai;
-		} else {
-			kfree(dai);
-		}
-		break;
-	case snd_soc_dapm_mixer:
-		ret = sof_widget_load_mixer(scomp, index, swidget, tw, &reply);
-		break;
-	case snd_soc_dapm_pga:
-		ret = sof_widget_load_pga(scomp, index, swidget, tw, &reply);
-		/* Find scontrol for this pga and set readback offset*/
-		list_for_each_entry(scontrol, &sdev->kcontrol_list, list) {
-			if (scontrol->comp_id == swidget->comp_id) {
-				scontrol->readback_offset = reply.offset;
-				break;
-			}
-		}
-		break;
-	case snd_soc_dapm_buffer:
-		ret = sof_widget_load_buffer(scomp, index, swidget, tw, &reply);
-		break;
-	case snd_soc_dapm_scheduler:
-		ret = sof_widget_load_pipeline(scomp, index, swidget, tw,
-					       &reply);
-		break;
-	case snd_soc_dapm_aif_out:
-		ret = sof_widget_load_pcm(scomp, index, swidget,
-					  SOF_IPC_STREAM_CAPTURE, tw, &reply);
-		break;
-	case snd_soc_dapm_aif_in:
-		ret = sof_widget_load_pcm(scomp, index, swidget,
-					  SOF_IPC_STREAM_PLAYBACK, tw, &reply);
-		break;
-	case snd_soc_dapm_src:
-		ret = sof_widget_load_src(scomp, index, swidget, tw, &reply);
-		break;
-	case snd_soc_dapm_siggen:
-		ret = sof_widget_load_siggen(scomp, index, swidget, tw, &reply);
-		break;
-	case snd_soc_dapm_mux:
-	case snd_soc_dapm_demux:
-	case snd_soc_dapm_switch:
-	case snd_soc_dapm_dai_link:
-	case snd_soc_dapm_kcontrol:
-	case snd_soc_dapm_effect:
-	default:
-		dev_warn(sdev->dev, "warning: widget type %d name %s not handled\n",
-			 tw->id, tw->name);
-		break;
-	}
-
-	/* check IPC reply */
-	if (ret < 0 || reply.rhdr.error < 0) {
-		dev_err(sdev->dev,
-			"error: DSP failed to add widget id %d type %d name : %s stream %s reply %d\n",
-			tw->shift, tw->id, tw->name,
-			tw->sname ? tw->sname : "none", reply.rhdr.error);
-		return ret;
-	}
-
-	w->dobj.private = swidget;
-	mutex_init(&swidget->mutex);
-	list_add(&swidget->list, &sdev->widget_list);
-	return ret;
-}
-
-static int sof_widget_unload(struct snd_soc_component *scomp,
-			     struct snd_soc_dobj *dobj)
-{
-	struct snd_sof_widget *swidget;
-	struct snd_sof_dai *dai;
-
-	swidget = dobj->private;
-	if (!swidget)
-		return 0;
-
-	dai = swidget->private;
-
-	/* remove and free dai object */
-	if (dai) {
-		list_del(&dai->list);
-		kfree(dai);
-	}
-
-	/* remove and free swidget object */
-	list_del(&swidget->list);
-	kfree(swidget);
-
-	return 0;
-}
-
-/* FE DAI - used for any driver specific init */
-static int sof_dai_load(struct snd_soc_component *scomp, int index,
-			struct snd_soc_dai_driver *dai_drv,
-			struct snd_soc_tplg_pcm *pcm, struct snd_soc_dai *dai)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_sof_pcm *spcm;
-
-	/* don't need to do anything for BEs atm */
-	if (!pcm)
-		return 0;
-
-	spcm = kzalloc(sizeof(*spcm), GFP_KERNEL);
-	if (!spcm)
-		return -ENOMEM;
-
-	spcm->sdev = sdev;
-	spcm->stream[SNDRV_PCM_STREAM_PLAYBACK].comp_id = COMP_ID_UNASSIGNED;
-	spcm->stream[SNDRV_PCM_STREAM_CAPTURE].comp_id = COMP_ID_UNASSIGNED;
-	if (pcm) {
-		spcm->pcm = *pcm;
-		dev_dbg(sdev->dev, "tplg: load pcm %s\n", pcm->dai_name);
-	}
-	dai_drv->dobj.private = spcm;
-	mutex_init(&spcm->mutex);
-	list_add(&spcm->list, &sdev->pcm_list);
-
-	return 0;
-}
-
-static int sof_dai_unload(struct snd_soc_component *scomp,
-			  struct snd_soc_dobj *dobj)
-{
-	struct snd_sof_pcm *spcm = dobj->private;
-
-	list_del(&spcm->list);
-	kfree(spcm);
-
-	return 0;
-}
-
-static int sof_link_ssp_load(struct snd_soc_component *scomp, int index,
-			     struct snd_soc_dai_link *link,
-			     struct snd_soc_tplg_link_config *cfg,
-			     struct snd_soc_tplg_hw_config *hw_config,
-			     struct sof_ipc_dai_config *config_template)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_tplg_private *private = &cfg->priv;
-	struct sof_ipc_dai_config *config;
-	struct sof_ipc_reply reply;
-	u32 size = sizeof(*config) +
-		sizeof(struct sof_ipc_dai_ssp_params);
-	int ret;
-
-	config = kzalloc(size, GFP_KERNEL);
-	if (!config)
-		return -ENOMEM;
-
-	/* init IPC */
-	*config = *config_template;
-	memset(&config->ssp[0], 0, sizeof(struct sof_ipc_dai_ssp_params));
-	config->hdr.size = size;
-
-	/* get any bespoke DAI tokens */
-	sof_parse_tokens(scomp, config, ssp_tokens,
-			 ARRAY_SIZE(ssp_tokens), private->array, private->size);
-
-	dev_dbg(sdev->dev, "tplg: config SSP%d fmt 0x%x mclk %d bclk %d fclk %d width (%d)%d slots %d\n",
-		config->id, config->format, config->mclk, config->bclk,
-		config->fclk, config->sample_valid_bits,
-		config->sample_container_bits, config->num_slots);
-
-	/* send message to DSP */
-	ret = sof_ipc_tx_message(sdev->ipc,
-				 config->hdr.cmd, config, size, &reply,
-				 sizeof(reply));
-
-	if (ret < 0)
-		dev_err(sdev->dev, "error: failed to set DAI config for SSP%d\n",
-			config->id);
-
-	kfree(config);
-	return ret;
-}
-
-static int sof_link_dmic_load(struct snd_soc_component *scomp, int index,
-			      struct snd_soc_dai_link *link,
-			      struct snd_soc_tplg_link_config *cfg,
-			      struct snd_soc_tplg_hw_config *hw_config,
-			      struct sof_ipc_dai_config *config_template)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_tplg_private *private = &cfg->priv;
-	struct sof_ipc_dai_config *config;
-	struct sof_ipc_reply reply;
-	u32 size = sizeof(*config) +
-		sizeof(struct sof_ipc_dai_dmic_params);
-	int ret;
-
-	config = kzalloc(size, GFP_KERNEL);
-	if (!config)
-		return -ENOMEM;
-
-	/* init IPC */
-	*config = *config_template;
-	memset(&config->dmic[0], 0, sizeof(struct sof_ipc_dai_dmic_params));
-	config->hdr.size = size;
-
-	/* get any bespoke DAI tokens */
-	sof_parse_tokens(scomp, config, dmic_tokens,
-			 ARRAY_SIZE(dmic_tokens), private->array,
-			 private->size);
-
-	dev_dbg(sdev->dev, "tplg: config DMIC%d fmt 0x%x mclk %d bclk %d fclk %d width %d slots %d\n",
-		config->id, config->format, config->mclk, config->bclk,
-		config->fclk, config->sample_container_bits, config->num_slots);
-
-	/* send message to DSP */
-	ret = sof_ipc_tx_message(sdev->ipc,
-				 config->hdr.cmd, config, size, &reply,
-				 sizeof(reply));
-
-	if (ret < 0)
-		dev_err(sdev->dev, "error: failed to set DAI config for DMIC%d\n",
-			config->id);
-
-	kfree(config);
-	return ret;
-}
-
-static int sof_link_hda_load(struct snd_soc_component *scomp, int index,
-			     struct snd_soc_dai_link *link,
-			     struct snd_soc_tplg_link_config *cfg,
-			     struct snd_soc_tplg_hw_config *hw_config,
-			     struct sof_ipc_dai_config *config_template)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_tplg_private *private = &cfg->priv;
-	struct sof_ipc_dai_config *config;
-	struct sof_ipc_reply reply;
-	u32 size = sizeof(*config) +
-		sizeof(struct sof_ipc_dai_hda_params);
-	int ret;
-
-	config = kzalloc(size, GFP_KERNEL);
-	if (!config)
-		return -ENOMEM;
-
-	/* init IPC */
-	*config = *config_template;
-	memset(&config->hda[0], 0, sizeof(struct sof_ipc_dai_hda_params));
-	config->hdr.size = size;
-
-	/* get any bespoke DAI tokens */
-	sof_parse_tokens(scomp, config, hda_tokens,
-			 ARRAY_SIZE(hda_tokens), private->array, private->size);
-
-	dev_dbg(sdev->dev, "tplg: config HDA%d fmt 0x%x mclk %d bclk %d fclk %d width %d slots %d\n",
-		config->id, config->format, config->mclk, config->bclk,
-		config->fclk, config->sample_container_bits, config->num_slots);
-
-	/* send message to DSP */
-	ret = sof_ipc_tx_message(sdev->ipc,
-				 config->hdr.cmd, config, size, &reply,
-				 sizeof(reply));
-
-	if (ret < 0)
-		dev_err(sdev->dev, "error: failed to set DAI config for HDA%d\n",
-			config->id);
-
-	kfree(config);
-	return ret;
-}
-
-/* DAI link - used for any driver specific init */
-static int sof_link_load(struct snd_soc_component *scomp, int index,
-			 struct snd_soc_dai_link *link,
-			 struct snd_soc_tplg_link_config *cfg)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_soc_tplg_private *private = &cfg->priv;
-	struct sof_ipc_dai_config config;
-	struct snd_soc_tplg_hw_config *hw_config;
-	struct snd_sof_dai *dai;
-	int ret = 0;
-
-	link->platform_name = "sof-audio";
-	link->nonatomic = true;
-
-	/* send BE configurations to DSP */
-	if (!link->no_pcm)
-		return 0;
-
-	/* only support 1 config atm */
-	if (cfg->num_hw_configs != 1) {
-		dev_err(sdev->dev, "error: unexpected DAI config count %d\n",
-			cfg->num_hw_configs);
-		return -EINVAL;
-	}
-
-	/* check we have some tokens - we need at least DAI type */
-	if (private->size == 0) {
-		dev_err(sdev->dev, "error: expected tokens for DAI, none found\n");
-		return -EINVAL;
-	}
-
-	memset(&config, 0, sizeof(config));
-
-	/* get any common DAI tokens */
-	sof_parse_tokens(scomp, &config, dai_link_tokens,
-			 ARRAY_SIZE(dai_link_tokens), private->array,
-			 private->size);
-
-	/* configure dai IPC message */
-	hw_config = &cfg->hw_config[0];
-
-	config.hdr.cmd = SOF_IPC_GLB_DAI_MSG | SOF_IPC_DAI_CONFIG;
-	config.id = hw_config->id;
-	config.format = hw_config->fmt;
-	config.mclk = hw_config->mclk_rate;
-	config.bclk = hw_config->bclk_rate;
-	config.fclk = hw_config->fsync_rate;
-	config.num_slots = hw_config->tdm_slots;
-	config.sample_container_bits = hw_config->tdm_slot_width;
-	config.mclk_master = hw_config->mclk_direction;
-	config.rx_slot_mask = hw_config->rx_slots;
-	config.tx_slot_mask = hw_config->tx_slots;
-
-	/* clock directions wrt codec */
-	if (hw_config->bclk_master) {
-		/* codec is bclk master */
-		if (hw_config->fsync_master)
-			config.format |= SOF_DAI_FMT_CBM_CFM;
-		else
-			config.format |= SOF_DAI_FMT_CBM_CFS;
-	} else {
-		/* codec is bclk slave */
-		if (hw_config->fsync_master)
-			config.format |= SOF_DAI_FMT_CBS_CFM;
-		else
-			config.format |= SOF_DAI_FMT_CBS_CFS;
-	}
-
-	/* inverted clocks ? */
-	if (hw_config->invert_bclk) {
-		if (hw_config->invert_fsync)
-			config.format |= SOF_DAI_FMT_IB_IF;
-		else
-			config.format |= SOF_DAI_FMT_IB_NF;
-	} else {
-		if (hw_config->invert_fsync)
-			config.format |= SOF_DAI_FMT_NB_IF;
-		else
-			config.format |= SOF_DAI_FMT_NB_NF;
-	}
-
-	/* now load DAI specific data and send IPC - type comes from token */
-	switch (config.type) {
-	case SOF_DAI_INTEL_SSP:
-		ret = sof_link_ssp_load(scomp, index, link, cfg, hw_config,
-					&config);
-		break;
-	case SOF_DAI_INTEL_DMIC:
-		ret = sof_link_dmic_load(scomp, index, link, cfg, hw_config,
-					 &config);
-		break;
-	case SOF_DAI_INTEL_HDA:
-		ret = sof_link_hda_load(scomp, index, link, cfg, hw_config,
-					&config);
-		break;
-	default:
-		dev_err(sdev->dev, "error: invalid DAI type %d\n", config.type);
-		ret = -EINVAL;
-		break;
-	}
-
-	dai = snd_sof_find_dai(sdev, (char *)link->name);
-	if (dai)
-		memcpy(&dai->dai_config, &config,
-		       sizeof(struct sof_ipc_dai_config));
-
-	return 0;
-}
-
-static int sof_link_unload(struct snd_soc_component *scomp,
-			   struct snd_soc_dobj *dobj)
-{
-	return 0;
-}
-
-/* bind PCM ID to host component ID */
-static int spcm_bind(struct snd_soc_component *scomp, struct snd_sof_pcm *spcm,
-		     const char *host)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_sof_widget *host_widget;
-
-	host_widget = snd_sof_find_swidget(sdev, (char *)host);
-	if (!host_widget) {
-		dev_err(sdev->dev, "error: can't find host component %s\n",
-			host);
-		return -ENODEV;
-	}
-
-	switch (host_widget->id) {
-	case snd_soc_dapm_aif_in:
-		spcm->stream[SNDRV_PCM_STREAM_PLAYBACK].comp_id =
-			host_widget->comp_id;
-		break;
-	case snd_soc_dapm_aif_out:
-		spcm->stream[SNDRV_PCM_STREAM_CAPTURE].comp_id =
-			host_widget->comp_id;
-		break;
-	default:
-		dev_err(sdev->dev, "error: host is wrong type %d\n",
-			host_widget->id);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-/* DAI link - used for any driver specific init */
-static int sof_route_load(struct snd_soc_component *scomp, int index,
-			  struct snd_soc_dapm_route *route)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct sof_ipc_pipe_comp_connect connect;
-	struct snd_sof_widget *source_swidget, *sink_swidget;
-	struct snd_sof_pcm *spcm;
-	struct sof_ipc_reply reply;
-	int ret;
-
-	memset(&connect, 0, sizeof(connect));
-	connect.hdr.size = sizeof(connect);
-	connect.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_COMP_CONNECT;
-
-	dev_dbg(sdev->dev, "sink %s control %s source %s\n",
-		route->sink, route->control ? route->control : "none",
-		route->source);
-
-	/* source component */
-	source_swidget = snd_sof_find_swidget(sdev, (char *)route->source);
-	if (!source_swidget) {
-		/* don't send any routes to DSP that include a driver PCM */
-		spcm = snd_sof_find_spcm_name(sdev, (char *)route->source);
-		if (spcm)
-			return spcm_bind(scomp, spcm, route->sink);
-
-		dev_err(sdev->dev, "error: source %s not found\n",
-			route->source);
-		return -EINVAL;
-	}
-
-	connect.source_id = source_swidget->comp_id;
-
-	/* sink component */
-	sink_swidget = snd_sof_find_swidget(sdev, (char *)route->sink);
-	if (!sink_swidget) {
-		/* don't send any routes to DSP that include a driver PCM */
-		spcm = snd_sof_find_spcm_name(sdev, (char *)route->sink);
-		if (spcm)
-			return spcm_bind(scomp, spcm, route->source);
-
-		dev_err(sdev->dev, "error: sink %s not found\n",
-			route->sink);
-		return -EINVAL;
-	}
-
-	connect.sink_id = sink_swidget->comp_id;
-
-	ret = sof_ipc_tx_message(sdev->ipc,
-				 connect.hdr.cmd, &connect, sizeof(connect),
-				 &reply, sizeof(reply));
-
-	/* check IPC return value */
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: failed to add route sink %s control %s source %s\n",
-			route->sink, route->control ? route->control : "none",
-			route->source);
-		return ret;
-	}
-
-	/* check IPC reply */
-	if (reply.error < 0) {
-		dev_err(sdev->dev, "error: DSP failed to add route sink %s control %s source %s result %d\n",
-			route->sink, route->control ? route->control : "none",
-			route->source, reply.error);
-		//return ret; // TODO:
-	}
-
-	return ret;
-}
-
-static int sof_route_unload(struct snd_soc_component *scomp,
-			    struct snd_soc_dobj *dobj)
-{
-	return 0;
-}
-
-static int sof_complete_pipeline(struct snd_soc_component *scomp,
-				 struct snd_sof_widget *swidget)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct sof_ipc_pipe_ready ready;
-	struct sof_ipc_reply reply;
-	int ret;
-
-	dev_dbg(sdev->dev, "tplg: complete pipeline %s id %d\n",
-		swidget->widget->name, swidget->comp_id);
-
-	memset(&ready, 0, sizeof(ready));
-	ready.hdr.size = sizeof(ready);
-	ready.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_PIPE_COMPLETE;
-	ready.comp_id = swidget->comp_id;
-
-	ret = sof_ipc_tx_message(sdev->ipc,
-				 ready.hdr.cmd, &ready, sizeof(ready), &reply,
-				 sizeof(reply));
-	if (ret < 0)
-		return ret;
-	return 1;
-}
-
-/* completion - called at completion of firmware loading */
-static void sof_complete(struct snd_soc_component *scomp)
-{
-	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
-	struct snd_sof_widget *swidget;
-
-	/* some widget types require completion notificattion */
-	list_for_each_entry(swidget, &sdev->widget_list, list) {
-		if (swidget->complete)
-			continue;
-
-		switch (swidget->id) {
-		case snd_soc_dapm_scheduler:
-			swidget->complete =
-				sof_complete_pipeline(scomp, swidget);
-			break;
-		default:
-			break;
-		}
-	}
-}
-
-/* manifest - optional to inform component of manifest */
-static int sof_manifest(struct snd_soc_component *scomp, int index,
-			struct snd_soc_tplg_manifest *man)
-{
-	return 0;
-}
-
-/* vendor specific kcontrol handlers available for binding */
-static const struct snd_soc_tplg_kcontrol_ops sof_io_ops[] = {
-	{SOF_TPLG_KCTL_VOL_ID, snd_sof_volume_get, snd_sof_volume_put},
-	{SOF_TPLG_KCTL_ENUM_ID, snd_sof_enum_get, snd_sof_enum_put},
-	{SOF_TPLG_KCTL_BYTES_ID, snd_sof_bytes_get, snd_sof_bytes_put},
-};
-
-/* vendor specific bytes ext handlers available for binding */
-static const struct snd_soc_tplg_bytes_ext_ops sof_bytes_ext_ops[] = {
-{},
-};
-
-static struct snd_soc_tplg_ops sof_tplg_ops = {
-	/* external kcontrol init - used for any driver specific init */
-	.control_load	= sof_control_load,
-	.control_unload	= sof_control_unload,
-
-	/* external kcontrol init - used for any driver specific init */
-	.dapm_route_load	= sof_route_load,
-	.dapm_route_unload	= sof_route_unload,
-
-	/* external widget init - used for any driver specific init */
-	.widget_load	= sof_widget_load,
-	.widget_ready	= sof_widget_ready,
-	.widget_unload	= sof_widget_unload,
-
-	/* FE DAI - used for any driver specific init */
-	.dai_load	= sof_dai_load,
-	.dai_unload	= sof_dai_unload,
-
-	/* DAI link - used for any driver specific init */
-	.link_load	= sof_link_load,
-	.link_unload	= sof_link_unload,
-
-	/* completion - called at completion of firmware loading */
-	.complete	= sof_complete,
-
-	/* manifest - optional to inform component of manifest */
-	.manifest	= sof_manifest,
-
-	/* vendor specific kcontrol handlers available for binding */
-	.io_ops		= sof_io_ops,
-	.io_ops_count	= ARRAY_SIZE(sof_io_ops),
-
-	/* vendor specific bytes ext handlers available for binding */
-	.bytes_ext_ops	= sof_bytes_ext_ops,
-	.bytes_ext_ops_count	= ARRAY_SIZE(sof_bytes_ext_ops),
-};
-
-int snd_sof_init_topology(struct snd_sof_dev *sdev,
-			  struct snd_soc_tplg_ops *ops)
-{
-	/* TODO: support linked list of topologies */
-	sdev->tplg_ops = ops;
-	return 0;
-}
-EXPORT_SYMBOL(snd_sof_init_topology);
-
-int snd_sof_load_topology(struct snd_sof_dev *sdev, const char *file)
-{
-	const struct firmware *fw;
-	struct snd_soc_tplg_hdr *hdr;
-	int ret;
-
-	dev_dbg(sdev->dev, "loading topology:%s\n", file);
-
-	ret = request_firmware(&fw, file, sdev->dev);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: tplg %s load failed with %d\n",
-			file, ret);
-		return ret;
-	}
-
-	hdr = (struct snd_soc_tplg_hdr *)fw->data;
-	ret = snd_soc_tplg_component_load(sdev->component,
-					  &sof_tplg_ops, fw,
-					  SND_SOC_TPLG_INDEX_ALL);
-	if (ret < 0) {
-		dev_err(sdev->dev, "error: tplg component load failed %d\n",
-			ret);
-		ret = -EINVAL;
-	}
-
-	release_firmware(fw);
-	return ret;
-}
-EXPORT_SYMBOL(snd_sof_load_topology);
-
-void snd_sof_free_topology(struct snd_sof_dev *sdev)
-{
-	int ret;
-
-	dev_dbg(sdev->dev, "free topology...\n");
-
-	ret = snd_soc_tplg_component_remove(sdev->component,
-					    SND_SOC_TPLG_INDEX_ALL);
-	if (ret < 0)
-		dev_err(sdev->dev,
-			"error: tplg component free failed %d\n", ret);
-}
-EXPORT_SYMBOL(snd_sof_free_topology);
diff --git a/sound/soc/sof/trace.c b/sound/soc/sof/trace.c
deleted file mode 100644
index dc452ad..0000000
--- a/sound/soc/sof/trace.c
+++ /dev/null
@@ -1,290 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
- *         Yan Wang <yan.wan@linux.intel.com>
- */
-
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/sched/signal.h>
-#include <linux/time.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-#include <linux/platform_device.h>
-#include <linux/firmware.h>
-#include <linux/debugfs.h>
-#include <uapi/sound/sof-ipc.h>
-#include <uapi/sound/sof-fw.h>
-#include "sof-priv.h"
-#include "ops.h"
-
-static int sof_wait_trace_avail(struct snd_sof_dev *sdev, size_t *count,
-				loff_t pos, size_t size)
-{
-	size_t avail;
-	wait_queue_entry_t wait;
-
-	/*
-	 * If host offset is less than local pos, it means write pointer of
-	 * host DMA buffer has been wrapped. We should output the trace data
-	 * at the end of host DMA buffer at first.
-	 */
-	if (sdev->host_offset < pos) {
-		avail = size - pos;
-		goto _host_end;
-	}
-
-	/* If there is available trace data now, it is unnecessary to wait. */
-	if (sdev->host_offset > pos)
-		goto _endcheck;
-
-	/* wait for available trace data from FW */
-	init_waitqueue_entry(&wait, current);
-	set_current_state(TASK_INTERRUPTIBLE);
-	add_wait_queue(&sdev->trace_sleep, &wait);
-
-	if (signal_pending(current)) {
-		remove_wait_queue(&sdev->trace_sleep, &wait);
-		goto _endcheck;
-	}
-
-	/* set timeout to max value, no error code */
-	schedule_timeout(MAX_SCHEDULE_TIMEOUT);
-	remove_wait_queue(&sdev->trace_sleep, &wait);
-
-_endcheck:
-	/* calculate the available count */
-	avail = sdev->host_offset - pos;
-
-_host_end:
-	/* return min value between available and request count */
-	*count = avail < *count ? avail : *count;
-
-	return 0;
-}
-
-static ssize_t sof_dfsentry_trace_read(struct file *file, char __user *buffer,
-				       size_t count, loff_t *ppos)
-{
-	struct snd_sof_dfsentry *dfse = file->private_data;
-	struct snd_sof_dev *sdev = dfse->sdev;
-	int err;
-	loff_t pos = *ppos;
-	loff_t lpos = pos;
-	size_t ret, size;
-
-	size = dfse->size;
-
-	/* check pos and count */
-	if (pos < 0)
-		return -EINVAL;
-	if (!count)
-		return 0;
-
-	/*
-	 * If pos exceeds size, it means host DMA buffer has been wrapped. So
-	 * local pos will be truncated from global pos. It is possible to wrap
-	 * host DMA buffer multiply times when keep output long time, so we
-	 * need one loop to process it.
-	 */
-	while (lpos >= size)
-		lpos -= size;
-
-	if (count > size - lpos)
-		count = size - lpos;
-
-	/* get available count based on current host offset */
-	err = sof_wait_trace_avail(sdev, &count, lpos, size);
-	if (err < 0) {
-		dev_err(sdev->dev,
-			"error: can't get more trace %d\n", err);
-		return 0;
-	}
-
-	/* copy available trace data to debugfs */
-	ret = copy_to_user(buffer, dfse->buf + lpos, count);
-
-	if (ret == count)
-		return -EFAULT;
-	count -= ret;
-
-	/* move debugfs reading position */
-	*ppos = pos + count;
-
-	return count;
-}
-
-static const struct file_operations sof_dfs_trace_fops = {
-	.open = simple_open,
-	.read = sof_dfsentry_trace_read,
-	.llseek = default_llseek,
-};
-
-static int trace_debugfs_create(struct snd_sof_dev *sdev)
-{
-	struct snd_sof_dfsentry *dfse;
-
-	if (!sdev)
-		return -EINVAL;
-
-	dfse = kzalloc(sizeof(*dfse), GFP_KERNEL);
-	if (!dfse)
-		return -ENOMEM;
-
-	dfse->buf = sdev->dmatb.area;
-	dfse->size = sdev->dmatb.bytes;
-	dfse->sdev = sdev;
-
-	dfse->dfsentry = debugfs_create_file("trace", 0444, sdev->debugfs_root,
-					     dfse, &sof_dfs_trace_fops);
-	if (!dfse->dfsentry) {
-		dev_err(sdev->dev,
-			"error: cannot create debugfs entry for trace\n");
-		kfree(dfse);
-		return -ENODEV;
-	}
-
-	return 0;
-}
-
-int snd_sof_init_trace(struct snd_sof_dev *sdev)
-{
-	struct sof_ipc_dma_trace_params params;
-	struct sof_ipc_reply ipc_reply;
-	int ret;
-
-	/* set false before start initialization */
-	sdev->dtrace_is_enabled = false;
-
-	/* allocate trace page table buffer */
-	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, sdev->parent,
-				  PAGE_SIZE, &sdev->dmatp);
-	if (ret < 0) {
-		dev_err(sdev->dev,
-			"error: can't alloc page table for trace %d\n", ret);
-		return ret;
-	}
-
-	/* allocate trace data buffer */
-	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV_SG, sdev->parent,
-				  DMA_BUF_SIZE_FOR_TRACE, &sdev->dmatb);
-	if (ret < 0) {
-		dev_err(sdev->dev,
-			"error: can't alloc buffer for trace%d\n", ret);
-		goto page_err;
-	}
-
-	/* craete compressed page table for audio firmware */
-	ret = snd_sof_create_page_table(sdev, &sdev->dmatb, sdev->dmatp.area,
-					sdev->dmatb.bytes);
-	if (ret < 0)
-		goto table_err;
-
-	sdev->dma_trace_pages = ret;
-	dev_dbg(sdev->dev, "dma_trace_pages: %d\n", sdev->dma_trace_pages);
-
-	ret = trace_debugfs_create(sdev);
-	if (ret < 0)
-		goto table_err;
-
-	/* set IPC parameters */
-	params.hdr.size = sizeof(params);
-	params.hdr.cmd = SOF_IPC_GLB_TRACE_MSG | SOF_IPC_TRACE_DMA_PARAMS;
-	params.buffer.phy_addr = sdev->dmatp.addr;
-	params.buffer.size = sdev->dmatb.bytes;
-	params.buffer.offset = 0;
-	params.buffer.pages = sdev->dma_trace_pages;
-
-	init_waitqueue_head(&sdev->trace_sleep);
-	sdev->host_offset = 0;
-
-	ret = snd_sof_dma_trace_init(sdev, &params.stream_tag);
-	if (ret < 0) {
-		dev_err(sdev->dev,
-			"error: fail in snd_sof_dma_trace_init %d\n", ret);
-		goto table_err;
-	}
-	dev_dbg(sdev->dev, "stream_tag: %d\n", params.stream_tag);
-
-	/* send IPC to the DSP */
-	ret = sof_ipc_tx_message(sdev->ipc,
-				 params.hdr.cmd, &params, sizeof(params),
-				 &ipc_reply, sizeof(ipc_reply));
-	if (ret < 0) {
-		dev_err(sdev->dev,
-			"error: can't set params for DMA for trace %d\n", ret);
-		goto table_err;
-	}
-
-	ret = snd_sof_dma_trace_trigger(sdev, SNDRV_PCM_TRIGGER_START);
-	if (ret < 0) {
-		dev_err(sdev->dev,
-			"error: snd_sof_dma_trace_trigger: start: %d\n", ret);
-		goto table_err;
-	}
-
-	sdev->dtrace_is_enabled = true;
-	return 0;
-
-table_err:
-	snd_dma_free_pages(&sdev->dmatb);
-page_err:
-	snd_dma_free_pages(&sdev->dmatp);
-	return ret;
-}
-EXPORT_SYMBOL(snd_sof_init_trace);
-
-int snd_sof_trace_update_pos(struct snd_sof_dev *sdev,
-			     struct sof_ipc_dma_trace_posn *posn)
-{
-	if (sdev->dtrace_is_enabled && sdev->host_offset != posn->host_offset) {
-		sdev->host_offset = posn->host_offset;
-		wake_up(&sdev->trace_sleep);
-	}
-
-	if (posn->overflow != 0)
-		dev_err(sdev->dev,
-			"error: DSP trace buffer overflow %u bytes. Total messages %d\n",
-			posn->overflow, posn->messages);
-
-	return 0;
-}
-
-void snd_sof_trace_notify_for_error(struct snd_sof_dev *sdev)
-{
-	if (sdev->dtrace_is_enabled) {
-		dev_err(sdev->dev, "error: waking up any trace sleepers\n");
-		wake_up(&sdev->trace_sleep);
-	}
-}
-EXPORT_SYMBOL(snd_sof_trace_notify_for_error);
-
-void snd_sof_release_trace(struct snd_sof_dev *sdev)
-{
-	int ret;
-
-	if (!sdev->dtrace_is_enabled)
-		return;
-
-	ret = snd_sof_dma_trace_trigger(sdev, SNDRV_PCM_TRIGGER_STOP);
-	if (ret < 0)
-		dev_err(sdev->dev,
-			"error: snd_sof_dma_trace_trigger: stop: %d\n", ret);
-
-	ret = snd_sof_dma_trace_release(sdev);
-	if (ret < 0)
-		dev_err(sdev->dev,
-			"error: fail in snd_sof_dma_trace_release %d\n", ret);
-
-	snd_dma_free_pages(&sdev->dmatb);
-	snd_dma_free_pages(&sdev->dmatp);
-}
-EXPORT_SYMBOL(snd_sof_release_trace);
diff --git a/sound/soc/sof/virtio-be.c b/sound/soc/sof/virtio-be.c
deleted file mode 100644
index 4c07cae..0000000
--- a/sound/soc/sof/virtio-be.c
+++ /dev/null
@@ -1,126 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Luo Xionghu <xionghu.luo@intel.com>
- *         Liam Girdwood <liam.r.girdwood@linux.intel.com>
- *
- */
-
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-#include <linux/platform_device.h>
-#include <linux/firmware.h>
-#include <virtio.h>
-#include <uapi/sound/sof-fw.h>
-#include "sof-priv.h"
-#include "ops.h"
-
-/* BE driver
- *
- * This driver will create IO Queues for communition from FE drivers.
- * The FE driver will send real IPC structures over the queue and then
- * the BE driver will send the structures directlt to the DSP. The BE will
- * get the IPC reply from the DSP and send it back to the FE over the queue.
- *
- * The virt IO message Q handlers in this file will :-
- *
- * 1) Check that the message is valid and not for any componenets that don't
- *    belong to the guest.
- *
- * 2) Call snd_sof_dsp_tx_msg(struct snd_sof_dev *sdev,
- *	struct snd_sof_ipc_msg *msg) to send the message to the DSP.
- *
- * Replies will be sent back using a similar method.
- */
-
-static int sof_virtio_validate(struct virtio_device *dev)
-{
-	/* do we need this func ?? */
-	return 0;
-}
-
-static int sof_virtio_probe(struct virtio_device *dev)
-{
-	/* register fe device with sof core */
-	//snd_sof_virtio_register_fe(dev);
-
-	/* create our virtqueues */s
-
-	/* send topology data to fe via virtq */
-
-	return 0;
-}
-
-static void sof_virtio_remove(struct virtio_device *dev)
-{
-	/* remove topology from fe via virtqueue */
-
-	/* destroy virtqueue */
-}
-
-#ifdef CONFIG_PM
-static int sof_virtio_freeze(struct virtio_device *dev)
-{
-	/* pause and suspend any streams for this FE */
-	return 0;
-}
-
-static int sof_virtio_restore(struct virtio_device *dev)
-{
-	/* restore and unpause any streams for this FE */
-	return 0;
-}
-#endif
-
-/* IDs of FEs */
-static const struct virtio_device_id *fe_id_table[] + {
-};
-
-static struct virtio_driver sof_be_virtio_driver = {
-	.driver = {
-		.name = "sof-virtio-be",
-		.owner = THIS_MODULE,
-	},
-
-	.id_table = fe_id_table,
-
-	//const unsigned int *feature_table;
-	//unsigned int feature_table_size;
-	//const unsigned int *feature_table_legacy;
-	//unsigned int feature_table_size_legacy;
-
-	validate = sof_virtio_validate,
-	probe = sof_virtio_probe,
-	remove = sof_virtio_remove,
-
-#ifdef CONFIG_PM
-	freeze = sof_virtio_freeze,
-	restore = sof_virtio_restore,
-#endif
-};
-
-/* this will be called by sof core when core is ready */
-int sof_virtio_register(struct snd_sof_dev *sdev)
-{
-	int ret;
-
-	ret = register_virtio_driver(&sof_be_virtio_driver);
-	/* do we need to do anythig else here */
-	return ret;
-}
-
-/* called by sof core when driver is removed */
-void sof_virtio_unregister(struct snd_sof_dev *sdev)
-{
-	unregister_virtio_driver(&sof_be_virtio_driver);
-	/* do we need to do anythig else here */
-}
diff --git a/sound/soc/sof/virtio-fe.c b/sound/soc/sof/virtio-fe.c
deleted file mode 100644
index 1019e65..0000000
--- a/sound/soc/sof/virtio-fe.c
+++ /dev/null
@@ -1,130 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2017 Intel Corporation. All rights reserved.
- *
- * Author: Luo Xionghu <xionghu.luo@intel.com>
- *         Liam Girdwood <liam.r.girdwood@linux.intel.com>
- */
-
-/*
- * virt IO FE driver
- *
- * The SOF driver thinks this driver is another audio DSP, however the calls
- * made by the SOF driver core do not directly go to HW, but over a virtIO
- * message Q to the virtIO BE driver.
- *
- * The virtIO message Q will use the *exact* same IPC structures as we currently
- * use in the mailbox.
- *
- * Guest OS SOF core -> SOF FE -> virtIO Q -> SOF BE ->
- * System OS SOF core -> DSP
- *
- * The mailbox IO and TX/RX msg functions below will do IO on the virt IO Q.
- */
-
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-#include <linux/firmware.h>
-#include <linux/device.h>
-#include <linux/virtio.h>
-#include <sound/sof.h>
-#include <uapi/sound/sof-fw.h>
-
-#include "sof-priv.h"
-#include "ops.h"
-#include "intel.h"
-
-/*
- * IPC Firmware ready.
- */
-static int virtio_fe_fw_ready(struct snd_sof_dev *sdev, u32 msg_id)
-{
-	/* not needed for FE ? */
-	return 0;
-}
-
-/*
- * IPC Mailbox IO
- */
-
-static void virtio_fe_mailbox_write(struct snd_sof_dev *sdev, u32 offset,
-				    void *message, size_t bytes)
-{
-	/* write data to message Q buffer before sending message */
-}
-
-static void virtio_fe_mailbox_read(struct snd_sof_dev *sdev, u32 offset,
-				   void *message, size_t bytes)
-{
-	/* read data from message Q buffer after receiving message */
-}
-
-static int virtio_fe_tx_busy(struct snd_sof_dev *sdev)
-{
-	/* return 1 if tx message Q is busy */
-}
-
-static int virtio_fe_tx_msg(struct snd_sof_dev *sdev,
-			    struct snd_sof_ipc_msg *msg)
-{
-	/* write msg to the virtio queue message for BE */
-
-	return 0;
-}
-
-static int virtio_fe_rx_msg(struct snd_sof_dev *sdev,
-			    struct snd_sof_ipc_msg *msg)
-{
-	/* read the virtio queue message from BE and copy to msg */
-	return 0;
-}
-
-/*
- * Probe and remove.
- */
-
-static int virtio_fe_probe(struct snd_sof_dev *sdev)
-{
-	/* register virtio device */
-
-	/* conenct virt queues to BE */
-}
-
-static int virtio_fe_remove(struct snd_sof_dev *sdev)
-{
-	/* free virtio resurces and unregister device */
-}
-
-/* baytrail ops */
-struct snd_sof_dsp_ops snd_sof_virtio_fe_ops = {
-	/* device init */
-	.probe		= virtio_fe_probe,
-	.remove		= virtio_fe_remove,
-
-	/* mailbox */
-	.mailbox_read	= virtio_fe_mailbox_read,
-	.mailbox_write	= virtio_fe_mailbox_write,
-
-	/* ipc */
-	.tx_msg		= virtio_fe_tx_msg,
-	.rx_msg		= virtio_fe_rx_msg,
-	.fw_ready	= virtio_fe_fw_ready,
-	.tx_busy	= virtio_fe_tx_busy,
-
-	/* module loading */
-//	.load_module	= snd_sof_parse_module_memcpy,
-
-	/*Firmware loading */
-	.load_firmware	= snd_sof_load_firmware_memcpy,
-};
-EXPORT_SYMBOL(snd_sof_virtio_fe_ops);
-
-MODULE_LICENSE("Dual BSD/GPL");
-- 
2.7.4

