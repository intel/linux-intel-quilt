From bb65ef7d36911280609696a0f96a557defaee3ce Mon Sep 17 00:00:00 2001
From: Aman Kumar <aman.kumar@intel.com>
Date: Tue, 22 Jun 2021 12:09:17 +0530
Subject: [PATCH 2/5] serial: 8250: PSE DMA quirk fix

PSE DMA require the peripheral to perform the
buffer mapping instead of DMA device.

Signed-off-by: Aman Kumar <aman.kumar@intel.com>
---
 drivers/tty/serial/8250/8250_dma.c | 86 ++++++++++++++++++++++++------
 1 file changed, 71 insertions(+), 15 deletions(-)

diff --git a/drivers/tty/serial/8250/8250_dma.c b/drivers/tty/serial/8250/8250_dma.c
index 890fa7ddaa7f..0ee351fc1a1d 100644
--- a/drivers/tty/serial/8250/8250_dma.c
+++ b/drivers/tty/serial/8250/8250_dma.c
@@ -8,9 +8,24 @@
 #include <linux/tty_flip.h>
 #include <linux/serial_reg.h>
 #include <linux/dma-mapping.h>
+#include <linux/pci.h>
 
 #include "8250.h"
 
+static bool pse_dma_quirk;
+
+static void quirk_pse_dma(struct pci_dev *dev)
+{
+	pse_dma_quirk = true;
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b96, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b97, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b98, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b99, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b9a, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b9b, quirk_pse_dma);
+
 static void __dma_tx_complete(void *param)
 {
 	struct uart_8250_port	*p = param;
@@ -19,9 +34,13 @@ static void __dma_tx_complete(void *param)
 	unsigned long	flags;
 	int		ret;
 
-	dma_sync_single_for_cpu(dma->txchan->device->dev, dma->tx_addr,
+	if (pse_dma_quirk) {
+		dma_sync_single_for_cpu(p->port.dev, dma->tx_addr,
+					UART_XMIT_SIZE, DMA_TO_DEVICE);
+	} else {
+		dma_sync_single_for_cpu(dma->txchan->device->dev, dma->tx_addr,
 				UART_XMIT_SIZE, DMA_TO_DEVICE);
-
+	}
 	spin_lock_irqsave(&p->port.lock, flags);
 
 	dma->tx_running = 0;
@@ -92,8 +111,13 @@ int serial8250_tx_dma(struct uart_8250_port *p)
 
 	dma->tx_cookie = dmaengine_submit(desc);
 
-	dma_sync_single_for_device(dma->txchan->device->dev, dma->tx_addr,
+	if (pse_dma_quirk) {
+		dma_sync_single_for_device(p->port.dev, dma->tx_addr,
 				   UART_XMIT_SIZE, DMA_TO_DEVICE);
+	} else {
+		dma_sync_single_for_device(dma->txchan->device->dev,
+				dma->tx_addr, UART_XMIT_SIZE, DMA_TO_DEVICE);
+	}
 
 	dma_async_issue_pending(dma->txchan);
 	if (dma->tx_err) {
@@ -209,23 +233,44 @@ int serial8250_request_dma(struct uart_8250_port *p)
 	if (!dma->rx_size)
 		dma->rx_size = PAGE_SIZE;
 
-	dma->rx_buf = dma_alloc_coherent(dma->rxchan->device->dev, dma->rx_size,
-					&dma->rx_addr, GFP_KERNEL);
+	if (pse_dma_quirk) {
+		dma->rx_buf = dma_alloc_coherent(p->port.dev, dma->rx_size,
+						&dma->rx_addr, GFP_KERNEL);
+	} else {
+		dma->rx_buf = dma_alloc_coherent(dma->rxchan->device->dev,
+				dma->rx_size, &dma->rx_addr, GFP_KERNEL);
+	}
+
 	if (!dma->rx_buf) {
 		ret = -ENOMEM;
 		goto err;
 	}
 
 	/* TX buffer */
-	dma->tx_addr = dma_map_single(dma->txchan->device->dev,
-					p->port.state->xmit.buf,
-					UART_XMIT_SIZE,
-					DMA_TO_DEVICE);
-	if (dma_mapping_error(dma->txchan->device->dev, dma->tx_addr)) {
-		dma_free_coherent(dma->rxchan->device->dev, dma->rx_size,
-				  dma->rx_buf, dma->rx_addr);
+	if (pse_dma_quirk) {
+		dma->tx_addr = dma_map_single(p->port.dev,
+						p->port.state->xmit.buf,
+						UART_XMIT_SIZE,
+						DMA_TO_DEVICE);
+		if (dma_mapping_error(p->port.dev, dma->tx_addr)) {
+			dma_free_coherent(p->port.dev, dma->rx_size,
+					dma->rx_buf, dma->rx_addr);
 		ret = -ENOMEM;
 		goto err;
+		}
+	} else {
+		dma->tx_addr = dma_map_single(dma->txchan->device->dev,
+						p->port.state->xmit.buf,
+						UART_XMIT_SIZE,
+						DMA_TO_DEVICE);
+
+		if (dma_mapping_error(dma->txchan->device->dev, dma->tx_addr)) {
+			dma_free_coherent(dma->rxchan->device->dev,
+					dma->rx_size, dma->rx_buf,
+					dma->rx_addr);
+			ret = -ENOMEM;
+			goto err;
+		}
 	}
 
 	dev_dbg_ratelimited(p->port.dev, "got both dma channels\n");
@@ -248,15 +293,26 @@ void serial8250_release_dma(struct uart_8250_port *p)
 
 	/* Release RX resources */
 	dmaengine_terminate_sync(dma->rxchan);
-	dma_free_coherent(dma->rxchan->device->dev, dma->rx_size, dma->rx_buf,
-			  dma->rx_addr);
+
+	if (pse_dma_quirk) {
+		dma_free_coherent(p->port.dev, dma->rx_size,
+				dma->rx_buf, dma->rx_addr);
+	} else {
+		dma_free_coherent(dma->rxchan->device->dev, dma->rx_size,
+				dma->rx_buf, dma->rx_addr);
+	}
 	dma_release_channel(dma->rxchan);
 	dma->rxchan = NULL;
 
 	/* Release TX resources */
 	dmaengine_terminate_sync(dma->txchan);
-	dma_unmap_single(dma->txchan->device->dev, dma->tx_addr,
+	if (pse_dma_quirk) {
+		dma_unmap_single(p->port.dev, dma->tx_addr,
+				UART_XMIT_SIZE, DMA_TO_DEVICE);
+	} else {
+		dma_unmap_single(dma->txchan->device->dev, dma->tx_addr,
 			 UART_XMIT_SIZE, DMA_TO_DEVICE);
+	}
 	dma_release_channel(dma->txchan);
 	dma->txchan = NULL;
 	dma->tx_running = 0;
-- 
2.17.1

