From 84379e14263bad8078e55a77fa18af7f56e2fea2 Mon Sep 17 00:00:00 2001
From: Ong Boon Leong <boon.leong.ong@intel.com>
Date: Tue, 13 Aug 2019 12:53:43 +0800
Subject: [PATCH 057/104] tc: Add support for configuring the frame preemption
 through taprio

For current implementation, we allow user to enable IEEE 802.1Qbu/
IEEE 802.3br Frame Preemption through taprio hardware offload only.

In future, we will enable user to independent enable/disable Frame
Preemption.

Thanks to Vinicius Costa Gomes for laying down the foundations for
supporting frame preemption in taprio qdisc.

Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
---
 include/net/pkt_sched.h        |  2 ++
 include/uapi/linux/pkt_sched.h |  1 +
 net/sched/sch_taprio.c         | 19 +++++++++++++++++++
 3 files changed, 22 insertions(+)

diff --git a/include/net/pkt_sched.h b/include/net/pkt_sched.h
index 3333c107f920..6f6eab09df08 100644
--- a/include/net/pkt_sched.h
+++ b/include/net/pkt_sched.h
@@ -175,6 +175,8 @@ struct tc_taprio_qopt_offload {
 	u64 cycle_time;
 	u64 cycle_time_extension;
 
+	/* bit nth being set means that the nth queue is preemptible */
+	u32 frame_preemption_queue_mask;
 	size_t num_entries;
 	struct tc_taprio_sched_entry entries[0];
 };
diff --git a/include/uapi/linux/pkt_sched.h b/include/uapi/linux/pkt_sched.h
index 4640ca9e7be8..d7ebf6f1e813 100644
--- a/include/uapi/linux/pkt_sched.h
+++ b/include/uapi/linux/pkt_sched.h
@@ -1176,6 +1176,7 @@ enum {
 	TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME_EXTENSION, /* s64 */
 	TCA_TAPRIO_ATTR_FLAGS, /* u32 */
 	TCA_TAPRIO_ATTR_TXTIME_DELAY, /* u32 */
+	TCA_TAPRIO_ATTR_FPE_QMASK, /* u32 */
 	__TCA_TAPRIO_ATTR_MAX,
 };
 
diff --git a/net/sched/sch_taprio.c b/net/sched/sch_taprio.c
index 94745867fb40..15465fd5b27f 100644
--- a/net/sched/sch_taprio.c
+++ b/net/sched/sch_taprio.c
@@ -82,6 +82,7 @@ struct taprio_sched {
 	struct hrtimer advance_timer;
 	struct list_head taprio_list;
 	u32 txtime_delay;
+	u32 fpe_q_mask;
 };
 
 static ktime_t sched_base_time(const struct sched_gate_list *sched)
@@ -756,6 +757,7 @@ static const struct nla_policy taprio_policy[TCA_TAPRIO_ATTR_MAX + 1] = {
 	[TCA_TAPRIO_ATTR_SCHED_CLOCKID]              = { .type = NLA_S32 },
 	[TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME]           = { .type = NLA_S64 },
 	[TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME_EXTENSION] = { .type = NLA_S64 },
+	[TCA_TAPRIO_ATTR_FPE_QMASK]                  = { .type = NLA_S32 },
 };
 
 static int fill_sched_entry(struct nlattr **tb, struct sched_entry *entry,
@@ -1212,6 +1214,8 @@ static int taprio_enable_offload(struct net_device *dev,
 	taprio->enable = 1;
 	taprio_sched_to_offload(q, sched, taprio);
 
+	taprio->frame_preemption_queue_mask = q->fpe_q_mask;
+
 	err = ops->ndo_setup_tc(dev, TC_SETUP_QDISC_TAPRIO, taprio);
 	if (err < 0) {
 		NL_SET_ERR_MSG(extack, "Specified device failed to setup taprio hardware offload");
@@ -1269,6 +1273,21 @@ static int taprio_change(struct Qdisc *sch, struct nlattr *opt,
 		q->flags = taprio_flags;
 	}
 
+	if (tb[TCA_TAPRIO_ATTR_FPE_QMASK]) {
+		q->fpe_q_mask = nla_get_u32(tb[TCA_TAPRIO_ATTR_FPE_QMASK]);
+		if (FULL_OFFLOAD_IS_ENABLED(q->flags) && !q->fpe_q_mask) {
+			NL_SET_ERR_MSG_MOD(extack,
+					   "Invalid FPE Queue Mask - all 0s");
+
+			return -EINVAL;
+		}
+	} else {
+		/* If 'fpe-qmask' is not set, mark fpe_q_mask=0 to indicate
+		 * FPE is disabled.
+		 */
+		q->fpe_q_mask = 0;
+	}
+
 	err = taprio_parse_mqprio_opt(dev, mqprio, extack, taprio_flags);
 	if (err < 0)
 		return err;
-- 
2.17.1

