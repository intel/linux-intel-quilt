From 92d508bd0152f2d71756a7b42b476e24ffd048ec Mon Sep 17 00:00:00 2001
From: Alexander Usyskin <alexander.usyskin@intel.com>
Date: Thu, 31 Oct 2024 10:08:57 +0200
Subject: [PATCH 4/5] issei: add heci hardware module

Add support for the ISSEI (Intel Silicon Security Engine Interface)
HECI PCI devices.
Add the necessary PCI handling routines, hardware definitions,
register mappings and hardware access routines.

This enables the communication via HECI PCI device advertized by BIOS.

Co-developed-by: Vitaly Lubart <lubvital@gmail.com>
Signed-off-by: Vitaly Lubart <lubvital@gmail.com>
Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
---
 drivers/misc/issei/Kconfig        |  14 +
 drivers/misc/issei/Makefile       |   4 +
 drivers/misc/issei/hw_heci.c      | 552 ++++++++++++++++++++++++++++++
 drivers/misc/issei/hw_heci.h      |  54 +++
 drivers/misc/issei/hw_heci_regs.h |  35 ++
 drivers/misc/issei/pci_heci.c     | 166 +++++++++
 6 files changed, 825 insertions(+)
 create mode 100644 drivers/misc/issei/hw_heci.c
 create mode 100644 drivers/misc/issei/hw_heci.h
 create mode 100644 drivers/misc/issei/hw_heci_regs.h
 create mode 100644 drivers/misc/issei/pci_heci.c

diff --git a/drivers/misc/issei/Kconfig b/drivers/misc/issei/Kconfig
index ffd027e826df..5fbdcb30e20d 100644
--- a/drivers/misc/issei/Kconfig
+++ b/drivers/misc/issei/Kconfig
@@ -11,3 +11,17 @@ config INTEL_SSEI
 
 	  If selected, the /dev/isseiX device will be created.
 	  If in doubt, select N.
+
+if INTEL_SSEI
+
+config INTEL_SSEI_HW_HECI
+	tristate "Intel Silicon Security Engine Interface Hardware"
+	depends on PCI
+	help
+	  HECI interface of communication channel between
+	  the host and the Silicon Security Engine.
+
+	  Implementation of ISSEI communication channel over
+	  the HECI hardware PCI device.
+
+endif
diff --git a/drivers/misc/issei/Makefile b/drivers/misc/issei/Makefile
index 712d62eb9790..fb904fda3949 100644
--- a/drivers/misc/issei/Makefile
+++ b/drivers/misc/issei/Makefile
@@ -9,3 +9,7 @@ issei-objs += fw_client.o
 issei-objs += host_client.o
 issei-objs += ham.o
 issei-objs += main.o
+
+obj-$(CONFIG_INTEL_SSEI_HW_HECI) += issei-heci.o
+issei-heci-objs := pci_heci.o
+issei-heci-objs += hw_heci.o
diff --git a/drivers/misc/issei/hw_heci.c b/drivers/misc/issei/hw_heci.c
new file mode 100644
index 000000000000..eee794e4da5c
--- /dev/null
+++ b/drivers/misc/issei/hw_heci.c
@@ -0,0 +1,552 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2023-2025 Intel Corporation */
+#include <linux/dev_printk.h>
+#include <linux/bitfield.h>
+#include <linux/bits.h>
+#include <linux/io.h>
+#include <linux/pci.h>
+#include <linux/pm_runtime.h>
+#include <linux/sizes.h>
+
+#include "hw_heci.h"
+#include "hw_heci_regs.h"
+#include "hw_msg.h"
+
+/**
+ * heci_reg_read - Reads 32bit data from the issei heci device
+ * @hw: the heci hardware structure
+ * @offset: offset from which to read the data
+ *
+ * Return: register value (u32)
+ */
+static inline u32 heci_reg_read(const struct issei_heci_hw *hw, unsigned long offset)
+{
+	return ioread32(hw->mem_addr + offset);
+}
+
+/**
+ * heci_reg_write - Writes 32bit data to the issei heci device
+ *
+ * @hw: the heci hardware structure
+ * @offset: offset from which to write the data
+ * @value: register value to write (u32)
+ */
+static inline void heci_reg_write(const struct issei_heci_hw *hw, unsigned long offset, u32 value)
+{
+	iowrite32(value, hw->mem_addr + offset);
+}
+
+/**
+ * heci_fwcbrw_read - Reads 32bit data from heci circular buffer
+ * @hw: the heci hardware structure
+ *
+ * Return: FW_CB_RW register value (u32)
+ */
+static inline u32 heci_fwcbrw_read(const struct issei_heci_hw *hw)
+{
+	return heci_reg_read(hw, FW_CB_RW);
+}
+
+/**
+ * heci_hcbww_write - write 32bit data to the host circular buffer
+ * @hw: the heci hardware structure
+ * @data: 32bit data to be written to the host circular buffer
+ */
+static inline void heci_hcbww_write(const struct issei_heci_hw *hw, u32 data)
+{
+	heci_reg_write(hw, H_CB_WW, data);
+}
+
+/**
+ * heci_irq_src - Filters IRQ source bits from the host CSR
+ * @hcsr: host CSR register value
+ *
+ * Return: interrupt source bits of host CSR
+ */
+static inline u32 heci_irq_src(u32 hcsr)
+{
+	return hcsr & H_CSR_IS;
+}
+
+/**
+ * heci_hcsr_read - Reads 32bit data from the host CSR
+ * @idev: the device structure
+ *
+ * Return: H_CSR register value (u32)
+ */
+static inline u32 heci_hcsr_read(const struct issei_device *idev)
+{
+	return heci_reg_read(to_heci_hw(idev), H_CSR);
+}
+
+/**
+ * heci_hcsr_write - writes H_CSR register to device
+ * @idev: the device structure
+ * @reg: new register value
+ */
+static inline void heci_hcsr_write(struct issei_device *idev, u32 reg)
+{
+	heci_reg_write(to_heci_hw(idev), H_CSR, reg);
+}
+
+/**
+ * heci_hcsr_set - writes H_CSR register to the heci device
+ * @idev: the device structure
+ * @reg: new register value
+ *
+ * Writes H_CSR register to the heci device
+ * and ignores the H_IS bit for it is write-one-to-zero.
+ *
+ */
+static inline void heci_hcsr_set(struct issei_device *idev, u32 reg)
+{
+	reg &= ~H_CSR_IS;
+	heci_hcsr_write(idev, reg);
+}
+
+/**
+ * heci_hcsr_set_hig - set host interrupt (set H_CSR_IG)
+ * @idev: the device structure
+ */
+static inline void heci_hcsr_set_hig(struct issei_device *idev)
+{
+	u32 reg;
+
+	reg = heci_hcsr_read(idev) | H_CSR_IG;
+	heci_hcsr_set(idev, reg);
+}
+
+/**
+ * heci_fwcsr_read - Reads 32bit data from the FW CSR
+ * @idev: the device structure
+ *
+ * Return: FW_CSR_HA register value (u32)
+ */
+static inline u32 heci_fwcsr_read(const struct issei_device *idev)
+{
+	return heci_reg_read(to_heci_hw(idev), FW_CSR_HA);
+}
+
+/**
+ * heci_count_full_read_slots - counts read full slots.
+ * @idev: the device structure
+ *
+ * Return: -EOVERFLOW if overflow, otherwise filled slots count
+ */
+static int heci_count_full_read_slots(struct issei_device *idev)
+{
+	u8 buffer_depth, filled_slots;
+	u8 read_ptr, write_ptr;
+	u32 reg;
+
+	reg = heci_fwcsr_read(idev);
+	buffer_depth = (u8)FIELD_GET(FW_CSR_CBD, reg);
+	read_ptr = (u8)FIELD_GET(FW_CSR_CBRP, reg);
+	write_ptr = (u8)FIELD_GET(FW_CSR_CBWP, reg);
+	filled_slots = write_ptr - read_ptr;
+
+	/* check for overflow */
+	if (filled_slots > buffer_depth)
+		return -EOVERFLOW;
+
+	dev_dbg(idev->dev, "filled_slots = %08x\n", filled_slots);
+	return filled_slots;
+}
+
+/**
+ * heci_irq_disable - disables heci device interrupts
+ * @idev: the device structure
+ * @reg: supplied hcsr register value
+ *
+ * disables heci device interrupts using supplied hcsr register value.
+ */
+static inline void heci_irq_disable(struct issei_device *idev, u32 reg)
+{
+	reg &= ~H_CSR_IE;
+	heci_hcsr_set(idev, reg);
+}
+
+/**
+ * heci_irq_clear - clear and stop interrupts
+ * @idev: the device structure
+ * @reg: supplied hcsr register value
+ */
+static inline void heci_irq_clear(struct issei_device *idev, u32 reg)
+{
+	if (heci_irq_src(reg))
+		heci_hcsr_write(idev, reg);
+}
+
+/**
+ * issei_heci_irq_clear - clear and stop interrupts
+ * @idev: the device structure
+ */
+static void issei_heci_irq_clear(struct issei_device *idev)
+{
+	u32 reg = heci_hcsr_read(idev);
+
+	heci_irq_clear(idev, reg);
+}
+
+/**
+ * issei_heci_irq_enable - enables heci device interrupts
+ * @idev: the device structure
+ */
+static void issei_heci_irq_enable(struct issei_device *idev)
+{
+	u32 reg;
+
+	reg = heci_hcsr_read(idev) | H_CSR_IE;
+	heci_hcsr_set(idev, reg);
+}
+
+/**
+ * issei_heci_irq_disable - disables heci device interrupts
+ * @idev: the device structure
+ */
+static void issei_heci_irq_disable(struct issei_device *idev)
+{
+	u32 reg = heci_hcsr_read(idev);
+
+	heci_irq_disable(idev, reg);
+}
+
+static void issei_heci_irq_sync(struct issei_device *idev)
+{
+	synchronize_irq(to_heci_hw(idev)->irq);
+}
+
+/**
+ * issei_heci_hw_reset_release - release device from the reset
+ * @idev: the device structure
+ */
+static void issei_heci_hw_reset_release(struct issei_device *idev)
+{
+	u32 reg = heci_hcsr_read(idev);
+
+	reg |= H_CSR_IG;
+	reg &= ~H_CSR_RST;
+	heci_hcsr_set(idev, reg);
+}
+
+/**
+ * heci_hw_is_ready - check whether the hw has turned ready
+ * @idev: the device structure
+ *
+ * Return: bool
+ */
+static bool heci_hw_is_ready(struct issei_device *idev)
+{
+	u32 reg = heci_fwcsr_read(idev);
+
+	return reg & FW_CSR_RDY;
+}
+
+/**
+ * heci_hw_is_resetting - check whether the hw is in reset
+ * @idev: the device structure
+ *
+ * Return: bool
+ */
+static bool heci_hw_is_resetting(struct issei_device *idev)
+{
+	u32 reg = heci_fwcsr_read(idev);
+
+	return reg & FW_CSR_RST;
+}
+
+/**
+ * issei_heci_host_set_ready - enable device
+ * @idev: the device structure
+ */
+static void issei_heci_host_set_ready(struct issei_device *idev)
+{
+	u32 reg = heci_hcsr_read(idev);
+
+	reg |= H_CSR_IE | H_CSR_IG | H_CSR_RDY;
+	heci_hcsr_set(idev, reg);
+}
+
+/**
+ * issei_heci_hw_reset - resets fw via heci csr register.
+ * @idev: the device structure
+ * @enable: if interrupt should be enabled after reset.
+ *
+ * Return: 0 on success an error code otherwise
+ */
+static int issei_heci_hw_reset(struct issei_device *idev, bool enable)
+{
+	u32 reg;
+
+	if (enable)
+		issei_heci_irq_enable(idev);
+
+	reg = heci_hcsr_read(idev);
+	/*
+	 * H_CSR_RST may be found lit before reset is started,
+	 * for example if preceding reset flow hasn't completed.
+	 * In that case asserting H_CSR_RST will be ignored, therefore
+	 * we need to clean H_CSR_RST bit to start a successful reset sequence.
+	 */
+	if (reg & H_CSR_RST) {
+		dev_warn(idev->dev, "H_CSR_RST is set = 0x%08X", reg);
+		reg &= ~H_CSR_RST;
+		heci_hcsr_set(idev, reg);
+		reg = heci_hcsr_read(idev);
+	}
+
+	reg |= H_CSR_RST | H_CSR_IG | H_CSR_IS;
+
+	if (!enable)
+		reg &= ~H_CSR_IE;
+
+	heci_hcsr_write(idev, reg);
+
+	/*
+	 * Host reads the H_CSR once to ensure that the
+	 * posted write to H_CSR completes.
+	 */
+	reg = heci_hcsr_read(idev);
+
+	if (!(reg & H_CSR_RST))
+		dev_warn(idev->dev, "H_CSR_RST is not set = 0x%08X", reg);
+
+	if (reg & H_CSR_RDY)
+		dev_warn(idev->dev, "H_CSR_RDY is not cleared 0x%08X", reg);
+
+	if (!enable)
+		issei_heci_hw_reset_release(idev);
+	return 0;
+}
+
+/**
+ * issei_heci_irq_write_generate - generate interrupt to signal write completion.
+ * @idev: the device structure
+ *
+ * Return: 0 on success, -EIO if hardware is not ready and requires reset
+ */
+static int issei_heci_irq_write_generate(struct issei_device *idev)
+{
+	struct issei_heci_hw *hw = to_heci_hw(idev);
+
+	scoped_guard(spinlock, &hw->access_lock)
+		heci_hcsr_set_hig(idev);
+	if (!heci_hw_is_ready(idev))
+		return -EIO;
+	return 0;
+}
+
+/**
+ * issei_heci_hw_config - initial hardware configuration.
+ * @idev: the device structure
+ *
+ * Return: 0 always
+ */
+static int issei_heci_hw_config(struct issei_device *idev)
+{
+	struct issei_heci_hw *hw = to_heci_hw(idev);
+	u32 reg;
+
+	/* Doesn't change in runtime */
+	reg = heci_hcsr_read(idev);
+	hw->hbuf_depth = FIELD_GET(H_CSR_CBD, reg);
+
+	return 0;
+}
+
+/**
+ * heci_write_hbuf - write to hardware buffer
+ * @idev: the device structure
+ * @data: data to write
+ * @data_len: data size
+ *
+ * Return: 0 on success, <0 on error
+ */
+static int heci_write_hbuf(struct issei_device *idev, const void *data, size_t data_len)
+{
+	struct issei_heci_hw *hw = to_heci_hw(idev);
+
+	if (!IS_ALIGNED(data_len, CB_SLOT_SIZE)) {
+		dev_err(idev->dev, "Data size %zu not aligned to slot size %lu\n",
+			data_len, CB_SLOT_SIZE);
+		return -EINVAL;
+	}
+
+	scoped_guard(spinlock, &hw->access_lock) {
+		const u32 *reg_buf = data;
+		size_t i;
+
+		for (i = 0; i < data_len / CB_SLOT_SIZE; i++)
+			heci_hcbww_write(hw, reg_buf[i]);
+	}
+
+	return issei_heci_irq_write_generate(idev);
+}
+
+/**
+ * heci_read_hbuf - read data from hardware buffer
+ * @idev: the device structure
+ * @data: buffer to store read data
+ * @data_len: buffer size
+ *
+ * Return: 0 on success, <0 on error
+ */
+static int heci_read_hbuf(struct issei_device *idev, void *data, size_t data_len)
+{
+	struct issei_heci_hw *hw = to_heci_hw(idev);
+	u32 *reg_buf = data;
+
+	if (!IS_ALIGNED(data_len, CB_SLOT_SIZE)) {
+		dev_err(idev->dev, "Data size %zu not aligned to slot size %lu\n",
+			data_len, CB_SLOT_SIZE);
+		return -EINVAL;
+	}
+
+	scoped_guard(spinlock, &hw->access_lock) {
+		for (; data_len >= CB_SLOT_SIZE; data_len -= CB_SLOT_SIZE)
+			*reg_buf++ = heci_fwcbrw_read(hw);
+	}
+	return 0;
+}
+
+/**
+ * issei_heci_setup_message_send - send setup message to firmware
+ * @idev: the device structure
+ *
+ * Return: 0 on success, <0 on error
+ */
+static int issei_heci_setup_message_send(struct issei_device *idev)
+{
+	struct ham_setup_shared_memory_req req = {
+		.msg_id = HAM_CB_MESSAGE_ID_REQ,
+		.ver = HAM_CB_MESSAGE_VER,
+		.reserved = 0,
+		.buffer_physical_address = idev->dma.daddr,
+		.host_to_fw_section_length = idev->dma.length.h2f,
+		.fw_to_host_section_length = idev->dma.length.f2h,
+		.control_length = idev->dma.length.ctl
+	};
+	int ret;
+
+
+	ret = heci_write_hbuf(idev, &req, sizeof(req));
+	if (ret)
+		dev_err(idev->dev, "Shared memory req write failed ret = %d\n", ret);
+
+	return ret;
+}
+
+/**
+ * issei_heci_setup_message_recv - receive setup message respnce from firmware
+ * @idev: the device structure
+ *
+ * Return: 0 on success, <0 on error
+ */
+static int issei_heci_setup_message_recv(struct issei_device *idev)
+{
+	struct ham_setup_shared_memory_res res;
+	int ret;
+
+	if (heci_count_full_read_slots(idev) != sizeof(res) / CB_SLOT_SIZE) {
+		dev_dbg(idev->dev, "Setup response is not fully received\n");
+		return -ENODATA;
+	}
+
+	ret = heci_read_hbuf(idev, &res, sizeof(res));
+	if (ret) {
+		dev_err(idev->dev, "Shared memory res read failed ret = %d\n", ret);
+		return ret;
+	}
+
+	if (res.msg_id != HAM_CB_MESSAGE_ID_RES) {
+		dev_err(idev->dev, "Shared memory res header 0x%x != 0x%x\n",
+			res.msg_id, HAM_CB_MESSAGE_ID_RES);
+		return -EPROTO;
+	}
+	if (res.status != 0) {
+		dev_err(idev->dev, "Shared memory res status %d != 0\n", res.status);
+		return -EPROTO;
+	}
+
+	return 0;
+}
+
+static struct issei_hw_ops hw_heci_ops = {
+	.irq_clear = issei_heci_irq_clear,
+	.irq_enable = issei_heci_irq_enable,
+	.irq_disable = issei_heci_irq_disable,
+	.irq_sync = issei_heci_irq_sync,
+
+	.hw_reset = issei_heci_hw_reset,
+	.hw_config = issei_heci_hw_config,
+	.hw_reset_release = issei_heci_hw_reset_release,
+	.host_set_ready = issei_heci_host_set_ready,
+
+	.hw_is_ready = heci_hw_is_ready,
+
+	.setup_message_send = issei_heci_setup_message_send,
+	.setup_message_recv = issei_heci_setup_message_recv,
+	.irq_write_generate = issei_heci_irq_write_generate,
+};
+
+irqreturn_t issei_heci_irq_quick_handler(int irq, void *dev_id)
+{
+	struct issei_device *idev = dev_id;
+	struct issei_heci_hw *hw = to_heci_hw(idev);
+	u32 reg;
+
+	reg = heci_hcsr_read(idev);
+	if (!heci_irq_src(reg))
+		return IRQ_NONE;
+
+	scoped_guard(spinlock, &hw->access_lock) {
+		reg = heci_hcsr_read(idev);
+		heci_irq_clear(idev, reg);
+
+		if (heci_hw_is_resetting(idev))
+			heci_hcsr_set_hig(idev);
+	}
+
+	dev_dbg(idev->dev, "interrupt source 0x%08X\n", heci_irq_src(reg));
+
+	atomic_set(&idev->rst_irq, 1);
+	wake_up_interruptible(&idev->wait_rst_irq);
+
+	return IRQ_HANDLED;
+}
+
+static const struct hw_heci_cfg hw_heci_pch_cfg = {
+	.dma_length.h2f = SZ_64K,
+	.dma_length.f2h = SZ_64K,
+	.dma_length.ctl = SZ_4K,
+};
+
+const struct hw_heci_cfg *issei_heci_get_cfg(kernel_ulong_t idx)
+{
+	return &hw_heci_pch_cfg;
+}
+
+/**
+ * issei_heci_dev_init - allocates and initializes the issei device structure with hw_heci
+ * @parent: device associated with physical device (pci/platform)
+ * @cfg: per device generation config
+ *
+ * Return: The issei_device pointer on success, NULL on failure.
+ */
+struct issei_device *issei_heci_dev_init(struct device *parent, const struct hw_heci_cfg *cfg)
+{
+	struct issei_device *idev;
+	struct issei_heci_hw *hw;
+
+	idev = devm_kzalloc(parent, sizeof(*idev) + sizeof(*hw), GFP_KERNEL);
+	if (!idev)
+		return NULL;
+
+	hw = to_heci_hw(idev);
+	spin_lock_init(&hw->access_lock);
+
+	issei_device_init(idev, parent, &cfg->dma_length, &hw_heci_ops);
+	hw->cfg = cfg;
+
+	return idev;
+}
diff --git a/drivers/misc/issei/hw_heci.h b/drivers/misc/issei/hw_heci.h
new file mode 100644
index 000000000000..7ba160c3db54
--- /dev/null
+++ b/drivers/misc/issei/hw_heci.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2023-2024 Intel Corporation */
+#ifndef _ISSEI_HW_HECI_H_
+#define _ISSEI_HW_HECI_H_
+
+#include <linux/types.h>
+#include <linux/spinlock.h>
+
+#include "issei_dev.h"
+
+struct device;
+struct issei_device;
+
+/*
+ * hw_heci_cfg - issei heci device configuration
+ *
+ * @dma_length: DMA area length
+ */
+struct hw_heci_cfg {
+	const struct issei_dma_length dma_length;
+};
+
+#define HW_HECI_RPM_TIMEOUT_MSEC 60000
+#define HW_HECI_READY_TIMEOUT_MSEC 2000
+#define HW_HECI_SETUP_TIMEOUT_MSEC 2000
+
+/**
+ * struct issei_heci_hw - issei heci hw specific data
+ *
+ * @cfg: per device generation config and ops
+ * @mem_addr: io memory address
+ * @irq: device irq number
+ * @access_lock: spinlock to protect hw access
+ * @hbuf_depth: depth of hardware host/write buffer in slots
+ */
+struct issei_heci_hw {
+	const struct hw_heci_cfg *cfg;
+	void __iomem *mem_addr;
+	int irq;
+	/* lock to serialize HW access */
+	spinlock_t access_lock;
+	u8 hbuf_depth;
+};
+
+#define to_heci_hw(dev) ((struct issei_heci_hw *)(dev)->hw)
+
+const struct hw_heci_cfg *issei_heci_get_cfg(kernel_ulong_t idx);
+
+struct issei_device *issei_heci_dev_init(struct device *parent, const struct hw_heci_cfg *cfg);
+
+irqreturn_t issei_heci_irq_quick_handler(int irq, void *dev_id);
+irqreturn_t issei_heci_irq_thread_handler(int irq, void *dev_id);
+
+#endif /* _ISSEI_HW_HECI_H_ */
diff --git a/drivers/misc/issei/hw_heci_regs.h b/drivers/misc/issei/hw_heci_regs.h
new file mode 100644
index 000000000000..5e804bdb2e94
--- /dev/null
+++ b/drivers/misc/issei/hw_heci_regs.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2023-2024 Intel Corporation */
+#ifndef _ISSEI_HW_HECI_REGS_H_
+#define _ISSEI_HW_HECI_REGS_H_
+
+#include <linux/bits.h>
+
+/* H_CB_WW - Host Circular Buffer (CB) Write Window register */
+#define H_CB_WW    0x0
+/* H_CSR - Host Control Status register */
+#define H_CSR      0x4
+#define H_CSR_CBD   GENMASK(31, 24) /* Host Circular Buffer Depth */
+#define H_CSR_CBWP  GENMASK(23, 16) /* Host Circular Buffer Write Pointer */
+#define H_CSR_CBRP  GENMASK(15, 8)  /* Host Circular Buffer Read Pointer */
+#define H_CSR_RST   BIT(4) /* Host Reset */
+#define H_CSR_RDY   BIT(3) /* Host Ready */
+#define H_CSR_IG    BIT(2) /* Host Interrupt Generate */
+#define H_CSR_IS    BIT(1) /* Host Interrupt Status */
+#define H_CSR_IE    BIT(0) /* Host Interrupt Enable */
+/* FW_CB_RW - FW Circular Buffer Read Window register (read only) */
+#define FW_CB_RW   0x8
+/* FW_CSR_HA - FW Control Status Host Access register (read only) */
+#define FW_CSR_HA  0xC
+#define FW_CSR_CBD  GENMASK(31, 24) /* FW CB (Circular Buffer) Depth */
+#define FW_CSR_CBWP GENMASK(23, 16) /* FW CB Write Pointer */
+#define FW_CSR_CBRP GENMASK(15, 8)  /* FW CB Read Pointer */
+#define FW_CSR_RST  BIT(4) /* FW Reset */
+#define FW_CSR_RDY  BIT(3) /* FW Ready */
+#define FW_CSR_IG   BIT(2) /* FW Interrupt Generate */
+#define FW_CSR_IS   BIT(1) /* FW Interrupt Status */
+#define FW_CSR_IE   BIT(0) /* FW Interrupt Enable */
+
+#define CB_SLOT_SIZE sizeof(u32) /* Circular Buffer windows size */
+
+#endif /* _ISSEI_HW_HECI_REGS_H_ */
diff --git a/drivers/misc/issei/pci_heci.c b/drivers/misc/issei/pci_heci.c
new file mode 100644
index 000000000000..b1fafd284521
--- /dev/null
+++ b/drivers/misc/issei/pci_heci.c
@@ -0,0 +1,166 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2023-2024 Intel Corporation */
+#include <linux/module.h>
+#include <linux/pci.h>
+
+#include "cdev.h"
+#include "hw_heci.h"
+#include "hw_heci_regs.h"
+
+static int issei_heci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	const struct hw_heci_cfg *cfg;
+	struct issei_device *idev;
+	struct issei_heci_hw *hw;
+	int err;
+
+	cfg = issei_heci_get_cfg(ent->driver_data);
+	if (!cfg)
+		return -ENODEV;
+
+	err = pcim_enable_device(pdev);
+	if (err) {
+		dev_err(&pdev->dev, "failed to enable pci device. err = %d\n", err);
+		return err;
+	}
+
+	err = pcim_iomap_regions(pdev, BIT(0), KBUILD_MODNAME);
+	if (err) {
+		dev_err(&pdev->dev, "failed to get pci regions. err = %d\n", err);
+		return err;
+	}
+
+	err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
+	if (err) {
+		dev_err(&pdev->dev, "no usable DMA configuration, aborting. err = %d\n", err);
+		return err;
+	}
+
+	pci_set_master(pdev);
+
+	idev = issei_heci_dev_init(&pdev->dev, cfg);
+	if (!idev)
+		return -ENOMEM;
+	hw = to_heci_hw(idev);
+	hw->mem_addr = pcim_iomap_table(pdev)[0];
+
+	err = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);
+	if (err < 0) {
+		dev_err(&pdev->dev, "pci_alloc_irq_vectors failure. err = %d\n", err);
+		return err;
+	}
+
+	hw->irq = pci_irq_vector(pdev, 0);
+
+	err = devm_request_threaded_irq(&pdev->dev, hw->irq,
+				   issei_heci_irq_quick_handler,
+				   NULL,
+				   IRQF_ONESHOT, KBUILD_MODNAME, idev);
+	if (err) {
+		dev_err(&pdev->dev, "request_threaded_irq failure. err = %d, irq = %d\n",
+			err, hw->irq);
+		goto release_irq;
+	}
+
+	err = issei_start(idev);
+	if (err)	{
+		dev_err(&pdev->dev, "init hw failure. err = %d.\n", err);
+		goto free_irq;
+	}
+
+	err = issei_register(idev, &pdev->dev);
+	if (err) {
+		dev_err(&pdev->dev, "register failure. err = %d.\n", err);
+		goto stop;
+	}
+
+	pci_set_drvdata(pdev, idev);
+
+	dev_dbg(&pdev->dev, "initialization successful.\n");
+
+	return 0;
+
+stop:
+	issei_stop(idev);
+free_irq:
+	/* Manually free IRQ otherwise PCI free irq vectors will fail */
+	devm_free_irq(&pdev->dev, hw->irq, idev);
+release_irq:
+	idev->ops->irq_disable(idev);
+	pci_free_irq_vectors(pdev);
+	return err;
+}
+
+static void __issei_heci_deconstruct(struct pci_dev *pdev)
+{
+	struct issei_device *idev = pci_get_drvdata(pdev);
+	struct issei_heci_hw *hw = to_heci_hw(idev);
+
+	issei_stop(idev);
+
+	idev->ops->irq_disable(idev);
+	/* Manually free IRQ otherwise PCI free irq vectors will fail */
+	devm_free_irq(&pdev->dev, hw->irq, idev);
+	pci_free_irq_vectors(pdev);
+}
+
+
+static void issei_heci_shutdown(struct pci_dev *pdev)
+{
+	dev_dbg(&pdev->dev, "shutdown\n");
+	__issei_heci_deconstruct(pdev);
+}
+
+static void issei_heci_remove(struct pci_dev *pdev)
+{
+	dev_dbg(&pdev->dev, "stop\n");
+	__issei_heci_deconstruct(pdev);
+
+	issei_deregister(pci_get_drvdata(pdev));
+}
+
+static int __maybe_unused issei_heci_pm_suspend(struct device *device)
+{
+	struct issei_device *idev = dev_get_drvdata(device);
+
+	issei_stop(idev);
+	idev->ops->irq_disable(idev);
+
+	return 0;
+}
+
+static int __maybe_unused issei_heci_pm_resume(struct device *device)
+{
+	struct issei_device *idev = dev_get_drvdata(device);
+
+	return issei_start(idev);
+}
+
+static const struct dev_pm_ops issei_heci_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(issei_heci_pm_suspend, issei_heci_pm_resume)
+};
+
+static const struct pci_device_id heci_pci_tbl[] = {
+	{PCI_VDEVICE(INTEL, 0xA85D)}, /* Lunar Lake M */
+	{PCI_VDEVICE(INTEL, 0xE35D)}, /* Panter Lake H */
+	{PCI_VDEVICE(INTEL, 0xE45D)}, /* Panter Lake P */
+
+	{0, }
+};
+MODULE_DEVICE_TABLE(pci, heci_pci_tbl);
+
+static struct pci_driver issei_heci_driver = {
+	.name = KBUILD_MODNAME,
+	.id_table = heci_pci_tbl,
+	.probe = issei_heci_probe,
+	.remove = issei_heci_remove,
+	.shutdown = issei_heci_shutdown,
+	.driver.pm = &issei_heci_pm_ops,
+	.driver.probe_type = PROBE_PREFER_ASYNCHRONOUS,
+};
+
+module_pci_driver(issei_heci_driver);
+
+MODULE_DESCRIPTION("Intel(R) Silicon Security Engine Interface - HECI");
+MODULE_LICENSE("GPL");
+MODULE_IMPORT_NS("INTEL_SSEI");
-- 
2.43.0

