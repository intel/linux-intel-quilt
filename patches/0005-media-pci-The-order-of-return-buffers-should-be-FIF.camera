From 6e6568fdc15056beea15007ccb165e2ad19b76b3 Mon Sep 17 00:00:00 2001
From: zouxiaoh <xiaohong.zou@intel.com>
Date: Fri, 16 May 2025 14:40:46 +0800
Subject: [PATCH 5/7] media: pci: The order of return buffers should be FIFO.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Change Description:
return_buffers : use "list_first_entry", will get these logs in hal:
“CamHAL[ERR] DeviceBase: dequeueBuffer, CamBuf index isn't same with
index used by kernel
CamHAL[ERR] CaptureUnit: Device:Generic grab frame failed:-22”

The index order is changed from sequential to reverse after return_buffers.
The reason why the normal start&stop does not expose the problem is that
every Hal start will start the buffer index from 0 instead of continuing
to use the buffer index returned last stop.

So need return_buffers from the list of tail,
and need use the "list_last_entry".

Signed-off-by: linya14x <linx.yang@intel.com>
Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
---
 .../media/pci/intel/ipu6/ipu6-isys-queue.c    | 31 ++++++++++---------
 1 file changed, 16 insertions(+), 15 deletions(-)

diff --git a/drivers/media/pci/intel/ipu6/ipu6-isys-queue.c b/drivers/media/pci/intel/ipu6/ipu6-isys-queue.c
index b931c43746940..14868b1ab441f 100644
--- a/drivers/media/pci/intel/ipu6/ipu6-isys-queue.c
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys-queue.c
@@ -519,39 +519,40 @@ static void return_buffers(struct ipu6_isys_queue *aq,
 	unsigned long flags;
 
 	spin_lock_irqsave(&aq->lock, flags);
-	while (!list_empty(&aq->incoming)) {
+
+	/*
+	 * Something went wrong (FW crash / HW hang / not all buffers
+	 * returned from isys) if there are still buffers queued in active
+	 * queue. We have to clean up places a bit.
+	 */
+	while (!list_empty(&aq->active)) {
 		struct vb2_buffer *vb;
 
-		ib = list_first_entry(&aq->incoming, struct ipu6_isys_buffer,
-				      head);
+		ib = list_last_entry(&aq->active, struct ipu6_isys_buffer,
+				     head);
 		vb = ipu6_isys_buffer_to_vb2_buffer(ib);
+
 		list_del(&ib->head);
 		spin_unlock_irqrestore(&aq->lock, flags);
 
 		vb2_buffer_done(vb, state);
 
 		spin_lock_irqsave(&aq->lock, flags);
+		need_reset = true;
 	}
 
-	/*
-	 * Something went wrong (FW crash / HW hang / not all buffers
-	 * returned from isys) if there are still buffers queued in active
-	 * queue. We have to clean up places a bit.
-	 */
-	while (!list_empty(&aq->active)) {
+	while (!list_empty(&aq->incoming)) {
 		struct vb2_buffer *vb;
 
-		ib = list_first_entry(&aq->active, struct ipu6_isys_buffer,
-				      head);
+		ib = list_last_entry(&aq->incoming, struct ipu6_isys_buffer,
+				     head);
 		vb = ipu6_isys_buffer_to_vb2_buffer(ib);
-
 		list_del(&ib->head);
 		spin_unlock_irqrestore(&aq->lock, flags);
 
 		vb2_buffer_done(vb, state);
 
 		spin_lock_irqsave(&aq->lock, flags);
-		need_reset = true;
 	}
 
 	spin_unlock_irqrestore(&aq->lock, flags);
@@ -699,8 +700,8 @@ static int reset_start_streaming(struct ipu6_isys_video *av)
 
 	spin_lock_irqsave(&aq->lock, flags);
 	while (!list_empty(&aq->active)) {
-		struct ipu6_isys_buffer *ib = list_first_entry(&aq->active,
-			struct ipu6_isys_buffer, head);
+		struct ipu6_isys_buffer *ib = list_last_entry(&aq->active,
+							      struct ipu6_isys_buffer, head);
 
 		list_del(&ib->head);
 		list_add_tail(&ib->head, &aq->incoming);
-- 
2.34.1

