From 8916a5d4a24a5608dad2155eeaf897bac882d345 Mon Sep 17 00:00:00 2001
From: "Li, Fei1" <fei1.li@intel.com>
Date: Sat, 24 Feb 2018 19:40:56 +0800
Subject: [PATCH 1117/2367] Rename driver/cwp to driver/acrn

Change-Id: Ia8e4c4abd489a2eb70bdeb9b60cfda7da58bb6cf
Tracked-On: 212688
Signed-off-by: Li, Fei1 <fei1.li@intel.com>
Reviewed-on: https://android.intel.com/619808
---
 drivers/Kconfig         |   2 +-
 drivers/Makefile        |   2 +-
 drivers/acrn/Kconfig    |  20 +++
 drivers/acrn/Makefile   |   3 +
 drivers/acrn/hvlog.c    | 432 ++++++++++++++++++++++++++++++++++++++++++++++++
 drivers/acrn/sbuf.c     | 237 ++++++++++++++++++++++++++
 drivers/acrn/sbuf.h     | 129 +++++++++++++++
 drivers/acrn/trace.c    | 299 +++++++++++++++++++++++++++++++++
 drivers/cwp/Kconfig     |  20 ---
 drivers/cwp/Makefile    |   3 -
 drivers/cwp/cwp_hvlog.c | 432 ------------------------------------------------
 drivers/cwp/cwp_trace.c | 304 ----------------------------------
 drivers/cwp/sbuf.c      | 237 --------------------------
 drivers/cwp/sbuf.h      | 129 ---------------
 14 files changed, 1122 insertions(+), 1127 deletions(-)
 create mode 100644 drivers/acrn/Kconfig
 create mode 100644 drivers/acrn/Makefile
 create mode 100644 drivers/acrn/hvlog.c
 create mode 100644 drivers/acrn/sbuf.c
 create mode 100644 drivers/acrn/sbuf.h
 create mode 100644 drivers/acrn/trace.c
 delete mode 100644 drivers/cwp/Kconfig
 delete mode 100644 drivers/cwp/Makefile
 delete mode 100644 drivers/cwp/cwp_hvlog.c
 delete mode 100644 drivers/cwp/cwp_trace.c
 delete mode 100644 drivers/cwp/sbuf.c
 delete mode 100644 drivers/cwp/sbuf.h

diff --git a/drivers/Kconfig b/drivers/Kconfig
index 430f6b0..cb03e48 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -217,7 +217,7 @@ source "drivers/opp/Kconfig"
 
 source "drivers/vbs/Kconfig"
 
-source "drivers/cwp/Kconfig"
+source "drivers/acrn/Kconfig"
 
 source "drivers/vhm/Kconfig"
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 5856632..0076bdd 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -188,4 +188,4 @@ obj-$(CONFIG_TEE)		+= tee/
 obj-$(CONFIG_MULTIPLEXER)	+= mux/
 obj-$(CONFIG_SDW)		+= sdw/
 obj-$(CONFIG_CWP_VHM) 		+= vhm/
-obj-$(CONFIG_CWP)		+= cwp/
+obj-$(CONFIG_ACRN)		+= acrn/
diff --git a/drivers/acrn/Kconfig b/drivers/acrn/Kconfig
new file mode 100644
index 00000000..9056a4f
--- /dev/null
+++ b/drivers/acrn/Kconfig
@@ -0,0 +1,20 @@
+config ACRN_SHARED_BUFFER
+	bool "Intel ACRN SHARED BUFFER"
+	---help---
+	  Ring buffer shared between ACRN Hypervisor and its SOS.
+	  Help ACRN performance profiling.
+
+config ACRN_TRACE
+	tristate "Intel ACRN Hypervisor Trace support"
+	select ACRN_SHARED_BUFFER
+	---help---
+		This is the Trace driver for the Intel ACRN hypervisor.
+		You can say y to build it into the kernel, or m to build
+		it as a module.
+
+config ACRN_HVLOG
+	bool "Intel ACRN Hypervisor Logmsg support"
+	select ACRN_SHARED_BUFFER
+	---help---
+		This is the Trace driver for the Intel ACRN hypervisor log.
+		You can say y to build it into the kernel.
diff --git a/drivers/acrn/Makefile b/drivers/acrn/Makefile
new file mode 100644
index 00000000..0a15771
--- /dev/null
+++ b/drivers/acrn/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_ACRN_SHARED_BUFFER) += sbuf.o
+obj-$(CONFIG_ACRN_TRACE) += trace.o
+obj-$(CONFIG_ACRN_HVLOG) += hvlog.o
diff --git a/drivers/acrn/hvlog.c b/drivers/acrn/hvlog.c
new file mode 100644
index 00000000..ed1ab79
--- /dev/null
+++ b/drivers/acrn/hvlog.c
@@ -0,0 +1,432 @@
+/*
+ * ACRN Hypervisor logmsg
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright (c) 2017 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information: Li Fei <fei1.li@intel.com>
+ *
+ * BSD LICENSE
+ *
+ * Copyright (C) 2017 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Li Fei <fei1.li@intel.com>
+ *
+ */
+#define pr_fmt(fmt) "ACRN HVLog: " fmt
+
+#include <linux/memblock.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/module.h>
+#include <linux/major.h>
+#include <linux/miscdevice.h>
+
+#include "sbuf.h"
+
+#define LOG_ENTRY_SIZE		80
+#define PCPU_NRS		4
+
+#define foreach_cpu(cpu, cpu_num)					\
+	for ((cpu) = 0; (cpu) < (cpu_num); (cpu)++)
+
+#define foreach_hvlog_type(idx, hvlog_type)				\
+	for ((idx) = 0; (idx) < (hvlog_type); (idx)++)
+
+enum sbuf_hvlog_index {
+	ACRN_CURRNET_HVLOG = 0,
+	ACRN_LAST_HVLOG,
+	ACRN_HVLOG_TYPE
+};
+
+struct acrn_hvlog {
+	struct miscdevice miscdev;
+	shared_buf_t *sbuf;
+	atomic_t open_cnt;
+	int pcpu_num;
+};
+
+static unsigned long long hvlog_buf_size;
+static unsigned long long hvlog_buf_base;
+
+static int __init early_hvlog(char *p)
+{
+	int ret;
+
+	pr_debug("%s(%s)\n", __func__, p);
+	hvlog_buf_size = memparse(p, &p);
+	if (*p != '@')
+		return 0;
+	hvlog_buf_base = memparse(p + 1, &p);
+
+	if (!!hvlog_buf_base && !!hvlog_buf_size) {
+		ret = memblock_reserve(hvlog_buf_base, hvlog_buf_size);
+		if (ret) {
+			pr_err("%s: Error reserving hvlog memblock\n",
+				__func__);
+			hvlog_buf_base = 0;
+			hvlog_buf_size = 0;
+			return ret;
+		}
+	}
+
+	return 0;
+}
+early_param("hvlog", early_hvlog);
+
+
+static inline shared_buf_t *hvlog_mark_unread(shared_buf_t *sbuf)
+{
+	/* sbuf must point to valid data.
+	 * clear the lowest bit in the magic to indicate that
+	 * the sbuf point to the last boot valid data, we should
+	 * read it later.
+	 */
+	if (sbuf != NULL)
+		sbuf->magic &= ~1;
+
+	return sbuf;
+}
+
+static int hvlog_open(struct inode *inode, struct file *filp)
+{
+	struct acrn_hvlog *acrn_hvlog;
+
+	acrn_hvlog = container_of(filp->private_data,
+				struct acrn_hvlog, miscdev);
+	pr_debug("%s, %s\n", __func__, acrn_hvlog->miscdev.name);
+
+	if (acrn_hvlog->pcpu_num >= PCPU_NRS) {
+		pr_err("%s, invalid pcpu_num: %d\n",
+				__func__, acrn_hvlog->pcpu_num);
+		return -EIO;
+	}
+
+	/* More than one reader at the same time could get data messed up */
+	if (atomic_cmpxchg(&acrn_hvlog->open_cnt, 0, 1) != 0)
+		return -EBUSY;
+
+	filp->private_data = acrn_hvlog;
+
+	return 0;
+}
+
+static int hvlog_release(struct inode *inode, struct file *filp)
+{
+	struct acrn_hvlog *acrn_hvlog;
+
+	acrn_hvlog = filp->private_data;
+
+	pr_debug("%s, %s\n", __func__, acrn_hvlog->miscdev.name);
+
+	if (acrn_hvlog->pcpu_num >= PCPU_NRS) {
+		pr_err("%s, invalid pcpu_num: %d\n",
+				__func__, acrn_hvlog->pcpu_num);
+		return -EIO;
+	}
+
+	atomic_dec(&acrn_hvlog->open_cnt);
+	filp->private_data = NULL;
+
+	return 0;
+}
+
+static ssize_t hvlog_read(struct file *filp, char __user *buf,
+				size_t count, loff_t *offset)
+{
+	char data[LOG_ENTRY_SIZE];
+	struct acrn_hvlog *acrn_hvlog;
+	int ret;
+
+	acrn_hvlog = (struct acrn_hvlog *)filp->private_data;
+
+	pr_debug("%s, %s\n", __func__, acrn_hvlog->miscdev.name);
+
+	if (acrn_hvlog->pcpu_num >= PCPU_NRS) {
+		pr_err("%s, invalid pcpu_num: %d\n",
+				__func__, acrn_hvlog->pcpu_num);
+		return -EIO;
+	}
+
+	if (acrn_hvlog->sbuf != NULL) {
+		ret = sbuf_get(acrn_hvlog->sbuf, (uint8_t *)&data);
+		if (ret > 0) {
+			if (copy_to_user(buf, &data, ret))
+				return -EFAULT;
+		}
+
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct file_operations hvlog_fops = {
+	.owner  = THIS_MODULE,
+	.open   = hvlog_open,
+	.release = hvlog_release,
+	.read = hvlog_read,
+};
+
+static struct acrn_hvlog hvlog_devs[ACRN_HVLOG_TYPE][PCPU_NRS] = {
+	[ACRN_CURRNET_HVLOG] = {
+		{
+			.miscdev = {
+				.name   = "acrn_hvlog_cur_0",
+				.minor  = MISC_DYNAMIC_MINOR,
+				.fops   = &hvlog_fops,
+			},
+			.pcpu_num = 0,
+		},
+		{
+			.miscdev = {
+				.name   = "acrn_hvlog_cur_1",
+				.minor  = MISC_DYNAMIC_MINOR,
+				.fops   = &hvlog_fops,
+			},
+			.pcpu_num = 1,
+		},
+		{
+			.miscdev = {
+				.name   = "acrn_hvlog_cur_2",
+				.minor  = MISC_DYNAMIC_MINOR,
+				.fops   = &hvlog_fops,
+			},
+			.pcpu_num = 2,
+		},
+		{
+			.miscdev = {
+				.name   = "acrn_hvlog_cur_3",
+				.minor  = MISC_DYNAMIC_MINOR,
+				.fops   = &hvlog_fops,
+			},
+			.pcpu_num = 3,
+		},
+	},
+	[ACRN_LAST_HVLOG] = {
+		{
+			.miscdev = {
+				.name   = "acrn_hvlog_last_0",
+				.minor  = MISC_DYNAMIC_MINOR,
+				.fops   = &hvlog_fops,
+			},
+			.pcpu_num = 0,
+		},
+		{
+			.miscdev = {
+				.name   = "acrn_hvlog_last_1",
+				.minor  = MISC_DYNAMIC_MINOR,
+				.fops   = &hvlog_fops,
+			},
+			.pcpu_num = 1,
+		},
+		{
+			.miscdev = {
+				.name   = "acrn_hvlog_last_2",
+				.minor  = MISC_DYNAMIC_MINOR,
+				.fops   = &hvlog_fops,
+			},
+			.pcpu_num = 2,
+		},
+		{
+			.miscdev = {
+				.name   = "acrn_hvlog_last_3",
+				.minor  = MISC_DYNAMIC_MINOR,
+				.fops   = &hvlog_fops,
+			},
+			.pcpu_num = 3,
+		},
+	}
+};
+
+static int __init acrn_hvlog_init(void)
+{
+	int ret = 0;
+	int i, j, idx;
+	uint32_t pcpu_id;
+	uint64_t logbuf_base0;
+	uint64_t logbuf_base1;
+	uint64_t logbuf_size;
+	uint32_t ele_size;
+	uint32_t ele_num;
+	uint32_t size;
+	bool sbuf_constructed = false;
+
+	shared_buf_t *sbuf0[PCPU_NRS];
+	shared_buf_t *sbuf1[PCPU_NRS];
+
+	pr_info("%s\n", __func__);
+	if (!hvlog_buf_base || !hvlog_buf_size) {
+		pr_warn("no fixed memory reserve for hvlog.\n");
+		return 0;
+	}
+
+	logbuf_base0 = hvlog_buf_base;
+	logbuf_size = (hvlog_buf_size >> 1);
+	logbuf_base1 = hvlog_buf_base + logbuf_size;
+
+	size = (logbuf_size / PCPU_NRS);
+	ele_size = LOG_ENTRY_SIZE;
+	ele_num = (size - SBUF_HEAD_SIZE) / ele_size;
+
+	foreach_cpu(pcpu_id, PCPU_NRS) {
+		sbuf0[pcpu_id] = sbuf_check_valid(ele_num, ele_size,
+					logbuf_base0 + size * pcpu_id);
+		sbuf1[pcpu_id] = sbuf_check_valid(ele_num, ele_size,
+					logbuf_base1 + size * pcpu_id);
+	}
+
+	foreach_cpu(pcpu_id, PCPU_NRS) {
+		if (sbuf0[pcpu_id] == NULL)
+			continue;
+
+		foreach_cpu(pcpu_id, PCPU_NRS) {
+			hvlog_devs[ACRN_LAST_HVLOG][pcpu_id].sbuf =
+					hvlog_mark_unread(sbuf0[pcpu_id]);
+			hvlog_devs[ACRN_CURRNET_HVLOG][pcpu_id].sbuf =
+				sbuf_construct(ele_num, ele_size,
+					logbuf_base1 + size * pcpu_id);
+		}
+		sbuf_constructed = true;
+	}
+
+	if (sbuf_constructed == false) {
+		foreach_cpu(pcpu_id, PCPU_NRS) {
+			if (sbuf1[pcpu_id] == NULL)
+				continue;
+
+			foreach_cpu(pcpu_id, PCPU_NRS) {
+				hvlog_devs[ACRN_LAST_HVLOG][pcpu_id].sbuf =
+					hvlog_mark_unread(sbuf1[pcpu_id]);
+			}
+		}
+		foreach_cpu(pcpu_id, PCPU_NRS) {
+			hvlog_devs[ACRN_CURRNET_HVLOG][pcpu_id].sbuf =
+				sbuf_construct(ele_num, ele_size,
+					logbuf_base0 + size * pcpu_id);
+		}
+		sbuf_constructed = true;
+	}
+
+	idx = ACRN_CURRNET_HVLOG;
+	{
+		foreach_cpu(pcpu_id, PCPU_NRS) {
+			ret = sbuf_share_setup(pcpu_id, ACRN_HVLOG,
+					hvlog_devs[idx][pcpu_id].sbuf);
+			if (ret < 0) {
+				pr_err("Failed to setup %s, errno %d\n",
+				hvlog_devs[idx][pcpu_id].miscdev.name, ret);
+				goto setup_err;
+			}
+		}
+	}
+
+	foreach_hvlog_type(idx, ACRN_HVLOG_TYPE) {
+		foreach_cpu(pcpu_id, PCPU_NRS) {
+			atomic_set(&hvlog_devs[idx][pcpu_id].open_cnt, 0);
+
+			ret = misc_register(
+					&hvlog_devs[idx][pcpu_id].miscdev);
+			if (ret < 0) {
+				pr_err("Failed to register %s, errno %d\n",
+				hvlog_devs[idx][pcpu_id].miscdev.name, ret);
+				goto reg_err;
+			}
+		}
+	}
+
+	return 0;
+
+reg_err:
+	foreach_hvlog_type(i, idx) {
+		foreach_cpu(j, PCPU_NRS) {
+			misc_deregister(&hvlog_devs[i][j].miscdev);
+		}
+	}
+
+	foreach_cpu(j, pcpu_id) {
+		misc_deregister(&hvlog_devs[idx][j].miscdev);
+	}
+
+	pcpu_id = PCPU_NRS;
+setup_err:
+	idx = ACRN_CURRNET_HVLOG;
+	{
+		foreach_cpu(j, pcpu_id) {
+			sbuf_share_setup(j, ACRN_HVLOG, 0);
+			sbuf_deconstruct(hvlog_devs[idx][j].sbuf);
+		}
+	}
+
+	return ret;
+}
+
+static void __exit acrn_hvlog_exit(void)
+{
+	int idx;
+	uint32_t pcpu_id;
+
+	pr_info("%s\n", __func__);
+
+	foreach_hvlog_type(idx, ACRN_HVLOG_TYPE) {
+		foreach_cpu(pcpu_id, PCPU_NRS) {
+			misc_deregister(&hvlog_devs[idx][pcpu_id].miscdev);
+		}
+	}
+
+	idx = ACRN_CURRNET_HVLOG;
+	{
+		foreach_cpu(pcpu_id, PCPU_NRS) {
+			sbuf_share_setup(pcpu_id, ACRN_HVLOG, 0);
+			sbuf_deconstruct(hvlog_devs[idx][pcpu_id].sbuf);
+		}
+	}
+}
+
+module_init(acrn_hvlog_init);
+module_exit(acrn_hvlog_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Intel Corp., http://www.intel.com");
+MODULE_DESCRIPTION("Driver for the Intel ACRN Hypervisor Logmsg");
+MODULE_VERSION("0.1");
diff --git a/drivers/acrn/sbuf.c b/drivers/acrn/sbuf.c
new file mode 100644
index 00000000..a358232
--- /dev/null
+++ b/drivers/acrn/sbuf.c
@@ -0,0 +1,237 @@
+/*
+ * shared buffer
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright (c) 2017 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information: Li Fei <fei1.li@intel.com>
+ *
+ * BSD LICENSE
+ *
+ * Copyright (C) 2017 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Li Fei <fei1.li@intel.com>
+ *
+ */
+
+#define pr_fmt(fmt) "SBuf: " fmt
+
+#include <linux/gfp.h>
+#include <asm/pgtable.h>
+#include <linux/vhm/acrn_hv_defs.h>
+#include <linux/vhm/vhm_hypercall.h>
+#include "sbuf.h"
+
+static inline bool sbuf_is_empty(shared_buf_t *sbuf)
+{
+	return (sbuf->head == sbuf->tail);
+}
+
+static inline uint32_t sbuf_next_ptr(uint32_t pos,
+		uint32_t span, uint32_t scope)
+{
+	pos += span;
+	pos = (pos >= scope) ? (pos - scope) : pos;
+	return pos;
+}
+
+static inline uint32_t sbuf_calculate_allocate_size(uint32_t ele_num,
+						uint32_t ele_size)
+{
+	uint64_t sbuf_allocate_size;
+
+	sbuf_allocate_size = ele_num * ele_size;
+	sbuf_allocate_size +=  SBUF_HEAD_SIZE;
+	if (sbuf_allocate_size > SBUF_MAX_SIZE) {
+		pr_err("num=0x%x, size=0x%x exceed 0x%llx!\n",
+			ele_num, ele_size, SBUF_MAX_SIZE);
+		return 0;
+	}
+
+	/* align to PAGE_SIZE */
+	return (sbuf_allocate_size + PAGE_SIZE - 1) & PAGE_MASK;
+}
+
+shared_buf_t *sbuf_allocate(uint32_t ele_num, uint32_t ele_size)
+{
+	shared_buf_t *sbuf;
+	struct page *page;
+	uint32_t sbuf_allocate_size;
+
+	if (!ele_num || !ele_size) {
+		pr_err("invalid parameter %s!\n", __func__);
+		return NULL;
+	}
+
+	sbuf_allocate_size = sbuf_calculate_allocate_size(ele_num, ele_size);
+	if (!sbuf_allocate_size)
+		return NULL;
+
+	page = alloc_pages(GFP_KERNEL | __GFP_ZERO,
+					get_order(sbuf_allocate_size));
+	if (page == NULL) {
+		pr_err("failed to alloc pages!\n");
+		return NULL;
+	}
+
+	sbuf = phys_to_virt(page_to_phys(page));
+	sbuf->ele_num = ele_num;
+	sbuf->ele_size = ele_size;
+	sbuf->size = ele_num * ele_size;
+	sbuf->magic = SBUF_MAGIC;
+	pr_info("ele_num=0x%x, ele_size=0x%x allocated!\n",
+		ele_num, ele_size);
+	return sbuf;
+}
+EXPORT_SYMBOL(sbuf_allocate);
+
+void sbuf_free(shared_buf_t *sbuf)
+{
+	uint32_t sbuf_allocate_size;
+
+	if ((sbuf == NULL) || sbuf->magic != SBUF_MAGIC) {
+		pr_err("invalid parameter %s\n", __func__);
+		return;
+	}
+
+	sbuf_allocate_size = sbuf_calculate_allocate_size(sbuf->ele_num,
+						sbuf->ele_size);
+	if (!sbuf_allocate_size)
+		return;
+
+	sbuf->magic = 0;
+	__free_pages((struct page *)virt_to_page(sbuf),
+			get_order(sbuf_allocate_size));
+}
+EXPORT_SYMBOL(sbuf_free);
+
+int sbuf_get(shared_buf_t *sbuf, uint8_t *data)
+{
+	const void *from;
+
+	if ((sbuf == NULL) || (data == NULL))
+		return -EINVAL;
+
+	if (sbuf_is_empty(sbuf)) {
+		/* no data available */
+		return 0;
+	}
+
+	from = (void *)sbuf + SBUF_HEAD_SIZE + sbuf->head;
+
+	memcpy(data, from, sbuf->ele_size);
+
+	sbuf->head = sbuf_next_ptr(sbuf->head, sbuf->ele_size, sbuf->size);
+
+	return sbuf->ele_size;
+}
+EXPORT_SYMBOL(sbuf_get);
+
+int sbuf_share_setup(uint32_t pcpu_id, uint32_t sbuf_id, shared_buf_t *sbuf)
+{
+	struct sbuf_setup_param ssp;
+
+	ssp.pcpu_id = pcpu_id;
+	ssp.sbuf_id = sbuf_id;
+
+	if (!sbuf) {
+		ssp.gpa = 0;
+	} else {
+		BUG_ON(!virt_addr_valid(sbuf));
+		ssp.gpa = virt_to_phys(sbuf);
+	}
+	pr_info("setup phys add = 0x%llx\n", ssp.gpa);
+
+	return hcall_setup_sbuf(virt_to_phys(&ssp));
+}
+EXPORT_SYMBOL(sbuf_share_setup);
+
+shared_buf_t *sbuf_check_valid(uint32_t ele_num, uint32_t ele_size,
+				uint64_t paddr)
+{
+	shared_buf_t *sbuf;
+
+	if (!ele_num || !ele_size || !paddr)
+		return NULL;
+
+	sbuf = (shared_buf_t *)phys_to_virt(paddr);
+	BUG_ON(!virt_addr_valid(sbuf));
+
+	if ((sbuf->magic == SBUF_MAGIC) &&
+		(sbuf->ele_num == ele_num) &&
+		(sbuf->ele_size == ele_size)) {
+		return sbuf;
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL(sbuf_check_valid);
+
+shared_buf_t *sbuf_construct(uint32_t ele_num, uint32_t ele_size,
+				uint64_t paddr)
+{
+	shared_buf_t *sbuf;
+
+	if (!ele_num || !ele_size || !paddr)
+		return NULL;
+
+	sbuf = (shared_buf_t *)phys_to_virt(paddr);
+	BUG_ON(!virt_addr_valid(sbuf));
+
+	memset(sbuf, 0, SBUF_HEAD_SIZE);
+	sbuf->magic = SBUF_MAGIC;
+	sbuf->ele_num = ele_num;
+	sbuf->ele_size = ele_size;
+	sbuf->size = ele_num * ele_size;
+	pr_info("construct sbuf at 0x%llx.\n", paddr);
+	return sbuf;
+}
+EXPORT_SYMBOL(sbuf_construct);
+
+void sbuf_deconstruct(shared_buf_t *sbuf)
+{
+	if (sbuf == NULL)
+		return;
+
+	sbuf->magic = 0;
+}
+EXPORT_SYMBOL(sbuf_deconstruct);
diff --git a/drivers/acrn/sbuf.h b/drivers/acrn/sbuf.h
new file mode 100644
index 00000000..4fae7a2
--- /dev/null
+++ b/drivers/acrn/sbuf.h
@@ -0,0 +1,129 @@
+/*
+ * shared buffer
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright (c) 2017 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information: Li Fei <fei1.li@intel.com>
+ *
+ * BSD LICENSE
+ *
+ * Copyright (C) 2017 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Li Fei <fei1.li@intel.com>
+ *
+ */
+
+#ifndef SHARED_BUF_H
+#define SHARED_BUF_H
+
+#include <linux/types.h>
+
+
+#define SBUF_MAGIC	0x5aa57aa71aa13aa3
+#define SBUF_MAX_SIZE	(1ULL << 22)
+#define SBUF_HEAD_SIZE	64
+
+/* sbuf flags */
+#define OVERRUN_CNT_EN	(1ULL << 0) /* whether overrun counting is enabled */
+#define OVERWRITE_EN	(1ULL << 1) /* whether overwrite is enabled */
+
+enum sbuf_type {
+	ACRN_TRACE,
+	ACRN_HVLOG,
+	ACRN_SBUF_TYPE_MAX,
+};
+/**
+ * (sbuf) head + buf (store (ele_num - 1) elements at most)
+ * buffer empty: tail == head
+ * buffer full:  (tail + ele_size) % size == head
+ *
+ *             Base of memory for elements
+ *                |
+ *                |
+ * ---------------------------------------------------------------------------------------
+ * | shared_buf_t | raw data (ele_size)| raw date (ele_size) | ... | raw data (ele_size) |
+ * ---------------------------------------------------------------------------------------
+ * |
+ * |
+ * shared_buf_t *buf
+ */
+
+/* Make sure sizeof(shared_buf_t) == SBUF_HEAD_SIZE */
+typedef struct shared_buf {
+	uint64_t magic;
+	uint32_t ele_num;	/* number of elements */
+	uint32_t ele_size;	/* sizeof of elements */
+	uint32_t head;		/* offset from base, to read */
+	uint32_t tail;		/* offset from base, to write */
+	uint64_t flags;
+	uint32_t overrun_cnt;	/* count of overrun */
+	uint32_t size;		/* ele_num * ele_size */
+	uint32_t padding[6];
+} ____cacheline_aligned shared_buf_t;
+
+static inline void sbuf_clear_flags(shared_buf_t *sbuf, uint64_t flags)
+{
+	sbuf->flags &= ~flags;
+}
+
+static inline void sbuf_set_flags(shared_buf_t *sbuf, uint64_t flags)
+{
+	sbuf->flags = flags;
+}
+
+static inline void sbuf_add_flags(shared_buf_t *sbuf, uint64_t flags)
+{
+	sbuf->flags |= flags;
+}
+
+shared_buf_t *sbuf_allocate(uint32_t ele_num, uint32_t ele_size);
+void sbuf_free(shared_buf_t *sbuf);
+int sbuf_get(shared_buf_t *sbuf, uint8_t *data);
+int sbuf_share_setup(uint32_t pcpu_id, uint32_t sbuf_id, shared_buf_t *sbuf);
+shared_buf_t *sbuf_check_valid(uint32_t ele_num, uint32_t ele_size,
+				uint64_t gpa);
+shared_buf_t *sbuf_construct(uint32_t ele_num, uint32_t ele_size,
+				uint64_t gpa);
+void sbuf_deconstruct(shared_buf_t *sbuf);
+
+#endif /* SHARED_BUF_H */
diff --git a/drivers/acrn/trace.c b/drivers/acrn/trace.c
new file mode 100644
index 00000000..2a9d87e
--- /dev/null
+++ b/drivers/acrn/trace.c
@@ -0,0 +1,299 @@
+/*
+*
+* ACRN Trace module
+*
+* This file is provided under a dual BSD/GPLv2 license.  When using or
+* redistributing this file, you may do so under either license.
+*
+* GPL LICENSE SUMMARY
+*
+* Copyright (c) 2017 Intel Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+*
+* Contact Information: Yan, Like <like.yan@intel.com>
+*
+* BSD LICENSE
+*
+* Copyright (c) 2017 Intel Corporation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above copyright
+*     notice, this list of conditions and the following disclaimer in
+*     the documentation and/or other materials provided with the
+*     distribution.
+*   * Neither the name of Intel Corporation nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+* Like Yan <like.yan@intel.com>
+*
+*/
+
+#define pr_fmt(fmt) "ACRNTrace: " fmt
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/major.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+
+#include <asm/hypervisor.h>
+
+#include "sbuf.h"
+
+
+#define TRACE_SBUF_SIZE		(4 * 1024 * 1024)
+#define TRACE_ELEMENT_SIZE	32 /* byte */
+#define TRACE_ELEMENT_NUM	((TRACE_SBUF_SIZE - SBUF_HEAD_SIZE) /	\
+				TRACE_ELEMENT_SIZE)
+
+#define foreach_cpu(cpu, cpu_num)					\
+	for ((cpu) = 0; (cpu) < (cpu_num); (cpu)++)
+
+#define MAX_NR_CPUS	4
+/* actual physical cpu number, initialized by module init */
+static int pcpu_num;
+
+static int nr_cpus = MAX_NR_CPUS;
+module_param(nr_cpus, int, S_IRUSR | S_IWUSR);
+
+static atomic_t open_cnt[MAX_NR_CPUS];
+static shared_buf_t *sbuf_per_cpu[MAX_NR_CPUS];
+
+static inline int get_id_from_devname(struct file *filep)
+{
+	uint32_t cpuid;
+	int err;
+	char id_str[16];
+	struct miscdevice *dev = filep->private_data;
+
+	strncpy(id_str, (void *)dev->name + sizeof("acrn_trace_") - 1, 16);
+	id_str[15] = '\0';
+	err = kstrtoul(&id_str[0], 10, (unsigned long *)&cpuid);
+
+	if (err)
+		return err;
+
+	if (cpuid >= pcpu_num) {
+		pr_err("%s, failed to get cpuid, cpuid %d\n",
+			__func__, cpuid);
+		return -1;
+	}
+
+	return cpuid;
+}
+
+/************************************************************************
+ *
+ * file_operations functions
+ *
+ ***********************************************************************/
+static int trace_open(struct inode *inode, struct file *filep)
+{
+	int cpuid = get_id_from_devname(filep);
+
+	pr_debug("%s, cpu %d\n", __func__, cpuid);
+	if (cpuid < 0)
+		return -ENXIO;
+
+	/* More than one reader at the same time could get data messed up */
+	if (atomic_read(&open_cnt[cpuid]))
+		return -EBUSY;
+
+	atomic_inc(&open_cnt[cpuid]);
+
+	return 0;
+}
+
+static int trace_release(struct inode *inode, struct file *filep)
+{
+	int cpuid = get_id_from_devname(filep);
+
+	pr_debug("%s, cpu %d\n", __func__, cpuid);
+	if (cpuid < 0)
+		return -ENXIO;
+
+	atomic_dec(&open_cnt[cpuid]);
+
+	return 0;
+}
+
+static int trace_mmap(struct file *filep, struct vm_area_struct *vma)
+{
+	int cpuid = get_id_from_devname(filep);
+	phys_addr_t paddr;
+
+	pr_debug("%s, cpu %d\n", __func__, cpuid);
+	if (cpuid < 0)
+		return -ENXIO;
+
+	BUG_ON(!virt_addr_valid(sbuf_per_cpu[cpuid]));
+	paddr = virt_to_phys(sbuf_per_cpu[cpuid]);
+
+	if (remap_pfn_range(vma, vma->vm_start,
+				paddr >> PAGE_SHIFT,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot)) {
+		pr_err("Failed to mmap sbuf for cpu%d\n", cpuid);
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+static const struct file_operations trace_fops = {
+	.owner  = THIS_MODULE,
+	.open   = trace_open,
+	.release = trace_release,
+	.mmap   = trace_mmap,
+};
+
+static struct miscdevice trace_dev0 = {
+	.name   = "acrn_trace_0",
+	.minor  = MISC_DYNAMIC_MINOR,
+	.fops   = &trace_fops,
+};
+
+static struct miscdevice trace_dev1 = {
+	.name   = "acrn_trace_1",
+	.minor  = MISC_DYNAMIC_MINOR,
+	.fops   = &trace_fops,
+};
+
+static struct miscdevice trace_dev2 = {
+	.name   = "acrn_trace_2",
+	.minor  = MISC_DYNAMIC_MINOR,
+	.fops   = &trace_fops,
+};
+
+static struct miscdevice trace_dev3 = {
+	.name   = "acrn_trace_3",
+	.minor  = MISC_DYNAMIC_MINOR,
+	.fops   = &trace_fops,
+};
+
+static struct miscdevice *trace_devs[4] = {
+	&trace_dev0,
+	&trace_dev1,
+	&trace_dev2,
+	&trace_dev3,
+};
+
+/*
+ * acrn_trace_init()
+ */
+static int __init acrn_trace_init(void)
+{
+	int ret = 0;
+	int i, cpu;
+
+	/* TBD: we could get the native cpu number by hypercall later */
+	pr_info("%s, cpu_num %d\n", __func__, nr_cpus);
+	if (nr_cpus > MAX_NR_CPUS) {
+		pr_err("nr_cpus %d exceed MAX_NR_CPUS %d !\n",
+			nr_cpus, MAX_NR_CPUS);
+		return -EINVAL;
+	}
+	pcpu_num = nr_cpus;
+
+	foreach_cpu(cpu, pcpu_num) {
+		/* allocate shared_buf */
+		sbuf_per_cpu[cpu] = sbuf_allocate(TRACE_ELEMENT_NUM,
+							TRACE_ELEMENT_SIZE);
+		if (!sbuf_per_cpu[cpu]) {
+			pr_err("Failed alloc SBuf, cpuid %d\n", cpu);
+			ret = -ENOMEM;
+			goto out_free;
+		}
+	}
+
+	foreach_cpu(cpu, pcpu_num) {
+		ret = sbuf_share_setup(cpu, ACRN_TRACE, sbuf_per_cpu[cpu]);
+		if (ret < 0) {
+			pr_err("Failed to setup SBuf, cpuid %d\n", cpu);
+			goto out_sbuf;
+		}
+	}
+
+	foreach_cpu(cpu, pcpu_num) {
+		ret = misc_register(trace_devs[cpu]);
+		if (ret < 0) {
+			pr_err("Failed to register acrn_trace_%d, errno %d\n",
+				cpu, ret);
+			goto out_dereg;
+		}
+	}
+
+	return ret;
+
+out_dereg:
+	for (i = --cpu; i >= 0; i--)
+		misc_deregister(trace_devs[i]);
+	cpu = pcpu_num;
+
+out_sbuf:
+	for (i = --cpu; i >= 0; i--)
+		sbuf_share_setup(i, ACRN_TRACE, NULL);
+	cpu = pcpu_num;
+
+out_free:
+	for (i = --cpu; i >= 0; i--)
+		sbuf_free(sbuf_per_cpu[i]);
+
+	return ret;
+}
+
+/*
+ * acrn_trace_exit()
+ */
+static void __exit acrn_trace_exit(void)
+{
+	int cpu;
+
+	pr_info("%s, cpu_num %d\n", __func__, pcpu_num);
+
+	foreach_cpu(cpu, pcpu_num) {
+		/* deregister devices */
+		misc_deregister(trace_devs[cpu]);
+
+		/* set sbuf pointer to NULL in HV */
+		sbuf_share_setup(cpu, ACRN_TRACE, NULL);
+
+		/* free sbuf, sbuf_per_cpu[cpu] should be set NULL */
+		sbuf_free(sbuf_per_cpu[cpu]);
+	}
+}
+
+module_init(acrn_trace_init);
+module_exit(acrn_trace_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Intel Corp., http://www.intel.com");
+MODULE_DESCRIPTION("Driver for the Intel ACRN Hypervisor Trace");
+MODULE_VERSION("0.1");
diff --git a/drivers/cwp/Kconfig b/drivers/cwp/Kconfig
deleted file mode 100644
index 091b3a1..00000000
--- a/drivers/cwp/Kconfig
+++ /dev/null
@@ -1,20 +0,0 @@
-config CWP_SHARED_BUFFER
-	bool "Intel CWP SHARED BUFFER"
-	---help---
-	  Ring buffer shared between CWP Hypervisor and its SOS.
-	  Help CWP performance profiling.
-
-config CWP_TRACE
-	tristate "Intel CWP Hypervisor Trace support"
-	select CWP_SHARED_BUFFER
-	---help---
-		This is the Trace driver for the Intel CWP hypervisor.
-		You can say y to build it into the kernel, or m to build
-		it as a module.
-
-config CWP_HVLOG
-	bool "Intel CWP Hypervisor Logmsg support"
-	select CWP_SHARED_BUFFER
-	---help---
-		This is the Trace driver for the Intel CWP hypervisor log.
-		You can say y to build it into the kernel.
diff --git a/drivers/cwp/Makefile b/drivers/cwp/Makefile
deleted file mode 100644
index 2e5fe43c..00000000
--- a/drivers/cwp/Makefile
+++ /dev/null
@@ -1,3 +0,0 @@
-obj-$(CONFIG_CWP_SHARED_BUFFER) += sbuf.o
-obj-$(CONFIG_CWP_TRACE) += cwp_trace.o
-obj-$(CONFIG_CWP_HVLOG) += cwp_hvlog.o
diff --git a/drivers/cwp/cwp_hvlog.c b/drivers/cwp/cwp_hvlog.c
deleted file mode 100644
index c9481a9..00000000
--- a/drivers/cwp/cwp_hvlog.c
+++ /dev/null
@@ -1,432 +0,0 @@
-/*
- * CWP Hypervisor logmsg
- *
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright (c) 2017 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * Contact Information: Li Fei <fei1.li@intel.com>
- *
- * BSD LICENSE
- *
- * Copyright (C) 2017 Intel Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * Li Fei <fei1.li@intel.com>
- *
- */
-#define pr_fmt(fmt) "CWP HVLog: " fmt
-
-#include <linux/memblock.h>
-#include <linux/kernel.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/module.h>
-#include <linux/major.h>
-#include <linux/miscdevice.h>
-
-#include "sbuf.h"
-
-#define LOG_ENTRY_SIZE		80
-#define PCPU_NRS		4
-
-#define foreach_cpu(cpu, cpu_num)					\
-	for ((cpu) = 0; (cpu) < (cpu_num); (cpu)++)
-
-#define foreach_hvlog_type(idx, hvlog_type)				\
-	for ((idx) = 0; (idx) < (hvlog_type); (idx)++)
-
-enum sbuf_hvlog_index {
-	CWP_CURRNET_HVLOG = 0,
-	CWP_LAST_HVLOG,
-	CWP_HVLOG_TYPE
-};
-
-struct cwp_hvlog {
-	struct miscdevice miscdev;
-	shared_buf_t *sbuf;
-	atomic_t open_cnt;
-	int pcpu_num;
-};
-
-static unsigned long long hvlog_buf_size;
-static unsigned long long hvlog_buf_base;
-
-static int __init early_hvlog(char *p)
-{
-	int ret;
-
-	pr_debug("%s(%s)\n", __func__, p);
-	hvlog_buf_size = memparse(p, &p);
-	if (*p != '@')
-		return 0;
-	hvlog_buf_base = memparse(p + 1, &p);
-
-	if (!!hvlog_buf_base && !!hvlog_buf_size) {
-		ret = memblock_reserve(hvlog_buf_base, hvlog_buf_size);
-		if (ret) {
-			pr_err("%s: Error reserving hvlog memblock\n",
-				__func__);
-			hvlog_buf_base = 0;
-			hvlog_buf_size = 0;
-			return ret;
-		}
-	}
-
-	return 0;
-}
-early_param("hvlog", early_hvlog);
-
-
-static inline shared_buf_t *hvlog_mark_unread(shared_buf_t *sbuf)
-{
-	/* sbuf must point to valid data.
-	 * clear the lowest bit in the magic to indicate that
-	 * the sbuf point to the last boot valid data, we should
-	 * read it later.
-	 */
-	if (sbuf != NULL)
-		sbuf->magic &= ~1;
-
-	return sbuf;
-}
-
-static int cwp_hvlog_open(struct inode *inode, struct file *filp)
-{
-	struct cwp_hvlog *cwp_hvlog;
-
-	cwp_hvlog = container_of(filp->private_data,
-				struct cwp_hvlog, miscdev);
-	pr_debug("%s, %s\n", __func__, cwp_hvlog->miscdev.name);
-
-	if (cwp_hvlog->pcpu_num >= PCPU_NRS) {
-		pr_err("%s, invalid pcpu_num: %d\n",
-				__func__, cwp_hvlog->pcpu_num);
-		return -EIO;
-	}
-
-	/* More than one reader at the same time could get data messed up */
-	if (atomic_cmpxchg(&cwp_hvlog->open_cnt, 0, 1) != 0)
-		return -EBUSY;
-
-	filp->private_data = cwp_hvlog;
-
-	return 0;
-}
-
-static int cwp_hvlog_release(struct inode *inode, struct file *filp)
-{
-	struct cwp_hvlog *cwp_hvlog;
-
-	cwp_hvlog = filp->private_data;
-
-	pr_debug("%s, %s\n", __func__, cwp_hvlog->miscdev.name);
-
-	if (cwp_hvlog->pcpu_num >= PCPU_NRS) {
-		pr_err("%s, invalid pcpu_num: %d\n",
-				__func__, cwp_hvlog->pcpu_num);
-		return -EIO;
-	}
-
-	atomic_dec(&cwp_hvlog->open_cnt);
-	filp->private_data = NULL;
-
-	return 0;
-}
-
-static ssize_t cwp_hvlog_read(struct file *filp, char __user *buf,
-				size_t count, loff_t *offset)
-{
-	char data[LOG_ENTRY_SIZE];
-	struct cwp_hvlog *cwp_hvlog;
-	int ret;
-
-	cwp_hvlog = (struct cwp_hvlog *)filp->private_data;
-
-	pr_debug("%s, %s\n", __func__, cwp_hvlog->miscdev.name);
-
-	if (cwp_hvlog->pcpu_num >= PCPU_NRS) {
-		pr_err("%s, invalid pcpu_num: %d\n",
-				__func__, cwp_hvlog->pcpu_num);
-		return -EIO;
-	}
-
-	if (cwp_hvlog->sbuf != NULL) {
-		ret = sbuf_get(cwp_hvlog->sbuf, (uint8_t *)&data);
-		if (ret > 0) {
-			if (copy_to_user(buf, &data, ret))
-				return -EFAULT;
-		}
-
-		return ret;
-	}
-
-	return 0;
-}
-
-static const struct file_operations cwp_hvlog_fops = {
-	.owner  = THIS_MODULE,
-	.open   = cwp_hvlog_open,
-	.release = cwp_hvlog_release,
-	.read = cwp_hvlog_read,
-};
-
-static struct cwp_hvlog cwp_hvlog_devs[CWP_HVLOG_TYPE][PCPU_NRS] = {
-	[CWP_CURRNET_HVLOG] = {
-		{
-			.miscdev = {
-				.name   = "cwp_hvlog_cur_0",
-				.minor  = MISC_DYNAMIC_MINOR,
-				.fops   = &cwp_hvlog_fops,
-			},
-			.pcpu_num = 0,
-		},
-		{
-			.miscdev = {
-				.name   = "cwp_hvlog_cur_1",
-				.minor  = MISC_DYNAMIC_MINOR,
-				.fops   = &cwp_hvlog_fops,
-			},
-			.pcpu_num = 1,
-		},
-		{
-			.miscdev = {
-				.name   = "cwp_hvlog_cur_2",
-				.minor  = MISC_DYNAMIC_MINOR,
-				.fops   = &cwp_hvlog_fops,
-			},
-			.pcpu_num = 2,
-		},
-		{
-			.miscdev = {
-				.name   = "cwp_hvlog_cur_3",
-				.minor  = MISC_DYNAMIC_MINOR,
-				.fops   = &cwp_hvlog_fops,
-			},
-			.pcpu_num = 3,
-		},
-	},
-	[CWP_LAST_HVLOG] = {
-		{
-			.miscdev = {
-				.name   = "cwp_hvlog_last_0",
-				.minor  = MISC_DYNAMIC_MINOR,
-				.fops   = &cwp_hvlog_fops,
-			},
-			.pcpu_num = 0,
-		},
-		{
-			.miscdev = {
-				.name   = "cwp_hvlog_last_1",
-				.minor  = MISC_DYNAMIC_MINOR,
-				.fops   = &cwp_hvlog_fops,
-			},
-			.pcpu_num = 1,
-		},
-		{
-			.miscdev = {
-				.name   = "cwp_hvlog_last_2",
-				.minor  = MISC_DYNAMIC_MINOR,
-				.fops   = &cwp_hvlog_fops,
-			},
-			.pcpu_num = 2,
-		},
-		{
-			.miscdev = {
-				.name   = "cwp_hvlog_last_3",
-				.minor  = MISC_DYNAMIC_MINOR,
-				.fops   = &cwp_hvlog_fops,
-			},
-			.pcpu_num = 3,
-		},
-	}
-};
-
-static int __init cwp_hvlog_init(void)
-{
-	int ret = 0;
-	int i, j, idx;
-	uint32_t pcpu_id;
-	uint64_t logbuf_base0;
-	uint64_t logbuf_base1;
-	uint64_t logbuf_size;
-	uint32_t ele_size;
-	uint32_t ele_num;
-	uint32_t size;
-	bool sbuf_constructed = false;
-
-	shared_buf_t *sbuf0[PCPU_NRS];
-	shared_buf_t *sbuf1[PCPU_NRS];
-
-	pr_info("%s\n", __func__);
-	if (!hvlog_buf_base || !hvlog_buf_size) {
-		pr_warn("no fixed memory reserve for hvlog.\n");
-		return 0;
-	}
-
-	logbuf_base0 = hvlog_buf_base;
-	logbuf_size = (hvlog_buf_size >> 1);
-	logbuf_base1 = hvlog_buf_base + logbuf_size;
-
-	size = (logbuf_size / PCPU_NRS);
-	ele_size = LOG_ENTRY_SIZE;
-	ele_num = (size - SBUF_HEAD_SIZE) / ele_size;
-
-	foreach_cpu(pcpu_id, PCPU_NRS) {
-		sbuf0[pcpu_id] = sbuf_check_valid(ele_num, ele_size,
-					logbuf_base0 + size * pcpu_id);
-		sbuf1[pcpu_id] = sbuf_check_valid(ele_num, ele_size,
-					logbuf_base1 + size * pcpu_id);
-	}
-
-	foreach_cpu(pcpu_id, PCPU_NRS) {
-		if (sbuf0[pcpu_id] == NULL)
-			continue;
-
-		foreach_cpu(pcpu_id, PCPU_NRS) {
-			cwp_hvlog_devs[CWP_LAST_HVLOG][pcpu_id].sbuf =
-					hvlog_mark_unread(sbuf0[pcpu_id]);
-			cwp_hvlog_devs[CWP_CURRNET_HVLOG][pcpu_id].sbuf =
-				sbuf_construct(ele_num, ele_size,
-					logbuf_base1 + size * pcpu_id);
-		}
-		sbuf_constructed = true;
-	}
-
-	if (sbuf_constructed == false) {
-		foreach_cpu(pcpu_id, PCPU_NRS) {
-			if (sbuf1[pcpu_id] == NULL)
-				continue;
-
-			foreach_cpu(pcpu_id, PCPU_NRS) {
-				cwp_hvlog_devs[CWP_LAST_HVLOG][pcpu_id].sbuf =
-					hvlog_mark_unread(sbuf1[pcpu_id]);
-			}
-		}
-		foreach_cpu(pcpu_id, PCPU_NRS) {
-			cwp_hvlog_devs[CWP_CURRNET_HVLOG][pcpu_id].sbuf =
-				sbuf_construct(ele_num, ele_size,
-					logbuf_base0 + size * pcpu_id);
-		}
-		sbuf_constructed = true;
-	}
-
-	idx = CWP_CURRNET_HVLOG;
-	{
-		foreach_cpu(pcpu_id, PCPU_NRS) {
-			ret = sbuf_share_setup(pcpu_id, CWP_HVLOG,
-					cwp_hvlog_devs[idx][pcpu_id].sbuf);
-			if (ret < 0) {
-				pr_err("Failed to setup %s, errno %d\n",
-				cwp_hvlog_devs[idx][pcpu_id].miscdev.name, ret);
-				goto setup_err;
-			}
-		}
-	}
-
-	foreach_hvlog_type(idx, CWP_HVLOG_TYPE) {
-		foreach_cpu(pcpu_id, PCPU_NRS) {
-			atomic_set(&cwp_hvlog_devs[idx][pcpu_id].open_cnt, 0);
-
-			ret = misc_register(
-					&cwp_hvlog_devs[idx][pcpu_id].miscdev);
-			if (ret < 0) {
-				pr_err("Failed to register %s, errno %d\n",
-				cwp_hvlog_devs[idx][pcpu_id].miscdev.name, ret);
-				goto reg_err;
-			}
-		}
-	}
-
-	return 0;
-
-reg_err:
-	foreach_hvlog_type(i, idx) {
-		foreach_cpu(j, PCPU_NRS) {
-			misc_deregister(&cwp_hvlog_devs[i][j].miscdev);
-		}
-	}
-
-	foreach_cpu(j, pcpu_id) {
-		misc_deregister(&cwp_hvlog_devs[idx][j].miscdev);
-	}
-
-	pcpu_id = PCPU_NRS;
-setup_err:
-	idx = CWP_CURRNET_HVLOG;
-	{
-		foreach_cpu(j, pcpu_id) {
-			sbuf_share_setup(j, CWP_HVLOG, 0);
-			sbuf_deconstruct(cwp_hvlog_devs[idx][j].sbuf);
-		}
-	}
-
-	return ret;
-}
-
-static void __exit cwp_hvlog_exit(void)
-{
-	int idx;
-	uint32_t pcpu_id;
-
-	pr_info("%s\n", __func__);
-
-	foreach_hvlog_type(idx, CWP_HVLOG_TYPE) {
-		foreach_cpu(pcpu_id, PCPU_NRS) {
-			misc_deregister(&cwp_hvlog_devs[idx][pcpu_id].miscdev);
-		}
-	}
-
-	idx = CWP_CURRNET_HVLOG;
-	{
-		foreach_cpu(pcpu_id, PCPU_NRS) {
-			sbuf_share_setup(pcpu_id, CWP_HVLOG, 0);
-			sbuf_deconstruct(cwp_hvlog_devs[idx][pcpu_id].sbuf);
-		}
-	}
-}
-
-module_init(cwp_hvlog_init);
-module_exit(cwp_hvlog_exit);
-
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_AUTHOR("Intel Corp., http://www.intel.com");
-MODULE_DESCRIPTION("Driver for the Intel CWP Hypervisor Logmsg");
-MODULE_VERSION("0.1");
diff --git a/drivers/cwp/cwp_trace.c b/drivers/cwp/cwp_trace.c
deleted file mode 100644
index 84efecb..00000000
--- a/drivers/cwp/cwp_trace.c
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
-*
-* CWP Trace module
-*
-* This file is provided under a dual BSD/GPLv2 license.  When using or
-* redistributing this file, you may do so under either license.
-*
-* GPL LICENSE SUMMARY
-*
-* Copyright (c) 2017 Intel Corporation. All rights reserved.
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of version 2 of the GNU General Public License as
-* published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful, but
-* WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-* General Public License for more details.
-*
-* Contact Information: Yan, Like <like.yan@intel.com>
-*
-* BSD LICENSE
-*
-* Copyright (c) 2017 Intel Corporation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions
-* are met:
-*
-*   * Redistributions of source code must retain the above copyright
-*     notice, this list of conditions and the following disclaimer.
-*   * Redistributions in binary form must reproduce the above copyright
-*     notice, this list of conditions and the following disclaimer in
-*     the documentation and/or other materials provided with the
-*     distribution.
-*   * Neither the name of Intel Corporation nor the names of its
-*     contributors may be used to endorse or promote products derived
-*     from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-* Like Yan <like.yan@intel.com>
-*
-*/
-
-#define pr_fmt(fmt) "CWPTrace: " fmt
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/major.h>
-#include <linux/miscdevice.h>
-#include <linux/fs.h>
-#include <linux/mm.h>
-
-#include <asm/hypervisor.h>
-
-#include "sbuf.h"
-
-
-#define TRACE_SBUF_SIZE		(4 * 1024 * 1024)
-#define TRACE_ELEMENT_SIZE	32 /* byte */
-#define TRACE_ELEMENT_NUM	((TRACE_SBUF_SIZE - SBUF_HEAD_SIZE) /	\
-				TRACE_ELEMENT_SIZE)
-
-#define foreach_cpu(cpu, cpu_num)					\
-	for ((cpu) = 0; (cpu) < (cpu_num); (cpu)++)
-
-#define MAX_NR_CPUS	4
-/* actual physical cpu number, initialized by module init */
-static int pcpu_num;
-
-static int nr_cpus = MAX_NR_CPUS;
-module_param(nr_cpus, int, S_IRUSR | S_IWUSR);
-
-static atomic_t open_cnt[MAX_NR_CPUS];
-static shared_buf_t *sbuf_per_cpu[MAX_NR_CPUS];
-
-static inline int get_id_from_devname(struct file *filep)
-{
-	uint32_t cpuid;
-	int err;
-	char id_str[16];
-	struct miscdevice *dev = filep->private_data;
-
-	strncpy(id_str, (void *)dev->name + sizeof("cwp_trace_") - 1, 16);
-	id_str[15] = '\0';
-	err = kstrtoul(&id_str[0], 10, (unsigned long *)&cpuid);
-
-	if (err)
-		return err;
-
-	if (cpuid >= pcpu_num) {
-		pr_err("%s, failed to get cpuid, cpuid %d\n",
-			__func__, cpuid);
-		return -1;
-	}
-
-	return cpuid;
-}
-
-/************************************************************************
- *
- * file_operations functions
- *
- ***********************************************************************/
-static int cwp_trace_open(struct inode *inode, struct file *filep)
-{
-	int cpuid = get_id_from_devname(filep);
-
-	pr_debug("%s, cpu %d\n", __func__, cpuid);
-	if (cpuid < 0)
-		return -ENXIO;
-
-	/* More than one reader at the same time could get data messed up */
-	if (atomic_read(&open_cnt[cpuid]))
-		return -EBUSY;
-
-	atomic_inc(&open_cnt[cpuid]);
-
-	return 0;
-}
-
-static int cwp_trace_release(struct inode *inode, struct file *filep)
-{
-	int cpuid = get_id_from_devname(filep);
-
-	pr_debug("%s, cpu %d\n", __func__, cpuid);
-	if (cpuid < 0)
-		return -ENXIO;
-
-	atomic_dec(&open_cnt[cpuid]);
-
-	return 0;
-}
-
-static int cwp_trace_mmap(struct file *filep, struct vm_area_struct *vma)
-{
-	int cpuid = get_id_from_devname(filep);
-	phys_addr_t paddr;
-
-	pr_debug("%s, cpu %d\n", __func__, cpuid);
-	if (cpuid < 0)
-		return -ENXIO;
-
-	BUG_ON(!virt_addr_valid(sbuf_per_cpu[cpuid]));
-	paddr = virt_to_phys(sbuf_per_cpu[cpuid]);
-
-	if (remap_pfn_range(vma, vma->vm_start,
-				paddr >> PAGE_SHIFT,
-				vma->vm_end - vma->vm_start,
-				vma->vm_page_prot)) {
-		pr_err("Failed to mmap sbuf for cpu%d\n", cpuid);
-		return -EAGAIN;
-	}
-
-	return 0;
-}
-
-static const struct file_operations cwp_trace_fops = {
-	.owner  = THIS_MODULE,
-	.open   = cwp_trace_open,
-	.release = cwp_trace_release,
-	.mmap   = cwp_trace_mmap,
-};
-
-static struct miscdevice cwp_trace_dev0 = {
-	.name   = "cwp_trace_0",
-	.minor  = MISC_DYNAMIC_MINOR,
-	.fops   = &cwp_trace_fops,
-};
-
-static struct miscdevice cwp_trace_dev1 = {
-	.name   = "cwp_trace_1",
-	.minor  = MISC_DYNAMIC_MINOR,
-	.fops   = &cwp_trace_fops,
-};
-
-static struct miscdevice cwp_trace_dev2 = {
-	.name   = "cwp_trace_2",
-	.minor  = MISC_DYNAMIC_MINOR,
-	.fops   = &cwp_trace_fops,
-};
-
-static struct miscdevice cwp_trace_dev3 = {
-	.name   = "cwp_trace_3",
-	.minor  = MISC_DYNAMIC_MINOR,
-	.fops   = &cwp_trace_fops,
-};
-
-static struct miscdevice *cwp_trace_devs[4] = {
-	&cwp_trace_dev0,
-	&cwp_trace_dev1,
-	&cwp_trace_dev2,
-	&cwp_trace_dev3,
-};
-
-/*
- * cwp_trace_init()
- */
-static int __init cwp_trace_init(void)
-{
-	int ret = 0;
-	int i, cpu;
-
-	if (x86_hyper_type != X86_HYPER_CWP) {
-		pr_err("cwp_trace: not support cwp hypervisor!\n");
-		return -EINVAL;
-	}
-
-	/* TBD: we could get the native cpu number by hypercall later */
-	pr_info("%s, cpu_num %d\n", __func__, nr_cpus);
-	if (nr_cpus > MAX_NR_CPUS) {
-		pr_err("nr_cpus %d exceed MAX_NR_CPUS %d !\n",
-			nr_cpus, MAX_NR_CPUS);
-		return -EINVAL;
-	}
-	pcpu_num = nr_cpus;
-
-	foreach_cpu(cpu, pcpu_num) {
-		/* allocate shared_buf */
-		sbuf_per_cpu[cpu] = sbuf_allocate(TRACE_ELEMENT_NUM,
-							TRACE_ELEMENT_SIZE);
-		if (!sbuf_per_cpu[cpu]) {
-			pr_err("Failed alloc SBuf, cpuid %d\n", cpu);
-			ret = -ENOMEM;
-			goto out_free;
-		}
-	}
-
-	foreach_cpu(cpu, pcpu_num) {
-		ret = sbuf_share_setup(cpu, CWP_TRACE, sbuf_per_cpu[cpu]);
-		if (ret < 0) {
-			pr_err("Failed to setup SBuf, cpuid %d\n", cpu);
-			goto out_sbuf;
-		}
-	}
-
-	foreach_cpu(cpu, pcpu_num) {
-		ret = misc_register(cwp_trace_devs[cpu]);
-		if (ret < 0) {
-			pr_err("Failed to register cwp_trace_%d, errno %d\n",
-				cpu, ret);
-			goto out_dereg;
-		}
-	}
-
-	return ret;
-
-out_dereg:
-	for (i = --cpu; i >= 0; i--)
-		misc_deregister(cwp_trace_devs[i]);
-	cpu = pcpu_num;
-
-out_sbuf:
-	for (i = --cpu; i >= 0; i--)
-		sbuf_share_setup(i, CWP_TRACE, NULL);
-	cpu = pcpu_num;
-
-out_free:
-	for (i = --cpu; i >= 0; i--)
-		sbuf_free(sbuf_per_cpu[i]);
-
-	return ret;
-}
-
-/*
- * cwp_trace_exit()
- */
-static void __exit cwp_trace_exit(void)
-{
-	int cpu;
-
-	pr_info("%s, cpu_num %d\n", __func__, pcpu_num);
-
-	foreach_cpu(cpu, pcpu_num) {
-		/* deregister devices */
-		misc_deregister(cwp_trace_devs[cpu]);
-
-		/* set sbuf pointer to NULL in HV */
-		sbuf_share_setup(cpu, CWP_TRACE, NULL);
-
-		/* free sbuf, sbuf_per_cpu[cpu] should be set NULL */
-		sbuf_free(sbuf_per_cpu[cpu]);
-	}
-}
-
-module_init(cwp_trace_init);
-module_exit(cwp_trace_exit);
-
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_AUTHOR("Intel Corp., http://www.intel.com");
-MODULE_DESCRIPTION("Driver for the Intel CWP Hypervisor Trace");
-MODULE_VERSION("0.1");
diff --git a/drivers/cwp/sbuf.c b/drivers/cwp/sbuf.c
deleted file mode 100644
index a358232..00000000
--- a/drivers/cwp/sbuf.c
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * shared buffer
- *
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright (c) 2017 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * Contact Information: Li Fei <fei1.li@intel.com>
- *
- * BSD LICENSE
- *
- * Copyright (C) 2017 Intel Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * Li Fei <fei1.li@intel.com>
- *
- */
-
-#define pr_fmt(fmt) "SBuf: " fmt
-
-#include <linux/gfp.h>
-#include <asm/pgtable.h>
-#include <linux/vhm/acrn_hv_defs.h>
-#include <linux/vhm/vhm_hypercall.h>
-#include "sbuf.h"
-
-static inline bool sbuf_is_empty(shared_buf_t *sbuf)
-{
-	return (sbuf->head == sbuf->tail);
-}
-
-static inline uint32_t sbuf_next_ptr(uint32_t pos,
-		uint32_t span, uint32_t scope)
-{
-	pos += span;
-	pos = (pos >= scope) ? (pos - scope) : pos;
-	return pos;
-}
-
-static inline uint32_t sbuf_calculate_allocate_size(uint32_t ele_num,
-						uint32_t ele_size)
-{
-	uint64_t sbuf_allocate_size;
-
-	sbuf_allocate_size = ele_num * ele_size;
-	sbuf_allocate_size +=  SBUF_HEAD_SIZE;
-	if (sbuf_allocate_size > SBUF_MAX_SIZE) {
-		pr_err("num=0x%x, size=0x%x exceed 0x%llx!\n",
-			ele_num, ele_size, SBUF_MAX_SIZE);
-		return 0;
-	}
-
-	/* align to PAGE_SIZE */
-	return (sbuf_allocate_size + PAGE_SIZE - 1) & PAGE_MASK;
-}
-
-shared_buf_t *sbuf_allocate(uint32_t ele_num, uint32_t ele_size)
-{
-	shared_buf_t *sbuf;
-	struct page *page;
-	uint32_t sbuf_allocate_size;
-
-	if (!ele_num || !ele_size) {
-		pr_err("invalid parameter %s!\n", __func__);
-		return NULL;
-	}
-
-	sbuf_allocate_size = sbuf_calculate_allocate_size(ele_num, ele_size);
-	if (!sbuf_allocate_size)
-		return NULL;
-
-	page = alloc_pages(GFP_KERNEL | __GFP_ZERO,
-					get_order(sbuf_allocate_size));
-	if (page == NULL) {
-		pr_err("failed to alloc pages!\n");
-		return NULL;
-	}
-
-	sbuf = phys_to_virt(page_to_phys(page));
-	sbuf->ele_num = ele_num;
-	sbuf->ele_size = ele_size;
-	sbuf->size = ele_num * ele_size;
-	sbuf->magic = SBUF_MAGIC;
-	pr_info("ele_num=0x%x, ele_size=0x%x allocated!\n",
-		ele_num, ele_size);
-	return sbuf;
-}
-EXPORT_SYMBOL(sbuf_allocate);
-
-void sbuf_free(shared_buf_t *sbuf)
-{
-	uint32_t sbuf_allocate_size;
-
-	if ((sbuf == NULL) || sbuf->magic != SBUF_MAGIC) {
-		pr_err("invalid parameter %s\n", __func__);
-		return;
-	}
-
-	sbuf_allocate_size = sbuf_calculate_allocate_size(sbuf->ele_num,
-						sbuf->ele_size);
-	if (!sbuf_allocate_size)
-		return;
-
-	sbuf->magic = 0;
-	__free_pages((struct page *)virt_to_page(sbuf),
-			get_order(sbuf_allocate_size));
-}
-EXPORT_SYMBOL(sbuf_free);
-
-int sbuf_get(shared_buf_t *sbuf, uint8_t *data)
-{
-	const void *from;
-
-	if ((sbuf == NULL) || (data == NULL))
-		return -EINVAL;
-
-	if (sbuf_is_empty(sbuf)) {
-		/* no data available */
-		return 0;
-	}
-
-	from = (void *)sbuf + SBUF_HEAD_SIZE + sbuf->head;
-
-	memcpy(data, from, sbuf->ele_size);
-
-	sbuf->head = sbuf_next_ptr(sbuf->head, sbuf->ele_size, sbuf->size);
-
-	return sbuf->ele_size;
-}
-EXPORT_SYMBOL(sbuf_get);
-
-int sbuf_share_setup(uint32_t pcpu_id, uint32_t sbuf_id, shared_buf_t *sbuf)
-{
-	struct sbuf_setup_param ssp;
-
-	ssp.pcpu_id = pcpu_id;
-	ssp.sbuf_id = sbuf_id;
-
-	if (!sbuf) {
-		ssp.gpa = 0;
-	} else {
-		BUG_ON(!virt_addr_valid(sbuf));
-		ssp.gpa = virt_to_phys(sbuf);
-	}
-	pr_info("setup phys add = 0x%llx\n", ssp.gpa);
-
-	return hcall_setup_sbuf(virt_to_phys(&ssp));
-}
-EXPORT_SYMBOL(sbuf_share_setup);
-
-shared_buf_t *sbuf_check_valid(uint32_t ele_num, uint32_t ele_size,
-				uint64_t paddr)
-{
-	shared_buf_t *sbuf;
-
-	if (!ele_num || !ele_size || !paddr)
-		return NULL;
-
-	sbuf = (shared_buf_t *)phys_to_virt(paddr);
-	BUG_ON(!virt_addr_valid(sbuf));
-
-	if ((sbuf->magic == SBUF_MAGIC) &&
-		(sbuf->ele_num == ele_num) &&
-		(sbuf->ele_size == ele_size)) {
-		return sbuf;
-	}
-
-	return NULL;
-}
-EXPORT_SYMBOL(sbuf_check_valid);
-
-shared_buf_t *sbuf_construct(uint32_t ele_num, uint32_t ele_size,
-				uint64_t paddr)
-{
-	shared_buf_t *sbuf;
-
-	if (!ele_num || !ele_size || !paddr)
-		return NULL;
-
-	sbuf = (shared_buf_t *)phys_to_virt(paddr);
-	BUG_ON(!virt_addr_valid(sbuf));
-
-	memset(sbuf, 0, SBUF_HEAD_SIZE);
-	sbuf->magic = SBUF_MAGIC;
-	sbuf->ele_num = ele_num;
-	sbuf->ele_size = ele_size;
-	sbuf->size = ele_num * ele_size;
-	pr_info("construct sbuf at 0x%llx.\n", paddr);
-	return sbuf;
-}
-EXPORT_SYMBOL(sbuf_construct);
-
-void sbuf_deconstruct(shared_buf_t *sbuf)
-{
-	if (sbuf == NULL)
-		return;
-
-	sbuf->magic = 0;
-}
-EXPORT_SYMBOL(sbuf_deconstruct);
diff --git a/drivers/cwp/sbuf.h b/drivers/cwp/sbuf.h
deleted file mode 100644
index 07588f9..00000000
--- a/drivers/cwp/sbuf.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * shared buffer
- *
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright (c) 2017 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * Contact Information: Li Fei <fei1.li@intel.com>
- *
- * BSD LICENSE
- *
- * Copyright (C) 2017 Intel Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * Li Fei <fei1.li@intel.com>
- *
- */
-
-#ifndef SHARED_BUF_H
-#define SHARED_BUF_H
-
-#include <linux/types.h>
-
-
-#define SBUF_MAGIC	0x5aa57aa71aa13aa3
-#define SBUF_MAX_SIZE	(1ULL << 22)
-#define SBUF_HEAD_SIZE	64
-
-/* sbuf flags */
-#define OVERRUN_CNT_EN	(1ULL << 0) /* whether overrun counting is enabled */
-#define OVERWRITE_EN	(1ULL << 1) /* whether overwrite is enabled */
-
-enum sbuf_type {
-	CWP_TRACE,
-	CWP_HVLOG,
-	CWP_SBUF_TYPE_MAX,
-};
-/**
- * (sbuf) head + buf (store (ele_num - 1) elements at most)
- * buffer empty: tail == head
- * buffer full:  (tail + ele_size) % size == head
- *
- *             Base of memory for elements
- *                |
- *                |
- * ---------------------------------------------------------------------------------------
- * | shared_buf_t | raw data (ele_size)| raw date (ele_size) | ... | raw data (ele_size) |
- * ---------------------------------------------------------------------------------------
- * |
- * |
- * shared_buf_t *buf
- */
-
-/* Make sure sizeof(shared_buf_t) == SBUF_HEAD_SIZE */
-typedef struct shared_buf {
-	uint64_t magic;
-	uint32_t ele_num;	/* number of elements */
-	uint32_t ele_size;	/* sizeof of elements */
-	uint32_t head;		/* offset from base, to read */
-	uint32_t tail;		/* offset from base, to write */
-	uint64_t flags;
-	uint32_t overrun_cnt;	/* count of overrun */
-	uint32_t size;		/* ele_num * ele_size */
-	uint32_t padding[6];
-} ____cacheline_aligned shared_buf_t;
-
-static inline void sbuf_clear_flags(shared_buf_t *sbuf, uint64_t flags)
-{
-	sbuf->flags &= ~flags;
-}
-
-static inline void sbuf_set_flags(shared_buf_t *sbuf, uint64_t flags)
-{
-	sbuf->flags = flags;
-}
-
-static inline void sbuf_add_flags(shared_buf_t *sbuf, uint64_t flags)
-{
-	sbuf->flags |= flags;
-}
-
-shared_buf_t *sbuf_allocate(uint32_t ele_num, uint32_t ele_size);
-void sbuf_free(shared_buf_t *sbuf);
-int sbuf_get(shared_buf_t *sbuf, uint8_t *data);
-int sbuf_share_setup(uint32_t pcpu_id, uint32_t sbuf_id, shared_buf_t *sbuf);
-shared_buf_t *sbuf_check_valid(uint32_t ele_num, uint32_t ele_size,
-				uint64_t gpa);
-shared_buf_t *sbuf_construct(uint32_t ele_num, uint32_t ele_size,
-				uint64_t gpa);
-void sbuf_deconstruct(shared_buf_t *sbuf);
-
-#endif /* SHARED_BUF_H */
-- 
2.7.4

