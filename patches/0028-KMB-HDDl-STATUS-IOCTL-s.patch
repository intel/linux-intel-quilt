From 79a11852157e1a99ff1ac0e153aabf9220bdb28c Mon Sep 17 00:00:00 2001
From: "C, Udhayakumar" <udhayakumar.c@intel.com>
Date: Fri, 22 Jan 2021 22:05:47 +0530
Subject: [PATCH 028/109] KMB HDDl STATUS IOCTL's

Signed-off-by: C, Udhayakumar <udhayakumar.c@intel.com>
---
 drivers/misc/hddl_device/hddl_device.c    |  3 +-
 drivers/misc/hddl_device/hddl_device_rh.c | 36 ++++++++++++++++++++---
 include/linux/hddl_device.h               | 13 ++++++++
 3 files changed, 46 insertions(+), 6 deletions(-)

diff --git a/drivers/misc/hddl_device/hddl_device.c b/drivers/misc/hddl_device/hddl_device.c
index 89e22adc3a03..1ae0cdefa929 100644
--- a/drivers/misc/hddl_device/hddl_device.c
+++ b/drivers/misc/hddl_device/hddl_device.c
@@ -413,7 +413,7 @@ static int intel_hddl_device_probe(struct intel_hddl_clients *d)
 	char device_name[XLINK_MAX_DEVICE_NAME_SIZE];
 	int rc;
 
-	if (d->status == HDDL_DEV_STATUS_CONNECTED)
+	if (d->status != HDDL_DEV_STATUS_DISCONNECTED)
 		return 0;
 	rc = xlink_get_device_name(&d->xlink_dev,
 				   device_name, XLINK_MAX_DEVICE_NAME_SIZE);
@@ -432,7 +432,6 @@ static int intel_hddl_device_probe(struct intel_hddl_clients *d)
 		dev_err(&d->pdev->dev, "failed to create thread\n");
 		return -EFAULT;
 	}
-	d->status = HDDL_DEV_STATUS_CONNECTED;
 
 	return 0;
 }
diff --git a/drivers/misc/hddl_device/hddl_device_rh.c b/drivers/misc/hddl_device/hddl_device_rh.c
index 78546ea64356..2ba76cd56612 100644
--- a/drivers/misc/hddl_device/hddl_device_rh.c
+++ b/drivers/misc/hddl_device/hddl_device_rh.c
@@ -128,10 +128,11 @@ static long hddl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	struct intel_hddl_device_priv *priv = file->private_data;
 	u32 __user *user_ptr = (u32 __user *)arg;
 	struct device *dev = &priv->pdev->dev;
-	struct sw_id_soft_reset soft_reset;
-	struct sw_id_hddl_data swid_data;
+	struct sw_id_hddl_status swid_status;
 	struct intel_hddl_clients **clients;
+	struct sw_id_soft_reset soft_reset;
 	struct intel_hddl_clients *client;
+	struct sw_id_hddl_data swid_data;
 	int i, rc;
 
 	if (!user_ptr) {
@@ -207,6 +208,28 @@ static long hddl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 				 &swid_data, sizeof(struct sw_id_hddl_data)))
 			return -EFAULT;
 		break;
+	case HDDL_READ_STATUS:
+		if (copy_from_user(&swid_status, user_ptr,
+				   sizeof(struct sw_id_hddl_status)))
+			return -EFAULT;
+		for (i = 0; i < priv->ndevs; i++) {
+			if (clients[i]->xlink_dev.sw_device_id ==
+					swid_status.sw_id) {
+				client = clients[i];
+				break;
+			}
+		}
+		if (!client) {
+			dev_err(dev, "device to get status not found %d",
+				swid_status.sw_id);
+			return -ENODEV;
+		}
+		swid_status.status = client->status;
+		swid_status.return_id = 1;
+		if (copy_to_user(user_ptr, &swid_status,
+				 sizeof(struct sw_id_hddl_status)))
+			return -EFAULT;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -591,10 +614,12 @@ static int intel_hddl_device_connect_task(void *data)
 	c->chan_num = priv->xlink_chan;
 	c->i2c_chan_num = priv->i2c_xlink_chan;
 	c->smbus_adap = priv->smbus_adap;
+	c->status = HDDL_DEV_STATUS_START;
 	if (intel_hddl_open_xlink_device(&priv->pdev->dev, c)) {
 		dev_err(&priv->pdev->dev, "HDDL open xlink dev failed\n");
 		return -ENODEV;
 	}
+	c->status = HDDL_DEV_STATUS_XLINK_OPENED;
 	ktime_get_real_ts64(&ts);
 	rc = xlink_write_volatile(xlink, c->chan_num, (u8 *)&ts,
 				  sizeof(struct timespec64));
@@ -604,7 +629,7 @@ static int intel_hddl_device_connect_task(void *data)
 			rc);
 		return rc;
 	}
-
+	c->status = HDDL_DEV_STATUS_UPDATED_TIMESTAMP;
 	size = sizeof(c->board_info);
 	rc = intel_hddl_get_xlink_data(&priv->pdev->dev,
 				       xlink, c->chan_num,
@@ -621,24 +646,27 @@ static int intel_hddl_device_connect_task(void *data)
 			rc);
 		return rc;
 	}
-
+	c->status = HDDL_DEV_STATUS_UPDATED_BOARD_INFO;
 	rc = intel_hddl_tsens_data(c);
 	if (rc) {
 		dev_err(&priv->pdev->dev, "HDDL: tsens data not rcvd\n");
 		goto close_xlink_dev;
 	}
+	c->status = HDDL_DEV_STATUS_UPDATED_THERMAL_INFO;
 	rc = intel_hddl_register_xlink_i2c_adap(&priv->pdev->dev, c);
 	if (rc) {
 		dev_err(&priv->pdev->dev,
 			"HDDL: register xlink i2c adapter failed\n");
 		goto close_xlink_dev;
 	}
+	c->status = HDDL_DEV_STATUS_UPDATED_I2C_ADAPTERS;
 	rc = intel_hddl_i2c_register_clients(&priv->pdev->dev, c);
 	if (rc) {
 		dev_err(&priv->pdev->dev,
 			"HDDL: register i2c clients failed\n");
 		goto remove_xlink_i2c_adap;
 	}
+	c->status = HDDL_DEV_STATUS_CONNECTED;
 	while (!kthread_should_stop())
 		msleep_interruptible(HDDL_NEW_DEV_POLL_TIME);
 
diff --git a/include/linux/hddl_device.h b/include/linux/hddl_device.h
index 1c21ad27ea33..d6bee2258baa 100644
--- a/include/linux/hddl_device.h
+++ b/include/linux/hddl_device.h
@@ -24,6 +24,7 @@
 #define HDDL_MAGIC 'x'
 #define HDDL_READ_SW_ID_DATA		_IOW(HDDL_MAGIC, 'a', void*)
 #define HDDL_SOFT_RESET		_IOW(HDDL_MAGIC, 'b', void*)
+#define HDDL_READ_STATUS	_IOW(HDDL_MAGIC, 'c', void*)
 
 struct sw_id_hddl_data {
 	u32 board_id;
@@ -52,11 +53,23 @@ enum hddl_device {
 
 enum hddl_device_status {
 	HDDL_DEV_STATUS_START,
+	HDDL_DEV_STATUS_XLINK_OPENED,
+	HDDL_DEV_STATUS_UPDATED_TIMESTAMP,
+	HDDL_DEV_STATUS_UPDATED_BOARD_INFO,
+	HDDL_DEV_STATUS_HANDSHAKE_COMPLETED,
+	HDDL_DEV_STATUS_UPDATED_THERMAL_INFO,
+	HDDL_DEV_STATUS_UPDATED_I2C_ADAPTERS,
 	HDDL_DEV_STATUS_CONNECTED,
 	HDDL_DEV_STATUS_DISCONNECTED,
 	HDDL_DEV_STATUS_END,
 };
 
+struct sw_id_hddl_status {
+	uint32_t sw_id;
+	enum hddl_device_status status;
+	uint32_t return_id;
+};
+
 enum hddl_msg_type {
 	HDDL_GET_NSENS		= 0x10,
 	HDDL_GET_SENS_NAME	= 0x11,
-- 
2.25.1

