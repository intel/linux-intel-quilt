From f7be9fb70bfd1665d34c2a02488f103a4f4250c5 Mon Sep 17 00:00:00 2001
From: Mika Westerberg <mika.westerberg@linux.intel.com>
Date: Wed, 7 Oct 2020 17:01:43 +0300
Subject: [PATCH 02/20] thunderbolt: Find XDomain by route instead of UUID

We are going to represent loops back to the host also as XDomains and
they all have the same (host) UUID, so finding them needs to use route
string instead. This also requires that we check if the XDomain device
is added to the bus before its properties can be updated. Otherwise the
remote UUID might not be populated yet.

Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
---
 drivers/thunderbolt/xdomain.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/drivers/thunderbolt/xdomain.c b/drivers/thunderbolt/xdomain.c
index c00ad817042e..e2866248f389 100644
--- a/drivers/thunderbolt/xdomain.c
+++ b/drivers/thunderbolt/xdomain.c
@@ -587,8 +587,6 @@ static void tb_xdp_handle_request(struct work_struct *work)
 		break;
 
 	case PROPERTIES_CHANGED_REQUEST: {
-		const struct tb_xdp_properties_changed *xchg =
-			(const struct tb_xdp_properties_changed *)pkg;
 		struct tb_xdomain *xd;
 
 		ret = tb_xdp_properties_changed_response(ctl, route, sequence);
@@ -598,8 +596,8 @@ static void tb_xdp_handle_request(struct work_struct *work)
 		 * the xdomain related to this connection as well in
 		 * case there is a change in services it offers.
 		 */
-		xd = tb_xdomain_find_by_uuid_locked(tb, &xchg->src_uuid);
-		if (xd) {
+		xd = tb_xdomain_find_by_route_locked(tb, route);
+		if (xd && device_is_registered(&xd->dev)) {
 			queue_delayed_work(tb->wq, &xd->get_properties_work,
 					   msecs_to_jiffies(50));
 			tb_xdomain_put(xd);
-- 
2.27.0

