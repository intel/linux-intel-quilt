From 2913c269b18fb7738dbd1fa7e66730954bc1522e Mon Sep 17 00:00:00 2001
From: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date: Thu, 15 Oct 2020 16:45:02 +0300
Subject: [PATCH 29/29] can: m_can: m_can_pci: Remove mram_base and offset

It seems in Elkhart Lake MRAM is not separate zero offset entity in MCAN
block. It has offset of 0x800 in address map visible to host CPU but the
same offset must be taken into account in MRAM configuration register.
Otherwise MCAN does not work. Perhaps it will end up overriding MCAN
register space since that starts from offset 0x0 in host visible memory
map.

This means that write_fifo/read_fifo callbacks from MCAN core code must
operate in the same base address than read_reg/write_reg callbacks since
MCAN core code pass the FIFO address offset that includes above offset
already.

Effectively this means we can get rid of offset definition here as well
as mram_base in struct m_can_pci_priv. Which was actually already unused
since iomap_write_fifo/iomap_read_fifo here already use register base
address.

Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
---
 drivers/net/can/m_can/m_can_pci.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/drivers/net/can/m_can/m_can_pci.c b/drivers/net/can/m_can/m_can_pci.c
index 1dbd35feaf17..04010ee0407c 100644
--- a/drivers/net/can/m_can/m_can_pci.c
+++ b/drivers/net/can/m_can/m_can_pci.c
@@ -17,14 +17,12 @@
 #include "m_can.h"
 
 #define M_CAN_PCI_MMIO_BAR		0
-#define M_CAN_MRAM_OFFSET		0x800
 
 #define M_CAN_CLOCK_FREQ_EHL		100000000
 #define CTL_CSR_INT_CTL_OFFSET		0x508
 
 struct m_can_pci_priv {
 	void __iomem *base;
-	void __iomem *mram_base;
 };
 
 static u32 iomap_read_reg(struct m_can_classdev *cdev, int reg)
@@ -100,7 +98,6 @@ static int m_can_pci_probe(struct pci_dev *pci, const struct pci_device_id *id)
 		return -ENOMEM;
 
 	priv->base = base;
-	priv->mram_base = base + M_CAN_MRAM_OFFSET;
 
 	ret = pci_alloc_irq_vectors(pci, 1, 1, PCI_IRQ_ALL_TYPES);
 	if (ret < 0)
-- 
2.27.0

