From 906f068a9e527b04420ed438c6ca874407fd9dba Mon Sep 17 00:00:00 2001
From: Voon Weifeng <weifeng.voon@intel.com>
Date: Mon, 11 May 2020 13:47:29 +0800
Subject: [PATCH 41/42] REVERTME: net: phy: WA for GPY115 which need a soft
 reset

Added a custom gpy_soft_reset() as the GPY115 need this WA which do a
soft reset even after a hard reset has happen.

Signed-off-by: Voon Weifeng <weifeng.voon@intel.com>
---
 drivers/net/phy/intel-gpy.c | 23 ++++++++++++++++++++++-
 1 file changed, 22 insertions(+), 1 deletion(-)

diff --git a/drivers/net/phy/intel-gpy.c b/drivers/net/phy/intel-gpy.c
index a075e6c381dd..ad1058efc8a8 100644
--- a/drivers/net/phy/intel-gpy.c
+++ b/drivers/net/phy/intel-gpy.c
@@ -28,6 +28,27 @@
 #define GPY_SGMII_DR_MASK	GENMASK(1, 0)	/* Data rate */
 #define GPY_SGMII_DR_2500	0x3
 
+/* WA for Q-SPEC GPY115 PHY ID */
+#define INTEL_PHY_ID_GPY115_C22		0x67C9DE00
+
+static int gpy_soft_reset(struct phy_device *phydev)
+{
+	int ret;
+	int phy_id;
+
+	ret = phy_read(phydev, MII_PHYSID1);
+	phy_id = ret << 16;
+
+	ret = phy_read(phydev, MII_PHYSID2);
+	phy_id |= ret;
+
+	/* WA for GPY115 which need a soft reset even after a hard reset */
+	if (phy_id == INTEL_PHY_ID_GPY115_C22)
+		return genphy_soft_reset(phydev);
+
+	return genphy_no_soft_reset(phydev);
+}
+
 static int gpy_config_aneg(struct phy_device *phydev)
 {
 	bool changed = false;
@@ -180,7 +201,7 @@ static struct phy_driver intel_gpy_drivers[] = {
 		.name		= "INTEL(R) Ethernet Network Connection GPY",
 		.get_features	= genphy_c45_pma_read_abilities,
 		.aneg_done	= genphy_c45_aneg_done,
-		.soft_reset	= genphy_no_soft_reset,
+		.soft_reset	= gpy_soft_reset,
 		.ack_interrupt	= gpy_ack_interrupt,
 		.did_interrupt	= gpy_did_interrupt,
 		.config_intr	= gpy_config_intr,
-- 
2.17.1

