From bbf2a020c5665034aac5edcbba3ae72ed288a464 Mon Sep 17 00:00:00 2001
From: Zhou Furong <furong.zhou@intel.com>
Date: Thu, 31 Jan 2019 13:26:25 +0800
Subject: [PATCH 11/43] keystore: Fix ISO C90 forbidden variable length array

Compile failed because variable length array found during
update to v5.0-rc4.

Change-Id: I17d74c0c6899cbdd9a6e6a3b0f532a15932d47ac
Tracked-On: PKT-1712
Signed-off-by: Zhou Furong <furong.zhou@intel.com>
---
 security/keystore/api_dal.c | 25 ++++++++++++++++++++-----
 security/keystore/mac.c     |  9 ++++++---
 2 files changed, 26 insertions(+), 8 deletions(-)

diff --git a/security/keystore/api_dal.c b/security/keystore/api_dal.c
index 3a6b1c24de26..e1d34ae1f2cd 100644
--- a/security/keystore/api_dal.c
+++ b/security/keystore/api_dal.c
@@ -513,8 +513,7 @@ int dal_keystore_wrap_key(const uint8_t *client_ticket,
 	uint8_t client_id[KEYSTORE_MAX_CLIENT_ID_SIZE];
 	int res = 0;
 	size_t response_code = 0;
-	uint8_t input[KEYSTORE_MAX_CLIENT_ID_SIZE + KEYSTORE_CLIENT_TICKET_SIZE
-				+ app_key_size + 2];
+	uint8_t *input;
 	int commandId = DAL_KEYSTORE_WRAP_KEY;
 	size_t output_len = 0;
 	uint8_t *out_buf = NULL;
@@ -531,6 +530,13 @@ int dal_keystore_wrap_key(const uint8_t *client_ticket,
 		return res;
 	}
 
+	input = kmalloc(KEYSTORE_MAX_CLIENT_ID_SIZE
+				+ KEYSTORE_CLIENT_TICKET_SIZE
+				+ app_key_size + 2, GFP_KERNEL);
+	if (!input) {
+		res = -ENOMEM;
+		goto exit;
+	}
 	memcpy(input, client_id, sizeof(client_id));
 	index += sizeof(client_id);
 	memcpy(input + index, client_ticket, KEYSTORE_CLIENT_TICKET_SIZE);
@@ -554,6 +560,8 @@ int dal_keystore_wrap_key(const uint8_t *client_ticket,
 		goto cmd_retry;
 	}
 
+	kzfree(input);
+
 	if (res) {
 		ks_err(KBUILD_MODNAME ": %s Error in send_and_receive: command id = %d %d %lu\n",
 			__func__, commandId, res, response_code);
@@ -644,9 +652,7 @@ int dal_keystore_load_key(const uint8_t *client_ticket,
 	uint8_t *out_buf = NULL;
 	int retry = 0;
 	size_t index = 0;
-	uint8_t input[KEYSTORE_MAX_CLIENT_ID_SIZE
-				  + KEYSTORE_CLIENT_TICKET_SIZE
-				  + wrapped_key_size];
+	uint8_t *input;
 
 	FUNC_BEGIN;
 
@@ -668,6 +674,13 @@ int dal_keystore_load_key(const uint8_t *client_ticket,
 		return res;
 	}
 
+	input = kmalloc(KEYSTORE_MAX_CLIENT_ID_SIZE
+				  + KEYSTORE_CLIENT_TICKET_SIZE
+				  + wrapped_key_size, GFP_KERNEL);
+	if (!input) {
+		res = -ENOMEM;
+		return res;
+	}
 	memcpy(input, client_id, sizeof(client_id));
 	index += sizeof(client_id);
 	memcpy(input + index, client_ticket, KEYSTORE_CLIENT_TICKET_SIZE);
@@ -688,6 +701,8 @@ int dal_keystore_load_key(const uint8_t *client_ticket,
 		goto cmd_retry;
 	}
 
+	kzfree(input);
+
 	if (res) {
 		ks_err(KBUILD_MODNAME ": %s Error in send_and_receive: command id = %d %d\n",
 				__func__, commandId, res);
diff --git a/security/keystore/mac.c b/security/keystore/mac.c
index fe6477a9f86e..6906fd269bb8 100644
--- a/security/keystore/mac.c
+++ b/security/keystore/mac.c
@@ -71,19 +71,22 @@ int keystore_calc_mac(const char *alg_name, const char *key, size_t klen,
 	if (rc) {
 		ks_err(KBUILD_MODNAME": crypto_ahash_setkey failed\n");
 	} else {
-		char hash_tmp[crypto_ahash_digestsize(tfm)];
+		char *hash_tmp;
+		unsigned int hashlen = crypto_ahash_digestsize(tfm);
 
-		memset(hash_tmp, 0, sizeof(hash_tmp));
+		hash_tmp = kzalloc(hashlen, GFP_KERNEL);
+		memset(hash_tmp, 0, hashlen);
 
 		ahash_request_set_crypt(req, &sg, hash_tmp, dlen);
 
 		rc = crypto_ahash_digest(req);
 		if (rc == 0) {
 			/* OK */
-			memcpy(hash_out, hash_tmp, sizeof(hash_tmp));
+			memcpy(hash_out, hash_tmp, hashlen);
 		} else {
 			ks_err(KBUILD_MODNAME": crypto_ahash_digest failed\n");
 		}
+		kfree(hash_tmp);
 	}
 
 	kfree(hash_buf);
-- 
2.17.1

