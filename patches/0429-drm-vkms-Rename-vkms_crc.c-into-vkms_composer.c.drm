From 56316b99a1fc3f9de4abfbf130d825731cafc841 Mon Sep 17 00:00:00 2001
From: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
Date: Tue, 25 Jun 2019 22:37:05 -0300
Subject: [PATCH 0429/1606] drm/vkms: Rename vkms_crc.c into vkms_composer.c

As a preparation work for introducing writeback to vkms, this patch
renames the file vkms_crc.c into vkms_composer.c. Accordingly, it also
adjusts the functions and data structures to match the changes.

No functional change.

Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Link: https://patchwork.freedesktop.org/patch/msgid/dea62063077ebf5cc1dfce8876e56788d15367e6.1561491964.git.rodrigosiqueiramelo@gmail.com
---
 drivers/gpu/drm/vkms/Makefile                 |  2 +-
 .../drm/vkms/{vkms_crc.c => vkms_composer.c}  | 98 ++++++++++---------
 drivers/gpu/drm/vkms/vkms_crtc.c              | 30 +++---
 drivers/gpu/drm/vkms/vkms_drv.c               |  4 +-
 drivers/gpu/drm/vkms/vkms_drv.h               | 28 +++---
 drivers/gpu/drm/vkms/vkms_plane.c             | 36 +++----
 6 files changed, 101 insertions(+), 97 deletions(-)
 rename drivers/gpu/drm/vkms/{vkms_crc.c => vkms_composer.c} (65%)

diff --git a/drivers/gpu/drm/vkms/Makefile b/drivers/gpu/drm/vkms/Makefile
index 89f09bec7b23..0b767d7efa24 100644
--- a/drivers/gpu/drm/vkms/Makefile
+++ b/drivers/gpu/drm/vkms/Makefile
@@ -1,4 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0-only
-vkms-y := vkms_drv.o vkms_plane.o vkms_output.o vkms_crtc.o vkms_gem.o vkms_crc.o
+vkms-y := vkms_drv.o vkms_plane.o vkms_output.o vkms_crtc.o vkms_gem.o vkms_composer.o
 
 obj-$(CONFIG_DRM_VKMS) += vkms.o
diff --git a/drivers/gpu/drm/vkms/vkms_crc.c b/drivers/gpu/drm/vkms/vkms_composer.c
similarity index 65%
rename from drivers/gpu/drm/vkms/vkms_crc.c
rename to drivers/gpu/drm/vkms/vkms_composer.c
index 30b048b67a32..eb7ea8be1f98 100644
--- a/drivers/gpu/drm/vkms/vkms_crc.c
+++ b/drivers/gpu/drm/vkms/vkms_composer.c
@@ -10,25 +10,25 @@
  * compute_crc - Compute CRC value on output frame
  *
  * @vaddr_out: address to final framebuffer
- * @crc_out: framebuffer's metadata
+ * @composer: framebuffer's metadata
  *
  * returns CRC value computed using crc32 on the visible portion of
  * the final framebuffer at vaddr_out
  */
-static uint32_t compute_crc(void *vaddr_out, struct vkms_crc_data *crc_out)
+static uint32_t compute_crc(void *vaddr_out, struct vkms_composer *composer)
 {
 	int i, j, src_offset;
-	int x_src = crc_out->src.x1 >> 16;
-	int y_src = crc_out->src.y1 >> 16;
-	int h_src = drm_rect_height(&crc_out->src) >> 16;
-	int w_src = drm_rect_width(&crc_out->src) >> 16;
+	int x_src = composer->src.x1 >> 16;
+	int y_src = composer->src.y1 >> 16;
+	int h_src = drm_rect_height(&composer->src) >> 16;
+	int w_src = drm_rect_width(&composer->src) >> 16;
 	u32 crc = 0;
 
 	for (i = y_src; i < y_src + h_src; ++i) {
 		for (j = x_src; j < x_src + w_src; ++j) {
-			src_offset = crc_out->offset
-				     + (i * crc_out->pitch)
-				     + (j * crc_out->cpp);
+			src_offset = composer->offset
+				     + (i * composer->pitch)
+				     + (j * composer->cpp);
 			/* XRGB format ignores Alpha channel */
 			memset(vaddr_out + src_offset + 24, 0,  8);
 			crc = crc32_le(crc, vaddr_out + src_offset,
@@ -43,8 +43,8 @@ static uint32_t compute_crc(void *vaddr_out, struct vkms_crc_data *crc_out)
  * blend - belnd value at vaddr_src with value at vaddr_dst
  * @vaddr_dst: destination address
  * @vaddr_src: source address
- * @crc_dst: destination framebuffer's metadata
- * @crc_src: source framebuffer's metadata
+ * @dest_composer: destination framebuffer's metadata
+ * @src_composer: source framebuffer's metadata
  *
  * Blend value at vaddr_src with value at vaddr_dst.
  * Currently, this function write value at vaddr_src on value
@@ -55,31 +55,31 @@ static uint32_t compute_crc(void *vaddr_out, struct vkms_crc_data *crc_out)
  *	 instead of overwriting it.
  */
 static void blend(void *vaddr_dst, void *vaddr_src,
-		  struct vkms_crc_data *crc_dst,
-		  struct vkms_crc_data *crc_src)
+		  struct vkms_composer *dest_composer,
+		  struct vkms_composer *src_composer)
 {
 	int i, j, j_dst, i_dst;
 	int offset_src, offset_dst;
 
-	int x_src = crc_src->src.x1 >> 16;
-	int y_src = crc_src->src.y1 >> 16;
+	int x_src = src_composer->src.x1 >> 16;
+	int y_src = src_composer->src.y1 >> 16;
 
-	int x_dst = crc_src->dst.x1;
-	int y_dst = crc_src->dst.y1;
-	int h_dst = drm_rect_height(&crc_src->dst);
-	int w_dst = drm_rect_width(&crc_src->dst);
+	int x_dst = src_composer->dst.x1;
+	int y_dst = src_composer->dst.y1;
+	int h_dst = drm_rect_height(&src_composer->dst);
+	int w_dst = drm_rect_width(&src_composer->dst);
 
 	int y_limit = y_src + h_dst;
 	int x_limit = x_src + w_dst;
 
 	for (i = y_src, i_dst = y_dst; i < y_limit; ++i) {
 		for (j = x_src, j_dst = x_dst; j < x_limit; ++j) {
-			offset_dst = crc_dst->offset
-				     + (i_dst * crc_dst->pitch)
-				     + (j_dst++ * crc_dst->cpp);
-			offset_src = crc_src->offset
-				     + (i * crc_src->pitch)
-				     + (j * crc_src->cpp);
+			offset_dst = dest_composer->offset
+				     + (i_dst * dest_composer->pitch)
+				     + (j_dst++ * dest_composer->cpp);
+			offset_src = src_composer->offset
+				     + (i * src_composer->pitch)
+				     + (j * src_composer->cpp);
 
 			memcpy(vaddr_dst + offset_dst,
 			       vaddr_src + offset_src, sizeof(u32));
@@ -88,25 +88,27 @@ static void blend(void *vaddr_dst, void *vaddr_src,
 	}
 }
 
-static void compose_cursor(struct vkms_crc_data *cursor_crc,
-			   struct vkms_crc_data *primary_crc, void *vaddr_out)
+static void compose_cursor(struct vkms_composer *cursor_composer,
+			   struct vkms_composer *primary_composer,
+			   void *vaddr_out)
 {
 	struct drm_gem_object *cursor_obj;
 	struct vkms_gem_object *cursor_vkms_obj;
 
-	cursor_obj = drm_gem_fb_get_obj(&cursor_crc->fb, 0);
+	cursor_obj = drm_gem_fb_get_obj(&cursor_composer->fb, 0);
 	cursor_vkms_obj = drm_gem_to_vkms_gem(cursor_obj);
 
 	if (WARN_ON(!cursor_vkms_obj->vaddr))
 		return;
 
-	blend(vaddr_out, cursor_vkms_obj->vaddr, primary_crc, cursor_crc);
+	blend(vaddr_out, cursor_vkms_obj->vaddr,
+	      primary_composer, cursor_composer);
 }
 
-static uint32_t _vkms_get_crc(struct vkms_crc_data *primary_crc,
-			      struct vkms_crc_data *cursor_crc)
+static uint32_t _vkms_get_crc(struct vkms_composer *primary_composer,
+			      struct vkms_composer *cursor_composer)
 {
-	struct drm_framebuffer *fb = &primary_crc->fb;
+	struct drm_framebuffer *fb = &primary_composer->fb;
 	struct drm_gem_object *gem_obj = drm_gem_fb_get_obj(fb, 0);
 	struct vkms_gem_object *vkms_obj = drm_gem_to_vkms_gem(gem_obj);
 	void *vaddr_out = kzalloc(vkms_obj->gem.size, GFP_KERNEL);
@@ -124,10 +126,10 @@ static uint32_t _vkms_get_crc(struct vkms_crc_data *primary_crc,
 
 	memcpy(vaddr_out, vkms_obj->vaddr, vkms_obj->gem.size);
 
-	if (cursor_crc)
-		compose_cursor(cursor_crc, primary_crc, vaddr_out);
+	if (cursor_composer)
+		compose_cursor(cursor_composer, primary_composer, vaddr_out);
 
-	crc = compute_crc(vaddr_out, primary_crc);
+	crc = compute_crc(vaddr_out, primary_composer);
 
 	kfree(vaddr_out);
 
@@ -135,35 +137,35 @@ static uint32_t _vkms_get_crc(struct vkms_crc_data *primary_crc,
 }
 
 /**
- * vkms_crc_work_handle - ordered work_struct to compute CRC
+ * vkms_composer_worker - ordered work_struct to compute CRC
  *
  * @work: work_struct
  *
- * Work handler for computing CRCs. work_struct scheduled in
+ * Work handler for composing and computing CRCs. work_struct scheduled in
  * an ordered workqueue that's periodically scheduled to run by
  * _vblank_handle() and flushed at vkms_atomic_crtc_destroy_state().
  */
-void vkms_crc_work_handle(struct work_struct *work)
+void vkms_composer_worker(struct work_struct *work)
 {
 	struct vkms_crtc_state *crtc_state = container_of(work,
 						struct vkms_crtc_state,
-						crc_work);
+						composer_work);
 	struct drm_crtc *crtc = crtc_state->base.crtc;
 	struct vkms_output *out = drm_crtc_to_vkms_output(crtc);
-	struct vkms_crc_data *primary_crc = NULL;
-	struct vkms_crc_data *cursor_crc = NULL;
+	struct vkms_composer *primary_composer = NULL;
+	struct vkms_composer *cursor_composer = NULL;
 	u32 crc32 = 0;
 	u64 frame_start, frame_end;
 	bool crc_pending;
 
-	spin_lock_irq(&out->crc_lock);
+	spin_lock_irq(&out->composer_lock);
 	frame_start = crtc_state->frame_start;
 	frame_end = crtc_state->frame_end;
 	crc_pending = crtc_state->crc_pending;
 	crtc_state->frame_start = 0;
 	crtc_state->frame_end = 0;
 	crtc_state->crc_pending = false;
-	spin_unlock_irq(&out->crc_lock);
+	spin_unlock_irq(&out->composer_lock);
 
 	/*
 	 * We raced with the vblank hrtimer and previous work already computed
@@ -173,13 +175,13 @@ void vkms_crc_work_handle(struct work_struct *work)
 		return;
 
 	if (crtc_state->num_active_planes >= 1)
-		primary_crc = crtc_state->active_planes[0]->crc_data;
+		primary_composer = crtc_state->active_planes[0]->composer;
 
 	if (crtc_state->num_active_planes == 2)
-		cursor_crc = crtc_state->active_planes[1]->crc_data;
+		cursor_composer = crtc_state->active_planes[1]->composer;
 
-	if (primary_crc)
-		crc32 = _vkms_get_crc(primary_crc, cursor_crc);
+	if (primary_composer)
+		crc32 = _vkms_get_crc(primary_composer, cursor_composer);
 
 	/*
 	 * The worker can fall behind the vblank hrtimer, make sure we catch up.
@@ -237,7 +239,7 @@ int vkms_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 	ret = vkms_crc_parse_source(src_name, &enabled);
 
 	spin_lock_irq(&out->lock);
-	out->crc_enabled = enabled;
+	out->composer_enabled = enabled;
 	spin_unlock_irq(&out->lock);
 
 	return ret;
diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 7e2a081f3764..49a8ec2cb1c1 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -24,14 +24,14 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 	if (!ret)
 		DRM_ERROR("vkms failure on handling vblank");
 
-	state = output->crc_state;
-	if (state && output->crc_enabled) {
+	state = output->composer_state;
+	if (state && output->composer_enabled) {
 		u64 frame = drm_crtc_accurate_vblank_count(crtc);
 
-		/* update frame_start only if a queued vkms_crc_work_handle()
+		/* update frame_start only if a queued vkms_composer_worker()
 		 * has read the data
 		 */
-		spin_lock(&output->crc_lock);
+		spin_lock(&output->composer_lock);
 		if (!state->crc_pending)
 			state->frame_start = frame;
 		else
@@ -39,11 +39,11 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 					 state->frame_start, frame);
 		state->frame_end = frame;
 		state->crc_pending = true;
-		spin_unlock(&output->crc_lock);
+		spin_unlock(&output->composer_lock);
 
-		ret = queue_work(output->crc_workq, &state->crc_work);
+		ret = queue_work(output->composer_workq, &state->composer_work);
 		if (!ret)
-			DRM_DEBUG_DRIVER("vkms_crc_work_handle already queued\n");
+			DRM_DEBUG_DRIVER("Composer worker already queued\n");
 	}
 
 	spin_unlock(&output->lock);
@@ -114,7 +114,7 @@ vkms_atomic_crtc_duplicate_state(struct drm_crtc *crtc)
 
 	__drm_atomic_helper_crtc_duplicate_state(crtc, &vkms_state->base);
 
-	INIT_WORK(&vkms_state->crc_work, vkms_crc_work_handle);
+	INIT_WORK(&vkms_state->composer_work, vkms_composer_worker);
 
 	return &vkms_state->base;
 }
@@ -126,7 +126,7 @@ static void vkms_atomic_crtc_destroy_state(struct drm_crtc *crtc,
 
 	__drm_atomic_helper_crtc_destroy_state(state);
 
-	WARN_ON(work_pending(&vkms_state->crc_work));
+	WARN_ON(work_pending(&vkms_state->composer_work));
 	kfree(vkms_state->active_planes);
 	kfree(vkms_state);
 }
@@ -141,7 +141,7 @@ static void vkms_atomic_crtc_reset(struct drm_crtc *crtc)
 
 	__drm_atomic_helper_crtc_reset(crtc, &vkms_state->base);
 	if (vkms_state)
-		INIT_WORK(&vkms_state->crc_work, vkms_crc_work_handle);
+		INIT_WORK(&vkms_state->composer_work, vkms_composer_worker);
 }
 
 static const struct drm_crtc_funcs vkms_crtc_funcs = {
@@ -222,7 +222,7 @@ static void vkms_crtc_atomic_begin(struct drm_crtc *crtc,
 	struct vkms_output *vkms_output = drm_crtc_to_vkms_output(crtc);
 
 	/* This lock is held across the atomic commit to block vblank timer
-	 * from scheduling vkms_crc_work_handle until the crc_data is updated
+	 * from scheduling vkms_composer_worker until the composer is updated
 	 */
 	spin_lock_irq(&vkms_output->lock);
 }
@@ -245,7 +245,7 @@ static void vkms_crtc_atomic_flush(struct drm_crtc *crtc,
 		crtc->state->event = NULL;
 	}
 
-	vkms_output->crc_state = to_vkms_crtc_state(crtc->state);
+	vkms_output->composer_state = to_vkms_crtc_state(crtc->state);
 
 	spin_unlock_irq(&vkms_output->lock);
 }
@@ -274,10 +274,10 @@ int vkms_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
 	drm_crtc_helper_add(crtc, &vkms_crtc_helper_funcs);
 
 	spin_lock_init(&vkms_out->lock);
-	spin_lock_init(&vkms_out->crc_lock);
+	spin_lock_init(&vkms_out->composer_lock);
 
-	vkms_out->crc_workq = alloc_ordered_workqueue("vkms_crc_workq", 0);
-	if (!vkms_out->crc_workq)
+	vkms_out->composer_workq = alloc_ordered_workqueue("vkms_composer", 0);
+	if (!vkms_out->composer_workq)
 		return -ENOMEM;
 
 	return ret;
diff --git a/drivers/gpu/drm/vkms/vkms_drv.c b/drivers/gpu/drm/vkms/vkms_drv.c
index 966b3d653189..ac790b6527e4 100644
--- a/drivers/gpu/drm/vkms/vkms_drv.c
+++ b/drivers/gpu/drm/vkms/vkms_drv.c
@@ -56,7 +56,7 @@ static void vkms_release(struct drm_device *dev)
 	drm_atomic_helper_shutdown(&vkms->drm);
 	drm_mode_config_cleanup(&vkms->drm);
 	drm_dev_fini(&vkms->drm);
-	destroy_workqueue(vkms->output.crc_workq);
+	destroy_workqueue(vkms->output.composer_workq);
 }
 
 static void vkms_atomic_commit_tail(struct drm_atomic_state *old_state)
@@ -82,7 +82,7 @@ static void vkms_atomic_commit_tail(struct drm_atomic_state *old_state)
 		struct vkms_crtc_state *vkms_state =
 			to_vkms_crtc_state(old_crtc_state);
 
-		flush_work(&vkms_state->crc_work);
+		flush_work(&vkms_state->composer_work);
 	}
 
 	drm_atomic_helper_cleanup_planes(dev, old_state);
diff --git a/drivers/gpu/drm/vkms/vkms_drv.h b/drivers/gpu/drm/vkms/vkms_drv.h
index e2d1aa089dec..fc6cda164336 100644
--- a/drivers/gpu/drm/vkms/vkms_drv.h
+++ b/drivers/gpu/drm/vkms/vkms_drv.h
@@ -20,7 +20,7 @@
 
 extern bool enable_cursor;
 
-struct vkms_crc_data {
+struct vkms_composer {
 	struct drm_framebuffer fb;
 	struct drm_rect src, dst;
 	unsigned int offset;
@@ -31,29 +31,29 @@ struct vkms_crc_data {
 /**
  * vkms_plane_state - Driver specific plane state
  * @base: base plane state
- * @crc_data: data required for CRC computation
+ * @composer: data required for composing computation
  */
 struct vkms_plane_state {
 	struct drm_plane_state base;
-	struct vkms_crc_data *crc_data;
+	struct vkms_composer *composer;
 };
 
 /**
  * vkms_crtc_state - Driver specific CRTC state
  * @base: base CRTC state
- * @crc_work: work struct to compute and add CRC entries
+ * @composer_work: work struct to compose and add CRC entries
  * @n_frame_start: start frame number for computed CRC
  * @n_frame_end: end frame number for computed CRC
  */
 struct vkms_crtc_state {
 	struct drm_crtc_state base;
-	struct work_struct crc_work;
+	struct work_struct composer_work;
 
 	int num_active_planes;
 	/* stack of active planes for crc computation, should be in z order */
 	struct vkms_plane_state **active_planes;
 
-	/* below three are protected by vkms_output.crc_lock */
+	/* below three are protected by vkms_output.composer_lock */
 	bool crc_pending;
 	u64 frame_start;
 	u64 frame_end;
@@ -66,16 +66,16 @@ struct vkms_output {
 	struct hrtimer vblank_hrtimer;
 	ktime_t period_ns;
 	struct drm_pending_vblank_event *event;
-	/* ordered wq for crc_work */
-	struct workqueue_struct *crc_workq;
-	/* protects concurrent access to crc_data */
+	/* ordered wq for composer_work */
+	struct workqueue_struct *composer_workq;
+	/* protects concurrent access to composer */
 	spinlock_t lock;
 
 	/* protected by @lock */
-	bool crc_enabled;
-	struct vkms_crtc_state *crc_state;
+	bool composer_enabled;
+	struct vkms_crtc_state *composer_state;
 
-	spinlock_t crc_lock;
+	spinlock_t composer_lock;
 };
 
 struct vkms_device {
@@ -143,6 +143,8 @@ const char *const *vkms_get_crc_sources(struct drm_crtc *crtc,
 int vkms_set_crc_source(struct drm_crtc *crtc, const char *src_name);
 int vkms_verify_crc_source(struct drm_crtc *crtc, const char *source_name,
 			   size_t *values_cnt);
-void vkms_crc_work_handle(struct work_struct *work);
+
+/* Composer Support */
+void vkms_composer_worker(struct work_struct *work);
 
 #endif /* _VKMS_DRV_H_ */
diff --git a/drivers/gpu/drm/vkms/vkms_plane.c b/drivers/gpu/drm/vkms/vkms_plane.c
index 18c630cfc485..8b60d3434d75 100644
--- a/drivers/gpu/drm/vkms/vkms_plane.c
+++ b/drivers/gpu/drm/vkms/vkms_plane.c
@@ -18,20 +18,20 @@ static struct drm_plane_state *
 vkms_plane_duplicate_state(struct drm_plane *plane)
 {
 	struct vkms_plane_state *vkms_state;
-	struct vkms_crc_data *crc_data;
+	struct vkms_composer *composer;
 
 	vkms_state = kzalloc(sizeof(*vkms_state), GFP_KERNEL);
 	if (!vkms_state)
 		return NULL;
 
-	crc_data = kzalloc(sizeof(*crc_data), GFP_KERNEL);
-	if (!crc_data) {
-		DRM_DEBUG_KMS("Couldn't allocate crc_data\n");
+	composer = kzalloc(sizeof(*composer), GFP_KERNEL);
+	if (!composer) {
+		DRM_DEBUG_KMS("Couldn't allocate composer\n");
 		kfree(vkms_state);
 		return NULL;
 	}
 
-	vkms_state->crc_data = crc_data;
+	vkms_state->composer = composer;
 
 	__drm_atomic_helper_plane_duplicate_state(plane,
 						  &vkms_state->base);
@@ -49,12 +49,12 @@ static void vkms_plane_destroy_state(struct drm_plane *plane,
 		/* dropping the reference we acquired in
 		 * vkms_primary_plane_update()
 		 */
-		if (drm_framebuffer_read_refcount(&vkms_state->crc_data->fb))
-			drm_framebuffer_put(&vkms_state->crc_data->fb);
+		if (drm_framebuffer_read_refcount(&vkms_state->composer->fb))
+			drm_framebuffer_put(&vkms_state->composer->fb);
 	}
 
-	kfree(vkms_state->crc_data);
-	vkms_state->crc_data = NULL;
+	kfree(vkms_state->composer);
+	vkms_state->composer = NULL;
 
 	__drm_atomic_helper_plane_destroy_state(old_state);
 	kfree(vkms_state);
@@ -91,21 +91,21 @@ static void vkms_plane_atomic_update(struct drm_plane *plane,
 {
 	struct vkms_plane_state *vkms_plane_state;
 	struct drm_framebuffer *fb = plane->state->fb;
-	struct vkms_crc_data *crc_data;
+	struct vkms_composer *composer;
 
 	if (!plane->state->crtc || !fb)
 		return;
 
 	vkms_plane_state = to_vkms_plane_state(plane->state);
 
-	crc_data = vkms_plane_state->crc_data;
-	memcpy(&crc_data->src, &plane->state->src, sizeof(struct drm_rect));
-	memcpy(&crc_data->dst, &plane->state->dst, sizeof(struct drm_rect));
-	memcpy(&crc_data->fb, fb, sizeof(struct drm_framebuffer));
-	drm_framebuffer_get(&crc_data->fb);
-	crc_data->offset = fb->offsets[0];
-	crc_data->pitch = fb->pitches[0];
-	crc_data->cpp = fb->format->cpp[0];
+	composer = vkms_plane_state->composer;
+	memcpy(&composer->src, &plane->state->src, sizeof(struct drm_rect));
+	memcpy(&composer->dst, &plane->state->dst, sizeof(struct drm_rect));
+	memcpy(&composer->fb, fb, sizeof(struct drm_framebuffer));
+	drm_framebuffer_get(&composer->fb);
+	composer->offset = fb->offsets[0];
+	composer->pitch = fb->pitches[0];
+	composer->cpp = fb->format->cpp[0];
 }
 
 static int vkms_plane_atomic_check(struct drm_plane *plane,
-- 
2.17.1

