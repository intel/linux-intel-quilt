From a3ad397273979ed45bdc1fb18020e7417f732bd3 Mon Sep 17 00:00:00 2001
From: Ong Boon Leong <boon.leong.ong@intel.com>
Date: Tue, 13 Aug 2019 12:53:43 +0800
Subject: [PATCH 055/113] tc: Add support for configuring the frame preemption
 through taprio

For current implementation, we allow user to enable IEEE 802.1Qbu/
IEEE 802.3br Frame Preemption through taprio hardware offload only.

In future, we will enable user to independent enable/disable Frame
Preemption.

Thanks to Vinicius Costa Gomes for laying down the foundations for
supporting frame preemption in taprio qdisc.

Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
---
 include/net/pkt_sched.h        |  2 ++
 include/uapi/linux/pkt_sched.h |  1 +
 net/sched/sch_taprio.c         | 19 +++++++++++++++++++
 3 files changed, 22 insertions(+)

Index: kernel-staging/include/net/pkt_sched.h
===================================================================
--- kernel-staging.orig/include/net/pkt_sched.h
+++ kernel-staging/include/net/pkt_sched.h
@@ -180,6 +180,8 @@ struct tc_taprio_qopt_offload {
 	u64 cycle_time;
 	u64 cycle_time_extension;
 
+	/* bit nth being set means that the nth queue is preemptible */
+	u32 frame_preemption_queue_mask;
 	size_t num_entries;
 	struct tc_taprio_sched_entry entries[0];
 };
Index: kernel-staging/include/uapi/linux/pkt_sched.h
===================================================================
--- kernel-staging.orig/include/uapi/linux/pkt_sched.h
+++ kernel-staging/include/uapi/linux/pkt_sched.h
@@ -1176,6 +1176,7 @@ enum {
 	TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME_EXTENSION, /* s64 */
 	TCA_TAPRIO_ATTR_FLAGS, /* u32 */
 	TCA_TAPRIO_ATTR_TXTIME_DELAY, /* u32 */
+	TCA_TAPRIO_ATTR_FPE_QMASK, /* u32 */
 	__TCA_TAPRIO_ATTR_MAX,
 };
 
Index: kernel-staging/net/sched/sch_taprio.c
===================================================================
--- kernel-staging.orig/net/sched/sch_taprio.c
+++ kernel-staging/net/sched/sch_taprio.c
@@ -79,6 +79,7 @@ struct taprio_sched {
 	struct sk_buff *(*dequeue)(struct Qdisc *sch);
 	struct sk_buff *(*peek)(struct Qdisc *sch);
 	u32 txtime_delay;
+	u32 fpe_q_mask;
 };
 
 struct __tc_taprio_qopt_offload {
@@ -774,6 +775,7 @@ static const struct nla_policy taprio_po
 	[TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME]           = { .type = NLA_S64 },
 	[TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME_EXTENSION] = { .type = NLA_S64 },
 	[TCA_TAPRIO_ATTR_FLAGS]                      = { .type = NLA_U32 },
+	[TCA_TAPRIO_ATTR_FPE_QMASK]                  = { .type = NLA_S32 },
 	[TCA_TAPRIO_ATTR_TXTIME_DELAY]		     = { .type = NLA_U32 },
 };
 
@@ -1226,6 +1228,8 @@ static int taprio_enable_offload(struct
 	offload->enable = 1;
 	taprio_sched_to_offload(q, sched, mqprio, offload);
 
+	offload->frame_preemption_queue_mask = q->fpe_q_mask;
+
 	err = ops->ndo_setup_tc(dev, TC_SETUP_QDISC_TAPRIO, offload);
 	if (err < 0) {
 		NL_SET_ERR_MSG(extack,
@@ -1430,6 +1434,21 @@ static int taprio_change(struct Qdisc *s
 
 	q->flags = err;
 
+	if (tb[TCA_TAPRIO_ATTR_FPE_QMASK]) {
+		q->fpe_q_mask = nla_get_u32(tb[TCA_TAPRIO_ATTR_FPE_QMASK]);
+		if (FULL_OFFLOAD_IS_ENABLED(q->flags) && !q->fpe_q_mask) {
+			NL_SET_ERR_MSG_MOD(extack,
+					   "Invalid FPE Queue Mask - all 0s");
+
+			return -EINVAL;
+		}
+	} else {
+		/* If 'fpe-qmask' is not set, mark fpe_q_mask=0 to indicate
+		 * FPE is disabled.
+		 */
+		q->fpe_q_mask = 0;
+	}
+
 	err = taprio_parse_mqprio_opt(dev, mqprio, extack, q->flags);
 	if (err < 0)
 		return err;
