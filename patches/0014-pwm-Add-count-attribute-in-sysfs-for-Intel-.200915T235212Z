From c5612e33a5de5b6ae673f25b4b36da9bf54e9ee5 Mon Sep 17 00:00:00 2001
From: "Lai, Poey Seng" <poey.seng.lai@intel.com>
Date: Fri, 10 May 2019 14:11:04 +0800
Subject: [PATCH 14/48] pwm: Add count attribute in sysfs for Intel Keem Bay

In Keem Bay, the number of repetitions for the period/waveform
can be configured from userspace. This requires addition of a sysfs
attribute to get/set the repetition count. Setting this value to 0
will result in continuous repetition of the waveform until the
channel is disabled or reconfigured.

Signed-off-by: Lai, Poey Seng <poey.seng.lai@intel.com>
Signed-off-by: Vineetha G. Jaya Kumaran <vineetha.g.jaya.kumaran@intel.com>
---
 drivers/pwm/core.c        |  3 ++-
 drivers/pwm/pwm-keembay.c | 15 ++++++++++++++-
 drivers/pwm/sysfs.c       | 37 +++++++++++++++++++++++++++++++++++++
 include/linux/pwm.h       |  2 ++
 4 files changed, 55 insertions(+), 2 deletions(-)

diff --git a/drivers/pwm/core.c b/drivers/pwm/core.c
index f877e77d9184..36aa9af5eaa8 100644
--- a/drivers/pwm/core.c
+++ b/drivers/pwm/core.c
@@ -464,7 +464,8 @@ int pwm_apply_state(struct pwm_device *pwm, const struct pwm_state *state)
 	if (state->period == pwm->state.period &&
 	    state->duty_cycle == pwm->state.duty_cycle &&
 	    state->polarity == pwm->state.polarity &&
-	    state->enabled == pwm->state.enabled)
+	    state->enabled == pwm->state.enabled &&
+	    state->count == pwm->state.count)
 		return 0;
 
 	if (chip->ops->apply) {
diff --git a/drivers/pwm/pwm-keembay.c b/drivers/pwm/pwm-keembay.c
index 986e64194e30..e8fc5862f681 100644
--- a/drivers/pwm/pwm-keembay.c
+++ b/drivers/pwm/pwm-keembay.c
@@ -29,7 +29,7 @@
 /* Mask */
 #define KMB_PWM_HIGH_MASK		GENMASK(31, 16)
 #define KMB_PWM_LOW_MASK		GENMASK(15, 0)
-#define KMB_PWM_COUNT_MASK		GENMASK(31, 0)
+#define KMB_PWM_REPEAT_COUNT_MASK	GENMASK(15, 0)
 
 /* PWM Register offset */
 #define KMB_PWM_LEADIN_OFFSET(ch)	(0x00 + 4 * (ch))
@@ -91,6 +91,10 @@ static void keembay_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,
 	pwm_h_count = FIELD_GET(KMB_PWM_HIGH_MASK, buff) * NSEC_PER_SEC;
 	state->duty_cycle = DIV_ROUND_UP_ULL(pwm_h_count, clk_rate);
 	state->period = DIV_ROUND_UP_ULL(pwm_h_count + pwm_l_count, clk_rate);
+
+	/* Read repetition count */
+	buff = readl(priv->base + KMB_PWM_LEADIN_OFFSET(pwm->hwpwm));
+	state->count = buff & KMB_PWM_REPEAT_COUNT_MASK;
 }
 
 static int keembay_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
@@ -113,6 +117,15 @@ static int keembay_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 		return 0;
 	}
 
+	if (state->count != current_state.count) {
+		if (state->count > KMB_PWM_COUNT_MAX)
+			return -EINVAL;
+
+		keembay_pwm_update_bits(priv, KMB_PWM_REPEAT_COUNT_MASK,
+					state->count,
+					KMB_PWM_LEADIN_OFFSET(pwm->hwpwm));
+	}
+
 	/*
 	 * The upper 16 bits of the KMB_PWM_HIGHLOW_OFFSET register contain
 	 * the high time of the waveform, while the last 16 bits contain
diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 2389b8669846..3c474fad17b4 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -215,11 +215,47 @@ static ssize_t capture_show(struct device *child,
 	return sprintf(buf, "%u %u\n", result.period, result.duty_cycle);
 }
 
+static ssize_t count_store(struct device *child,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct pwm_export *export = child_to_pwm_export(child);
+	struct pwm_device *pwm = export->pwm;
+	struct pwm_state state;
+	unsigned int val;
+	int ret;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	mutex_lock(&export->lock);
+	pwm_get_state(pwm, &state);
+	state.count = val;
+	ret = pwm_apply_state(pwm, &state);
+	mutex_unlock(&export->lock);
+
+	return ret ? : size;
+}
+
+static ssize_t count_show(struct device *child,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	const struct pwm_device *pwm = child_to_pwm_device(child);
+	struct pwm_state state;
+
+	pwm_get_state(pwm, &state);
+
+	return sprintf(buf, "%d\n", state.count);
+}
+
 static DEVICE_ATTR_RW(period);
 static DEVICE_ATTR_RW(duty_cycle);
 static DEVICE_ATTR_RW(enable);
 static DEVICE_ATTR_RW(polarity);
 static DEVICE_ATTR_RO(capture);
+static DEVICE_ATTR_RW(count);
 
 static struct attribute *pwm_attrs[] = {
 	&dev_attr_period.attr,
@@ -227,6 +263,7 @@ static struct attribute *pwm_attrs[] = {
 	&dev_attr_enable.attr,
 	&dev_attr_polarity.attr,
 	&dev_attr_capture.attr,
+	&dev_attr_count.attr,
 	NULL
 };
 ATTRIBUTE_GROUPS(pwm);
diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index b2c9c460947d..d8a3d05584f4 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -52,12 +52,14 @@ enum {
  * struct pwm_state - state of a PWM channel
  * @period: PWM period (in nanoseconds)
  * @duty_cycle: PWM duty cycle (in nanoseconds)
+ * @count: Repeat count of PWM waveforms.
  * @polarity: PWM polarity
  * @enabled: PWM enabled status
  */
 struct pwm_state {
 	unsigned int period;
 	unsigned int duty_cycle;
+	unsigned int count;
 	enum pwm_polarity polarity;
 	bool enabled;
 };
-- 
2.17.1

