From 1b77043a6561646bc113a9691ef4bca4d2439618 Mon Sep 17 00:00:00 2001
From: Liu Xinyun <xinyun.liu@intel.com>
Date: Mon, 9 Sep 2019 23:59:56 +0800
Subject: [PATCH 22/24] drm/i915/gvt: enable GOP driver for different display
 modes

Get display mode from the first active crtc which assigned to the vGPU
and pass the information through vgtif to OVMF gop driver

For resolutions above 1920x1080@32bpp, will show the guest content to
the top-left portion of the display

Tracked-On: projectacrn/acrn-hypervisor#3624
Co-Developed-by: He Min <min.he@intel.com>
Signed-off-by: Liu Xinyun <xinyun.liu@intel.com>
Reviewed-by: Zhao Yakui <yakui.zhao@intel.com>
Signed-off-by: Xiaoguang Wu <xiaoguang.wu@intel.com>
Reviewed-by: Colin Xu <colin.xu@intel.com>
---
 drivers/gpu/drm/i915/gvt/display.c  | 116 +++++++++++++++++++++++++---
 drivers/gpu/drm/i915/gvt/gvt.h      |  13 ++++
 drivers/gpu/drm/i915/gvt/handlers.c |  11 ++-
 drivers/gpu/drm/i915/gvt/vgpu.c     |   8 ++
 drivers/gpu/drm/i915/i915_drv.h     |   3 +
 drivers/gpu/drm/i915/i915_pvinfo.h  |  15 ++++
 6 files changed, 153 insertions(+), 13 deletions(-)

diff --git a/drivers/gpu/drm/i915/gvt/display.c b/drivers/gpu/drm/i915/gvt/display.c
index 84d9b0989860..742b00644b4f 100644
--- a/drivers/gpu/drm/i915/gvt/display.c
+++ b/drivers/gpu/drm/i915/gvt/display.c
@@ -2710,9 +2710,86 @@ void intel_gvt_init_display(struct intel_gvt *gvt)
 }
 
 #if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+#define GOP_FB_SIZE		0x800000
+#define GOP_DISPLAY_WIDTH	1920u
+#define GOP_DISPLAY_HEIGHT	1080u
+
+/*
+ * check_gop_mode to query current mode and pass it to GOP
+ *
+ * 1. Get current mode from ctrc)
+ * 2. use crtc mode as GOP mode if mode <=1920x1080
+ * 3. use 1920x1080 as GOP mode if mode > 1080p
+ * 4.   enable panel scale (ToDO)
+ * 5. pass GOP mode to OVMF
+ *
+ */
+static int check_gop_mode(struct intel_vgpu *vgpu)
+{
+	struct drm_i915_private *dev_priv = vgpu->gvt->dev_priv;
+	unsigned int pipe;
+	struct intel_crtc *crtc;
+	struct intel_crtc_state *crtc_state;
+	struct drm_display_mode mode;
+	bool found = false;
+
+	/* we will get the gop output on the first pipe the vgpu ownes */
+	for_each_pipe(dev_priv, pipe) {
+		if (vgpu->gvt->pipe_info[pipe].owner == vgpu->id) {
+			found = true;
+			break;
+		}
+	}
+
+	if (found == false) {
+		gvt_dbg_dpy("Failed to find owned plane for %d", vgpu->id);
+		return -ENODEV;
+	}
+
+	crtc = intel_get_crtc_for_pipe(vgpu->gvt->dev_priv, pipe);
+	crtc_state = to_intel_crtc_state(crtc->base.state);
+	intel_mode_from_pipe_config(&mode, crtc_state);
+
+	drm_mode_debug_printmodeline(&mode);
+
+	if (mode.vdisplay <= 0 || mode.hdisplay <= 0)
+		return -EINVAL;
+
+	vgpu->gm.gop.width = mode.hdisplay;
+	vgpu->gm.gop.height = mode.vdisplay;
+	vgpu->gm.gop.pitch = mode.hdisplay;
+	vgpu->gm.gop.Bpp = 4;
+
+	/* populate mode for OVMF GOP driver */
+	if (mode.hdisplay * mode.vdisplay * 4 > GOP_FB_SIZE) {
+		vgpu_vreg_t(vgpu, vgtif_reg(gop.width)) =
+			min(vgpu->gm.gop.width, GOP_DISPLAY_WIDTH);
+		vgpu_vreg_t(vgpu, vgtif_reg(gop.height)) =
+			min(vgpu->gm.gop.height, GOP_DISPLAY_HEIGHT);
+		vgpu_vreg_t(vgpu, vgtif_reg(gop.pitch)) =
+			min(vgpu->gm.gop.pitch, GOP_DISPLAY_WIDTH);
+	} else {
+		vgpu_vreg_t(vgpu, vgtif_reg(gop.width)) = vgpu->gm.gop.width;
+		vgpu_vreg_t(vgpu, vgtif_reg(gop.height)) = vgpu->gm.gop.height;
+		vgpu_vreg_t(vgpu, vgtif_reg(gop.pitch)) = vgpu->gm.gop.pitch;
+	}
+
+	vgpu->gm.gop.size = 4 * vgpu_vreg_t(vgpu, vgtif_reg(gop.width)) *
+				vgpu_vreg_t(vgpu, vgtif_reg(gop.height));
+	vgpu_vreg_t(vgpu, vgtif_reg(gop.Bpp)) = 4;
+	vgpu_vreg_t(vgpu, vgtif_reg(gop.size)) = vgpu->gm.gop.size;
+
+	DRM_INFO("prepare GOP fb: %dKB for %dX%d@%d\n",
+			vgpu_vreg_t(vgpu, vgtif_reg(gop.size))>>10,
+			vgpu_vreg_t(vgpu, vgtif_reg(gop.width)),
+			vgpu_vreg_t(vgpu, vgtif_reg(gop.height)),
+			vgpu_vreg_t(vgpu, vgtif_reg(gop.Bpp))*8);
+	return 0;
+}
+
 /*
- * prepare_gop_fb will allocate a arrange of memory, then map them into the
- * ggtt table of the guest partition in the aperture.
+ * prepare_gop_fb will allocate a arrange of memory, and then map them
+ * into the ggtt table of the guest partition in the aperture.
  */
 static int prepare_gop_fb(struct intel_vgpu *vgpu, u32 size)
 {
@@ -2775,18 +2852,21 @@ static int prepare_gop_fb(struct intel_vgpu *vgpu, u32 size)
 	return ret;
 }
 
-#define GOP_DISPLAY_WIDTH 1920
-#define GOP_DISPLAY_HEIGHT 1080
 static int setup_gop_display(struct intel_vgpu *vgpu)
 {
 	int ret = 0;
 	unsigned int pipe;
 	struct drm_i915_private *dev_priv = vgpu->gvt->dev_priv;
 	bool found = false;
-	u32 width = GOP_DISPLAY_WIDTH, height = GOP_DISPLAY_HEIGHT;
+	u32 width, height, Bpp;
 	u32 stride, ctl, surf;
 	unsigned long irqflags;
 
+	width = vgpu_vreg_t(vgpu, vgtif_reg(gop.width));
+	height = vgpu_vreg_t(vgpu, vgtif_reg(gop.height));
+	Bpp = vgpu_vreg_t(vgpu, vgtif_reg(gop.Bpp));
+
+	DRM_INFO("Set up display w:%u h:%u for GOP \n", width, height);
 
 	/* we will display the gop output on the first plane the vgpu ownes */
 	for_each_pipe(dev_priv, pipe) {
@@ -2802,7 +2882,7 @@ static int setup_gop_display(struct intel_vgpu *vgpu)
 	}
 
 	/* Sizes are 0 based */
-	stride = width * 4 / 64; /* 32bit per pixel */
+	stride = width * Bpp / 64; /* 32bit per pixel */
 	width--;
 	height--;
 	surf = vgpu->gm.high_gm_node.start;
@@ -2824,24 +2904,40 @@ static int setup_gop_display(struct intel_vgpu *vgpu)
 	return ret;
 }
 
-#define GOP_FB_SIZE 0x800000  /* 8M FB size */
 int intel_vgpu_g2v_setup_gop(struct intel_vgpu *vgpu)
 {
 	int ret = 0;
 
+	gvt_dbg_dpy("intel_vgpu_g2v_setup_gop\n");
+
 	if (vgpu->gm.gop_fb_pages)
 		goto Done;
 
-	ret = prepare_gop_fb(vgpu, GOP_FB_SIZE);
+	ret = check_gop_mode(vgpu);
+	if (ret) {
+		gvt_vgpu_err("gop check pipe faile %d\n", ret);
+		goto Done;
+	}
+
+	ret = prepare_gop_fb(vgpu, vgpu->gm.gop.size);
 	if (ret) {
-		gvt_dbg_dpy("gop prepared failed %d\n", ret);
+		gvt_vgpu_err("gop prepared failed %d\n", ret);
 		goto Done;
 	}
 
 	ret = setup_gop_display(vgpu);
 	if (ret) {
-		gvt_dbg_dpy("gop display setup failed %d\n", ret);
+		gvt_vgpu_err("gop display setup failed %d\n", ret);
+		goto Done;
 	}
+
+	vgpu->gm.gop.fb_base = GOP_FB_BASE;
+
+	vgpu_vreg(vgpu, _vgtif_reg(gop.fb_base)) = vgpu->gm.gop.fb_base;
+
+	gvt_dbg_dpy("set up gop FbBase: %x\n",
+			vgpu_vreg(vgpu, _vgtif_reg(gop.fb_base)));
+
 Done:
 	return 0;
 }
diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 69e4c7f978ff..320339171608 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -75,6 +75,17 @@ struct intel_gvt_device_info {
 	u32 max_surface_size;
 };
 
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+struct gvt_gop_info {
+	unsigned int fb_base;
+	unsigned int width;
+	unsigned int height;
+	unsigned int pitch;
+	unsigned int Bpp;
+	unsigned int size;
+};
+#endif
+
 /* GM resources owned by a vGPU */
 struct intel_vgpu_gm {
 	u64 aperture_sz;
@@ -83,6 +94,7 @@ struct intel_vgpu_gm {
 	struct drm_mm_node high_gm_node;
 #if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
 	struct page **gop_fb_pages;
+	struct gvt_gop_info gop;
 	u32 gop_fb_size;
 #endif
 };
@@ -122,6 +134,7 @@ struct intel_vgpu_irq {
 };
 
 #if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+/* ToDo: GOP_FB_BASE from kernel parameter */
 #define GOP_FB_BASE	0xDF000000
 #endif
 
diff --git a/drivers/gpu/drm/i915/gvt/handlers.c b/drivers/gpu/drm/i915/gvt/handlers.c
index 8e733882cd6d..70858c696c52 100644
--- a/drivers/gpu/drm/i915/gvt/handlers.c
+++ b/drivers/gpu/drm/i915/gvt/handlers.c
@@ -1741,9 +1741,6 @@ static int sbi_ctl_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,
 	return 0;
 }
 
-#define _vgtif_reg(x) \
-	(VGT_PVINFO_PAGE + offsetof(struct vgt_if, x))
-
 static int pvinfo_mmio_read(struct intel_vgpu *vgpu, unsigned int offset,
 		void *p_data, unsigned int bytes)
 {
@@ -1765,6 +1762,14 @@ static int pvinfo_mmio_read(struct intel_vgpu *vgpu, unsigned int offset,
 	case 0x78010:	/* vgt_caps */
 	case 0x7881c:
 		break;
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+	case _vgtif_reg(gop.fb_base) ... _vgtif_reg(gop.size):
+		gvt_vgpu_err("pvinfo read gop: [%x:%x] = %x\n",
+				offset, bytes, *(u32 *)p_data);
+		if (offset + bytes > _vgtif_reg(gop.size) + 4)
+			invalid_read = true;
+		break;
+#endif
 	default:
 		invalid_read = true;
 		break;
diff --git a/drivers/gpu/drm/i915/gvt/vgpu.c b/drivers/gpu/drm/i915/gvt/vgpu.c
index 2881ace75d1f..88a81c5e9910 100644
--- a/drivers/gpu/drm/i915/gvt/vgpu.c
+++ b/drivers/gpu/drm/i915/gvt/vgpu.c
@@ -66,6 +66,14 @@ void populate_pvinfo_page(struct intel_vgpu *vgpu)
 	vgpu_vreg_t(vgpu, vgtif_reg(cursor_x_hot)) = UINT_MAX;
 	vgpu_vreg_t(vgpu, vgtif_reg(cursor_y_hot)) = UINT_MAX;
 
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+	vgpu_vreg_t(vgpu, vgtif_reg(gop.fb_base)) = 0;
+	vgpu_vreg_t(vgpu, vgtif_reg(gop.width)) = 0;
+	vgpu_vreg_t(vgpu, vgtif_reg(gop.height)) = 0;
+	vgpu_vreg_t(vgpu, vgtif_reg(gop.pitch)) = 0;
+	vgpu_vreg_t(vgpu, vgtif_reg(gop.Bpp)) = 0;
+	vgpu_vreg_t(vgpu, vgtif_reg(gop.size)) = 0;
+#endif
 	gvt_dbg_core("Populate PVINFO PAGE for vGPU %d\n", vgpu->id);
 	gvt_dbg_core("aperture base [GMADR] 0x%llx size 0x%llx\n",
 		vgpu_aperture_gmadr_base(vgpu), vgpu_aperture_sz(vgpu));
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index a32ed0198003..112f8811bdbf 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -61,6 +61,9 @@
 #include "i915_fixed.h"
 #include "i915_params.h"
 #include "i915_reg.h"
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+#include "i915_pvinfo.h"
+#endif
 #include "i915_utils.h"
 
 #include "display/intel_bios.h"
diff --git a/drivers/gpu/drm/i915/i915_pvinfo.h b/drivers/gpu/drm/i915/i915_pvinfo.h
index 217c9fca820d..c06af784a039 100644
--- a/drivers/gpu/drm/i915/i915_pvinfo.h
+++ b/drivers/gpu/drm/i915/i915_pvinfo.h
@@ -115,9 +115,24 @@ struct vgt_if {
 	u32 execlist_context_descriptor_lo;
 	u32 execlist_context_descriptor_hi;
 
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+	struct {
+		u32 fb_base;
+		u32 width;
+		u32 height;
+		u32 pitch;
+		u32 Bpp;
+		u32 size;
+	} gop;
+	u32  rsv8[0x200 - 30];    /* pad to one page */
+#else
 	u32  rsv7[0x200 - 24];    /* pad to one page */
+#endif
 } __packed;
 
+#define _vgtif_reg(x) \
+       (VGT_PVINFO_PAGE + offsetof(struct vgt_if, x))
+
 #define vgtif_offset(x) (offsetof(struct vgt_if, x))
 
 #define vgtif_reg(x) _MMIO(VGT_PVINFO_PAGE + vgtif_offset(x))
-- 
2.17.1

