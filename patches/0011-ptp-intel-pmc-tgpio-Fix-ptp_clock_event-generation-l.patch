From da59b8631297b84280c3c1ef63a5bf551fa66700 Mon Sep 17 00:00:00 2001
From: "Tan, Raymond" <raymond.tan@intel.com>
Date: Sun, 3 Nov 2019 15:49:52 +0800
Subject: [PATCH 11/11] ptp: intel-pmc-tgpio: Fix ptp_clock_event generation
 logic

Using FOR loop with the iteration of EC values is not correct,
because as long as EC != 0, there will be ptp_clock_event sent to
userspace.

Since this is a polling mode, we need to check with the previous EC
value, prior to generate ptp_clock_event to userspace.

Signed-off-by: Tan, Raymond <raymond.tan@intel.com>
---
 drivers/ptp/ptp-intel-pmc-tgpio.c | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/drivers/ptp/ptp-intel-pmc-tgpio.c b/drivers/ptp/ptp-intel-pmc-tgpio.c
index 02634f81c807..994c7fb74cae 100644
--- a/drivers/ptp/ptp-intel-pmc-tgpio.c
+++ b/drivers/ptp/ptp-intel-pmc-tgpio.c
@@ -54,6 +54,7 @@ struct intel_pmc_tgpio {
 
 	struct task_struct	*event_thread;
 	bool			input;
+	u64				prev_ec;
 };
 #define to_intel_pmc_tgpio(i)	(container_of((i), struct intel_pmc_tgpio, info))
 
@@ -168,8 +169,7 @@ static int intel_pmc_tgpio_event_thread(void *_tgpio)
 			schedule();
 
 		reg = intel_pmc_tgpio_readq(tgpio->base, TGPIOEC31_0);
-
-		for (i = 0; i < reg; i++) {
+		if (tgpio->prev_ec != reg) {
 			struct ptp_clock_event event;
 
 			event.type = PTP_CLOCK_EXTTS;
@@ -178,6 +178,10 @@ static int intel_pmc_tgpio_event_thread(void *_tgpio)
 					TGPIOTCV31_0);
 
 			ptp_clock_event(tgpio->clock, &event);
+
+			mutex_lock(&tgpio->lock);
+			tgpio->prev_ec = reg;
+			mutex_unlock(&tgpio->lock);
 		}
 		schedule_timeout_interruptible(10);
 	}
@@ -217,6 +221,7 @@ static int intel_pmc_tgpio_config_input(struct intel_pmc_tgpio *tgpio,
 
 	intel_pmc_tgpio_writel(tgpio->base, TGPIOCTL, ctrl);
 	tgpio->input = input;
+	tgpio->prev_ec = 0;
 
 	if (input)
 		wake_up_process(tgpio->event_thread);
-- 
2.17.1

