From 395bdd608c8ad415fc00d89acafab62b307ef58e Mon Sep 17 00:00:00 2001
From: Piotr Maziarz <piotrx.maziarz@linux.intel.com>
Date: Mon, 9 Mar 2020 08:22:54 -0400
Subject: [PATCH 1187/1214] ASoC: Intel: Fix IPC timeout when system overload

IPC Timeout should check time that DSP takes to respond. Before this
change timeout can happen when scheduler delays IPC sending or interrupt
isn't processed on time. Both this situations could happen when system
is overloaded. This patch makes driver resistant to those situations.

Tracked-On: PKT-3258,OAM-90492
Signed-off-by: Piotr Maziarz <piotrx.maziarz@linux.intel.com>
Signed-off-by: Maciej Bach <maciejx.bach@intel.com>
---
 sound/soc/intel/common/sst-dsp-priv.h |  7 +++++++
 sound/soc/intel/common/sst-ipc.c      | 28 +++++++++++++++++++++++++++-
 sound/soc/intel/common/sst-ipc.h      |  1 +
 sound/soc/intel/skylake/cnl-sst-dsp.c |  4 ++++
 sound/soc/intel/skylake/cnl-sst-dsp.h |  5 +++++
 sound/soc/intel/skylake/cnl-sst.c     |  7 +------
 sound/soc/intel/skylake/skl-sst-dsp.c |  4 ++++
 sound/soc/intel/skylake/skl-sst-ipc.c |  5 -----
 sound/soc/intel/skylake/skl-sst-ipc.h |  5 +++++
 9 files changed, 54 insertions(+), 12 deletions(-)

diff --git a/sound/soc/intel/common/sst-dsp-priv.h b/sound/soc/intel/common/sst-dsp-priv.h
index 196bb7d..fd02fc3 100644
--- a/sound/soc/intel/common/sst-dsp-priv.h
+++ b/sound/soc/intel/common/sst-dsp-priv.h
@@ -294,6 +294,12 @@ struct sst_mem_block {
 	struct list_head list;		/* Map list of free/used blocks */
 };
 
+enum ipc_state {
+	IPC_STATE_RESET = 0,
+	IPC_STATE_RECEIVED,
+	IPC_STATE_DEFERRED,
+};
+
 /*
  * Generic SST Shim Interface.
  */
@@ -310,6 +316,7 @@ struct sst_dsp {
 	void *thread_context;
 	int irq;
 	u32 id;
+	enum ipc_state ipc_state;
 
 	/* operations */
 	struct sst_ops *ops;
diff --git a/sound/soc/intel/common/sst-ipc.c b/sound/soc/intel/common/sst-ipc.c
index 07dabab..4d0e802 100644
--- a/sound/soc/intel/common/sst-ipc.c
+++ b/sound/soc/intel/common/sst-ipc.c
@@ -57,10 +57,29 @@ static int tx_wait_done(struct sst_generic_ipc *ipc,
 	unsigned long flags;
 	int ret;
 
+	wait_event(msg->waitq, ipc->sent);
+again:
 	/* wait for DSP completion (in all cases atm inc pending) */
 	ret = wait_event_timeout(msg->waitq, msg->complete,
 		msecs_to_jiffies(IPC_TIMEOUT_MSECS));
 
+	if (ipc->dsp->ipc_state == IPC_STATE_RECEIVED) {
+		/* fw did its job, now wait until it's processed */
+		if (!ret) {
+			wait_event(msg->waitq, msg->complete);
+			ret = 1;
+		}
+	}
+
+	if (ipc->dsp->ipc_state == IPC_STATE_DEFERRED) {
+		/* reply delayed due to nofitication */
+		if (!ret)
+			wait_event(msg->waitq, msg->complete);
+		msg->complete = false;
+		ipc->dsp->ipc_state = IPC_STATE_RESET;
+		goto again;
+	}
+
 	spin_lock_irqsave(&ipc->dsp->spinlock, flags);
 	if (ret == 0) {
 		if (ipc->ops.shim_dbg != NULL)
@@ -118,6 +137,8 @@ static int ipc_tx_message(struct sst_generic_ipc *ipc, u64 header,
 	msg->errno = 0;
 	msg->pending = false;
 	msg->complete = false;
+	ipc->sent = false;
+	ipc->dsp->ipc_state = IPC_STATE_RESET;
 
 	if ((tx_bytes) && (ipc->ops.tx_data_copy != NULL))
 		ipc->ops.tx_data_copy(msg, tx_data, tx_bytes);
@@ -131,6 +152,7 @@ static int ipc_tx_message(struct sst_generic_ipc *ipc, u64 header,
         } else {
                 spin_unlock_irqrestore(&ipc->dsp->spinlock, flags);
                 ipc->ops.direct_tx_msg(ipc);
+		ipc->sent = true;
         }
 
 	if (wait)
@@ -198,8 +220,12 @@ static void ipc_tx_msgs(struct work_struct *work)
 		msg = list_first_entry(&ipc->tx_list, struct ipc_message, list);
 		list_move(&msg->list, &ipc->rx_list);
 
-		if (ipc->ops.tx_msg != NULL)
+		if (ipc->ops.tx_msg != NULL) {
 			ipc->ops.tx_msg(ipc, msg);
+			ipc->sent = true;
+			if (msg->wait)
+				wake_up(&msg->waitq);
+		}
 	}
 
 	spin_unlock_irq(&ipc->dsp->spinlock);
diff --git a/sound/soc/intel/common/sst-ipc.h b/sound/soc/intel/common/sst-ipc.h
index eae3fa7..7c47e2c 100644
--- a/sound/soc/intel/common/sst-ipc.h
+++ b/sound/soc/intel/common/sst-ipc.h
@@ -67,6 +67,7 @@ struct sst_generic_ipc {
 	wait_queue_head_t wait_txq;
 	struct task_struct *tx_thread;
 	struct work_struct kwork;
+	bool sent;
 	bool pending;
 	struct ipc_message *msg;
 	int tx_data_max_size;
diff --git a/sound/soc/intel/skylake/cnl-sst-dsp.c b/sound/soc/intel/skylake/cnl-sst-dsp.c
index ac313e8..5122824 100644
--- a/sound/soc/intel/skylake/cnl-sst-dsp.c
+++ b/sound/soc/intel/skylake/cnl-sst-dsp.c
@@ -221,6 +221,10 @@ irqreturn_t cnl_dsp_sst_interrupt(int irq, void *dev_id)
 	}
 
 	if (hipctdr & CNL_ADSP_REG_HIPCTDR_BUSY) {
+		if (CNL_IPC_GLB_NOTIFY_RSP_TYPE(hipctdr))
+			ctx->ipc_state = IPC_STATE_RECEIVED;
+		else if (ctx->ipc_state != IPC_STATE_RECEIVED)
+			ctx->ipc_state = IPC_STATE_DEFERRED;
 		cnl_ipc_int_disable(ctx);
 		ret = IRQ_WAKE_THREAD;
 	}
diff --git a/sound/soc/intel/skylake/cnl-sst-dsp.h b/sound/soc/intel/skylake/cnl-sst-dsp.h
index 5f0653b..73fd8f1 100644
--- a/sound/soc/intel/skylake/cnl-sst-dsp.h
+++ b/sound/soc/intel/skylake/cnl-sst-dsp.h
@@ -103,6 +103,11 @@ struct sst_generic_ipc;
 #define CNL_ADSPCS_CPA_SHIFT	24
 #define CNL_ADSPCS_CPA(x)	(x << CNL_ADSPCS_CPA_SHIFT)
 
+#define CNL_IPC_GLB_NOTIFY_RSP_SHIFT	29
+#define CNL_IPC_GLB_NOTIFY_RSP_MASK	0x1
+#define CNL_IPC_GLB_NOTIFY_RSP_TYPE(x)	(((x) >> CNL_IPC_GLB_NOTIFY_RSP_SHIFT) \
+					& CNL_IPC_GLB_NOTIFY_RSP_MASK)
+
 int cnl_dsp_enable_core(struct sst_dsp *ctx, unsigned int core);
 int cnl_dsp_disable_core(struct sst_dsp *ctx, unsigned int core);
 irqreturn_t cnl_dsp_sst_interrupt(int irq, void *dev_id);
diff --git a/sound/soc/intel/skylake/cnl-sst.c b/sound/soc/intel/skylake/cnl-sst.c
index 19e0a4f..9883de9 100644
--- a/sound/soc/intel/skylake/cnl-sst.c
+++ b/sound/soc/intel/skylake/cnl-sst.c
@@ -425,11 +425,6 @@ static struct sst_ops cnl_ops = {
 	.free = cnl_dsp_free,
 };
 
-#define CNL_IPC_GLB_NOTIFY_RSP_SHIFT	29
-#define CNL_IPC_GLB_NOTIFY_RSP_MASK	0x1
-#define CNL_IPC_GLB_NOTIFY_RSP_TYPE(x)	(((x) >> CNL_IPC_GLB_NOTIFY_RSP_SHIFT) \
-					& CNL_IPC_GLB_NOTIFY_RSP_MASK)
-
 static irqreturn_t cnl_dsp_irq_thread_handler(int irq, void *context)
 {
 	struct sst_dsp *dsp = context;
@@ -476,7 +471,7 @@ static irqreturn_t cnl_dsp_irq_thread_handler(int irq, void *context)
 
 		return IRQ_HANDLED;
 	}
-	
+
 	return IRQ_NONE;
 }
 
diff --git a/sound/soc/intel/skylake/skl-sst-dsp.c b/sound/soc/intel/skylake/skl-sst-dsp.c
index a0a9513..e7a2766 100644
--- a/sound/soc/intel/skylake/skl-sst-dsp.c
+++ b/sound/soc/intel/skylake/skl-sst-dsp.c
@@ -374,6 +374,10 @@ irqreturn_t skl_dsp_sst_interrupt(int irq, void *dev_id)
 	}
 
 	if (hipct & SKL_ADSP_REG_HIPCT_BUSY) {
+		if (IPC_GLB_NOTIFY_RSP_TYPE(hipct))
+			ctx->ipc_state = IPC_STATE_RECEIVED;
+		else if (ctx->ipc_state != IPC_STATE_RECEIVED)
+			ctx->ipc_state = IPC_STATE_DEFERRED;
 		skl_ipc_int_disable(ctx);
 		result = IRQ_WAKE_THREAD;
 	}
diff --git a/sound/soc/intel/skylake/skl-sst-ipc.c b/sound/soc/intel/skylake/skl-sst-ipc.c
index ee15c05..3cb2342 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.c
+++ b/sound/soc/intel/skylake/skl-sst-ipc.c
@@ -68,11 +68,6 @@
 #define IPC_GLB_NOTIFY_MSG_TYPE(x)	(((x) >> IPC_GLB_NOTIFY_MSG_TYPE_SHIFT)	\
 						& IPC_GLB_NOTIFY_MSG_TYPE_MASK)
 
-#define IPC_GLB_NOTIFY_RSP_SHIFT	29
-#define IPC_GLB_NOTIFY_RSP_MASK		0x1
-#define IPC_GLB_NOTIFY_RSP_TYPE(x)	(((x) >> IPC_GLB_NOTIFY_RSP_SHIFT) \
-					& IPC_GLB_NOTIFY_RSP_MASK)
-
 /* Pipeline operations */
 
 /* Create pipeline message */
diff --git a/sound/soc/intel/skylake/skl-sst-ipc.h b/sound/soc/intel/skylake/skl-sst-ipc.h
index 26afd49..81ed3af 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.h
+++ b/sound/soc/intel/skylake/skl-sst-ipc.h
@@ -32,6 +32,11 @@ struct sst_generic_ipc;
 #define	SKL_EVENT_GLB_MODULE_NOTIFICATION	12
 #define	SKL_TPLG_CHG_NOTIFY	3
 
+#define IPC_GLB_NOTIFY_RSP_SHIFT	29
+#define IPC_GLB_NOTIFY_RSP_MASK		0x1
+#define IPC_GLB_NOTIFY_RSP_TYPE(x)	(((x) >> IPC_GLB_NOTIFY_RSP_SHIFT) \
+					& IPC_GLB_NOTIFY_RSP_MASK)
+
 enum skl_ipc_pipeline_state {
 	PPL_INVALID_STATE =	0,
 	PPL_UNINITIALIZED =	1,
-- 
2.7.4

