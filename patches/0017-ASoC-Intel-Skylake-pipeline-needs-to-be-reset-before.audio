From 30eb87014f3a92d48f27d5f64f56d2c4b11ca31c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Amadeusz=20S=C5=82awi=C5=84ski?=
 <amadeuszx.slawinski@intel.com>
Date: Thu, 12 Jul 2018 12:55:26 +0200
Subject: [PATCH 017/154] ASoC: Intel: Skylake: pipeline needs to be reset
 before disconnect
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Before actual deletion, pipeline should enter reset state. Currently,
pipe skips this checkpoint and goes straight to finish line. This is not
the expected path by DSP, so correct it.

Change-Id: I1b78ac3c8c99116526852d17f57605566b445017
Signed-off-by: Amadeusz Sławiński <amadeuszx.slawinski@intel.com>
Signed-off-by: Cezary Rojewski <cezary.rojewski@intel.com>
---
 sound/soc/intel/skylake/skl-messages.c | 21 +++++++++++++++------
 1 file changed, 15 insertions(+), 6 deletions(-)

diff --git a/sound/soc/intel/skylake/skl-messages.c b/sound/soc/intel/skylake/skl-messages.c
index d108fb5e9366..137f295e6871 100644
--- a/sound/soc/intel/skylake/skl-messages.c
+++ b/sound/soc/intel/skylake/skl-messages.c
@@ -1217,9 +1217,9 @@ int skl_create_pipeline(struct skl_dev *skl, struct skl_pipe *pipe)
 
 /*
  * A pipeline needs to be deleted on cleanup. If a pipeline is running, then
- * pause the pipeline first and then delete it
- * The pipe delete is done by sending delete pipeline IPC. DSP will stop the
- * DMA engines and releases resources
+ * pause the pipeline first. Before actual deletion, pipeline should enter
+ * reset state. Finish the procedure by sending delete pipeline IPC.
+ * DSP will stop the DMA engines and releases resources
  */
 int skl_delete_pipe(struct skl_dev *skl, struct skl_pipe *pipe)
 {
@@ -1227,6 +1227,10 @@ int skl_delete_pipe(struct skl_dev *skl, struct skl_pipe *pipe)
 
 	dev_dbg(skl->dev, "%s: pipe = %d\n", __func__, pipe->ppl_id);
 
+	/* If pipe was not created in FW, do not try to delete it */
+	if (pipe->state < SKL_PIPE_CREATED)
+		return 0;
+
 	/* If pipe is started, do stop the pipe in FW. */
 	if (pipe->state >= SKL_PIPE_STARTED) {
 		ret = skl_set_pipe_state(skl, pipe, PPL_PAUSED);
@@ -1238,9 +1242,14 @@ int skl_delete_pipe(struct skl_dev *skl, struct skl_pipe *pipe)
 		pipe->state = SKL_PIPE_PAUSED;
 	}
 
-	/* If pipe was not created in FW, do not try to delete it */
-	if (pipe->state < SKL_PIPE_CREATED)
-		return 0;
+	/* reset pipe state before deletion */
+	ret = skl_set_pipe_state(skl, pipe, PPL_RESET);
+	if (ret < 0) {
+		dev_err(skl->dev, "Failed to reset pipe ret=%d\n", ret);
+		return ret;
+	}
+
+	pipe->state = SKL_PIPE_RESET;
 
 	ret = skl_ipc_delete_pipeline(&skl->ipc, pipe->ppl_id);
 	if (ret < 0) {
-- 
2.17.1

