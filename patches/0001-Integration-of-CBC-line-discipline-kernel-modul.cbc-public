From 2b78b6d15180e81880466cba3c100bbf0b8fae6b Mon Sep 17 00:00:00 2001
From: "G Jaya Kumaran, Vineetha" <vineetha.g.jaya.kumaran@intel.com>
Date: Thu, 24 May 2018 18:45:28 +0800
Subject: [PATCH 1/3] Integration of CBC line discipline kernel module

This patch enables the Carrier Board Communication (CBC)
kernel module, which is implemented as a Linux kernel line
discipline attached to a UART device. The CBC protocol
defines a number of different channels which are provided
as Linux character device nodes.

Change-Id: Ic2a72229df9e9a80e306f2f44da37b1ac8539af3
Signed-off-by: G Jaya Kumaran, Vineetha <vineetha.g.jaya.kumaran@intel.com>
---
 drivers/tty/Kconfig                   |   3 +
 drivers/tty/Makefile                  |   1 +
 drivers/tty/cbc/Kconfig               |  22 +
 drivers/tty/cbc/Makefile              |  14 +
 drivers/tty/cbc/cbc_core.c            | 307 +++++++++
 drivers/tty/cbc/cbc_core.h            |  44 ++
 drivers/tty/cbc/cbc_core_public.h     |  28 +
 drivers/tty/cbc/cbc_device.c          |  66 ++
 drivers/tty/cbc/cbc_device.h          | 107 ++++
 drivers/tty/cbc/cbc_device_manager.c  | 879 ++++++++++++++++++++++++++
 drivers/tty/cbc/cbc_device_manager.h  |  66 ++
 drivers/tty/cbc/cbc_link_checksum.c   |  59 ++
 drivers/tty/cbc/cbc_link_checksum.h   |  44 ++
 drivers/tty/cbc/cbc_link_layer.c      | 484 ++++++++++++++
 drivers/tty/cbc/cbc_link_layer.h      |  38 ++
 drivers/tty/cbc/cbc_memory.c          | 153 +++++
 drivers/tty/cbc/cbc_memory.h          | 146 +++++
 drivers/tty/cbc/cbc_mux_multiplexer.c | 145 +++++
 drivers/tty/cbc/cbc_mux_multiplexer.h |  62 ++
 drivers/tty/cbc/cbc_types.h           | 137 ++++
 include/cbc/cbc-core.h                |  24 +
 include/uapi/linux/cbc/cbc-core.h     |  24 +
 include/uapi/linux/major.h            |   2 +
 include/uapi/linux/tty.h              |   5 +-
 24 files changed, 2858 insertions(+), 2 deletions(-)
 create mode 100644 drivers/tty/cbc/Kconfig
 create mode 100644 drivers/tty/cbc/Makefile
 create mode 100644 drivers/tty/cbc/cbc_core.c
 create mode 100644 drivers/tty/cbc/cbc_core.h
 create mode 100644 drivers/tty/cbc/cbc_core_public.h
 create mode 100644 drivers/tty/cbc/cbc_device.c
 create mode 100644 drivers/tty/cbc/cbc_device.h
 create mode 100644 drivers/tty/cbc/cbc_device_manager.c
 create mode 100644 drivers/tty/cbc/cbc_device_manager.h
 create mode 100644 drivers/tty/cbc/cbc_link_checksum.c
 create mode 100644 drivers/tty/cbc/cbc_link_checksum.h
 create mode 100644 drivers/tty/cbc/cbc_link_layer.c
 create mode 100644 drivers/tty/cbc/cbc_link_layer.h
 create mode 100644 drivers/tty/cbc/cbc_memory.c
 create mode 100644 drivers/tty/cbc/cbc_memory.h
 create mode 100644 drivers/tty/cbc/cbc_mux_multiplexer.c
 create mode 100644 drivers/tty/cbc/cbc_mux_multiplexer.h
 create mode 100644 drivers/tty/cbc/cbc_types.h
 create mode 100644 include/cbc/cbc-core.h
 create mode 100644 include/uapi/linux/cbc/cbc-core.h

diff --git a/drivers/tty/Kconfig b/drivers/tty/Kconfig
index 0840d27381ea..7210714592ac 100644
--- a/drivers/tty/Kconfig
+++ b/drivers/tty/Kconfig
@@ -441,4 +441,7 @@ config VCC
 	depends on SUN_LDOMS
 	help
 	  Support for Sun logical domain consoles.
+
+source "drivers/tty/cbc/Kconfig"
+
 endif # TTY
diff --git a/drivers/tty/Makefile b/drivers/tty/Makefile
index c72cafdf32b4..4ae6744406d4 100644
--- a/drivers/tty/Makefile
+++ b/drivers/tty/Makefile
@@ -33,5 +33,6 @@ obj-$(CONFIG_PPC_EPAPR_HV_BYTECHAN) += ehv_bytechan.o
 obj-$(CONFIG_GOLDFISH_TTY)	+= goldfish.o
 obj-$(CONFIG_MIPS_EJTAG_FDC_TTY) += mips_ejtag_fdc.o
 obj-$(CONFIG_VCC)		+= vcc.o
+obj-$(CONFIG_CBC_LDISC)		+= cbc/
 
 obj-y += ipwireless/
diff --git a/drivers/tty/cbc/Kconfig b/drivers/tty/cbc/Kconfig
new file mode 100644
index 000000000000..c9cde7fa43ca
--- /dev/null
+++ b/drivers/tty/cbc/Kconfig
@@ -0,0 +1,22 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# CBC (CarrierBoardCommunication) subsystem configuration
+#
+
+config CBC_LDISC
+		 tristate "CBC (Carrier Board Communication) line discipline"
+		 depends on TTY
+		 help
+		   The CBC driver implements a line discipline supporting
+		   the proprietary CBC (Carrier Board Communication) protocol.
+
+		   The CBC protocol is a serial line protocol with multiplexing
+		   intended to be used in automotive IVI platforms for multi-
+		   plexed communication between a vehicle IOC and CPU. It is
+		   designed to transport small data packets (up to 64 bytes)
+		   and features a transport protocol to transport larger data
+		   chunks over a point to point connection.
+
+		   When initialised the driver presents a number of channels as
+		   character devices.
+
diff --git a/drivers/tty/cbc/Makefile b/drivers/tty/cbc/Makefile
new file mode 100644
index 000000000000..c0517817f605
--- /dev/null
+++ b/drivers/tty/cbc/Makefile
@@ -0,0 +1,14 @@
+# SPDX-License-Identifier: GPL-2.0
+
+
+cbc-ldisc-y := cbc_core.o
+cbc-ldisc-y += cbc_device.o
+cbc-ldisc-y += cbc_device_manager.o
+cbc-ldisc-y += cbc_link_checksum.o
+cbc-ldisc-y += cbc_link_layer.o
+cbc-ldisc-y += cbc_memory.o
+cbc-ldisc-y += cbc_mux_multiplexer.o
+
+obj-$(CONFIG_CBC_LDISC) += cbc-ldisc.o
+
+ccflags-y :=  -O2 -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -fstack-protector
\ No newline at end of file
diff --git a/drivers/tty/cbc/cbc_core.c b/drivers/tty/cbc/cbc_core.c
new file mode 100644
index 000000000000..d9d15fa224ae
--- /dev/null
+++ b/drivers/tty/cbc/cbc_core.c
@@ -0,0 +1,307 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/tty.h>
+#include <linux/uaccess.h>
+
+#include "cbc_core.h"
+#include "cbc_types.h"
+#include "cbc_device_manager.h"
+#include "cbc_link_layer.h"
+#include "cbc_mux_multiplexer.h"
+
+MODULE_AUTHOR("Gerhard Bocksch.  gerhard.bocksch@intel.com");
+MODULE_DESCRIPTION("CBC serial protocol demultiplexer");
+MODULE_LICENSE("GPL");
+
+static int granularity = 4;
+module_param(granularity, int, 0644);
+MODULE_PARM_DESC(granularity,
+		"The granularity of the CBC messages. default: 4");
+
+MODULE_ALIAS_LDISC(N_CBCCORE);
+
+/* Marker to mark the cbc_core as valid. */
+#define CBC_MAGIC 0xAFFEAFFE
+
+static struct cbc_struct cbc_core = { .magic = CBC_MAGIC };
+
+/*
+ * cbc_core_configure_channel - Set the priority and receive
+ *                              callback for a CBC channel.
+ * @channel_idx: Channel identifier (see cbc_channel_enumeration)
+ * @priority: Priority for channel.
+ * @data: Data associated with channel.
+ * @receive: Receive callback associated with channel.
+ */
+void cbc_core_configure_channel(u32 const channel_idx, const u8 priority,
+				void *data,
+				void (*receive)(void *data, const u16 length,
+				const u8 * const buffer))
+{
+	cbc_mux_configure_data_channel(channel_idx, priority, data, receive);
+}
+EXPORT_SYMBOL_GPL(cbc_core_configure_channel);
+
+/*
+ * cbc_core_send_data - Send to a CBC channel.
+ * @channel_idx: Channel identifier (see cbc_channel_enumeration)
+ * @priority: Priority for channel.
+ * @data: Data associated with channel.
+ * @receive: Receive function associated with channel.
+ */
+void cbc_core_send_data(const u32 channel_idx, const u16 length,
+						const u8 * const buffer)
+{
+	cbc_manager_transmit_data(channel_idx, length, buffer);
+}
+EXPORT_SYMBOL_GPL(cbc_core_send_data);
+
+/*
+ * cbc_ldisc_open - Open the CBC connection to the IOC.
+ * @tty: Handle to tty.
+ *
+ * This function is called by the tty module when the
+ * line discipline is requested. It allocates the memory pool and creates the
+ * CBC devices.
+ * Called in process context serialized from other ldisc calls.
+ *
+ * Return: 0 on success error otherwise.
+ */
+static int cbc_ldisc_open(struct tty_struct *tty)
+{
+	struct cbc_struct *cbc;
+	int err;
+
+	pr_debug("cbc-ldisc open.\n");
+	mutex_lock(&cbc_core.ldisc_mutex);
+
+	if (WARN_ON(tty->ops->write == NULL)) {
+		pr_err("cbc-ldisc open write not supported.\n");
+		err = -EOPNOTSUPP;
+		goto err_exit;
+	}
+
+	cbc = tty->disc_data;
+
+	err = -EEXIST;
+	/* First make sure we're not already connected. */
+	if (WARN_ON(cbc && cbc->magic == CBC_MAGIC)) {
+		pr_err(
+		"cbc-ldisc CBC line discipline already open or CBC magic wrong.\n");
+		goto err_exit;
+	}
+
+	cbc = &cbc_core;
+
+	cbc->tty = tty;
+	tty->disc_data = cbc;
+	tty->receive_room = 65536;
+
+	/* Create class cbc-core. This will appear as /sys/class/cbc* */
+	cbc->cbc_class = class_create(THIS_MODULE, "cbc");
+
+	if (WARN_ON(!cbc->cbc_class)) {
+		pr_err("cbc-ldisc open could not create cbc class.\n");
+		goto err_exit;
+	}
+
+	/* Create memory pool */
+	cbc->memory_pool = cbc_memory_pool_create(
+			CBC_QUEUE_LENGTH * CBC_CHANNEL_MAX_NUMBER);
+	if (WARN_ON(!cbc->memory_pool)) {
+		pr_err("failed to create memory pool.\n");
+		goto err_exit;
+	}
+
+	/* Initialise on every open, so we start with sequence-counters at 0.*/
+	cbc_link_layer_init(cbc->memory_pool);
+
+	/* Register devices here. */
+	err = cbc_register_devices(cbc->cbc_class, cbc->memory_pool);
+	if (err != 0) {
+		pr_err("register devices failed\n");
+		goto err_exit;
+	}
+
+	cbc_link_layer_set_frame_granularity(granularity);
+
+	/* tty layer expects 0 on success */
+	mutex_unlock(&cbc_core.ldisc_mutex);
+	return 0;
+
+err_exit: mutex_unlock(&cbc_core.ldisc_mutex);
+	return err;
+}
+
+/*
+ * cbc_ldisc_close - Close down the CBC communication.
+ * @tty: Handle to tty
+ *
+ * Unregister CBC devices and destroy CBC class.
+ */
+static void cbc_ldisc_close(struct tty_struct *tty)
+{
+	struct cbc_struct *cbc;
+
+	mutex_lock(&cbc_core.ldisc_mutex);
+
+	cbc = (struct cbc_struct *) tty->disc_data;
+	pr_debug("cbc-ldisc close\n");
+
+	if (cbc && cbc->magic == CBC_MAGIC && cbc->tty == tty) {
+		cbc_unregister_devices(cbc->cbc_class);
+		class_destroy(cbc->cbc_class);
+		if (WARN_ON(!cbc_memory_pool_try_free(cbc->memory_pool)))
+			pr_err("could not free memory pool.\n");
+		tty->disc_data = NULL;
+		cbc->tty = NULL;
+	} else {
+		WARN_ON(1);
+		pr_err("ldisc close with wrong CBC magic.\n");
+	}
+
+	mutex_unlock(&cbc_core.ldisc_mutex);
+}
+
+/*
+ * Close line discipline on ldisc hangup.
+ * @tty: Handle to tty
+ */
+static int cbc_ldisc_hangup(struct tty_struct *tty)
+{
+	cbc_ldisc_close(tty);
+	return 0;
+}
+
+/*
+ * cbc_ldisc_receive_buf - .receive call for a line discipline.
+ * @tty: Handle to tty
+ * @cp:  Received data buffer.
+ * @fp:  Not used
+ * @count: Amount of data received.
+ *
+ * Attempts to read a single CBC frame at a time. Cycles round
+ * until all data has been processed.
+ */
+static void cbc_ldisc_receive_buf(struct tty_struct *tty,
+		const unsigned char *cp, char *fp, int count)
+{
+	struct cbc_struct *cbc;
+	u8 accepted_bytes; /* per cbc_serial_receive call */
+	unsigned int accepted_bytes_sum = 0;
+
+	mutex_lock(&cbc_core.ldisc_mutex);
+	cbc = (struct cbc_struct *) tty->disc_data;
+
+	if (cbc && (cbc->magic == CBC_MAGIC) && (cbc->tty == tty)) {
+		do {
+			u8 chunksize = 254;
+
+			if ((count - accepted_bytes_sum) < 255)
+				chunksize = count - accepted_bytes_sum;
+			accepted_bytes = cbc_core_on_receive_cbc_serial_data(
+					chunksize, cp + accepted_bytes_sum);
+			accepted_bytes_sum += accepted_bytes;
+			cbc_link_layer_rx_handler();
+		} while (accepted_bytes_sum != count);
+	}
+	mutex_unlock(&cbc_core.ldisc_mutex);
+}
+
+/*
+ * Called from ldisc when write is possible. Not used.
+ */
+static void cbc_ldisc_write_wakeup(struct tty_struct *tty)
+{
+	(void) tty;
+}
+
+/* Called to send messages from channel specific device to the IOC */
+enum cbc_error target_specific_send_cbc_uart_data(u16 length,
+						const u8 *raw_buffer)
+{
+	mutex_lock(&cbc_core.ldisc_mutex);
+	if (cbc_core.tty) {
+		set_bit(TTY_DO_WRITE_WAKEUP, &cbc_core.tty->flags);
+
+		cbc_core.tty->ops->write(cbc_core.tty, raw_buffer, length);
+	}
+	mutex_unlock(&cbc_core.ldisc_mutex);
+
+	return CBC_OK;
+}
+
+static struct tty_ldisc_ops cbc_ldisc = {
+	.owner = THIS_MODULE,
+	.name = "cbc-ldisc",
+	.magic = TTY_LDISC_MAGIC,
+	.open = cbc_ldisc_open,
+	.close = cbc_ldisc_close,
+	.hangup = cbc_ldisc_hangup,
+	.receive_buf = cbc_ldisc_receive_buf,
+	.write_wakeup = cbc_ldisc_write_wakeup
+};
+
+/*
+ * cbc_init - Module init call.
+ * Registers this module as TTY line discipline.
+ */
+static int __init cbc_init(void)
+{
+	int status;
+
+	pr_debug("cbc-ldisc init\n");
+	mutex_init(&cbc_core.ldisc_mutex);
+	mutex_lock(&cbc_core.ldisc_mutex);
+
+	cbc_kmod_devices_init();
+
+	/* Fill in line discipline, and register it */
+	status = tty_register_ldisc(N_CBCCORE, &cbc_ldisc);
+	if (status)
+		pr_err("cbc-ldisc: can't register line discipline\n");
+
+	mutex_unlock(&cbc_core.ldisc_mutex);
+	return 0;
+}
+
+/*
+ * cbc_exit - Module exit call.
+ *
+ * De-registers itself as line discipline.
+ */
+static void __exit cbc_exit(void)
+{
+	int i;
+
+	mutex_lock(&cbc_core.ldisc_mutex);
+
+	pr_debug("cbc-ldisc Exit\n");
+
+	i = tty_unregister_ldisc(N_CBCCORE);
+	if (i)
+		pr_err("cbc-ldisc: can't unregister ldisc (err %d).\n", i);
+
+	mutex_unlock(&cbc_core.ldisc_mutex);
+}
+
+module_init(cbc_init);
+module_exit(cbc_exit);
diff --git a/drivers/tty/cbc/cbc_core.h b/drivers/tty/cbc/cbc_core.h
new file mode 100644
index 000000000000..71e07a3f7765
--- /dev/null
+++ b/drivers/tty/cbc/cbc_core.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef CBC_CORE_MOD_H_
+#define CBC_CORE_MOD_H_
+
+#include <linux/cbc/cbc-core.h>
+#include <linux/cdev.h>
+#include <linux/ioctl.h>
+#include <linux/mutex.h>
+#include <linux/tty.h>
+
+#include "cbc_memory.h"
+
+#define CBC_IOCTL_MAGIC 0xf4
+
+/*
+ * struct cbc_struct -
+ *
+ * @magic: Marker to mark the cbc_core as valid.
+ * @tty: tty associated with the CBC driver.
+ * @class: CBC device class
+ * @memory_pool: Memory pool of CBC buffer allocated for used by CBC driver.
+ * @ldisc_mutex: Mutex to avoid unloading while accessing the driver
+ */
+struct cbc_struct {
+	int magic;
+	struct tty_struct *tty;
+	struct class *cbc_class;
+	struct cbc_memory_pool *memory_pool;
+	struct mutex ldisc_mutex;
+};
+
+#endif /* CBC_CORE_MOD_H_ */
diff --git a/drivers/tty/cbc/cbc_core_public.h b/drivers/tty/cbc/cbc_core_public.h
new file mode 100644
index 000000000000..85928f6efc68
--- /dev/null
+++ b/drivers/tty/cbc/cbc_core_public.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef CBC_CORE_PUBLIC_H
+#define CBC_CORE_PUBLIC_H
+
+#include "cbc_types.h"
+
+/* CBC version.	*/
+#define CBC_VERSION_ID		1
+
+/* The following function needs to be implemented on CM/IOC. */
+enum cbc_error target_specific_send_cbc_uart_data(u16 length,
+						const u8 *raw_buffer);
+
+
+#endif /* CBC_CORE_PUBLIC_H */
+
diff --git a/drivers/tty/cbc/cbc_device.c b/drivers/tty/cbc/cbc_device.c
new file mode 100644
index 000000000000..1933a8527015
--- /dev/null
+++ b/drivers/tty/cbc/cbc_device.c
@@ -0,0 +1,66 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/sched.h>
+
+#include "cbc_device.h"
+
+
+void cbc_device_init(struct cbc_device_data *cd)
+{
+	if (cd)
+		INIT_LIST_HEAD(&cd->open_files_head);
+}
+
+void cbc_file_init(struct cbc_file_data *file)
+{
+	if (file) {
+		cbc_buffer_queue_init(&file->queue);
+		init_waitqueue_head(&file->wq_read);
+		INIT_LIST_HEAD(&file->list);
+	}
+}
+
+void cbc_file_enqueue(struct cbc_file_data *fd, struct cbc_buffer *buffer)
+{
+	if (fd) {
+		if (cbc_buffer_queue_enqueue(&fd->queue, buffer)) {
+			cbc_buffer_increment_ref(buffer);
+			wake_up_interruptible(&fd->wq_read);
+		}
+	}
+}
+
+struct cbc_buffer *cbc_file_dequeue(struct cbc_file_data *fd)
+{
+	struct cbc_buffer *buffer = NULL;
+
+	if (fd)
+		buffer = cbc_buffer_queue_dequeue(&fd->queue);
+
+	if (buffer && atomic_read(&buffer->refcount) == 0) {
+		buffer = NULL;
+		pr_err("cbc-core: De-queueing an already freed buffer\n");
+	}
+
+	return buffer;
+}
+
+int cbc_file_queue_empty(struct cbc_file_data *fd)
+{
+	if (fd)
+		return (fd->queue.write == fd->queue.read);
+
+	return 1;
+}
+
diff --git a/drivers/tty/cbc/cbc_device.h b/drivers/tty/cbc/cbc_device.h
new file mode 100644
index 000000000000..deb0cd922316
--- /dev/null
+++ b/drivers/tty/cbc/cbc_device.h
@@ -0,0 +1,107 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef CBC_DEVICE_H_
+#define CBC_DEVICE_H_
+
+#include <linux/cdev.h>
+#include <linux/circ_buf.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/wait.h>
+
+
+#include "cbc_types.h"
+#include "cbc_memory.h"
+
+enum cbc_device_type {
+	CBC_DEVICE_TYPE_DEFAULT,
+	CBC_DEVICE_TYPE_RAW,
+	CBC_DEVICE_TYPE_HIDDEN,
+	CBC_DEVICE_TYPE_DEBUG
+};
+
+/*
+ * struct cbc_device_data -Data for a single channel e.g. /dev/cbc-pmt.
+ * @device_name: Device name.
+ * @device_type: CBC device type.
+ * See c:type 'enum cbc_device_type <cbc_device_type>'.
+ * @device: Pointer to device struct.
+ * @open_files_head: Linked list of open files for this device.
+ *
+ * Configuration for a given CBC device. It will be stored in the device private
+ * data.
+ */
+struct cbc_device_data {
+	char *device_name;
+	enum cbc_device_type device_type;
+	struct device *device;
+	struct list_head open_files_head;
+};
+
+/*
+ * struct cbc_file_data - Data for a CBC device file .
+ * @queue: CBC buffer queue for this device.
+ * @wq_read: wait_queue_head_t fused for waking device on events.
+ * @cbc_device: Device data for this device.
+ * @list: list_head.
+ *
+ */
+struct cbc_file_data {
+	struct cbc_buffer_queue queue;
+	wait_queue_head_t wq_read;
+	struct cbc_device_data *cbc_device;
+	struct list_head list;
+};
+
+/*
+ * cbc_device_init - Initialise CBC device data
+ * @cd: pointer to CBC device data.
+ *
+ * Initialises device's list_head.
+ */
+void cbc_device_init(struct cbc_device_data *cd);
+
+/*
+ * cbc_file_init - Initialise CBC file data
+ * @file: pointer to CBC file data.
+ *
+ * Initialises device file's CBC queue, wait_queue_head_t and list_head.
+ */
+void cbc_file_init(struct cbc_file_data *file);
+
+/*
+ * cbc_file_enqueue -Add CBC buffer to queue.
+ * @fd: CBC device file data.
+ * buffer: Pointer to CBC buffer.
+ * Increases reference count on buffer.
+ */
+void cbc_file_enqueue(struct cbc_file_data *fd, struct cbc_buffer *buffer);
+
+/*
+ * cbc_file_dequeue - Remove buffer from head of queue.
+ * @fd: CBC device file data.
+ *
+ * Does not decrease reference count.
+ */
+struct cbc_buffer *cbc_file_dequeue(struct cbc_file_data *fd);
+
+/*
+ * cbc_file_queue_empty - Is CBC queue empty?
+ */
+int cbc_file_queue_empty(struct cbc_file_data *fd);
+
+#endif /* CBC_DEVICE_H_ */
diff --git a/drivers/tty/cbc/cbc_device_manager.c b/drivers/tty/cbc/cbc_device_manager.c
new file mode 100644
index 000000000000..0e74183d9828
--- /dev/null
+++ b/drivers/tty/cbc/cbc_device_manager.c
@@ -0,0 +1,879 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+#include "cbc_core.h"
+#include "cbc_device.h"
+#include "cbc_device_manager.h"
+#include "cbc_memory.h"
+#include "cbc_mux_multiplexer.h"
+#include "cbc_types.h"
+
+static int major; /* Default to dynamic major */
+module_param(major, int, 0);
+MODULE_PARM_DESC(major, "Major device number");
+
+/*
+ * Minor start number.
+ * This has to be 0 to allow a lookup of the device structs in an array.
+ */
+#define CBC_MINOR 0
+/* Device-name/driver-name when registering the devices in the linux kernel.*/
+#define DEVICE_NAME "cbc-core"
+
+/* Max number of open files per cbc channel */
+#define MAX_OPEN_FILES 6
+
+static void demuxed_receive(void *void_data, struct cbc_buffer *cbc_buffer);
+
+static int cbc_device_open(struct inode *, struct file *);
+static int cbc_device_release(struct inode *, struct file *);
+static ssize_t cbc_device_read(struct file *, char __user *, size_t,
+							  loff_t *);
+static ssize_t cbc_device_write(struct file *, const char __user *, size_t,
+								loff_t *);
+static unsigned int cbc_device_poll(struct file *file, poll_table *wait);
+static long cbc_device_ioctl(struct file *, unsigned int, unsigned long);
+
+static const struct file_operations cbc_dev_file_operations = {
+	.owner = THIS_MODULE,
+	.open = cbc_device_open,
+	.release = cbc_device_release,
+	.read = cbc_device_read,
+	.write = cbc_device_write,
+	.poll = cbc_device_poll,
+	.unlocked_ioctl = cbc_device_ioctl
+};
+
+struct cbc_device_manager {
+	struct cdev cdev;
+	struct cbc_device_data channels[CBC_CHANNEL_MAX_NUMBER];
+	struct mutex send_lock;
+	struct cbc_memory_pool *cbc_memory;
+};
+
+/* Currently, only one CBC per kernel supported.*/
+static struct cbc_device_manager cbc_device_mgr_configuration = {
+	.channels[CBC_CHANNEL_PMT].device_type =
+				CBC_DEVICE_TYPE_HIDDEN,
+	.channels[CBC_CHANNEL_PMT].device_name =
+				"cbc-pmt",
+
+	.channels[CBC_CHANNEL_LIFECYCLE].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_LIFECYCLE].device_name =
+				"cbc-lifecycle",
+
+	.channels[CBC_CHANNEL_SIGNALS].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_SIGNALS].device_name =
+				"cbc-signals",
+
+	.channels[CBC_CHANNEL_EARLY_SIGNALS].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_EARLY_SIGNALS].device_name =
+				"cbc-early-signals",
+
+	.channels[CBC_CHANNEL_DIAGNOSIS].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_DIAGNOSIS].device_name =
+				"cbc-diagnosis",
+
+	.channels[CBC_CHANNEL_DLT].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_DLT].device_name =
+				"cbc-dlt",
+
+	.channels[CBC_CHANNEL_LINDA].device_type =
+				CBC_DEVICE_TYPE_HIDDEN,
+	.channels[CBC_CHANNEL_LINDA].device_name =
+				"cbc-linda",
+
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_0].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_0].device_name =
+				"cbc-raw0",
+
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_1].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_1].device_name =
+				"cbc-raw1",
+
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_2].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_2].device_name =
+				"cbc-raw2",
+
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_3].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_3].device_name =
+				"cbc-raw3",
+
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_4].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_4].device_name =
+				"cbc-raw4",
+
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_5].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_5].device_name =
+				"cbc-raw5",
+
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_6].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_6].device_name =
+				"cbc-raw6",
+
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_7].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_7].device_name =
+				"cbc-raw7",
+
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_8].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_8].device_name =
+				"cbc-raw8",
+
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_9].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_9].device_name =
+				"cbc-raw9",
+
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_10].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_10].device_name =
+				"cbc-raw10",
+
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_11].device_type =
+				CBC_DEVICE_TYPE_DEFAULT,
+	.channels[CBC_CHANNEL_OEM_RAW_CHANNEL_11].device_name =
+				"cbc-raw11",
+
+	.channels[CBC_CHANNEL_DEBUG_OUT].device_type =
+				CBC_DEVICE_TYPE_DEBUG,
+	.channels[CBC_CHANNEL_DEBUG_OUT].device_name =
+				"cbc-debug-out",
+
+	.channels[CBC_CHANNEL_DEBUG_IN].device_type =
+				CBC_DEVICE_TYPE_DEBUG,
+	.channels[CBC_CHANNEL_DEBUG_IN].device_name =
+				"cbc-debug-in",
+};
+
+static struct cbc_mux_channel_configuration cbc_mux_config;
+
+/*
+ * priority_show - Retrieve device attribute priority.
+ * @dev: device (i.e /dev/cbc*)
+ * @attr: Priority attribute
+ * @buf:  Buffer to write to.
+ *
+ * Every channel (entry in /dev) has a priority.
+ * This can be set/read by a ioctl or in the sysfs.
+ */
+static ssize_t priority_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct cbc_device_data *chn_data =
+			(struct cbc_device_data *) dev_get_drvdata(dev);
+	int idx = chn_data - &cbc_device_mgr_configuration.channels[0];
+	int prio = cbc_mux_multiplexer_get_priority(idx);
+
+	pr_debug("cbc-core: read priority %i for channel: %i\n", prio, idx);
+	return scnprintf(buf, PAGE_SIZE, "%i\n", prio);
+}
+
+/*
+ * priority_store - Store device attribute priority.
+ * @dev: device (i.e /dev/cbc*)
+ * @attr: Priority attribute
+ * @buf:  Buffer to write to.
+ *
+ * Every channel (entry in /dev) has a priority.
+ * This can be set/read by a ioctl or in the sysfs.
+ */
+static ssize_t priority_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct cbc_device_data *chn_data =
+		(struct cbc_device_data *) dev_get_drvdata(dev);
+	int idx = chn_data - &cbc_device_mgr_configuration.channels[0];
+	u8 tmp = 0;
+	int res = kstrtou8(buf, 0, &tmp);
+
+	if ((res == 0) && (tmp < 8)) {
+		pr_debug("cbc-core: write priority %i to channel %i\n", tmp,
+									idx);
+		cbc_mux_multiplexer_set_priority(idx, tmp);
+	}
+	return count;
+}
+static DEVICE_ATTR_RW(priority);
+
+/*
+ * cbc_device_open - Open CBC char device. Implementation of .open.
+ * @inode:Pointer to inode object for this device.
+ * @file: Pointer to file object for this device.
+ *
+ * Return 0 if device opened successfully, Linux error code otherwise.
+ */
+static int cbc_device_open(struct inode *inode, struct file *file)
+{
+	struct cbc_device_data *device_data =
+			&cbc_device_mgr_configuration.channels[MINOR(
+					inode->i_rdev)];
+	int ret = 0;
+	u32 num_open_files = 0;
+	struct cbc_file_data *file_data = kmalloc(sizeof(struct cbc_file_data),
+								GFP_KERNEL);
+
+	if (!device_data)
+		ret = -EIO;
+
+	if (!file_data)
+		ret = -ENOMEM;
+
+	if (ret == 0) {
+		pr_debug("cbc_core: device_open: %d.%d %s\n",
+				MAJOR(inode->i_rdev), MINOR(inode->i_rdev),
+				device_data->device_name);
+
+		if (MINOR(inode->i_rdev) >= CBC_CHANNEL_MAX_NUMBER) {
+			pr_err("cbc-core: invalid cbc channel number.\n");
+			ret = -ENODEV;
+		}
+	}
+
+	if (ret == 0) {
+		struct list_head *tmp;
+
+		list_for_each(tmp, &device_data->open_files_head)
+			num_open_files++;
+
+		if (num_open_files > MAX_OPEN_FILES)
+			ret = -EBUSY;
+	}
+
+	if (ret == 0) {
+		cbc_file_init(file_data);
+		file_data->cbc_device = device_data;
+		list_add(&file_data->list, &device_data->open_files_head);
+		file->private_data = file_data;
+	} else {
+		kfree(file_data);
+	}
+
+	return ret;
+}
+
+/*
+ * cbc_device_release - Release char device. Implementation of .release
+ * @inode:Pointer to inode object for this device.
+ * @file: Pointer to file object for this device.
+ */
+static int cbc_device_release(struct inode *inode, struct file *file)
+{
+	u32 dev_idx = MINOR(inode->i_rdev);
+	struct cbc_file_data *file_data = file->private_data;
+
+	if (file_data) {
+		list_del(&file_data->list);
+
+		pr_debug("cbc-core: device_release: %d.%d %s\n",
+			MAJOR(inode->i_rdev), dev_idx,
+			file_data->cbc_device->device_name);
+
+		while (!cbc_file_queue_empty(file_data))
+			cbc_buffer_release(cbc_file_dequeue(file_data));
+
+		kfree(file_data);
+		file->private_data = NULL;
+	}
+	return 0;
+}
+
+/*
+ * cbc_device_read - CBC device read. Implementation of .read.
+ * @file: Pointer to file object for this device.
+ * @user_buffer: Pointer to buffer containing data to be read.
+ * @length:Length of buffer.
+ * @offset: Offset into buffer.
+ */
+static ssize_t cbc_device_read(struct file *file, char __user *user_buffer,
+						size_t length, loff_t *offset)
+{
+	struct cbc_file_data *f = (struct cbc_file_data *) file->private_data;
+	s32 ret = 0;
+
+	if (!f)
+		ret = -EIO;
+
+	if (ret == 0) {
+		while (cbc_file_queue_empty(f) && (ret == 0)) {
+			if (file->f_flags & O_NONBLOCK) {
+				ret = -EAGAIN;
+				return ret;
+			}
+			ret = wait_event_interruptible(f->wq_read,
+					!(cbc_file_queue_empty(f)));
+			if ((ret != 0) && (ret != -ERESTARTSYS)) {
+				/*
+				 * ERESTARTSYS happens when a file is polled
+				 * while shutting down the ldisc.
+				 * This is not an error.
+				 */
+				pr_err("cbc-core:  fifo_read: woke up with error %d.\n",
+					ret);
+				ret = -EIO;
+			}
+		}
+	}
+
+	if (ret == 0) {
+		if (!cbc_file_queue_empty(f)) {
+			struct cbc_buffer *cbc_buffer;
+
+			cbc_buffer = cbc_file_dequeue(f);
+
+			if (cbc_buffer) {
+				u32 offset = CBC_HEADER_SIZE;
+				u16 data_length = cbc_buffer->payload_length;
+
+				if (f->cbc_device->device_type ==
+						CBC_DEVICE_TYPE_RAW) {
+					offset = CBC_HEADER_SIZE +
+						CBC_RAWHEADER_SIZE;
+					data_length = data_length -
+						CBC_RAWHEADER_SIZE;
+				} else if (f->cbc_device->device_type ==
+						CBC_DEVICE_TYPE_DEBUG) {
+					offset = 0;
+					data_length = cbc_buffer->frame_length;
+				}
+
+				if (data_length <= length) {
+					ret =  copy_to_user(
+						(void __user *) user_buffer,
+						&cbc_buffer->data[offset],
+						data_length);
+					if (ret == 0) {
+						ret = data_length;
+					} else {
+						pr_err(
+						"cbc-core: device_read %u bytes copy to user failed.\n",
+						data_length);
+					}
+				} else {
+					pr_err(
+						"cbc-core: device_read, buffer too small for %u bytes.\n",
+						data_length);
+					ret = -EINVAL;
+				}
+				cbc_buffer_release(cbc_buffer);
+			} else {
+				pr_err("cbc-core: dequeued a null-buffer.\n");
+			}
+
+		} else {
+			pr_err("cbc-core: queue empty after response to wait.\n");
+		}
+
+	}
+	return ret;
+}
+
+/*
+ * cbc_device_write - Write data to char device. Implementation of .write.
+ * @file: Pointer to file object for this device.
+ * @user_buffer: Pointer to buffer containing data to be read.
+ * @length:Length of buffer.
+ * @offset: Offset into buffer.
+ */
+static ssize_t cbc_device_write(struct file *file,
+		const char __user *user_buffer, size_t length, loff_t *offset)
+{
+	int n = 0;
+	struct cbc_file_data *file_data =
+			(struct cbc_file_data *) file->private_data;
+	struct cbc_device_data *chn_data = file_data->cbc_device;
+
+	struct cbc_buffer *cbc_buffer = cbc_memory_pool_get_buffer(
+				cbc_device_mgr_configuration.cbc_memory);
+	int ret = 0;
+	u32 payload_offset = CBC_HEADER_SIZE;
+	u32 additional_header_size = 0;
+
+	u32 tmp = (u32) length;
+
+	if (!cbc_buffer) {
+		pr_err("cbc-core: Out of memory.\n");
+		ret = -ENOMEM;
+	}
+
+	if (ret == 0) {
+		if (chn_data == NULL) {
+			pr_err("cbc-core: Channel data is NULL.\n");
+			ret = -EINVAL;
+		}
+	}
+
+	if (ret == 0) {
+		if (chn_data->device_type == CBC_DEVICE_TYPE_RAW) {
+			payload_offset = CBC_HEADER_SIZE + CBC_RAWHEADER_SIZE;
+			additional_header_size = CBC_RAWHEADER_SIZE;
+		} else if (chn_data->device_type == CBC_DEVICE_TYPE_DEBUG) {
+			ret = -EINVAL; /* debug channels do not support write */
+		}
+	}
+
+	if (length + payload_offset > CBC_BUFFER_SIZE) {
+		pr_err(
+		"cbc-core: Device_write %u bytes not possible,maximum buffer size exceeded.\n",
+		 tmp);
+		ret = -EINVAL;
+	}
+
+	if (ret == 0) {
+		if (user_buffer == NULL) {
+			pr_err("cbc-core: Device_write buffer is NULL.\n");
+			ret = -EINVAL;
+		}
+	}
+
+	if (ret == 0) {
+		if (copy_from_user(&cbc_buffer->data[payload_offset],
+				(void __user *) user_buffer, length) == 0) {
+			int idx = chn_data -
+				&cbc_device_mgr_configuration.channels[0];
+
+			n = length;
+			cbc_buffer->payload_length = length +
+						additional_header_size;
+			cbc_manager_transmit_buffer(idx, cbc_buffer);
+		}
+	}
+
+	cbc_buffer_release(cbc_buffer);
+
+	if (ret == 0)
+		ret = n;
+	return ret;
+}
+
+/*
+ * cbc_mux_configure_data_channel - Configure the specified channel.
+ * @channel_idx: Channel identifier.
+ * @data: Data associated with this channel.
+ * @receive: Data receive function for this channel.
+ *
+ * Other kernel modules may wish to use the CBC line discipline.
+ * They can potentially define their own configurations for the CBC channels.
+ */
+void cbc_mux_configure_data_channel(u32 const channel_idx, const u8 priority,
+				void *data,
+				void (*receive)(void *data, const u16 length,
+				const u8 * const buffer))
+{
+	if (channel_idx < CBC_CHANNEL_MAX_NUMBER) {
+		struct cbc_mux_channel *list =
+			&cbc_mux_config.cbc_mux_channel_list[channel_idx];
+		list->data = data;
+		list->priority = priority;
+		list->buffer_receive = NULL;
+		list->data_receive = receive;
+	}
+}
+
+
+/*
+ * cbc_register_devices - Register the CBC channels as Linux character devices.
+ * @cbc_class: CBC device class.
+ * @memory: CBC memory pool allocated for CBC buffers.
+ *
+ * Return: 0 on success or Linux error code.
+ */
+int cbc_register_devices(struct class *cbc_class,
+			struct cbc_memory_pool *memory)
+{
+	int ret = 0;
+	int i;
+	dev_t devid;
+
+	struct cbc_device_manager *cbc = &cbc_device_mgr_configuration;
+
+	cbc->cbc_memory = memory;
+
+	/* Set up the devices after the line discipline is opened. */
+	if (major) {
+		devid = MKDEV(major, 0);
+		ret = register_chrdev_region(devid, CBC_CHANNEL_MAX_NUMBER,
+		DEVICE_NAME);
+	} else {
+		ret = alloc_chrdev_region(&devid, 0, CBC_CHANNEL_MAX_NUMBER,
+		DEVICE_NAME);
+		major = MAJOR(devid);
+	}
+
+	if (ret < 0)
+		pr_err("cbc-core: ldisc open register chrdev region failed.\n");
+
+	if (ret == 0) {
+		cdev_init(&cbc->cdev, &cbc_dev_file_operations);
+		cbc->cdev.owner = THIS_MODULE;
+		cbc->cdev.ops = &cbc_dev_file_operations;
+		ret = cdev_add(&cbc->cdev, MKDEV(major, CBC_MINOR),
+						CBC_CHANNEL_MAX_NUMBER);
+		if (ret < 0) {
+			unregister_chrdev_region(MKDEV(major, CBC_MINOR),
+						CBC_CHANNEL_MAX_NUMBER);
+			pr_err("cbc-core: ldisc open add cdev failed\n");
+		}
+	}
+
+	if (ret == 0) {
+		for (i = 0; i < CBC_CHANNEL_MAX_NUMBER; i++) {
+			cbc_device_init(&cbc->channels[i]);
+
+			if (cbc->channels[i].device_type !=
+					CBC_DEVICE_TYPE_HIDDEN) {
+				/*
+				 * Create the devices.
+				 * These will appear in /sys/class/cbc and
+				 * if udev is running, /dev
+				 */
+				cbc->channels[i].device = device_create(
+					cbc_class, NULL,
+					MKDEV(major, i), NULL,
+					cbc->channels[i].device_name,
+					i);
+
+				/* Add the attribute */
+				ret = device_create_file(
+					cbc->channels[i].device,
+					&dev_attr_priority);
+
+				/* Set private data to point to the fifo */
+				dev_set_drvdata(cbc->channels[i].device,
+							&cbc->channels[i]);
+			} else {
+				cbc->channels[i].device = NULL;
+			}
+		}
+	}
+
+	if (ret != 0)
+		cbc_unregister_devices(cbc_class);
+
+	return ret;
+}
+
+/*
+ * cbc_unregister_devices - Remove CBC devices.
+ * @cbc_class: CBC Device class.
+ *
+ * Remove CBC device files and unregisters chrdev region.
+ */
+void cbc_unregister_devices(struct class *cbc_class)
+{
+	int i;
+	struct cbc_device_manager *cbc = &cbc_device_mgr_configuration;
+
+	/* Remove the /dev/cbc* devices */
+	cdev_del(&cbc->cdev);
+
+	for (i = 0; i < CBC_CHANNEL_MAX_NUMBER; i++) {
+		if (cbc->channels[i].device != NULL) {
+			device_remove_file(cbc->channels[i].device,
+						&dev_attr_priority);
+			device_destroy(cbc_class, MKDEV(major, i));
+		}
+	}
+
+	/*
+	 * Also destroys all class attribute files,
+	 * because they are ref. counted.
+	 */
+	unregister_chrdev_region(MKDEV(major, CBC_MINOR),
+					CBC_CHANNEL_MAX_NUMBER);
+
+	cbc->cbc_memory = NULL;
+}
+
+/*
+ * cbc_manager_transmit_data - Transmit data on specified channel.
+ * @channel_idx: Channel identifier.
+ * @length: Length of data.
+ * @buffer: Pointer to data buffer.
+ *
+ * If a CBC buffer is available from the memory pool, and the channel
+ * is valid, the supplied data is copied into a CBC buffer and transmitted.
+ */
+void cbc_manager_transmit_data(const u32 channel_idx, const u16 length,
+						const u8 * const buffer)
+{
+	struct cbc_buffer *cbc_buffer = cbc_memory_pool_get_buffer(
+				cbc_device_mgr_configuration.cbc_memory);
+	struct cbc_device_data *chn_data;
+	u32 offset = CBC_HEADER_SIZE;
+	u32 copy_length = length;
+
+	if (channel_idx >= CBC_CHANNEL_MAX_NUMBER) {
+		pr_err("cbc_mux_transmit_data(): Invalid cbc channel idx.\n");
+		return;
+	}
+
+	chn_data = &cbc_device_mgr_configuration.channels[channel_idx];
+
+	if (!cbc_buffer)
+		return;
+
+	if (chn_data->device_type == CBC_DEVICE_TYPE_RAW)
+		offset = CBC_HEADER_SIZE + CBC_RAWHEADER_SIZE;
+
+	if (length + offset > CBC_MAX_TOTAL_FRAME_SIZE)
+		copy_length = CBC_MAX_TOTAL_FRAME_SIZE - offset;
+
+	memcpy(&cbc_buffer->data[offset], buffer, copy_length);
+
+	cbc_manager_transmit_buffer(channel_idx, cbc_buffer);
+	cbc_buffer_release(cbc_buffer);
+}
+
+/*
+ * cbc_manager_transmit_buffer - Transmits CBC buffer on specified channel.
+ * @channel_idx: Channel identifier.
+ * @buffer: CBC buffer to transmit.
+ */
+void cbc_manager_transmit_buffer(const u32 channel_idx,
+				struct cbc_buffer *buffer)
+{
+	if (channel_idx >= CBC_CHANNEL_MAX_NUMBER) {
+		pr_err("cbc_mux_transmit_data(): Invalid cbc channel idx.\n");
+	} else {
+		enum cbc_error res = CBC_OK;
+		struct cbc_device_data *chn_data =
+			&cbc_device_mgr_configuration.channels[channel_idx];
+
+		mutex_lock(&cbc_device_mgr_configuration.send_lock);
+
+		if (chn_data->device_type == CBC_DEVICE_TYPE_RAW) {
+			/*
+			 * Room for raw header is already reserved in buffer.
+			 * Calculate raw header data length without raw
+			 * header.
+			 */
+			u32 real_payload_size = buffer->payload_length -
+							CBC_RAWHEADER_SIZE;
+
+			buffer->data[CBC_HEADER_SIZE] =
+					CBC_RAW_CHANNEL_DIRECT_TRANSPORT;
+			buffer->data[CBC_HEADER_SIZE + 1] =
+					(u8) (real_payload_size & 0xFF);
+			buffer->data[CBC_HEADER_SIZE + 2] =
+					(u8) ((real_payload_size >> 8) & 0xFFU);
+		}
+
+		res = cbc_mux_multiplexer_transmit_buffer(channel_idx, buffer);
+		mutex_unlock(&cbc_device_mgr_configuration.send_lock);
+		if (res != CBC_OK)
+			pr_err("Error transmitting frame %u.\n", res);
+	}
+	/* Buffer is released in the calling cbc_device_write() */
+}
+
+/*
+ * cbc_device_poll - Set up polling based on current status of queue.
+ * @file: Handle to cbc_device_data.
+ * @wait: Pointer to poll_table.
+ *
+ * Return: Updated poll mask.
+ */
+static unsigned int cbc_device_poll(struct file *file, poll_table *wait)
+{
+	struct cbc_file_data *f = (struct cbc_file_data *) file->private_data;
+	unsigned int mask = 0;
+
+	poll_wait(file, &f->wq_read, wait);
+
+	if (!cbc_file_queue_empty(f))
+		mask |= (POLLIN | POLLRDNORM);
+
+	if (!(f->queue.read + CBC_QUEUE_LENGTH == f->queue.write))
+		mask |= (POLLOUT | POLLWRNORM);
+
+	return mask;
+}
+
+/*
+ * cbc_device_ioctl - Handle CBC channel ioctl call.
+ * @file: Handle to cbc_device_data.
+ * @cmd: ioctl command.
+ * @arg: argument associated with the command.
+ *
+ * The flag field and priority can get get/set for a CBC device (channel).
+ *
+ * Return: 0 if command successfully handled, Linux error otherwise.
+ */
+static long cbc_device_ioctl(struct file *file, unsigned int cmd,
+						unsigned long arg)
+{
+	int tmp;
+	struct cbc_file_data *file_data =
+			(struct cbc_file_data *) file->private_data;
+	struct cbc_device_data *chn_data = file_data->cbc_device;
+
+	int idx = chn_data - &cbc_device_mgr_configuration.channels[0];
+
+	switch (cmd) {
+	case CBC_PRIORITY_GET:
+		tmp = cbc_mux_multiplexer_get_priority(idx);
+		if (copy_to_user((void __user *) arg, &tmp, sizeof(tmp)))
+			return -EFAULT;
+		return 0;
+
+	case CBC_PRIORITY_SET:
+		if (copy_from_user(&tmp, (void __user *) arg, sizeof(tmp)))
+			return -EFAULT;
+		cbc_mux_multiplexer_set_priority(idx, tmp);
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+
+}
+
+/*
+ * get_default_priority - Get default priority for specified channel.
+ * @channel_id: channel identifier.
+ *
+ * Return: Priority for specified channel.
+ */
+static u8 get_default_priority(enum cbc_channel_enumeration channel_id)
+{
+	u8 result = 1;
+
+	switch (channel_id) {
+	case CBC_CHANNEL_PMT:
+	case CBC_CHANNEL_LIFECYCLE:
+	case CBC_CHANNEL_DLT:
+	case CBC_CHANNEL_LINDA:
+		result = 6;
+		break;
+
+	case CBC_CHANNEL_DIAGNOSIS:
+		result = 2;
+		break;
+
+	default:
+		result = 3;
+		break;
+	}
+	return result;
+}
+
+/*
+ * demuxed_receive - Handle a CBC buffer received over UART.
+ * @void_data: CBC device data.
+ * @cbc_buffer: CBC buffer received over UART.
+ *
+ * Checks if there is valid data. Determines the frame type and
+ * adds to buffer queue.
+ */
+static void demuxed_receive(void *void_data, struct cbc_buffer *cbc_buffer)
+{
+	struct cbc_device_data *device_data =
+			(struct cbc_device_data *) void_data;
+	struct list_head *current_item;
+	struct cbc_file_data *current_file_data;
+
+	if (device_data && cbc_buffer
+			&& cbc_buffer->frame_length >
+			CBC_HEADER_SIZE + CBC_CHECKSUM_SIZE) {
+		/* Payload_length includes raw_header */
+		u16 payload_length = cbc_buffer->frame_length -
+				(CBC_HEADER_SIZE + CBC_CHECKSUM_SIZE);
+
+		if (device_data->device_type == CBC_DEVICE_TYPE_RAW) {
+			if (cbc_buffer->frame_length >
+				(CBC_HEADER_SIZE + CBC_RAWHEADER_SIZE +
+						CBC_CHECKSUM_SIZE)) {
+				u16 raw_length;
+
+				raw_length = cbc_buffer->data[4];
+				raw_length |= (cbc_buffer->data[5] << 8);
+
+				if (raw_length + CBC_RAWHEADER_SIZE >
+							payload_length) {
+					pr_err(
+					"raw length (%i) is longer than payload length (%i)\n",
+					raw_length, payload_length);
+					/* Payload_length already set
+					 * to max value
+					 */
+				} else {
+					payload_length = raw_length +
+							CBC_RAWHEADER_SIZE;
+				}
+			} else {
+				pr_err("cbc-core: Frame to short for a raw frame\n");
+			}
+			cbc_buffer->payload_length = payload_length;
+		} else if (device_data->device_type ==
+						CBC_DEVICE_TYPE_DEFAULT) {
+			cbc_buffer->payload_length = payload_length;
+		}
+		/* else, do not touch payload_length in a debug-channel */
+
+		/* Enqueue */
+		for (current_item = device_data->open_files_head.next
+		; current_item != &device_data->open_files_head; current_item =
+							current_item->next) {
+
+			current_file_data = list_entry(current_item,
+					struct cbc_file_data, list);
+			/* File_enqueue increases ref. count. */
+			cbc_file_enqueue(current_file_data, cbc_buffer);
+		}
+	} else {
+		pr_err("cbc-core: (<- IOC) dev_receive data is null\n");
+	}
+}
+
+/*
+ * cbc_kmod_devices_init - Configure CBC multiplexer.
+ *
+ * Configures multiplexer channel list and configures the multiplexer using
+ * this list. Initialises mutex lock for multiplexer.
+ */
+void cbc_kmod_devices_init(void)
+{
+	/*
+	 * Set up the multiplexer channel list and use it to configure the
+	 * multiplexer.
+	 */
+	u32 i = 0;
+
+	for (; i < CBC_CHANNEL_MAX_NUMBER; i++) {
+		cbc_mux_config.cbc_mux_channel_list[i].buffer_receive =
+				demuxed_receive;
+		cbc_mux_config.cbc_mux_channel_list[i].data_receive = NULL;
+		cbc_mux_config.cbc_mux_channel_list[i].data =
+				&cbc_device_mgr_configuration.channels[i];
+		cbc_mux_config.cbc_mux_channel_list[i].priority =
+				get_default_priority(i);
+	}
+
+	cbc_mux_multiplexer_setup(&cbc_mux_config);
+	mutex_init(&cbc_device_mgr_configuration.send_lock);
+}
diff --git a/drivers/tty/cbc/cbc_device_manager.h b/drivers/tty/cbc/cbc_device_manager.h
new file mode 100644
index 000000000000..a6f9b45da1aa
--- /dev/null
+++ b/drivers/tty/cbc/cbc_device_manager.h
@@ -0,0 +1,66 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef CBC_DEVICE_MANAGER_H
+#define CBC_DEVICE_MANAGER_H
+
+#include "cbc_memory.h"
+
+#include <linux/types.h>
+#include <linux/device.h>
+
+void cbc_kmod_devices_init(void);
+
+int cbc_register_devices(struct class *cbc_class,
+					struct cbc_memory_pool *memory);
+
+void cbc_unregister_devices(struct class *cbc_class);
+
+/*
+ * cbc_mux_configure_data_channel - Configure channels
+ * @channel_idx: Channel identifier (see cbc_channel_enumeration)
+ * @priority: Priority for this channel
+ * @data: Channel data
+ * @receive: Receive data function associated with this channel.
+ * Channels can only be configured after cbc_kmod_devices_init().
+ * This will overwrite the settings for the devices.
+ * The device will be created anyway, to allow the cbc_socket_server to
+ * work without a requirement for handling missing devices.
+ */
+void cbc_mux_configure_data_channel(u32 const channel_idx, const u8 priority,
+				void *data,
+				void (*receive)(void *data, const u16 length,
+				const u8 * const buffer));
+
+/*
+ * cbc_manager_transmit_data - Transmit data to IOC.
+ * @channel_idx: Channel identifier (see cbc_channel_enumeration)
+ * @length: Length of data
+ * @buffer: The data
+ *
+ * This is the version provided as a kernel symbol.
+ */
+void cbc_manager_transmit_data(const u32 channel_idx, const u16 length,
+						const u8 * const buffer);
+
+/*
+ * cbc_manager_transmit_data - Transmit data to IOC.
+ * @channel_idx: Channel identifier (see cbc_channel_enumeration)
+ * @buffer: The data
+ *
+ * This is the internal version, without memcpy.
+ */
+void cbc_manager_transmit_buffer(const u32 channel_idx,
+	struct cbc_buffer *buffer);
+
+#endif /* CBC_DEVICE_MANAGER_H */
diff --git a/drivers/tty/cbc/cbc_link_checksum.c b/drivers/tty/cbc/cbc_link_checksum.c
new file mode 100644
index 000000000000..69f0ca74c3c8
--- /dev/null
+++ b/drivers/tty/cbc/cbc_link_checksum.c
@@ -0,0 +1,59 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include "cbc_types.h"
+#include "cbc_link_checksum.h"
+
+enum cbc_error cbc_checksum_calculate(u8 length,
+				u8 const * const payload_data, u8 *checksum)
+{
+	u8 result = 0; /* Holds result of calculation */
+	u8 counter = 0;
+
+	/* Parameter validation */
+	if (length == 0U)
+		return CBC_ERROR_PARAMETER_INCORRECT;
+
+	if ((payload_data == NULL) || (checksum == NULL))
+		return CBC_ERROR_NULL_POINTER_SUPPLIED;
+
+	/* Perform calculation */
+	do {
+		result += (u8) ((0x100 - *(payload_data + counter++)) & 0xFFU);
+	} while (counter != length);
+
+	*checksum = result;
+
+	return CBC_OK;
+}
+
+enum cbc_error cbc_checksum_check(u8 length, u8 const * const payload_data,
+					u8 checksum, u8 *expected_checksum)
+{
+	u8 calculated_checksum = 0U;
+	enum cbc_error result = CBC_OK;
+
+	enum cbc_error calc_result = cbc_checksum_calculate(length,
+				payload_data, &calculated_checksum);
+
+	if ((calc_result == CBC_OK) &&
+			(checksum == calculated_checksum))
+		result = CBC_OK;
+	else
+		result = CBC_ERROR_CHECKSUM_MISMATCH;
+
+	if (expected_checksum != NULL)
+		*expected_checksum = calculated_checksum;
+
+	return result;
+}
diff --git a/drivers/tty/cbc/cbc_link_checksum.h b/drivers/tty/cbc/cbc_link_checksum.h
new file mode 100644
index 000000000000..9f8f50f2cbd7
--- /dev/null
+++ b/drivers/tty/cbc/cbc_link_checksum.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _CBC_LINK_CHECKSUM_H_
+#define _CBC_LINK_CHECKSUM_H_
+
+#include "cbc_types.h"
+
+/*
+ * cbc_checksum_calculate - Calculate checksum.
+ * @length: data length
+ * @payload_data:The data buffer.
+ * @checksum: Pointer to checksum.
+ *
+ * Based on summation of inverted individual byte values.
+ *
+ * Return: cbc_error if checksum cannot be generated.
+ */
+
+enum cbc_error cbc_checksum_calculate(u8 length,
+				u8 const * const payload_data, u8 *checksum);
+
+/*
+ * Check checksum is valid for current data.
+ * @length: data length
+ * @payload_data: The data buffer.
+ * @checksum: Checksum value to check
+ * @expected_checksum: Expected checksum.
+ *
+ * Return: cbc_error if checksum is invalid.
+ */
+enum cbc_error cbc_checksum_check(u8 length, u8 const * const payload_data,
+					u8 checksum, u8 *expected_checksum);
+
+#endif /*_CBC_LINK_CHECKSUM_H_ */
diff --git a/drivers/tty/cbc/cbc_link_layer.c b/drivers/tty/cbc/cbc_link_layer.c
new file mode 100644
index 000000000000..a55cd8ce7add
--- /dev/null
+++ b/drivers/tty/cbc/cbc_link_layer.c
@@ -0,0 +1,484 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/circ_buf.h>
+#include <linux/mutex.h>
+
+#include "cbc_core_public.h"
+#include "cbc_link_checksum.h"
+#include "cbc_link_layer.h"
+#include "cbc_memory.h"
+#include "cbc_mux_multiplexer.h"
+
+#define CBC_MAX_RING_BUFFER_SIZE 256
+
+/*
+ * struct cbc_queue_control - Structure holding the queue control data.
+ * @next_element: Next element in received data buffer.
+ * @current_element: Current element in received data buffer.
+ *
+ * Handles the current (and next) position in the received data circular buffer.
+ */
+struct cbc_queue_control {
+	u8 next_element;
+	u8 current_element;
+};
+
+static struct cbc_memory_pool *memory_pool;
+
+static u8 rx_cvh_ring_message[CBC_MAX_RING_BUFFER_SIZE];
+static struct cbc_queue_control cvh_rx_queue_control;
+static u8 number_of_bytes_expected;
+static u8 number_of_bytes_skipped;
+static u8 ignore_all_skipped_bytes =			1;
+static u8 last_rx_frame_valid =					1;
+static u8 rx_sequence_counter;
+
+/* Transmitted data queue. */
+static struct cbc_buffer_queue tx_queue;
+static u8 tx_sequence_counter; /* Sequence counter value for next tx frame */
+static u8 cbc_frame_granularity;
+static struct mutex transmit_frame_mutex;
+
+static void cbc_link_layer_transmit_frame(void);
+static void cbc_link_release_rx_data(u8 bytes_to_free);
+
+/*
+ * calculate_total_frame_length - Calculates the total length of a frame.
+ * @buffer: Pointer to CBC buffer.
+ *
+ * Used for outgoing frames. Calculates the total length of a frame
+ * depending on its payload_length. Total length is stored in
+ * cbc_buffer->frame_length.
+ */
+static void calculate_total_frame_length(struct cbc_buffer *buffer);
+
+/*
+ * cbc_link_release_rx_data - Release the specified number of bytes from the
+ *			      internal rx buffer.
+ * @bytes_to_free: Number of bytes to be released.
+ */
+static void cbc_link_release_rx_data(u8 bytes_to_free)
+{
+	cvh_rx_queue_control.current_element += bytes_to_free;
+}
+
+static void calculate_total_frame_length(struct cbc_buffer *buffer)
+{
+	u8 frame_length_in_bytes;
+
+	if (!buffer)
+		return;
+
+	frame_length_in_bytes = buffer->payload_length + CBC_HEADER_SIZE +
+							CBC_CHECKSUM_SIZE;
+
+	/* Adjust frame_length to granularity */
+	if ((frame_length_in_bytes % cbc_frame_granularity) != 0)
+		frame_length_in_bytes += cbc_frame_granularity -
+					(frame_length_in_bytes %
+					cbc_frame_granularity);
+
+	buffer->frame_length = frame_length_in_bytes;
+}
+
+/*
+ * cbc_link_layer_transmit_frame - Transmits a frame over a UART.
+ */
+static void cbc_link_layer_transmit_frame(void)
+{
+	u8 total_len;
+	u8 checksum = 0U;
+	s32 mutex_lock_result = -1;
+	u32 frame_transmission_counter = CBC_MAX_FRAME_TRANSMISSION_NUMBER;
+	struct cbc_buffer *buffer = NULL;
+
+	mutex_lock_result = mutex_lock_interruptible(&transmit_frame_mutex);
+	if (mutex_lock_result != 0) {
+		pr_err("cbc-core: Could not lock the transmit_frame_mutex\n");
+		return;
+	}
+
+	/* If queue is not empty. */
+	if (tx_queue.read != tx_queue.write)
+		buffer = cbc_buffer_queue_dequeue(&tx_queue);
+
+	while (buffer && frame_transmission_counter) {
+		total_len = buffer->frame_length;
+		frame_transmission_counter--;
+
+		/* Reset sequence counter bits first */
+		buffer->data[1U] &= ~CBC_SEQUENCE_COUNTER_WIDTH_MASK;
+
+		/* Qdd sequence counter */
+		buffer->data[1U] |= tx_sequence_counter;
+
+		/*
+		 * Qdd checksum, subtract 1, as the checksum field
+		 * itself cannot be included in calculation
+		 */
+		cbc_checksum_calculate(total_len - 1U, buffer->data,
+						&checksum);
+		buffer->data[total_len - 1U] = checksum;
+
+		/* Try to send the frame */
+		if (target_specific_send_cbc_uart_data(total_len,
+				buffer->data) != CBC_OK) {
+			/* Not sent, release anyway */
+			pr_debug("cbc-core: Could not send packet.\n");
+
+		} else {
+			/*
+			 * Data was transmitted, so increase the
+			 * sequence counter for next frame
+			 */
+			tx_sequence_counter = (tx_sequence_counter + 1U)
+				& CBC_SEQUENCE_COUNTER_WIDTH_MASK;
+		} /* else */
+		cbc_buffer_release(buffer);
+		buffer = NULL;
+
+		/* If queue is not empty. */
+		if (tx_queue.read != tx_queue.write)
+			buffer = cbc_buffer_queue_dequeue(&tx_queue);
+	}
+
+	mutex_unlock(&transmit_frame_mutex);
+}
+
+/*
+ * cbc_link_layer_get_stored_serial_data - Get stored serial data.
+ * @out_buf:Pointer to buffer populated with serial data.
+ * @max_length: Maximum amount of data to be retrieved.
+ *
+ * Populates out_buf and returns number of bytes read. Stop reading if the
+ * maximum length is reached.
+ *
+ * Return: The amount of data read.
+ */
+static u8 cbc_link_layer_get_stored_serial_data(u8 *out_buf,
+						u8 const max_length)
+{
+	u8 index8 = 0;
+	u8 curr = cvh_rx_queue_control.current_element;
+	u8 next = cvh_rx_queue_control.next_element;
+
+	while (((curr + index8) & 0xFFU) != next) {
+		out_buf[index8] = rx_cvh_ring_message[(curr + index8) &	0xFFU];
+		index8++;
+		/* Avoid memory overflow of target array */
+		if (index8 >= max_length)
+			break;
+	}
+	return index8;
+}
+
+/*
+ * cbc_link_layer_set_frame_granularity - Set the CBC frame granularity.
+ * @granularity: Supported values are 4, 8, 16 and 32 bytes.
+ *
+ * Return: CBC error, OK or incorrect parameter (if invalid granularity
+ * supplied).
+ */
+enum cbc_error cbc_link_layer_set_frame_granularity(u8 granularity)
+{
+	if ((granularity == 4) || (granularity == 8) || (granularity == 16) ||
+							(granularity == 32U)) {
+		cbc_frame_granularity = granularity;
+		return CBC_OK;
+	} else {
+		return CBC_ERROR_PARAMETER_INCORRECT;
+	} /* else */
+}
+
+/*
+ * cbc_link_layer_init - Initialize link layer.
+ *
+ * This function shall be called once during startup.
+ * It shall be the first function of this file to be called.
+ */
+void cbc_link_layer_init(struct cbc_memory_pool *memory)
+{
+	cvh_rx_queue_control.next_element =		0;
+	cvh_rx_queue_control.current_element =	0;
+
+	memory_pool = memory;
+
+	number_of_bytes_expected =		0;
+	number_of_bytes_skipped =		0;
+	ignore_all_skipped_bytes =		1;
+	last_rx_frame_valid =			1;
+	rx_sequence_counter =			0;
+
+	cbc_buffer_queue_init(&tx_queue);
+	tx_sequence_counter =			0;
+
+	cbc_frame_granularity =			4;
+
+	mutex_init(&transmit_frame_mutex);
+}
+
+/*
+ * cbc_core_on_receive_cbc_serial_data - Called on reception of data on UART.
+ * @length: Maximum size of data to retrieve in one go.
+ * @rx_buf: Pointer to buffer to populate.
+ *
+ * This function is called on reception of serial data. It extracts single CBC
+ * frames from the received data. If incomplete frames are received, it waits
+ * for more data. Buffers are added to a circular buffer rx_cvh_ring_message.
+ *
+ * Return number of bytes retrieved.
+ */
+u8 cbc_core_on_receive_cbc_serial_data(u8 length, const u8 *rx_buf)
+{
+	u8 number_of_bytes_accepted =	0;
+	u8 next_try_element =		0;
+
+	while (length != 0) {
+		next_try_element =
+				(u8) ((cvh_rx_queue_control.next_element + 1U)
+						% CBC_MAX_RING_BUFFER_SIZE);
+		if (next_try_element != cvh_rx_queue_control.current_element) {
+			rx_cvh_ring_message[cvh_rx_queue_control.next_element] =
+								*rx_buf;
+
+			cvh_rx_queue_control.next_element = next_try_element;
+			rx_buf++; /* next byte */
+			length--;
+			number_of_bytes_accepted++;
+		} else {
+			/* Buffer is full, do not store additional bytes */
+			return number_of_bytes_accepted;
+		} /* else */
+	} /* while */
+	return number_of_bytes_accepted;
+}
+
+static void _cbc_link_layer_checksum(u8 *rx_cvh_frame, u8 frame_length)
+{
+	u8 expected_checksum = 0U;
+	u8 checksum = 0U;
+
+	checksum = rx_cvh_frame[frame_length - 1U];
+	/* Check checksum is valid. */
+	if (cbc_checksum_check(frame_length - 1U,
+				rx_cvh_frame, checksum,
+				&expected_checksum)
+				!= CBC_OK) {
+		pr_err("cbc-core: Received CBC frame contains an invalid checksum\n");
+		pr_err("cbc-core: found 0x%x expected 0x%x. frame discarded (length: %i), try to realign.\n",
+				checksum,
+				expected_checksum,
+				frame_length);
+		cbc_link_release_rx_data(1U);
+		number_of_bytes_skipped = 1;
+		last_rx_frame_valid = 0;
+	} else {
+		/* check the sequence counter */
+		if ((rx_cvh_frame[1]
+			& CBC_SEQUENCE_COUNTER_WIDTH_MASK)
+			!= rx_sequence_counter) {
+			pr_err("cbc-core: Found unexpected Rx sequence counter %i, expected %i\n",
+				rx_cvh_frame[1]
+				& 0x3,
+				rx_sequence_counter);
+
+			/*
+			 * Reset the sequence counter
+			 * to the received value.
+			 *
+			 */
+			rx_sequence_counter =
+			rx_cvh_frame[1]
+			& CBC_SEQUENCE_COUNTER_WIDTH_MASK;
+		}
+	}
+
+}
+
+/*
+ * cbc_link_layer_rx_handler - Process data received on UART.
+ *
+ * Processes received serial data and parses for complete frames
+ */
+void cbc_link_layer_rx_handler(void)
+{
+	u8 bytes_avail = 0U;
+	u8 service_layer_frame_length = 0U;
+	u8 frame_length = 0U;
+
+	struct cbc_buffer *buffer;
+	u8 *rx_cvh_frame;
+
+	buffer = cbc_memory_pool_get_buffer(memory_pool);
+
+	if (!buffer) {
+		pr_err("cbc-core: Out of memory.\n");
+		return;
+	}
+
+	bytes_avail = cbc_link_layer_get_stored_serial_data(
+					buffer->data, CBC_BUFFER_SIZE);
+	rx_cvh_frame = buffer->data;
+
+	/* Wait for at least one frame (minimum size) */
+	while ((bytes_avail >= 8U) &&
+				(bytes_avail >=	number_of_bytes_expected)) {
+		/* Check for start of frame */
+		if (rx_cvh_frame[0] == CBC_SOF) {
+			/* Log skipped bytes if necessary */
+			if (number_of_bytes_skipped > 0U) {
+				if (ignore_all_skipped_bytes == 0U)
+					pr_err("Skipped %d bytes.\n",
+						number_of_bytes_skipped);
+
+				number_of_bytes_skipped = 0U;
+				ignore_all_skipped_bytes = 1U;
+			}
+
+			service_layer_frame_length = (rx_cvh_frame[1] >>
+						CBC_FRAME_LENGTH_SHIFT) &
+						CBC_FRAME_LENGTH_WIDTH_MASK;
+
+			frame_length = (service_layer_frame_length + 2U) * 4U;
+
+			if (frame_length > CBC_MAX_TOTAL_FRAME_SIZE) {
+				pr_err("cbc: Received frame has illegal length (%u bytes).Frame discarded, try to realign.\n",
+					frame_length);
+				cbc_link_release_rx_data(1U);
+				number_of_bytes_skipped = 1U;
+				last_rx_frame_valid = 0U;
+			} else if (bytes_avail >= frame_length) {
+				/* ok */
+				_cbc_link_layer_checksum(rx_cvh_frame,
+							 frame_length);
+
+				/* Increment seq. counter. */
+				rx_sequence_counter++;
+				rx_sequence_counter &=
+				CBC_SEQUENCE_COUNTER_WIDTH_MASK;
+
+				/* Forward frame to Mux. layer. */
+				buffer->frame_length = frame_length;
+				cbc_mux_multiplexer_process_rx_buffer(
+							buffer);
+				cbc_link_release_rx_data(frame_length);
+
+					last_rx_frame_valid = 1;
+				 /* else */
+				number_of_bytes_expected = 0;
+			} else {
+				/*
+				 * Wait for missing bytes to arrive,
+				 * leave and try again.
+				 */
+				number_of_bytes_expected = frame_length;
+			} /* else */
+		} else {
+			if (!(last_rx_frame_valid && (rx_cvh_frame[0] ==
+						CBC_INTER_FRAME_FILL_BYTE)))
+				ignore_all_skipped_bytes = 0;
+
+			/*
+			 * No alignment found,
+			 * skip current byte and try next one.
+			 */
+			cbc_link_release_rx_data(1U);
+			number_of_bytes_expected = 0;
+			++number_of_bytes_skipped;
+		} /* else */
+
+		/* Process rx_buffer increases ref count,
+		 * so always release here.
+		 */
+		cbc_buffer_release(buffer);
+		buffer = cbc_memory_pool_get_buffer(memory_pool);
+
+		if (!buffer) {
+			pr_err("cbc-core: Out of memory.\n");
+			rx_cvh_frame = NULL;
+			return;
+		}
+		bytes_avail =
+				cbc_link_layer_get_stored_serial_data(
+				buffer->data, CBC_BUFFER_SIZE);
+		rx_cvh_frame = buffer->data;
+	} /* while */
+
+	cbc_buffer_release(buffer);
+
+}
+
+/*
+ * cbc_link_layer_tx_handler - Triggers pending data transmission.
+ */
+enum cbc_error cbc_link_layer_tx_handler(void)
+{
+	cbc_link_layer_transmit_frame();
+
+	return CBC_OK;
+}
+
+/*
+ * cbc_link_layer_assemble_buffer_for_transmission - Add frame to queue for
+ *						     transmission.
+ * @mux: CBC channel frame is associated with.
+ * @priority: Priority for frame.
+ * @buffer: Frame data.
+ *
+ * Generate a CBC frame from supplied data.
+ * Fills in CBC header details (adds start of frame identifier, frame length
+ * and channel. Also adds padding. Buffer is added to queue and transmission
+ * is triggered.
+ *
+ * Return CBC error code (CBC_OK if frame assembled successfully).
+ */
+enum cbc_error cbc_link_layer_assemble_buffer_for_transmission(u8 mux,
+				u8 priority, struct cbc_buffer *buffer)
+{
+	u8 frame_length_in_bytes;
+	enum cbc_error result = CBC_OK;
+	u32 i;
+
+	if (!buffer)
+		return CBC_ERROR_NULL_POINTER_SUPPLIED;
+
+	calculate_total_frame_length(buffer);
+	frame_length_in_bytes = buffer->frame_length;
+
+	/* Fill in padding */
+	for (i = buffer->payload_length + CBC_HEADER_SIZE;
+				i < frame_length_in_bytes; i++)
+		buffer->data[i] = 0xFF;
+
+	/* Fill in cbc header. */
+	buffer->data[0] = CBC_SOF; /* set start of frame byte */
+	buffer->data[1] = ((((frame_length_in_bytes - 4U - 1U) / 4U) &
+					CBC_FRAME_LENGTH_WIDTH_MASK) <<
+					CBC_FRAME_LENGTH_SHIFT);
+	buffer->data[2] = ((mux & CBC_MULTIPLEXER_WIDTH_MASK) <<
+					CBC_MULTIPLEXER_SHIFT) |
+					(priority & CBC_PRIORITY_WIDTH_MASK);
+
+	/*
+	 * If transmission is done in a different thread,
+	 * check for queue full first.
+	 */
+	cbc_buffer_queue_enqueue(&tx_queue, buffer);
+	cbc_buffer_increment_ref(buffer);
+
+	/* Trigger transmission */
+	cbc_link_layer_transmit_frame();
+
+	return result;
+}
diff --git a/drivers/tty/cbc/cbc_link_layer.h b/drivers/tty/cbc/cbc_link_layer.h
new file mode 100644
index 000000000000..ba70a99b04e6
--- /dev/null
+++ b/drivers/tty/cbc/cbc_link_layer.h
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef CBC_LINK_LAYER_H_
+#define CBC_LINK_LAYER_H_
+
+#include "cbc_types.h"
+#include "cbc_memory.h"
+
+void cbc_link_layer_init(struct cbc_memory_pool *memory);
+
+enum cbc_error cbc_link_layer_set_frame_granularity(u8 granularity);
+
+enum cbc_error cbc_link_layer_tx_handler(void);
+
+void cbc_link_layer_rx_handler(void);
+
+u8 cbc_core_on_receive_cbc_serial_data(u8 length, const u8 *rx_buf);
+
+enum cbc_error cbc_link_layer_assemble_frame_for_transmission(u8 mux,
+				u8 priority, u8 service_frame_length,
+				u8 const * const raw_buffer);
+
+enum cbc_error cbc_link_layer_assemble_buffer_for_transmission(u8 mux,
+			u8 priority, struct cbc_buffer *buffer);
+
+#endif /*CBC_LINK_LAYER_H_ */
+
diff --git a/drivers/tty/cbc/cbc_memory.c b/drivers/tty/cbc/cbc_memory.c
new file mode 100644
index 000000000000..69cf65e8901a
--- /dev/null
+++ b/drivers/tty/cbc/cbc_memory.c
@@ -0,0 +1,153 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/slab.h>
+
+#include "cbc_memory.h"
+
+bool cbc_memory_pool_try_free(struct cbc_memory_pool *pool)
+{
+	u32 i = 0;
+	bool allfree = true;
+	int tmp;
+
+	if (!pool)
+		return 0;
+
+	mutex_lock(&pool->lock);
+
+	for (i = 0; i < (pool->num_blocks); i++) {
+		tmp = atomic_read(&pool->pool[i].refcount);
+		if (tmp > 0) {
+			pr_err("Buffer %i was not freed. (%i refs)\n",
+								i, tmp);
+			allfree = false;
+		}
+	}
+
+	mutex_unlock(&pool->lock);
+
+	if (allfree)
+		kfree(pool);
+
+	return allfree;
+}
+
+struct cbc_memory_pool *cbc_memory_pool_create(const u16 num_blocks)
+{
+	size_t size;
+	struct cbc_memory_pool *new_pool;
+	u32 i = 0;
+
+	/* Check we have a valid queue length before we go any further. */
+	BUILD_BUG_ON(CBC_QUEUE_LENGTH & (CBC_QUEUE_LENGTH - 1));
+
+	size = sizeof(struct cbc_memory_pool)
+		+ (sizeof(struct cbc_buffer) * num_blocks);
+
+	new_pool = kmalloc(size, GFP_KERNEL);
+	new_pool->num_blocks = num_blocks;
+	mutex_init(&new_pool->lock);
+
+	for (i = 0; i < num_blocks; i++)
+		atomic_set(&new_pool->pool[i].refcount, 0);
+
+	return new_pool;
+}
+
+struct cbc_buffer *cbc_memory_pool_get_buffer(struct cbc_memory_pool *pool)
+{
+	u32 i = 0;
+	struct cbc_buffer *buffer = NULL;
+	int tmp;
+
+	if (pool) {
+		mutex_lock(&pool->lock);
+
+		for (; i < pool->num_blocks; i++) {
+			tmp = atomic_read(&pool->pool[i].refcount);
+			if (tmp == 0) {
+				atomic_inc_and_test(&pool->pool[i].refcount);
+				buffer = &pool->pool[i];
+				buffer->payload_length = 0;
+				buffer->frame_length = 0;
+				break;
+			}
+		}
+		mutex_unlock(&pool->lock);
+	}
+	return buffer;
+}
+
+void cbc_buffer_release(struct cbc_buffer *buffer)
+{
+	int tmp;
+
+	if (!buffer)
+		return;
+
+	atomic_read(&buffer->refcount);
+
+	tmp = atomic_dec_return(&buffer->refcount);
+	if (tmp == 0)
+		memset(buffer->data, 0xCD, CBC_BUFFER_SIZE);
+
+}
+
+void cbc_buffer_increment_ref(struct cbc_buffer *buffer)
+{
+	if (buffer)
+		atomic_inc(&buffer->refcount);
+}
+
+void cbc_buffer_queue_init(struct cbc_buffer_queue *queue)
+{
+	queue->write = 0;
+	queue->read = 0;
+}
+
+int cbc_buffer_queue_enqueue(struct cbc_buffer_queue *queue,
+				struct cbc_buffer *buffer)
+{
+	if (!queue || !buffer)
+		return 0;
+
+	if (queue->read + CBC_QUEUE_LENGTH == queue->write) {
+		pr_err("cbc buffer queue full\n");
+		return 0;
+	}
+
+	queue->queue[queue->write & CBC_QUEUE_BM] = buffer;
+	queue->write++;
+	return 1;
+}
+
+struct cbc_buffer *cbc_buffer_queue_dequeue(struct cbc_buffer_queue *queue)
+{
+	struct cbc_buffer *buffer = NULL;
+
+	if (!queue)
+		return buffer;
+
+	if (queue->read == queue->write) {
+		pr_err("cbc buffer queue: dequeue while empty.\n");
+		return buffer;
+	}
+
+	buffer = queue->queue[queue->read & CBC_QUEUE_BM];
+	queue->queue[queue->read & CBC_QUEUE_BM] = NULL;
+	queue->read++;
+
+	return buffer;
+}
+
diff --git a/drivers/tty/cbc/cbc_memory.h b/drivers/tty/cbc/cbc_memory.h
new file mode 100644
index 000000000000..d6e34fcd48ca
--- /dev/null
+++ b/drivers/tty/cbc/cbc_memory.h
@@ -0,0 +1,146 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef CBC_MEMORY_H_
+#define CBC_MEMORY_H_
+
+#include <linux/kernel.h>
+#include <linux/atomic.h>
+#include <linux/mutex.h>
+
+#include "cbc_types.h"
+
+#define CBC_BUFFER_SIZE CBC_MAX_TOTAL_FRAME_SIZE
+
+/*
+ * struct cbc_buffer - Represents a single CBC frame buffer.
+ * @frame_length: Total length  including headers and checksum.
+ * @payload_length: Length of payload without fill-bytes, including raw-
+ *			header if present.
+ * @refcount: Reference count incremented/decremented when queuing
+ *	de-queueing the buffer.
+ * @data: Contents of buffer.
+ */
+struct cbc_buffer {
+	u16 frame_length;
+	u16 payload_length;
+	atomic_t refcount;
+	u8 data[CBC_BUFFER_SIZE];
+};
+
+/*
+ * struct cbc_memory_pool - Memory pool for cbc_buffer.
+ * @num_blocks: Number of blocks allocated (CBC queue length * maximum number of
+ *		channels.
+ * lock:	Mutex to lock memory operations.
+ * pool:	The actual pool of CBC buffers.
+ *
+ * The cbc_memory_pool holds a number of cbc_buffers with reference counting.
+ */
+struct cbc_memory_pool {
+	u16 num_blocks;
+	struct mutex lock;
+	struct cbc_buffer pool[0];
+};
+
+/* CBC queue length has to be a power of 2 */
+#define CBC_QUEUE_LENGTH 16
+#define CBC_QUEUE_BM (CBC_QUEUE_LENGTH - 1)
+
+/*
+ * cbc_buffer_queue - Circular buffer for cbc_buffer pointers.
+ * @queue:	The queue of CBC buffer pointers.
+ * @write:	Head of queue.
+ * @read:	Tail of queue.
+ *
+ * Reference count handling is not done by this queue.
+ */
+struct cbc_buffer_queue {
+	struct cbc_buffer *queue[CBC_QUEUE_LENGTH];
+	u8 write;
+	u8 read;
+};
+
+/* cbc_memory_pool_create - Create memory pool of CBC buffers.
+ * @num_blocks: Size of memory pool to create (based on queue size and number
+ *			maximum of channels).
+ *
+ * Use kmalloc to create a new cbc_memory_pool with given number of cbc_buffers.
+ */
+struct cbc_memory_pool *cbc_memory_pool_create(const u16 num_blocks);
+
+/*
+ * cbc_memory_pool_try_free - Frees the pool if no buffer is in use.
+ * @pool: Pointer to memory pool.
+ *
+ * Ensure no new buffers are requested while calling this.
+ *
+ * Return: True if pool has been freed, false if not.
+ */
+bool cbc_memory_pool_try_free(struct cbc_memory_pool *pool);
+
+/*
+ * cbc_memory_pool_get_buffer - Returns a free CBC buffer if available.
+ * @pool: Pointer to memory pool.
+ *
+ * Return: Pointer to buffer is one is available, null otherwise.
+ */
+struct cbc_buffer *cbc_memory_pool_get_buffer(struct cbc_memory_pool *pool);
+
+/*
+ * cbc_buffer_release - Release CBC buffer (if not is use elsewhere).
+ * @buffer: Buffer to release.
+ *
+ * Decreases the reference count. A reference count of 0 marks this buffer as
+ * free.
+ */
+void cbc_buffer_release(struct cbc_buffer *buffer);
+
+/*
+ * cbc_buffer_increment_ref - Increases the reference count for a CBC buffer.
+ * @buffer: Buffer to increment ref count for.
+ */
+void cbc_buffer_increment_ref(struct cbc_buffer *buffer);
+
+/*
+ * cbc_buffer_queue_init - Initializes a cbc_buffer_queue.
+ * @queue: CBC buffer queue to initialise.
+ *
+ * Initialises head and tail.
+ */
+void cbc_buffer_queue_init(struct cbc_buffer_queue *queue);
+
+/*
+ * cbc_buffer_queue_enqueue - Add CBC buffer to a queue.
+ * @queue:	CBC buffer queue.
+ * @buffer:	Buffer to add.
+ *
+ * Enqueues a buffer into the queue. If the queue is full,
+ * the buffer will not be enqueued without any error.
+ * does not do reference count handling.
+ */
+int cbc_buffer_queue_enqueue(struct cbc_buffer_queue *queue,
+				struct cbc_buffer *buffer);
+
+/*
+ * cbc_buffer_queue_dequeue - Remove buffer from queue if not in use
+ *					  elsewhere.
+ * @queue:	CBC buffer queue
+ * @buffer:	Buffer to dequeue
+ *
+ * Dequeues a buffer. If queue is empty, null is returned.
+ * Does not do reference count handling
+ */
+struct cbc_buffer *cbc_buffer_queue_dequeue(struct cbc_buffer_queue *queue);
+
+#endif /* CBC_DEVICE_H_ */
diff --git a/drivers/tty/cbc/cbc_mux_multiplexer.c b/drivers/tty/cbc/cbc_mux_multiplexer.c
new file mode 100644
index 000000000000..4439e34f5142
--- /dev/null
+++ b/drivers/tty/cbc/cbc_mux_multiplexer.c
@@ -0,0 +1,145 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include "cbc_link_layer.h"
+#include "cbc_mux_multiplexer.h"
+
+static struct cbc_mux_channel_configuration *cbc_mux_configuration;
+
+void cbc_mux_multiplexer_setup(struct cbc_mux_channel_configuration *config)
+{
+	cbc_mux_configuration = config;
+}
+
+/*
+ * cbc_mux_multiplexer_process_rx_buffer - Processes a received buffer.
+ * @cbc_buffer: CBC buffer to process.
+ *
+ * If the frame is valid, and the channel is valid, the contents of the CBC
+ * buffer are passed to the channel's receive function.
+ */
+void cbc_mux_multiplexer_process_rx_buffer(struct cbc_buffer *cbc_buffer)
+{
+	u8 mux_idx = 0U;
+	struct cbc_mux_channel_configuration *config;
+
+	config = cbc_mux_configuration;
+	if (!cbc_buffer || cbc_buffer->frame_length < CBC_HEADER_SIZE)
+		return;
+
+	mux_idx = (u8) ((cbc_buffer->data[2] >> CBC_MULTIPLEXER_SHIFT)
+				& CBC_MULTIPLEXER_WIDTH_MASK) & 0xFFU;
+
+	if (config) {
+		struct cbc_mux_channel *channel;
+
+		channel = &config->cbc_mux_channel_list[mux_idx];
+
+		if (channel) {
+			if (channel->buffer_receive) {
+				channel->buffer_receive(channel->data,
+						cbc_buffer);
+			} else if (channel->data_receive) {
+				channel->data_receive(channel->data,
+					cbc_buffer->payload_length,
+					&cbc_buffer->data[CBC_HEADER_SIZE]);
+				cbc_buffer_release(cbc_buffer);
+			}
+		}
+
+		/* Send to debug device */
+		channel = &config->cbc_mux_channel_list[CBC_CHANNEL_DEBUG_IN];
+		if (channel && channel->buffer_receive)
+			channel->buffer_receive(channel->data, cbc_buffer);
+	}
+}
+
+/*
+ * cbc_mux_multiplexer_transmit_buffer - Send a buffer.
+ * @channel_idx: Channel identifier.
+ * @buffer: CBC buffer to transmit.
+ *
+ * Assembles CBC buffer for transmission.
+ *
+ * Return: CBC Error.
+ */
+enum cbc_error cbc_mux_multiplexer_transmit_buffer(
+			enum cbc_channel_enumeration channel_idx,
+			struct cbc_buffer *cbc_buffer)
+{
+	enum cbc_error result = CBC_OK;
+	struct cbc_mux_channel *channel;
+	struct cbc_mux_channel_configuration *config;
+
+	config = cbc_mux_configuration;
+
+	/*
+	 * Transmit will release the buffer, make sure a reference is held.
+	 * until it is enqueued in the debug device.
+	 */
+	cbc_buffer_increment_ref(cbc_buffer);
+
+	if (config) {
+		cbc_link_layer_assemble_buffer_for_transmission(
+			(u8) channel_idx,
+			config->cbc_mux_channel_list[channel_idx].priority,
+			cbc_buffer);
+
+		/* Send to debug device */
+		channel = &config->cbc_mux_channel_list[CBC_CHANNEL_DEBUG_OUT];
+		if (channel && channel->buffer_receive)
+			channel->buffer_receive(channel->data, cbc_buffer);
+	}
+
+	/* Send to debug device */
+	channel = &config->cbc_mux_channel_list[CBC_CHANNEL_DEBUG_OUT];
+	if (channel && channel->buffer_receive)
+		channel->buffer_receive(channel->data, cbc_buffer);
+
+	cbc_buffer_release(cbc_buffer);
+
+	return result;
+}
+
+/*
+ * cbc_mux_multiplexer_set_priority - Set priority for specified channel.
+ *						   multiplexer.
+ * @channel_num: Channel ID.
+ * @new_priority: UNew priority value.
+ */
+
+void cbc_mux_multiplexer_set_priority(u32 channel_num, u8 new_priority)
+{
+	struct cbc_mux_channel_configuration *config;
+
+	config = cbc_mux_configuration;
+	if (config && (channel_num < CBC_CHANNEL_MAX_NUMBER))
+		config->cbc_mux_channel_list[channel_num].priority =
+								new_priority;
+}
+
+/*
+ * cbc_mux_multiplexer_get_priority - Get priority for specified channel.
+ * @channel_num: Channel ID.
+ *
+ * Return: Priority for this channel.
+ */
+u8 cbc_mux_multiplexer_get_priority(u32 channel_num)
+{
+	struct cbc_mux_channel_configuration *config;
+
+	config = cbc_mux_configuration;
+	if (config && (channel_num < CBC_CHANNEL_MAX_NUMBER))
+		return config->cbc_mux_channel_list[channel_num].priority;
+	return 0;
+}
diff --git a/drivers/tty/cbc/cbc_mux_multiplexer.h b/drivers/tty/cbc/cbc_mux_multiplexer.h
new file mode 100644
index 000000000000..aa24777d6a13
--- /dev/null
+++ b/drivers/tty/cbc/cbc_mux_multiplexer.h
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef CBC_MUX_MULTIPLEXER_H_
+#define CBC_MUX_MULTIPLEXER_H_
+
+#include "cbc_types.h"
+#include "cbc_memory.h"
+
+struct cbc_mux_channel {
+	void (*buffer_receive)(void *data, struct cbc_buffer *cbc_buffer);
+	void (*data_receive)(void *data, const u16 length,
+					const u8 * const buffer);
+	void *data;
+	u8 priority;
+};
+
+/*
+ * Channel configuration struct.
+ *
+ * Priorities can be set via ioctl or in sysfs.
+ * Recommended values for the priorities:
+ *	   - CBC_CHANNEL_PMT: 6
+ *	   - CBC_CHANNEL_SYSTEM_CONTROL: 6
+ *	   - CBC_CHANNEL_PROCESS_DATA: 3
+ *	   - CBC_CHANNEL_DIAGNOSTICS: 3
+ *	   - CBC_CHANNEL_SW_TRANSFER: 2
+ *	   - CBC_CHANNEL_DEBUG: 6
+ *	   - CBC_CHANNEL_LINDA: 6
+ *	   - default: 3
+ *
+ */
+struct cbc_mux_channel_configuration {
+	struct cbc_mux_channel cbc_mux_channel_list[CBC_CHANNEL_MAX_NUMBER];
+};
+
+/* Pass configuration to Multiplexer. */
+void cbc_mux_multiplexer_setup(struct cbc_mux_channel_configuration *config);
+
+/* Process buffer received over UARYT via link layer. */
+void cbc_mux_multiplexer_process_rx_buffer(struct cbc_buffer *cbc_buffer);
+
+enum cbc_error cbc_mux_multiplexer_transmit_buffer(
+					enum cbc_channel_enumeration channel,
+					struct cbc_buffer *cbc_buffer);
+
+void cbc_mux_multiplexer_set_priority(u32 channel_num, u8 new_priority);
+
+u8 cbc_mux_multiplexer_get_priority(u32 channel_num);
+
+#endif /*CBC_MUX_MULTIPLEXER_H_ */
+
diff --git a/drivers/tty/cbc/cbc_types.h b/drivers/tty/cbc/cbc_types.h
new file mode 100644
index 000000000000..28d6877ff36e
--- /dev/null
+++ b/drivers/tty/cbc/cbc_types.h
@@ -0,0 +1,137 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef CBC_TYPES_H_
+#define CBC_TYPES_H_
+
+#include <linux/types.h>
+
+
+/* Start of frame indicator. */
+#define CBC_SOF						0x05
+/* Fill byte allowed between CBC frames */
+#define CBC_INTER_FRAME_FILL_BYTE			0xFF
+
+/*Width bit mask for priority in Mux. layer */
+#define CBC_PRIORITY_WIDTH_MASK				GENMASK(2, 0)
+/* Width bit mask for multiplexer in Mux layer */
+#define CBC_MULTIPLEXER_WIDTH_MASK			GENMASK(4, 0)
+/* Shift multiplexer in Mux layer */
+#define CBC_MULTIPLEXER_SHIFT				0x03
+
+/* Width bit mask for sequence counter in link layer */
+#define CBC_SEQUENCE_COUNTER_WIDTH_MASK			GENMASK(1, 0)
+/* Width bit mask for frame length link layer */
+#define CBC_FRAME_LENGTH_WIDTH_MASK				GENMASK(4, 0)
+/* Maximum possible frame size that can be specified
+ * with the IAS_CBC_FRAME_LENGTH_WIDTH_MASK
+ */
+#define CBC_MAX_POSSIBLE_FRAME_SIZE ((CBC_FRAME_LENGTH_WIDTH_MASK + 2) * 4)
+/* Frame shift length in link layer */
+#define CBC_FRAME_LENGTH_SHIFT				0x02
+
+#define CBC_HEADER_SIZE						0x03
+#define CBC_RAWHEADER_SIZE					0x03
+#define CBC_CHECKSUM_SIZE					1
+
+/*
+ * Maximum size of a CBC frame. This includes the
+ * IAS_CBC_MAX_SERVICE_FRAME_SIZE, 4 bytes of CBC protocol
+ * overhead and up to 28 additional bytes for padding to
+ * 32 byte granularity.
+ */
+#define CBC_MAX_TOTAL_FRAME_SIZE			96
+
+/* Enumeration of supported CBC channels */
+enum cbc_channel_enumeration {
+	CBC_CHANNEL_PMT =						0,
+	CBC_CHANNEL_LIFECYCLE =					1,
+	CBC_CHANNEL_SIGNALS =					2,
+	CBC_CHANNEL_EARLY_SIGNALS =				3,
+	CBC_CHANNEL_DIAGNOSIS =					4,
+	CBC_CHANNEL_DLT =						5,
+	CBC_CHANNEL_LINDA =						6,
+	CBC_CHANNEL_OEM_RAW_CHANNEL_0 =			7,
+	CBC_CHANNEL_OEM_RAW_CHANNEL_1 =			8,
+	CBC_CHANNEL_OEM_RAW_CHANNEL_2 =			9,
+	CBC_CHANNEL_OEM_RAW_CHANNEL_3 =			10,
+	CBC_CHANNEL_OEM_RAW_CHANNEL_4 =			11,
+	CBC_CHANNEL_OEM_RAW_CHANNEL_5 =			12,
+	CBC_CHANNEL_OEM_RAW_CHANNEL_6 =			13,
+	CBC_CHANNEL_OEM_RAW_CHANNEL_7 =			14,
+	CBC_CHANNEL_OEM_RAW_CHANNEL_8 =			15,
+	CBC_CHANNEL_OEM_RAW_CHANNEL_9 =			16,
+	CBC_CHANNEL_OEM_RAW_CHANNEL_10 =		17,
+	CBC_CHANNEL_OEM_RAW_CHANNEL_11 =		18,
+	CBC_CHANNEL_DEBUG_OUT =					19,
+	CBC_CHANNEL_DEBUG_IN =					20,
+	CBC_CHANNEL_MAX_NUMBER =				21
+};
+
+/*
+ * CBC load monitoring (transmit/receive throughput, errors etc.) can
+ * be compiled in using the following define.
+ */
+
+/* Enumeration containing available errors */
+enum cbc_error {
+	CBC_OK =							0,
+	CBC_ERROR_QUEUE_UNINITIALIZED =			1,
+	CBC_ERROR_QUEUE_FULL =					2,
+	CBC_ERROR_QUEUE_EMPTY =					3,
+	CBC_ERROR_PARAMETER_INCORRECT =			4,
+	CBC_ERROR_NULL_POINTER_SUPPLIED =		5,
+	CBC_ERROR_CHECKSUM_MISMATCH =			6,
+	CBC_ERROR_UNKNOWN_CHANNEL =				7,
+	CBC_ERROR_OUT_OF_QUEUE_MEMORY =			8,
+	CBC_ERROR_NO_DATA_IN_QUEUE_MEMORY =		9,
+	CBC_ERROR_NOT_PROCESSED =				10,
+	CBC_ERROR_TP_FRAME_NOT_SUPPORTED =		11,
+	CBC_ERROR_TP_FRAME_NOT_EXPECTED =		12,
+	CBC_ERROR_BUSY_TRY_AGAIN =				13,
+	CBC_ERROR_TEC =							14,
+	CBC_ERROR_UNKNOWN_PERIPHERAL_ID =		15,
+	CBC_ERROR_HW_NO_WRITE_ACCESS =			16,
+	CBC_ERROR_HW_NO_READ_ACCESS =			17,
+	CBC_ERROR_NOT_IMPLEMENTED =				18,
+	CBC_ERROR_GENERAL_ERROR =				19,
+	CBC_ERROR_UDP_GET_ADR =					20,
+	CBC_ERROR_UDP_OPEN_SOCKET =				21,
+	CBC_ERROR_UDP_CONNECTION_REFUSED =		22,
+	CBC_ERROR_UDP_CLOSE_INVALID_ID =		23,
+	CBC_ERROR_UDP_CLOSE_ERR =				24,
+	CBC_ERROR_DTC_LIST_EMPTY =				25,
+	CBC_ERROR_INCORRECT_VERSION =			26,
+	CBC_ERROR_POWER_SUPPLY_ERROR =			27,
+	CBC_ERROR_PARAMETER_INVALID =			28,
+	E_CBC_ERROR_NOT_INITIALIZED =			29,
+	CBC_ERROR_NUMBER_OF_ERRORS =			30,
+	CBC_ERROR_CUSTOMER_IMPLEMENTATION_MISSING =		31
+};
+
+/*
+ * Maximum number of CBC frames transmitted in each cyclic call of the CBC
+ * core.
+ */
+#	define CBC_MAX_FRAME_TRANSMISSION_NUMBER			50
+
+/*
+ * Enumeration indicating whether raw channel uses protocol or handles raw
+ * data.
+ */
+enum cbc_service_raw_channel_svc {
+	CBC_RAW_CHANNEL_USE_TRANSPORT_PROTOCOL =		1,
+	CBC_RAW_CHANNEL_DIRECT_TRANSPORT =				2
+}
+;
+#endif /* CBC_TYPES_H_ */
diff --git a/include/cbc/cbc-core.h b/include/cbc/cbc-core.h
new file mode 100644
index 000000000000..4bcdf52d84eb
--- /dev/null
+++ b/include/cbc/cbc-core.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _UAPI_CBC_CORE_H_
+#define _UAPI_CBC_CORE_H_
+
+#include <linux/ioctl.h>
+
+/* Get/set the priority of this channel */
+#define CBC_PRIORITY_GET _IOR(CBC_IOCTL_MAGIC, 2, int)
+#define CBC_PRIORITY_SET _IOW(CBC_IOCTL_MAGIC, 3, int)
+
+
+#endif /* CBC_CORE_MOD_H_ */
diff --git a/include/uapi/linux/cbc/cbc-core.h b/include/uapi/linux/cbc/cbc-core.h
new file mode 100644
index 000000000000..4bcdf52d84eb
--- /dev/null
+++ b/include/uapi/linux/cbc/cbc-core.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * CBC line discipline kernel module.
+ * Handles Carrier Board Communications (CBC) protocol.
+ *
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _UAPI_CBC_CORE_H_
+#define _UAPI_CBC_CORE_H_
+
+#include <linux/ioctl.h>
+
+/* Get/set the priority of this channel */
+#define CBC_PRIORITY_GET _IOR(CBC_IOCTL_MAGIC, 2, int)
+#define CBC_PRIORITY_SET _IOW(CBC_IOCTL_MAGIC, 3, int)
+
+
+#endif /* CBC_CORE_MOD_H_ */
diff --git a/include/uapi/linux/major.h b/include/uapi/linux/major.h
index 7e5fa8e15c43..e08767b96a45 100644
--- a/include/uapi/linux/major.h
+++ b/include/uapi/linux/major.h
@@ -135,6 +135,8 @@
 
 #define ATARAID_MAJOR		114
 
+#define CBC_CORE_MAJOR		115
+
 #define SCSI_DISK8_MAJOR	128
 #define SCSI_DISK9_MAJOR	129
 #define SCSI_DISK10_MAJOR	130
diff --git a/include/uapi/linux/tty.h b/include/uapi/linux/tty.h
index 376cccf397be..20217970ebfd 100644
--- a/include/uapi/linux/tty.h
+++ b/include/uapi/linux/tty.h
@@ -6,7 +6,7 @@
  * 'tty.h' defines some structures used by tty_io.c and some defines.
  */
 
-#define NR_LDISCS		30
+#define NR_LDISCS		31
 
 /* line disciplines */
 #define N_TTY		0
@@ -37,6 +37,7 @@
 #define N_TRACEROUTER	24	/* Trace data routing for MIPI P1149.7 */
 #define N_NCI		25	/* NFC NCI UART */
 #define N_SPEAKUP	26	/* Speakup communication with synths */
-#define N_NULL		27	/* Null ldisc used for error handling */
+#define N_CBCCORE	27	/* cbc protocol */
+#define N_NULL		28	/* Null ldisc used for error handling */
 
 #endif /* _UAPI_LINUX_TTY_H */
-- 
2.19.1

