From ad962ff8e4d8e251648040a1c045a1f010c72a3c Mon Sep 17 00:00:00 2001
From: Jani Nikula <jani.nikula@intel.com>
Date: Wed, 29 Jan 2025 16:46:36 +0200
Subject: [PATCH 0640/1107] drm/i915/mst: handle mst pbn_div in
 intel_dp_mtp_tu_compute_config()

Move mst_state->pbn_div calculation to intel_dp_mtp_tu_compute_config()
to allow further refactoring.

Reviewed-by: Imre Deak <imre.deak@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/0cc1b507601c9964ebae7d50b1f90b1ce00acb11.1738161945.git.jani.nikula@intel.com
Signed-off-by: Jani Nikula <jani.nikula@intel.com>
---
 drivers/gpu/drm/i915/display/intel_dp_mst.c | 31 ++++++++++-----------
 1 file changed, 14 insertions(+), 17 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_dp_mst.c b/drivers/gpu/drm/i915/display/intel_dp_mst.c
index a0d909c6cc83..375c606755cc 100644
--- a/drivers/gpu/drm/i915/display/intel_dp_mst.c
+++ b/drivers/gpu/drm/i915/display/intel_dp_mst.c
@@ -216,15 +216,25 @@ int intel_dp_mtp_tu_compute_config(struct intel_dp *intel_dp,
 {
 	struct intel_display *display = to_intel_display(intel_dp);
 	struct drm_atomic_state *state = crtc_state->uapi.state;
+	struct drm_dp_mst_topology_state *mst_state = NULL;
 	struct intel_connector *connector =
 		to_intel_connector(conn_state->connector);
 	const struct drm_display_mode *adjusted_mode =
 		&crtc_state->hw.adjusted_mode;
-	fixed20_12 pbn_div;
+	bool is_mst = intel_dp->is_mst;
 	int bpp, slots = -EINVAL;
 	int dsc_slice_count = 0;
 	int max_dpt_bpp;
 
+	if (is_mst) {
+		mst_state = drm_atomic_get_mst_topology_state(state, &intel_dp->mst_mgr);
+		if (IS_ERR(mst_state))
+			return PTR_ERR(mst_state);
+
+		mst_state->pbn_div = drm_dp_get_vc_payload_bw(crtc_state->port_clock,
+							      crtc_state->lane_count);
+	}
+
 	if (dsc) {
 		if (!intel_dp_supports_fec(intel_dp, connector, crtc_state))
 			return -EINVAL;
@@ -232,9 +242,6 @@ int intel_dp_mtp_tu_compute_config(struct intel_dp *intel_dp,
 		crtc_state->fec_enable = !intel_dp_is_uhbr(crtc_state);
 	}
 
-	pbn_div = drm_dp_get_vc_payload_bw(crtc_state->port_clock,
-					   crtc_state->lane_count);
-
 	max_dpt_bpp = intel_dp_mst_max_dpt_bpp(crtc_state, dsc);
 	if (max_bpp > max_dpt_bpp) {
 		drm_dbg_kms(display->drm, "Limiting bpp to max DPT bpp (%d -> %d)\n",
@@ -270,7 +277,7 @@ int intel_dp_mtp_tu_compute_config(struct intel_dp *intel_dp,
 					 link_bpp_x16,
 					 &crtc_state->dp_m_n);
 
-		if (intel_dp->is_mst) {
+		if (is_mst) {
 			int remote_bw_overhead;
 			int remote_tu;
 			fixed20_12 pbn;
@@ -295,7 +302,7 @@ int intel_dp_mtp_tu_compute_config(struct intel_dp *intel_dp,
 			pbn.full = dfixed_const(intel_dp_mst_calc_pbn(adjusted_mode->crtc_clock,
 								      link_bpp_x16,
 								      remote_bw_overhead));
-			remote_tu = DIV_ROUND_UP(pbn.full, pbn_div.full);
+			remote_tu = DIV_ROUND_UP(pbn.full, mst_state->pbn_div.full);
 
 			/*
 			 * Aligning the TUs ensures that symbols consisting of multiple
@@ -313,7 +320,7 @@ int intel_dp_mtp_tu_compute_config(struct intel_dp *intel_dp,
 			 * allocated for the whole path and the TUs allocated for the
 			 * first branch device's link also applies here.
 			 */
-			pbn.full = remote_tu * pbn_div.full;
+			pbn.full = remote_tu * mst_state->pbn_div.full;
 
 			drm_WARN_ON(display->drm, remote_tu < crtc_state->dp_m_n.tu);
 			crtc_state->dp_m_n.tu = remote_tu;
@@ -369,16 +376,6 @@ static int mst_stream_find_vcpi_slots_for_bpp(struct intel_dp *intel_dp,
 					      struct drm_connector_state *conn_state,
 					      int step, bool dsc)
 {
-	struct drm_atomic_state *state = crtc_state->uapi.state;
-	struct drm_dp_mst_topology_state *mst_state;
-
-	mst_state = drm_atomic_get_mst_topology_state(state, &intel_dp->mst_mgr);
-	if (IS_ERR(mst_state))
-		return PTR_ERR(mst_state);
-
-	mst_state->pbn_div = drm_dp_get_vc_payload_bw(crtc_state->port_clock,
-						      crtc_state->lane_count);
-
 	return intel_dp_mtp_tu_compute_config(intel_dp, crtc_state, conn_state,
 					      min_bpp, max_bpp, step, dsc);
 }
-- 
2.25.1

