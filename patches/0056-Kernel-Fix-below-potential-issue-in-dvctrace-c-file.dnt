From ff0b07a3ea23380b1e741e369358a15674ad6817 Mon Sep 17 00:00:00 2001
From: "Duan, YayongX" <yayongx.duan@intel.com>
Date: Mon, 14 May 2018 21:11:48 +0000
Subject: [PATCH 56/63] Kernel: Fix below potential issue in dvctrace c file

Issue description:
1. when "buf" is NULL, there is not a protection.
2. if there is not only one USB descriptor was saved in
   'buf', below two rare issues maybe occur:
    1) (descriptor length*2) > 'strlen(buf)'
	    'sscanf()' stops at the null terminator.
	     No overflow, but the mismatch could be indicative
       	     of another problem resulting potentially in data loss.
    2) (descriptor length*2) < 'strlen(buf)'
             No overflow, but data loss if there are more descriptors
	     than accounted for in the length.
Patch effect:
1. Ensuring 'buf' is not NULL.
2. Checking 'strlen(buf)' is consist of several (descriptor length*2)
   to make descriptor can be read correctly.
3. remove useless 'while(len)' loop that check real descriptor to enhance
   performance.
4. merge the code for 'lenth' 'type' and 'sub_type' checking to enhance performance.
Change-Id: I4abd5194d91423b5b6201911881d0656f2055a59
Tracked-On:
Signed-off-by: Duan, YayongX <yayongx.duan@intel.com>
Signed-off-by: Tian, Baofeng <baofeng.tian@intel.com>
---
 drivers/bus/dvctrace.c | 63 +++++++++++++++++++-----------------------
 1 file changed, 29 insertions(+), 34 deletions(-)

diff --git a/drivers/bus/dvctrace.c b/drivers/bus/dvctrace.c
index 915c42593edb..a44b1b3e5490 100644
--- a/drivers/bus/dvctrace.c
+++ b/drivers/bus/dvctrace.c
@@ -42,45 +42,34 @@
 static int count_descriptors(const char *buf, size_t size)
 {
 	size_t off = 0;
-	int i, j, count = 0;
-	u8 len, tmp;
+	int j, count0 = 0, count1 = 0;
+	u8 len, type, sub_type;
 
+	if (buf == NULL)
+		return -EINVAL;
+	/* Ensuring 'buf' only has serval correct format USB descriptors */
+	while(off < size) {
+		j = sscanf(buf + off, "%2hhx", &len);
+		if (j <= 0)
+			return -EINVAL;
+	/* skip related data and space to read next 'len': aa bb cc ... */
+		off += len * 3;
+		count0++;
+	}
+	if (off != size)
+		return -EINVAL;
+	off = 0;
 	DVCT_IN();
-	while (off < size) {
+	/* Check every USB descriptor type and sub_type */
+	while (count0--) {
 		/*the length*/
-		j = sscanf(buf + off, "%2hhx%n", &len, &i);
-		if (!j)
-			break;
-		if (j < 0 || len < 4)
-			return -EINVAL;
-		len--;
-		off += i;
-
-		/*Type*/
-		j = sscanf(buf + off, "%2hhx%n", &tmp, &i);
-		if (j <= 0 || tmp != USB_DT_CS_INTERFACE)
+		j = sscanf(buf + off, "%2hhx%2hhx%2hhx", &len, &type, &sub_type);
+		if (j <= 0 || type != USB_DT_CS_INTERFACE || sub_type < DC_INPUT_CONNECTION || sub_type > DC_DEBUG_ATTRIBUTES)
 			return -EINVAL;
-		len--;
-		off += i;
-
-		/*Sub Type*/
-		j = sscanf(buf + off, "%2hhx%n", &tmp, &i);
-		if (j <= 0 || tmp < DC_INPUT_CONNECTION
-		    || tmp > DC_DEBUG_ATTRIBUTES)
-			return -EINVAL;
-		len--;
-		off += i;
-
-		while (len) {
-			j = sscanf(buf + off, "%2hhx%n", &tmp, &i);
-			if (j <= 0)
-				return -EINVAL;
-			len--;
-			off += i;
-		}
-		count++;
+		off += len * 3;
+		count1++;
 	}
-	return count;
+	return count1;
 }
 
 /* Parse @buf and get a pointer to the descriptor identified
@@ -91,6 +80,8 @@ static u8 *get_descriptor(const char *buf, size_t size, int idx)
 	int i, j, k, count = 0;
 	u8 len, tmp, *ret = NULL;
 
+	if (buf == NULL)
+		return ERR_PTR(-EINVAL);
 	DVCT_IN();
 	while (off < size) {
 		j = sscanf(buf + off, "%2hhx%n", &len, &i);
@@ -318,6 +309,8 @@ static int count_strings(const char *buf, size_t size)
 	size_t off = 0, slen;
 	int i = 0, j, desc_offset, offset;
 
+	if (buf == NULL)
+		return -EINVAL;
 	DVCT_IN();
 	while (off < size) {
 		j = sscanf(buf + off, "%d.%d: %n", &desc_offset, &offset, &i);
@@ -346,6 +339,8 @@ static char *get_string(const char *buf, size_t size, int index,
 	int i, j;
 	char *ret = ERR_PTR(-EINVAL);
 
+	if (buf == NULL)
+		return ERR_PTR(-EINVAL);
 	DVCT_IN();
 	while (off < size) {
 		j = sscanf(buf + off, "%d.%d: %n", desc_offset, offset, &i);
-- 
2.19.1

