From 69630367458cca34724f95e457786593ac28c7bb Mon Sep 17 00:00:00 2001
From: Traian Schiau <traianx.schiau@intel.com>
Date: Thu, 31 Mar 2016 11:32:11 +0300
Subject: [PATCH 03/62] dvctrace: Topology descriptors support.

DvC Trace supports additional custom USB descriptors that
should be provided by the source device.

Signed-off-by: Traian Schiau <traianx.schiau@intel.com>
---
 Documentation/ABI/testing/sysfs-bus-dvctrace |  42 ++
 drivers/bus/dvctrace.c                       | 441 +++++++++++++++++++
 drivers/usb/gadget/function/f_dvctrace.c     | 149 +++++--
 drivers/usb/gadget/function/u_dvctrace.h     |   1 +
 include/linux/dvctrace.h                     |  33 +-
 5 files changed, 633 insertions(+), 33 deletions(-)

diff --git a/Documentation/ABI/testing/sysfs-bus-dvctrace b/Documentation/ABI/testing/sysfs-bus-dvctrace
index 0abdd3293364..bf2b5bb2144a 100644
--- a/Documentation/ABI/testing/sysfs-bus-dvctrace
+++ b/Documentation/ABI/testing/sysfs-bus-dvctrace
@@ -24,3 +24,45 @@ Description:	(RW) The protocol id of a dvc-trace source device,
 		this will used in function driver interface
 		descriptors (u8). According to USB debug class
 		specification the protocol id is vendor specific.
+
+What:		/sys/bus/dvctrace/devices/<device>/descriptors
+Date:		May 2015
+KernelVersion:	4.0
+Contact:	Traian Schiau <traianx.schiau@intel.com>
+Description:	(RW) Hex-dump of the descriptors provided by the
+		source device.
+		eg. A debug class output connection descriptor
+		09 24 02 04 03 00 00 00 00
+		ll tt ss xx xx xx xx xx ii
+		 |  |  |                 +- iConnection string id.
+		 |  |  +- Descriptor sub-type DC_OUTPUT_CONNECTION
+		 |  +- Descriptor type (USB_DT_CS_INTERFACE)
+		 +- Descriptor length
+		Writing:
+		  - is not allowed while the device is Reserved or In Use.
+		  - will replace all the descriptors currently present.
+		  - will remove any strings previously provided.
+		  - should use the same format.
+		  - accepts multiple descriptors separated by space or '\n'.
+
+What:		/sys/bus/dvctrace/devices/<device>/strings
+Date:		May 2015
+KernelVersion:	4.0
+Contact:	Traian Schiau <traianx.schiau@intel.com>
+Description:	(RW) Currently set usb descriptor strings in
+		<descriptor_index>.<offset>: string format.
+		<descriptor_index>.<offset> identifies the location where
+		the string id is needed.
+		eg. Having the same debug class output connection descriptor,
+		as the first descriptor.
+		09 24 02 04 03 00 00 00 00
+		ll tt ss xx xx xx xx xx ii
+		                         +- iConnection string id.
+		0.8: My output connection - will identify the string associated
+		with this descriptor.
+		Writing:
+		  - is not allowed while the device is Reserved or In Use.
+		  - will replace all the strings currently present.
+		  - should use the same format.
+		  - accepts multiple strings separated by ";" or '\n'.
+		    eg. "0.4: first string; 1.4: second string"
diff --git a/drivers/bus/dvctrace.c b/drivers/bus/dvctrace.c
index c1770ca44422..906e972103d9 100644
--- a/drivers/bus/dvctrace.c
+++ b/drivers/bus/dvctrace.c
@@ -19,6 +19,7 @@
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/dvctrace.h>
+#include <linux/usb/debug.h>
 
 #ifdef DVCT_DEBUG
 #define DVCT_IN() pr_debug("in\n")
@@ -26,6 +27,435 @@
 #define DVCT_IN() do {} while (0)
 #endif
 
+/* Count the number of USB descriptors in the given ascii hex string
+ * What we expect:
+ *   ll tt ss xx xx xx
+ *    |  |  |  +- Fill up the descriptor
+ *    |  |  +- Descriptor sub-type (1-4)
+ *    |  |       DC_INPUT_CONNECTION		0x01
+ *    |  |       DC_OUTPUT_CONNECTION		0x02
+ *    |  |       DC_DEBUG_UNIT			0x03
+ *    |  |       DC_DEBUG_ATTRIBUTES		0x04
+ *    |  +- Descriptor type (USB_DT_CS_INTERFACE)
+ *    +- Descriptor length (check > 3 and we have the rest of it)
+ */
+static int count_descriptors(const char *buf, size_t size)
+{
+	size_t off = 0;
+	int i, j, count = 0;
+	u8 len, tmp;
+
+	DVCT_IN();
+	while (off < size) {
+		/*the length*/
+		j = sscanf(buf + off, "%2hhx%n", &len, &i);
+		if (!j)
+			break;
+		if (j < 0 || len < 4)
+			return -EINVAL;
+		len--;
+		off += i;
+
+		/*Type*/
+		j = sscanf(buf + off, "%2hhx%n", &tmp, &i);
+		if (j <= 0 || tmp != USB_DT_CS_INTERFACE)
+			return -EINVAL;
+		len--;
+		off += i;
+
+		/*Sub Type*/
+		j = sscanf(buf + off, "%2hhx%n", &tmp, &i);
+		if (j <= 0 || tmp < DC_INPUT_CONNECTION
+		    || tmp > DC_DEBUG_ATTRIBUTES)
+			return -EINVAL;
+		len--;
+		off += i;
+
+		while (len) {
+			j = sscanf(buf + off, "%2hhx%n", &tmp, &i);
+			if (j <= 0)
+				return -EINVAL;
+			len--;
+			off += i;
+		}
+		count++;
+	}
+	return count;
+}
+
+/* Parse @buf and get a pointer to the descriptor identified
+ *  @idx*/
+static u8 *get_descriptor(const char *buf, size_t size, int idx)
+{
+	size_t off = 0;
+	int i, j, k, count = 0;
+	u8 len, tmp, *ret = NULL;
+
+	DVCT_IN();
+	while (off < size) {
+		j = sscanf(buf + off, "%2hhx%n", &len, &i);
+		if (j < 0)
+			return ERR_PTR(-EINVAL);
+		if (!j)
+			return ERR_PTR(-ERANGE);
+
+		if (count == idx) {
+			ret = kmalloc(len, GFP_KERNEL);
+			if (!ret)
+				return ERR_PTR(-ENOMEM);
+			ret[0] = len;
+		}
+		off += i;
+		for (k = 1; k < len; k++) {
+			j = sscanf(buf + off, "%2hhx%n", &tmp, &i);
+			if (j <= 0) {
+				kfree(ret);
+				return ERR_PTR(-EINVAL);
+			}
+			if (count == idx)
+				ret[k] = tmp;
+			off += i;
+		}
+		if (count == idx)
+			break;
+		count++;
+	}
+	return ret;
+}
+
+
+static void free_strings(struct dvct_usb_descriptors *desc)
+{
+	struct usb_string *string;
+
+	DVCT_IN();
+	for (string = desc->str.strings; string && string->s; string++)
+		kfree(string->s);
+
+	kfree(desc->str.strings);
+	desc->str.strings = NULL;
+	kfree(desc->lk_tbl);
+	desc->lk_tbl = NULL;
+}
+
+static void free_descriptors(struct dvct_usb_descriptors *desc)
+{
+	struct usb_descriptor_header **hdr;
+
+	DVCT_IN();
+	if (desc->dvc_spec) {
+		for (hdr = desc->dvc_spec; *hdr; hdr++)
+			kfree(*hdr);
+		kfree(desc->dvc_spec);
+		desc->dvc_spec = NULL;
+	}
+	free_strings(desc);
+	kfree(desc);
+}
+
+static int alloc_strings(struct dvct_usb_descriptors *desc, int count)
+{
+	DVCT_IN();
+	desc->lk_tbl = kzalloc((count + 1) * sizeof(struct dvct_string_lookup),
+			       GFP_KERNEL);
+	if (!desc->lk_tbl)
+		goto  err;
+
+	desc->str.strings = kzalloc(sizeof(desc->str), GFP_KERNEL);
+	if (!desc->str.strings)
+		goto err_str;
+
+	desc->str.language = 0x0409;
+
+	return count;
+err_str:
+	kfree(desc->lk_tbl);
+	desc->lk_tbl = NULL;
+err:
+	return -ENOMEM;
+}
+
+static struct dvct_usb_descriptors *alloc_descriptors(int count)
+{
+	struct dvct_usb_descriptors *desc;
+
+	DVCT_IN();
+	desc = kzalloc(sizeof(struct dvct_usb_descriptors), GFP_KERNEL);
+	if (!desc)
+		return ERR_PTR(-ENOMEM);
+
+	desc->dvc_spec =
+		kzalloc((count + 1) * sizeof(struct usb_descriptor_header *),
+			GFP_KERNEL);
+
+	if (!desc->dvc_spec) {
+		kfree(desc);
+		return ERR_PTR(-ENOMEM);
+	}
+	return desc;
+}
+
+static ssize_t descriptors_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct dvct_source_device *ds_dev = dev_to_dvct_source_device(dev);
+	struct usb_descriptor_header **desc;
+	int ret = 0;
+
+	DVCT_IN();
+	if (!ds_dev->desc || !ds_dev->desc->dvc_spec
+	    || !*ds_dev->desc->dvc_spec)
+		return sprintf(buf, "No Descriptors.\n");
+
+	for (desc = ds_dev->desc->dvc_spec; *desc; desc++) {
+		u8 len, *pdesc;
+		int i;
+
+		len = (*desc)->bLength;
+		pdesc = (u8 *)(*desc);
+		for (i = 0; i < len; i++)
+			ret += snprintf(buf + ret, PAGE_SIZE - ret, "%02hhX ",
+					pdesc[i]);
+		buf[ret - 1] = '\n';
+	}
+	return ret;
+}
+
+static ssize_t descriptors_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct dvct_source_device *ds_dev = dev_to_dvct_source_device(dev);
+	int desc_count, i;
+	u8 *hdr;
+
+	DVCT_IN();
+
+	if (ds_dev->instance_taken)
+		return -EBUSY;
+
+	/*count the new descriptors, exit if invalid input*/
+	desc_count = count_descriptors(buf, size);
+	if (desc_count <= 0) {
+		dev_warn(dev, "Invalid descriptor input:[%zu] %s", size, buf);
+		return -EINVAL;
+	}
+
+	if (ds_dev->desc && ds_dev->desc != &ds_dev->static_desc)
+		free_descriptors(ds_dev->desc);
+
+	ds_dev->desc = alloc_descriptors(desc_count);
+	if (IS_ERR_OR_NULL(ds_dev->desc)) {
+		ds_dev->desc = NULL;
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < desc_count; i++) {
+		hdr = get_descriptor(buf, size, i);
+		if (IS_ERR_OR_NULL(hdr)) {
+			dev_err(dev, "Cannot get descriptor %d, %ld\n", i,
+				PTR_ERR(hdr));
+			free_descriptors(ds_dev->desc);
+			ds_dev->desc = NULL;
+			return -EINVAL;
+		}
+		ds_dev->desc->dvc_spec[i] = (struct usb_descriptor_header *)hdr;
+	}
+	return size;
+}
+
+static DEVICE_ATTR_RW(descriptors);
+
+
+/*find out at which member(offset) of which descriptor the pointer
+ * points to */
+static int dvctrace_string_ptr_to_offset(struct usb_descriptor_header **first,
+					u8 *ptr, int *desc_offset, int *offset)
+{
+	u8 *hdr_start, *hdr_end;
+	int idx = 0;
+
+	DVCT_IN();
+	for (; *first; first++, idx++) {
+		hdr_start = (u8 *) (*first);
+		hdr_end = hdr_start + ((*first)->bLength - 1);
+		if (ptr >= hdr_start && ptr <= hdr_end) {
+			*desc_offset = idx;
+			*offset = ptr - hdr_start;
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+static u8 *dvctrace_offset_to_string_ptr(struct usb_descriptor_header **first,
+					 int desc_offset, int offset)
+{
+	int idx = 0;
+
+	DVCT_IN();
+	for (; *first; first++, idx++) {
+		if (idx == desc_offset) {
+			if (offset >= (*first)->bLength)
+				return ERR_PTR(-ERANGE);
+			return ((u8 *) (*first)) + offset;
+		}
+	}
+	return ERR_PTR(-ERANGE);
+}
+
+static int count_strings(const char *buf, size_t size)
+{
+	int count = 0;
+	size_t off = 0, slen;
+	int i = 0, j, desc_offset, offset;
+
+	DVCT_IN();
+	while (off < size) {
+		j = sscanf(buf + off, "%d.%d: %n", &desc_offset, &offset, &i);
+		if (j < 2)
+			break;
+		off += i;
+		slen = 0;
+		while (off + slen < size) {
+			if (buf[off + slen] == ';' || buf[off + slen] == '\n')
+				break;
+			slen++;
+		}
+		off += slen;
+		if (buf[off] == ';' || buf[off] == '\n')
+			off++;
+		count++;
+	}
+	return count;
+}
+
+static char *get_string(const char *buf, size_t size, int index,
+			int *desc_offset, int *offset)
+{
+	int count = 0;
+	size_t off = 0, slen;
+	int i, j;
+	char *ret = ERR_PTR(-EINVAL);
+
+	DVCT_IN();
+	while (off < size) {
+		j = sscanf(buf + off, "%d.%d: %n", desc_offset, offset, &i);
+		if (j < 2)
+			return  ERR_PTR(-EINVAL);
+		off += i;
+		slen = 0;
+		while (off + slen < size) {
+			if (buf[off + slen] == ';' || buf[off + slen] == '\n')
+				break;
+			slen++;
+		}
+
+		if (count == index) {
+			ret = kmalloc(slen+1, GFP_KERNEL);
+			if (!ret)
+				return ERR_PTR(-ENOMEM);
+			memcpy(ret, buf + off, slen);
+			ret[slen] = 0;
+			return ret;
+		}
+		off += slen;
+		if (buf[off] == ';' || buf[off] == '\n')
+			off++;
+		count++;
+	}
+	return ERR_PTR(-EINVAL);
+}
+
+static ssize_t strings_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct dvct_string_lookup *lk_s;
+	struct dvct_source_device *ds_dev = dev_to_dvct_source_device(dev);
+	int ret = 0;
+
+	DVCT_IN();
+	if (!ds_dev->desc || !ds_dev->desc->dvc_spec
+	    || !*ds_dev->desc->dvc_spec)
+		return sprintf(buf, "No Descriptors.\n");
+
+	if (!ds_dev->desc->lk_tbl)
+		return sprintf(buf, "No Strings.\n");
+
+	for (lk_s = ds_dev->desc->lk_tbl; lk_s->str && lk_s->id; lk_s++) {
+		int desc_offset, offset;
+
+		if (dvctrace_string_ptr_to_offset(ds_dev->desc->dvc_spec,
+						  lk_s->id, &desc_offset,
+						  &offset))
+			ret += snprintf(buf + ret, PAGE_SIZE,
+					"Unknown(%p): %s\n", lk_s->id,
+					lk_s->str->s);
+		else
+			ret += snprintf(buf + ret, PAGE_SIZE, "%d.%d: %s\n",
+					desc_offset, offset, lk_s->str->s);
+	}
+	return ret;
+}
+
+static ssize_t strings_store(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct dvct_source_device *ds_dev = dev_to_dvct_source_device(dev);
+	int count, i, ret;
+
+	DVCT_IN();
+	if (ds_dev->instance_taken)
+		return -EBUSY;
+
+	count = count_strings(buf, size);
+	if (count <= 0) {
+		dev_err(dev, "Invalid input string:(%zu) %s\n", size, buf);
+		return -EINVAL;
+	}
+
+	if (ds_dev->desc == &ds_dev->static_desc) {
+		dev_warn(&ds_dev->device, "Cannot set strings in static descriptors\n");
+		return -EINVAL;
+	}
+
+	if (ds_dev->desc->str.strings)
+		free_strings(ds_dev->desc);
+
+	ret = alloc_strings(ds_dev->desc, count);
+	if (ret < 0) {
+		dev_err(dev, "Cannot allocate strings %d\n", ret);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < count; i++) {
+		char *tmp;
+		int d_off, off;
+		u8 *pid;
+
+		tmp = get_string(buf, size, i, &d_off, &off);
+		if (IS_ERR_OR_NULL(tmp)) {
+			free_strings(ds_dev->desc);
+			return -EINVAL;
+		}
+
+		pid = dvctrace_offset_to_string_ptr(ds_dev->desc->dvc_spec,
+						    d_off, off);
+		if (IS_ERR_OR_NULL(pid)) {
+			dev_warn(&ds_dev->device, "String out of bounds\n");
+			free_strings(ds_dev->desc);
+			return -EINVAL;
+		}
+
+		ds_dev->desc->lk_tbl[i].id = pid;
+		ds_dev->desc->lk_tbl[i].str = &ds_dev->desc->str.strings[i];
+		ds_dev->desc->str.strings[i].s = tmp;
+	}
+	return size;
+}
+
+static DEVICE_ATTR_RW(strings);
+
 static ssize_t protocol_show(struct device *dev, struct device_attribute *attr,
 			     char *buf)
 {
@@ -71,6 +501,8 @@ static DEVICE_ATTR_RO(status);
 static struct attribute *dvct_source_attrs[] = {
 	&dev_attr_protocol.attr,
 	&dev_attr_status.attr,
+	&dev_attr_strings.attr,
+	&dev_attr_descriptors.attr,
 	NULL,
 };
 
@@ -208,6 +640,9 @@ int dvct_source_device_add(struct dvct_source_device *ds_dev,
 		return ret;
 	}
 
+	if (ds_dev->static_desc.dvc_spec)
+		ds_dev->desc = &ds_dev->static_desc;
+
 	dev_notice(&dvctrace_bus, "Adding device %s\n", ds_dev->name_add);
 	return 0;
 };
@@ -216,6 +651,12 @@ EXPORT_SYMBOL_GPL(dvct_source_device_add);
 void dvct_source_device_del(struct dvct_source_device *ds_dev)
 {
 	DVCT_IN();
+
+	if (ds_dev->desc && ds_dev->desc != &ds_dev->static_desc) {
+		free_descriptors(ds_dev->desc);
+		ds_dev->desc = NULL;
+	}
+
 	device_del(&ds_dev->device);
 };
 EXPORT_SYMBOL_GPL(dvct_source_device_del);
diff --git a/drivers/usb/gadget/function/f_dvctrace.c b/drivers/usb/gadget/function/f_dvctrace.c
index dffd06126d8f..d5cb49db52bc 100644
--- a/drivers/usb/gadget/function/f_dvctrace.c
+++ b/drivers/usb/gadget/function/f_dvctrace.c
@@ -39,6 +39,26 @@ enum {
 	DVCT_HS_DESC_COUNT,/*Count of super speed descriptors*/
 };
 
+/*The full list of descriptors will look like:
+ * IAD_DESCRIPTOR         -----|=> USB function specific
+ * CONTROL_ITF_DESCRIPTOR -----|
+ * SOURCE_SPECIFIC_DESCRIPTOR_0    ----|
+ * ....                                |=> s_cnt descriptors provided by the
+ * SOURCE_SPECIFIC_DESCRIPTOR_s_cnt----|   source device.
+ * DATA_ITF_DESCRIPTOR -----|
+ * ENDPOINT_DESCRIPTOR      |=> USB function specific
+ * ....                -----|
+ * This makes a good part of the descriptors to shift,
+ * the following should help*/
+#define DVCT_IAD_DESC_DYN_POS(s_cnt)		(DVCT_IAD_DESC_POS)
+#define DVCT_CITF_DESC_DYN_POS(s_cnt)		(DVCT_CITF_DESC_POS)
+#define DVCT_SOURCE_DESC_FIRST(s_cnt)		(DVCT_DITF_DESC_POS)
+#define DVCT_DITF_DESC_DYN_POS(s_cnt)		((s_cnt)+DVCT_DITF_DESC_POS)
+#define DVCT_EP_DESC_DYN_POS(s_cnt)		((s_cnt)+DVCT_EP_DESC_POS)
+#define DVCT_EP_COMP_DESC_DYN_POS(s_cnt)	((s_cnt)+DVCT_EP_COMP_DESC_POS)
+#define DVCT_LS_DESC_DYN_COUNT(s_cnt)		((s_cnt)+DVCT_LS_DESC_COUNT)
+#define DVCT_HS_DESC_DYN_COUNT(s_cnt)		((s_cnt)+DVCT_HS_DESC_COUNT)
+
 enum {
 	DVCT_STR_IAD_IDX,
 	DVCT_STR_C_ITF_IDX,
@@ -49,25 +69,35 @@ enum {
 
 static int dvct_alloc_desc(struct dvct_function *d_fun)
 {
+	int i;
+	unsigned int s_desc_count = 0;
+	struct usb_descriptor_header **s_desc;
 	struct dvct_function_desc *desc = &d_fun->desc;
 
 	DVCT_IN();
 
+	if (d_fun->source_dev->desc) {
+		for (s_desc = d_fun->source_dev->desc->dvc_spec;
+		     s_desc && (*s_desc); s_desc++)
+			s_desc_count++;
+	}
+
+	/*alloc the descriptors array */
 	desc->fs =
-	    kzalloc(DVCT_LS_DESC_COUNT * sizeof(struct usb_descriptor_header *),
-		    GFP_KERNEL);
+	    kzalloc(DVCT_LS_DESC_DYN_COUNT(s_desc_count) *
+		    sizeof(struct usb_descriptor_header *), GFP_KERNEL);
 	if (!desc->fs)
 		goto err_fs;
 
 	desc->hs =
-	    kzalloc(DVCT_LS_DESC_COUNT * sizeof(struct usb_descriptor_header *),
-		    GFP_KERNEL);
+	    kzalloc(DVCT_LS_DESC_DYN_COUNT(s_desc_count) *
+		    sizeof(struct usb_descriptor_header *), GFP_KERNEL);
 	if (!desc->hs)
 		goto err_hs;
 
 	desc->ss =
-	    kzalloc(DVCT_HS_DESC_COUNT * sizeof(struct usb_descriptor_header *),
-		    GFP_KERNEL);
+	    kzalloc(DVCT_HS_DESC_DYN_COUNT(s_desc_count) *
+		    sizeof(struct usb_descriptor_header *), GFP_KERNEL);
 	if (!desc->ss)
 		goto err_ss;
 
@@ -84,9 +114,12 @@ static int dvct_alloc_desc(struct dvct_function *d_fun)
 	desc->iad->bFunctionProtocol = d_fun->source_dev->protocol;
 	/*bFirstInterface - updated on bind */
 
-	desc->fs[DVCT_IAD_DESC_POS] = (struct usb_descriptor_header *)desc->iad;
-	desc->hs[DVCT_IAD_DESC_POS] = (struct usb_descriptor_header *)desc->iad;
-	desc->ss[DVCT_IAD_DESC_POS] = (struct usb_descriptor_header *)desc->iad;
+	desc->fs[DVCT_IAD_DESC_DYN_POS(s_desc_count)] =
+	    (struct usb_descriptor_header *)desc->iad;
+	desc->hs[DVCT_IAD_DESC_DYN_POS(s_desc_count)] =
+	    (struct usb_descriptor_header *)desc->iad;
+	desc->ss[DVCT_IAD_DESC_DYN_POS(s_desc_count)] =
+	    (struct usb_descriptor_header *)desc->iad;
 
 	/*Control interface */
 	desc->c_itf = kzalloc(sizeof(*desc->c_itf), GFP_KERNEL);
@@ -99,13 +132,25 @@ static int dvct_alloc_desc(struct dvct_function *d_fun)
 	desc->c_itf->bInterfaceSubClass = USB_SUBCLASS_DEBUG_CONTROL;
 	desc->c_itf->bInterfaceProtocol = d_fun->source_dev->protocol;
 
-	desc->fs[DVCT_CITF_DESC_POS] =
+	desc->fs[DVCT_CITF_DESC_DYN_POS(s_desc_count)] =
 	    (struct usb_descriptor_header *)desc->c_itf;
-	desc->hs[DVCT_CITF_DESC_POS] =
+	desc->hs[DVCT_CITF_DESC_DYN_POS(s_desc_count)] =
 	    (struct usb_descriptor_header *)desc->c_itf;
-	desc->ss[DVCT_CITF_DESC_POS] =
+	desc->ss[DVCT_CITF_DESC_DYN_POS(s_desc_count)] =
 	    (struct usb_descriptor_header *)desc->c_itf;
 
+	if (d_fun->source_dev->desc) {
+		/*Copy whatever the source device has provided */
+		s_desc = d_fun->source_dev->desc->dvc_spec;
+		for (i = 0; i < s_desc_count; i++) {
+			desc->fs[DVCT_SOURCE_DESC_FIRST(s_desc_count) + i]
+			    = s_desc[i];
+			desc->hs[DVCT_SOURCE_DESC_FIRST(s_desc_count) + i]
+			    = s_desc[i];
+			desc->ss[DVCT_SOURCE_DESC_FIRST(s_desc_count) + i]
+			    = s_desc[i];
+		}
+	}
 	/*Data interface */
 	desc->d_itf = kzalloc(sizeof(*desc->d_itf), GFP_KERNEL);
 	if (!desc->d_itf)
@@ -118,11 +163,11 @@ static int dvct_alloc_desc(struct dvct_function *d_fun)
 	desc->d_itf->bInterfaceSubClass = USB_SUBCLASS_DVC_TRACE;
 	desc->d_itf->bInterfaceProtocol = d_fun->source_dev->protocol;
 
-	desc->fs[DVCT_DITF_DESC_POS] =
+	desc->fs[DVCT_DITF_DESC_DYN_POS(s_desc_count)] =
 	    (struct usb_descriptor_header *)desc->d_itf;
-	desc->hs[DVCT_DITF_DESC_POS] =
+	desc->hs[DVCT_DITF_DESC_DYN_POS(s_desc_count)] =
 	    (struct usb_descriptor_header *)desc->d_itf;
-	desc->ss[DVCT_DITF_DESC_POS] =
+	desc->ss[DVCT_DITF_DESC_DYN_POS(s_desc_count)] =
 	    (struct usb_descriptor_header *)desc->d_itf;
 
 	/*Full Speed ep */
@@ -136,7 +181,7 @@ static int dvct_alloc_desc(struct dvct_function *d_fun)
 	desc->fs_ep->bmAttributes = USB_ENDPOINT_XFER_BULK;
 	desc->fs_ep->wMaxPacketSize = cpu_to_le16(64);
 
-	desc->fs[DVCT_EP_DESC_POS] =
+	desc->fs[DVCT_EP_DESC_DYN_POS(s_desc_count)] =
 	    (struct usb_descriptor_header *)desc->fs_ep;
 
 	/*High Speed ep */
@@ -150,7 +195,7 @@ static int dvct_alloc_desc(struct dvct_function *d_fun)
 	desc->hs_ep->bmAttributes = USB_ENDPOINT_XFER_BULK;
 	desc->hs_ep->wMaxPacketSize = cpu_to_le16(512);
 
-	desc->hs[DVCT_EP_DESC_POS] =
+	desc->hs[DVCT_EP_DESC_DYN_POS(s_desc_count)] =
 	    (struct usb_descriptor_header *)desc->hs_ep;
 
 	/*Super Speed ep */
@@ -164,7 +209,7 @@ static int dvct_alloc_desc(struct dvct_function *d_fun)
 	desc->ss_ep->bmAttributes = USB_ENDPOINT_XFER_BULK;
 	desc->ss_ep->wMaxPacketSize = cpu_to_le16(1024);
 
-	desc->ss[DVCT_EP_DESC_POS] =
+	desc->ss[DVCT_EP_DESC_DYN_POS(s_desc_count)] =
 	    (struct usb_descriptor_header *)desc->ss_ep;
 
 	/*Super Speed ep comp */
@@ -175,7 +220,7 @@ static int dvct_alloc_desc(struct dvct_function *d_fun)
 	desc->ss_ep_comp->bLength = USB_DT_SS_EP_COMP_SIZE;
 	desc->ss_ep_comp->bDescriptorType = USB_DT_SS_ENDPOINT_COMP;
 
-	desc->ss[DVCT_EP_COMP_DESC_POS] =
+	desc->ss[DVCT_EP_COMP_DESC_DYN_POS(s_desc_count)] =
 	    (struct usb_descriptor_header *)desc->ss_ep_comp;
 
 	/* strings */
@@ -186,6 +231,14 @@ static int dvct_alloc_desc(struct dvct_function *d_fun)
 	if (!desc->str.strings)
 		goto err_str;
 
+	/*lookup table */
+	desc->lk_tbl =
+	    kzalloc(DVCT_STR_COUNT * sizeof(struct dvct_string_lookup),
+		    GFP_KERNEL);
+	if (!desc->lk_tbl)
+		goto err_str_lk;
+
+	/*actual strings */
 	 /*IAD*/
 	    desc->str.strings[DVCT_STR_IAD_IDX].s =
 	    kasprintf(GFP_KERNEL, "DvC Trace (%s)",
@@ -193,6 +246,10 @@ static int dvct_alloc_desc(struct dvct_function *d_fun)
 	if (!desc->str.strings[DVCT_STR_IAD_IDX].s)
 		goto err_str_iad;
 
+	desc->lk_tbl[DVCT_STR_IAD_IDX].str =
+	    &desc->str.strings[DVCT_STR_IAD_IDX];
+	desc->lk_tbl[DVCT_STR_IAD_IDX].id = &desc->iad->iFunction;
+
 	/*control */
 	desc->str.strings[DVCT_STR_C_ITF_IDX].s =
 	    kasprintf(GFP_KERNEL, "DvC Trace Control (%s)",
@@ -200,6 +257,10 @@ static int dvct_alloc_desc(struct dvct_function *d_fun)
 	if (!desc->str.strings[DVCT_STR_C_ITF_IDX].s)
 		goto err_str_ctrl;
 
+	desc->lk_tbl[DVCT_STR_C_ITF_IDX].str =
+	    &desc->str.strings[DVCT_STR_C_ITF_IDX];
+	desc->lk_tbl[DVCT_STR_C_ITF_IDX].id = &desc->c_itf->iInterface;
+
 	/*data */
 	desc->str.strings[DVCT_STR_D_ITF_IDX].s =
 	    kasprintf(GFP_KERNEL, "DvC Trace Data (%s)",
@@ -207,6 +268,10 @@ static int dvct_alloc_desc(struct dvct_function *d_fun)
 	if (!desc->str.strings[DVCT_STR_D_ITF_IDX].s)
 		goto err_str_data;
 
+	desc->lk_tbl[DVCT_STR_D_ITF_IDX].str =
+	    &desc->str.strings[DVCT_STR_D_ITF_IDX];
+	desc->lk_tbl[DVCT_STR_D_ITF_IDX].id = &desc->d_itf->iInterface;
+
 	return 0;
 /*cleanup*/
 err_str_data:
@@ -214,6 +279,8 @@ static int dvct_alloc_desc(struct dvct_function *d_fun)
 err_str_ctrl:
 	kfree(desc->str.strings[DVCT_STR_IAD_IDX].s);
 err_str_iad:
+	kfree(desc->lk_tbl);
+err_str_lk:
 	kfree(desc->str.strings);
 err_str:
 	kfree(desc->ss_ep_comp);
@@ -249,6 +316,7 @@ static void dvct_free_desc(struct dvct_function *d_fun)
 	kfree(desc->str.strings[DVCT_STR_D_ITF_IDX].s);
 	kfree(desc->str.strings[DVCT_STR_C_ITF_IDX].s);
 	kfree(desc->str.strings[DVCT_STR_IAD_IDX].s);
+	kfree(desc->lk_tbl);
 	kfree(desc->str.strings);
 	kfree(desc->ss_ep_comp);
 	kfree(desc->ss_ep);
@@ -290,25 +358,25 @@ int dvct_stop_transfer(struct dvct_function *d_fun)
 EXPORT_SYMBOL(dvct_stop_transfer);
 
 static int dvct_strings_setup(struct usb_composite_dev *cdev,
-				  struct dvct_function *f_fun)
+			      struct usb_string *strings,
+			      struct dvct_string_lookup *lk_tbl)
 {
 	int status;
+	struct dvct_string_lookup *str_lk;
 
 	DVCT_IN();
-	if (!f_fun->desc.str.strings)
+	if (!strings || !lk_tbl)
 		return -EINVAL;
 
-	status = usb_string_ids_tab(cdev, f_fun->desc.str.strings);
+	status = usb_string_ids_tab(cdev, strings);
 	if (status < 0)
 		return status;
 
-	f_fun->desc.iad->iFunction =
-	    f_fun->desc.str.strings[DVCT_STR_IAD_IDX].id;
-	f_fun->desc.c_itf->iInterface =
-	    f_fun->desc.str.strings[DVCT_STR_C_ITF_IDX].id;
-	f_fun->desc.d_itf->iInterface =
-	    f_fun->desc.str.strings[DVCT_STR_D_ITF_IDX].id;
-
+	for (str_lk = lk_tbl; str_lk->str; str_lk++) {
+		*str_lk->id = str_lk->str->id;
+		pr_info("Setting id %d for str \"%s\"\n", str_lk->str->id,
+			str_lk->str->s);
+	}
 	return 0;
 }
 
@@ -395,7 +463,17 @@ static int dvct_function_bind(struct usb_configuration *cconfig,
 	DVCT_IN();
 	d_fun->cdev = cconfig->cdev;
 
-	ret = dvct_strings_setup(d_fun->cdev, d_fun);
+	/*allocate id's */
+	/*strings. not crucial just print on failure */
+	if (d_fun->source_dev->desc && d_fun->source_dev->desc->str.strings) {
+		ret = dvct_strings_setup(d_fun->cdev,
+					 d_fun->source_dev->desc->str.strings,
+					 d_fun->source_dev->desc->lk_tbl);
+		if (ret)
+			pr_warn("Cannot allocate source device string id's\n");
+	}
+	ret = dvct_strings_setup(d_fun->cdev, d_fun->desc.str.strings,
+				 d_fun->desc.lk_tbl);
 	if (ret)
 		pr_warn("Cannot allocate function string id's\n");
 
@@ -715,8 +793,13 @@ static struct usb_function *dvct_alloc_func(struct usb_function_instance *inst)
 	if (ret)
 		goto err_des;
 
-	/*String table */
-	d_fun->function.strings =
+	/*String table*/
+	/*1 - source dev (if present) , 1 - function, 1 - NULL */
+	if (d_fun->source_dev->desc && d_fun->source_dev->desc->str.strings)
+		d_fun->function.strings =
+		    kzalloc(3 * sizeof(struct usb_gadget_strings), GFP_KERNEL);
+	else
+		d_fun->function.strings =
 		    kzalloc(2 * sizeof(struct usb_gadget_strings), GFP_KERNEL);
 
 	if (!d_fun->function.strings) {
@@ -725,6 +808,8 @@ static struct usb_function *dvct_alloc_func(struct usb_function_instance *inst)
 	}
 
 	d_fun->function.strings[0] = &d_fun->desc.str;
+	if (d_fun->source_dev->desc && d_fun->source_dev->desc->str.strings)
+		d_fun->function.strings[1] = &d_fun->source_dev->desc->str;
 
 	d_fun->function.name = "dvctrace";
 	d_fun->function.fs_descriptors = d_fun->desc.fs;
diff --git a/drivers/usb/gadget/function/u_dvctrace.h b/drivers/usb/gadget/function/u_dvctrace.h
index 564d6fa7525d..56a5d0cd577a 100644
--- a/drivers/usb/gadget/function/u_dvctrace.h
+++ b/drivers/usb/gadget/function/u_dvctrace.h
@@ -37,6 +37,7 @@ struct dvct_function_desc {
 
 	/* strings */
 	struct usb_gadget_strings str;
+	struct dvct_string_lookup *lk_tbl;
 };
 
 struct dvct_function {
diff --git a/include/linux/dvctrace.h b/include/linux/dvctrace.h
index 18291efb18b6..4a21f58b1aae 100644
--- a/include/linux/dvctrace.h
+++ b/include/linux/dvctrace.h
@@ -50,22 +50,53 @@
 #define dvct_clr_status(s, m) atomic_set(s, atomic_read(s) & (~(m)))
 #define dvct_get_status(s, m) (atomic_read(s) & (m))
 
+/**
+ * dvct_string_lookup - helper struct to better manage the string id allocation
+ * @str: the usb string to allocate the id for
+ * @id:	the location in the descriptor where the id should be updated
+ */
+struct dvct_string_lookup {
+	struct usb_string *str;
+	u8 *id;			/*points to the location of the string id */
+};
+
+/**
+ * dvctrace_usb_descriptors - holds DvC Trace usb descriptors information
+ * @dvc_spec: Dvc Trace specific descriptors, will be added in the function
+ *	usb descriptors.
+ * @str: Usb gadget string table for strings referenced in @dvc_spec.
+ * @lk_tbl: Strings lookup table.
+ *
+ * From a strict USB point of view the descriptors are optional so @dvc_spec,
+ * @str.strings and @lk_tbl can be null. However the dvc-trace host
+ * implementation might need them.
+ */
+struct dvct_usb_descriptors {
+	struct usb_descriptor_header **dvc_spec; /*null terminated*/
+	struct usb_gadget_strings str;
+	struct dvct_string_lookup *lk_tbl;/*null terminated*/
+};
+
 /**
  * dvct_source_device - DvC Trace function to source (backend) interface
  *
  * @name_add: postfix used to compute the source name (<driver_name>-<name_add>)
  * @protocol: Interface protocol code (used in IAD, control and data
+ * @static_desc: DvC-Trace specific usb descriptors, provided by the driver
+ *			interface descriptors)
  *
- * @instance_taken, @function_taken, @lock, @device are reserved for
+ * @instance_taken, @function_taken, @lock, @device, @desc are reserved for
  * internal use only.
  */
 struct dvct_source_device {
 	const char *name_add;
 	u8 protocol;
+	struct dvct_usb_descriptors static_desc;
 	u32 instance_taken:1;
 	u32 function_taken:1;
 	spinlock_t lock;
 	struct device device;
+	struct dvct_usb_descriptors *desc;
 };
 
 /**
-- 
2.19.1

