From 2775f149611fa81e9e228e1a5a40f766bfb7893e Mon Sep 17 00:00:00 2001
From: Sia Jee Heng <jee.heng.sia@intel.com>
Date: Mon, 7 Sep 2020 14:59:09 +0800
Subject: [PATCH 14/21] dmaengine: dw-axi-dmac: Add Intel KeemBay AxiDMA BYTE
 and HALFWORD registers

Set BYTE and HALFWORD registers for memory to device operation. These
registers are not needed for device to memory operation.

Upstream-Status: Pending

Signed-off-by: Sia Jee Heng <jee.heng.sia@intel.com>
---
 .../dma/dw-axi-dmac/dw-axi-dmac-platform.c    | 38 ++++++++++++++++++-
 1 file changed, 36 insertions(+), 2 deletions(-)

diff --git a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
index 012677822794..6c95a3a5a354 100644
--- a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
+++ b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
@@ -312,7 +312,7 @@ static void axi_chan_block_xfer_start(struct axi_dma_chan *chan,
 				      struct axi_dma_desc *first)
 {
 	u32 priority = chan->chip->dw->hdata->priority[chan->id];
-	u32 reg, irq_mask;
+	u32 reg, irq_mask, reg_width, offset, val;
 	u8 lms = 0; /* Select AXI0 master for LLI fetching */
 
 	if (unlikely(axi_chan_is_hw_enable(chan))) {
@@ -334,6 +334,24 @@ static void axi_chan_block_xfer_start(struct axi_dma_chan *chan,
 	       DWAXIDMAC_HS_SEL_HW << CH_CFG_H_HS_SEL_SRC_POS);
 	switch (chan->direction) {
 	case DMA_MEM_TO_DEV:
+		if (chan->chip->apb_regs) {
+			reg_width = __ffs(chan->config.dst_addr_width);
+			/* Configure Byte and Halfword register
+			 * for MEM_TO_DEV only
+			 */
+			if (reg_width == DWAXIDMAC_TRANS_WIDTH_16) {
+				offset = DMAC_APB_HALFWORD_WR_CH_EN;
+				val = readl(chan->chip->apb_regs + offset);
+				val |= 0x1 << chan->id;
+				writel(val, chan->chip->apb_regs + offset);
+			} else if (reg_width == DWAXIDMAC_TRANS_WIDTH_8) {
+				offset = DMAC_APB_BYTE_WR_CH_EN;
+				val = readl(chan->chip->apb_regs + offset);
+				val |= 0x1 << chan->id;
+				writel(val, chan->chip->apb_regs + offset);
+			}
+		}
+
 		reg |= (chan->config.device_fc ?
 			DWAXIDMAC_TT_FC_MEM_TO_PER_DST :
 			DWAXIDMAC_TT_FC_MEM_TO_PER_DMAC)
@@ -1055,7 +1073,9 @@ static irqreturn_t dw_axi_dma_interrupt(int irq, void *dev_id)
 static int dma_chan_terminate_all(struct dma_chan *dchan)
 {
 	struct axi_dma_chan *chan = dchan_to_axi_dma_chan(dchan);
+	u32 reg_width = __ffs(chan->config.dst_addr_width);
 	unsigned long flags;
+	u32 offset, val;
 	u32 count = 0;
 	LIST_HEAD(head);
 
@@ -1070,8 +1090,22 @@ static int dma_chan_terminate_all(struct dma_chan *dchan)
 				"%s failed to stop\n", axi_chan_name(chan));
 	}
 
-	if (chan->chip->apb_regs && chan->direction != DMA_MEM_TO_MEM)
+	if (chan->chip->apb_regs && chan->direction != DMA_MEM_TO_MEM) {
 		dw_axi_dma_set_hw_channel(chan->chip, chan->hw_hs_num, false);
+		if (chan->direction == DMA_MEM_TO_DEV) {
+			if (reg_width == DWAXIDMAC_TRANS_WIDTH_8) {
+				offset = DMAC_APB_BYTE_WR_CH_EN;
+				val = ioread32(chan->chip->apb_regs + offset);
+				val &= ~(0x01 << chan->id);
+				iowrite32(val, chan->chip->apb_regs + offset);
+			} else if (reg_width == DWAXIDMAC_TRANS_WIDTH_16) {
+				offset = DMAC_APB_HALFWORD_WR_CH_EN;
+				val = ioread32(chan->chip->apb_regs + offset);
+				val &= ~(0x01 << chan->id);
+				iowrite32(val, chan->chip->apb_regs + offset);
+			}
+		}
+	}
 
 	vchan_get_all_descriptors(&chan->vc, &head);
 
-- 
2.27.0

