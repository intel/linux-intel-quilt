From 0ce570bb3e93d4f0c6ca58249e44b584970c64e3 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Mon, 2 Dec 2019 11:08:35 +0000
Subject: [PATCH 2464/4530] drm/i915/gt: Use soft-rc6 for w/a protection

Now that we have soft-rc6 in place, we can use that instead of the
forcewake to disable rc6 while active; preferred by a few
microbenchmarks.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Acked-by: Andi Shyti <andi.shyti@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20191202110836.2342685-1-chris@chris-wilson.co.uk
---
 drivers/gpu/drm/i915/gt/intel_gt_pm.c |  9 ---------
 drivers/gpu/drm/i915/gt/intel_rc6.c   | 19 +++++++++++++------
 drivers/gpu/drm/i915/gt/intel_rc6.h   |  1 -
 3 files changed, 13 insertions(+), 16 deletions(-)

diff --git a/drivers/gpu/drm/i915/gt/intel_gt_pm.c b/drivers/gpu/drm/i915/gt/intel_gt_pm.c
index a1a47670ff8b..b61bd5948b5e 100644
--- a/drivers/gpu/drm/i915/gt/intel_gt_pm.c
+++ b/drivers/gpu/drm/i915/gt/intel_gt_pm.c
@@ -61,9 +61,6 @@ static int __gt_unpark(struct intel_wakeref *wf)
 	gt->awake = intel_display_power_get(i915, POWER_DOMAIN_GT_IRQ);
 	GEM_BUG_ON(!gt->awake);
 
-	if (NEEDS_RC6_CTX_CORRUPTION_WA(i915))
-		intel_uncore_forcewake_get(gt->uncore, FORCEWAKE_ALL);
-
 	intel_rc6_unpark(&gt->rc6);
 	intel_rps_unpark(&gt->rps);
 	i915_pmu_gt_unparked(i915);
@@ -91,12 +88,6 @@ static int __gt_park(struct intel_wakeref *wf)
 	/* Everything switched off, flush any residual interrupt just in case */
 	intel_synchronize_irq(i915);
 
-	if (NEEDS_RC6_CTX_CORRUPTION_WA(i915)) {
-		intel_rc6_ctx_wa_check(&gt->rc6);
-		intel_uncore_forcewake_put(gt->uncore, FORCEWAKE_ALL);
-	}
-
-	/* Defer dropping the display power well for 100ms, it's slow! */
 	GEM_BUG_ON(!wakeref);
 	intel_display_power_put_async(i915, POWER_DOMAIN_GT_IRQ, wakeref);
 
diff --git a/drivers/gpu/drm/i915/gt/intel_rc6.c b/drivers/gpu/drm/i915/gt/intel_rc6.c
index c4379c49c20d..f58674f4aaec 100644
--- a/drivers/gpu/drm/i915/gt/intel_rc6.c
+++ b/drivers/gpu/drm/i915/gt/intel_rc6.c
@@ -527,26 +527,25 @@ void intel_rc6_ctx_wa_resume(struct intel_rc6 *rc6)
  * Check if an RC6 CTX corruption has happened since the last check and if so
  * disable RC6 and runtime power management.
 */
-void intel_rc6_ctx_wa_check(struct intel_rc6 *rc6)
+static bool intel_rc6_ctx_wa_check(struct intel_rc6 *rc6)
 {
 	struct drm_i915_private *i915 = rc6_to_i915(rc6);
 
 	if (!NEEDS_RC6_CTX_CORRUPTION_WA(i915))
-		return;
+		return false;
 
 	if (rc6->ctx_corrupted)
-		return;
+		return false;
 
 	if (!intel_rc6_ctx_corrupted(rc6))
-		return;
+		return false;
 
 	dev_notice(i915->drm.dev,
 		   "RC6 context corruption, disabling runtime power management\n");
 
-	intel_rc6_disable(rc6);
 	rc6->ctx_corrupted = true;
 
-	return;
+	return true;
 }
 
 static void __intel_rc6_disable(struct intel_rc6 *rc6)
@@ -627,6 +626,9 @@ void intel_rc6_enable(struct intel_rc6 *rc6)
 	else if (INTEL_GEN(i915) >= 6)
 		gen6_rc6_enable(rc6);
 
+	if (NEEDS_RC6_CTX_CORRUPTION_WA(i915))
+		rc6->ctl_enable = 0;
+
 	intel_uncore_forcewake_put(uncore, FORCEWAKE_ALL);
 
 	/* rc6 is ready, runtime-pm is go! */
@@ -652,6 +654,11 @@ void intel_rc6_park(struct intel_rc6 *rc6)
 	if (!rc6->enabled)
 		return;
 
+	if (unlikely(intel_rc6_ctx_wa_check(rc6))) {
+		intel_rc6_disable(rc6);
+		return;
+	}
+
 	/* Turn off the HW timers and go directly to rc6 */
 	set(uncore, GEN6_RC_CONTROL, GEN6_RC_CTL_RC6_ENABLE);
 	set(uncore, GEN6_RC_STATE, 0x4 << RC_SW_TARGET_STATE_SHIFT);
diff --git a/drivers/gpu/drm/i915/gt/intel_rc6.h b/drivers/gpu/drm/i915/gt/intel_rc6.h
index 20d740ff7e55..f2821576bfd3 100644
--- a/drivers/gpu/drm/i915/gt/intel_rc6.h
+++ b/drivers/gpu/drm/i915/gt/intel_rc6.h
@@ -25,7 +25,6 @@ void intel_rc6_disable(struct intel_rc6 *rc6);
 u64 intel_rc6_residency_ns(struct intel_rc6 *rc6, i915_reg_t reg);
 u64 intel_rc6_residency_us(struct intel_rc6 *rc6, i915_reg_t reg);
 
-void intel_rc6_ctx_wa_check(struct intel_rc6 *rc6);
 void intel_rc6_ctx_wa_resume(struct intel_rc6 *rc6);
 
 #endif /* INTEL_RC6_H */
-- 
2.17.1

