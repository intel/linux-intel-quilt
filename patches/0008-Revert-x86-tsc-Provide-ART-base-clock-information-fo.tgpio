From db2aafff7a89ad9dd519dd5df83f13e514f216c1 Mon Sep 17 00:00:00 2001
From: Hao Li <hao3.li@intel.com>
Date: Wed, 25 Sep 2024 12:39:04 +0800
Subject: [PATCH 08/43] Revert "x86/tsc: Provide ART base clock information for
 TSC"

This reverts commit 3a52886c8f972c3a5b70bfec330c71817cd7fc63.

Signed-off-by: Hao Li <hao3.li@intel.com>
---
 arch/x86/kernel/tsc.c           | 43 +++++++++++++++------------------
 include/linux/clocksource_ids.h |  1 -
 2 files changed, 19 insertions(+), 25 deletions(-)

diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c
index 731c711b55a6..7f3eab1d0ce4 100644
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@ -53,9 +53,9 @@ int tsc_clocksource_reliable;
 
 static int __read_mostly tsc_force_recalibrate;
 
-static struct clocksource_base art_base_clk = {
-	.id    = CSID_X86_ART,
-};
+static u32 art_to_tsc_numerator;
+static u32 art_to_tsc_denominator;
+static u64 art_to_tsc_offset;
 static bool have_art;
 
 struct cyc2ns {
@@ -1070,13 +1070,14 @@ core_initcall(cpufreq_register_tsc_scaling);
 #endif /* CONFIG_CPU_FREQ */
 
 #define ART_MIN_DENOMINATOR (1)
+#define ART_CPUID_LEAF (0x15)
 
 /*
  * If ART is present detect the numerator:denominator to convert to TSC
  */
 static void __init detect_art(void)
 {
-	unsigned int unused;
+	unsigned int unused[2];
 
 	if (boot_cpu_data.cpuid_level < CPUID_LEAF_TSC)
 		return;
@@ -1091,14 +1092,13 @@ static void __init detect_art(void)
 	    tsc_async_resets)
 		return;
 
-	cpuid(CPUID_LEAF_TSC, &art_base_clk.denominator,
-	      &art_base_clk.numerator, &art_base_clk.freq_khz, &unused);
+	cpuid(ART_CPUID_LEAF, &art_to_tsc_denominator,
+	      &art_to_tsc_numerator, unused, unused+1);
 
-	art_base_clk.freq_khz /= KHZ;
-	if (art_base_clk.denominator < ART_MIN_DENOMINATOR)
+	if (art_to_tsc_denominator < ART_MIN_DENOMINATOR)
 		return;
 
-	rdmsrl(MSR_IA32_TSC_ADJUST, art_base_clk.offset);
+	rdmsrl(MSR_IA32_TSC_ADJUST, art_to_tsc_offset);
 
 	/* Make this sticky over multiple CPU init calls */
 	setup_force_cpu_cap(X86_FEATURE_ART);
@@ -1303,13 +1303,13 @@ struct system_counterval_t convert_art_to_tsc(u64 art)
 {
 	u64 tmp, res, rem;
 
-	rem = do_div(art, art_base_clk.denominator);
+	rem = do_div(art, art_to_tsc_denominator);
 
-	res = art * art_base_clk.numerator;
-	tmp = rem * art_base_clk.numerator;
+	res = art * art_to_tsc_numerator;
+	tmp = rem * art_to_tsc_numerator;
 
-	do_div(tmp, art_base_clk.denominator);
-	res += tmp + art_base_clk.offset;
+	do_div(tmp, art_to_tsc_denominator);
+	res += tmp + art_to_tsc_offset;
 
 	return (struct system_counterval_t) {
 		.cs_id	= have_art ? CSID_X86_TSC : CSID_GENERIC,
@@ -1356,6 +1356,7 @@ struct system_counterval_t convert_art_ns_to_tsc(u64 art_ns)
 }
 EXPORT_SYMBOL(convert_art_ns_to_tsc);
 
+
 static void tsc_refine_calibration_work(struct work_struct *work);
 static DECLARE_DELAYED_WORK(tsc_irqwork, tsc_refine_calibration_work);
 /**
@@ -1457,10 +1458,8 @@ static void tsc_refine_calibration_work(struct work_struct *work)
 	if (tsc_unstable)
 		goto unreg;
 
-	if (boot_cpu_has(X86_FEATURE_ART)) {
+	if (boot_cpu_has(X86_FEATURE_ART))
 		have_art = true;
-		clocksource_tsc.base = &art_base_clk;
-	}
 	clocksource_register_khz(&clocksource_tsc, tsc_khz);
 unreg:
 	clocksource_unregister(&clocksource_tsc_early);
@@ -1485,10 +1484,8 @@ static int __init init_tsc_clocksource(void)
 	 * the refined calibration and directly register it as a clocksource.
 	 */
 	if (boot_cpu_has(X86_FEATURE_TSC_KNOWN_FREQ)) {
-		if (boot_cpu_has(X86_FEATURE_ART)) {
+		if (boot_cpu_has(X86_FEATURE_ART))
 			have_art = true;
-			clocksource_tsc.base = &art_base_clk;
-		}
 		clocksource_register_khz(&clocksource_tsc, tsc_khz);
 		clocksource_unregister(&clocksource_tsc_early);
 
@@ -1512,12 +1509,10 @@ static bool __init determine_cpu_tsc_frequencies(bool early)
 
 	if (early) {
 		cpu_khz = x86_platform.calibrate_cpu();
-		if (tsc_early_khz) {
+		if (tsc_early_khz)
 			tsc_khz = tsc_early_khz;
-		} else {
+		else
 			tsc_khz = x86_platform.calibrate_tsc();
-			clocksource_tsc.freq_khz = tsc_khz;
-		}
 	} else {
 		/* We should not be here with non-native cpu calibration */
 		WARN_ON(x86_platform.calibrate_cpu != native_calibrate_cpu);
diff --git a/include/linux/clocksource_ids.h b/include/linux/clocksource_ids.h
index c4ef4ae2eded..cd0c36a9d333 100644
--- a/include/linux/clocksource_ids.h
+++ b/include/linux/clocksource_ids.h
@@ -10,7 +10,6 @@ enum clocksource_ids {
 	CSID_X86_TSC_EARLY,
 	CSID_X86_TSC,
 	CSID_X86_KVM_CLK,
-	CSID_X86_ART,
 	CSID_MAX,
 };
 
-- 
2.25.1

