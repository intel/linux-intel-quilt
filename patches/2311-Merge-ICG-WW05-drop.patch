From 58d240fe8cc8e0771e87fa8b994590e71fc2ee78 Mon Sep 17 00:00:00 2001
From: spoluri <sarat.chandra.poluri@intel.com>
Date: Fri, 15 Feb 2019 15:22:59 -0700
Subject: [PATCH 2311/2345] Merge ICG WW05 drop

Signed-off-by: spoluri <sarat.chandra.poluri@intel.com>
---
 .../media/i2c/crlmodule/crl_ov495_configuration.h  | 284 ++++++++++++
 drivers/media/i2c/crlmodule/crlmodule-data.c       |   2 +
 drivers/media/i2c/ti960-reg.h                      |  24 +
 drivers/media/i2c/ti960.c                          | 514 +++++++++++++++++----
 drivers/media/i2c/ti964.c                          |   5 +-
 drivers/media/pci/intel/ici/Makefile               |   2 +-
 drivers/media/pci/intel/ici/libintel-ipu4_ici.c    |   7 -
 drivers/media/pci/intel/ipu-bus.c                  |   1 +
 drivers/media/pci/intel/ipu-buttress.c             |   6 +-
 drivers/media/pci/intel/ipu-cpd.c                  |   8 +
 drivers/media/pci/intel/ipu-cpd.h                  |   6 +
 drivers/media/pci/intel/ipu-fw-com.c               |   4 +-
 drivers/media/pci/intel/ipu-fw-isys.c              |   7 +-
 drivers/media/pci/intel/ipu-fw-isys.h              |  15 +-
 drivers/media/pci/intel/ipu-fw-psys.h              |   8 +
 drivers/media/pci/intel/ipu-isys-csi2-be-soc.c     |   9 +-
 drivers/media/pci/intel/ipu-isys-csi2-be.c         |   1 -
 drivers/media/pci/intel/ipu-isys-csi2.c            |  13 +-
 drivers/media/pci/intel/ipu-isys-media.h           |  70 +++
 drivers/media/pci/intel/ipu-isys-queue.c           |  18 +-
 drivers/media/pci/intel/ipu-isys-queue.h           |   1 +
 drivers/media/pci/intel/ipu-isys-subdev.c          |  93 ++--
 drivers/media/pci/intel/ipu-isys-subdev.h          |   5 +-
 drivers/media/pci/intel/ipu-isys-tpg.c             |  12 +-
 drivers/media/pci/intel/ipu-isys-tpg.h             |   6 +-
 drivers/media/pci/intel/ipu-isys-video.c           |  79 ++--
 drivers/media/pci/intel/ipu-isys.c                 |  52 ++-
 drivers/media/pci/intel/ipu-isys.h                 |   5 +
 drivers/media/pci/intel/ipu-psys.c                 |  92 +++-
 drivers/media/pci/intel/ipu-psys.h                 |  18 +-
 drivers/media/pci/intel/ipu.c                      |  35 +-
 drivers/media/pci/intel/ipu.h                      |   3 +
 drivers/media/pci/intel/ipu4/Makefile              |   1 -
 .../pci/intel/ipu4/ipu-platform-isys-csi2-reg.h    |   3 +
 drivers/media/pci/intel/ipu4/ipu-platform.h        |   3 +-
 .../media/pci/intel/ipu4/ipu4-css/Makefile.isyslib |   5 -
 .../intel/ipu4/ipu4-css/ia_css_fw_pkg_release.h    |   2 +-
 .../media/pci/intel/ipu4/ipu4-css/ipu-wrapper.c    |   1 +
 .../interface/ia_css_isys_fw_bridged_types.h       |   1 +
 .../interface/ia_css_isysapi_proxy_region_defs.h   |   9 -
 .../isysapi/interface/ia_css_isysapi_types.h       |   1 +
 .../ipu4/ipu4-css/lib2600/support/assert_support.h |  10 +
 .../pci/intel/ipu4/ipu4-css/lib2600psys/Makefile   |   2 +-
 .../DSS_V2_program_group/ia_css_fw_pkg_release.h   |   2 +-
 .../lib2600psys/lib/support/assert_support.h       |  10 +
 .../lib/vied_parameters/vied_parameters.mk         |   1 -
 .../ipu4/ipu4-css/lib2600psys/libcsspsys2600.c     |  14 +-
 .../media/pci/intel/ipu4/ipu4-css/libintel-ipu4.c  |  11 +-
 drivers/media/pci/intel/ipu4/ipu4-isys.c           |  40 +-
 .../pci/intel/ipu4/ipu4p-css/Makefile.isyslib      |   5 -
 .../intel/ipu4/ipu4p-css/ia_css_fw_pkg_release.h   |   2 +-
 .../media/pci/intel/ipu4/ipu4p-css/ipu-wrapper.c   |   1 +
 .../lib2600/cpd_binary/ia_css_fw_pkg_release.h     |   2 +-
 .../lib2600/isysapi/interface/ia_css_isysapi.h     |   5 -
 .../ipu4p-css/lib2600/support/assert_support.h     |  10 +
 .../pci/intel/ipu4/ipu4p-css/lib2600psys/Makefile  |   2 +-
 .../lib/CNL_program_group/ia_css_fw_pkg_release.h  |   2 +-
 .../lib/ICL_program_group/ia_css_fw_pkg_release.h  |   2 +-
 .../lib2600psys/lib/config/psys/subsystem_cnlB0.mk |   3 +
 .../lib2600psys/lib/support/assert_support.h       |  10 +
 .../ipu4/ipu4p-css/lib2600psys/libcsspsys2600.c    |  10 +-
 .../pci/intel/ipu4/ipu4p-css/libintel-ipu4p.c      |  11 +-
 include/media/crlmodule.h                          |   4 +-
 include/media/ti960.h                              |   7 +-
 include/uapi/linux/crlmodule.h                     |   3 +
 65 files changed, 1290 insertions(+), 310 deletions(-)
 create mode 100644 drivers/media/i2c/crlmodule/crl_ov495_configuration.h
 create mode 120000 drivers/media/pci/intel/ipu4/ipu4-css/ipu-wrapper.c
 create mode 120000 drivers/media/pci/intel/ipu4/ipu4p-css/ipu-wrapper.c

diff --git a/drivers/media/i2c/crlmodule/crl_ov495_configuration.h b/drivers/media/i2c/crlmodule/crl_ov495_configuration.h
new file mode 100644
index 00000000..6884cf5
--- /dev/null
+++ b/drivers/media/i2c/crlmodule/crl_ov495_configuration.h
@@ -0,0 +1,284 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2017 - 2018 Intel Corporation
+ *
+ * Author: Ying Chang <ying.chang@intel.com>
+ *         Meng J Chen <meng.j.chen@intel.com>
+ *         Zhaox Li <zhaox.li@intel.com>
+ *
+ */
+
+#ifndef __CRLMODULE_OV495_CONFIGURATION_H_
+#define __CRLMODULE_OV495_CONFIGURATION_H_
+
+#include "crlmodule-sensor-ds.h"
+
+struct crl_sensor_detect_config ov495_sensor_detect_regset[] = {
+	{
+		.reg = {0x3000, CRL_REG_LEN_08BIT, 0xFF},
+		.width = 8,
+	},
+	{
+		.reg = {0x3001, CRL_REG_LEN_08BIT, 0xFF},
+		.width = 8,
+	},
+	{
+		.reg = {0x3002, CRL_REG_LEN_08BIT, 0xFF},
+		.width = 8,
+	},
+	{
+		.reg = {0x3003, CRL_REG_LEN_08BIT, 0xFF},
+		.width = 8,
+	},
+};
+
+static struct crl_pll_configuration ov495_pll_configurations[] = {
+	{
+		.input_clk = 27000000,
+		.op_sys_clk = 400000000,
+		.bitsperpixel = 16,
+		.pixel_rate_csi = 108000000,
+		.pixel_rate_pa = 108000000, /* pixel_rate = op_sys_clk*2 *csi_lanes/bitsperpixel */
+		.csi_lanes = 4,
+		.comp_items = 0,
+		.ctrl_data = 0,
+		.pll_regs_items = 0,
+		.pll_regs = 0,
+	},
+};
+
+static struct crl_subdev_rect_rep ov495_1280_1080_rects[] = {
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_PIXEL_ARRAY,
+		.in_rect.left = 0,
+		.in_rect.top = 0,
+		.in_rect.width = 1280,
+		.in_rect.height = 1080,
+		.out_rect.left = 0,
+		.out_rect.top = 0,
+		.out_rect.width = 1280,
+		.out_rect.height = 1080,
+	},
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_BINNER,
+		.in_rect.left = 0,
+		.in_rect.top = 0,
+		.in_rect.width = 1280,
+		.in_rect.height = 1080,
+		.out_rect.left = 0,
+		.out_rect.top = 0,
+		.out_rect.width = 1280,
+		.out_rect.height = 1080,
+	},
+};
+
+static struct crl_subdev_rect_rep ov495_1920_1080_rects[] = {
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_PIXEL_ARRAY,
+		.in_rect.left = 0,
+		.in_rect.top = 0,
+		.in_rect.width = 1920,
+		.in_rect.height = 1080,
+		.out_rect.left = 0,
+		.out_rect.top = 0,
+		.out_rect.width = 1920,
+		.out_rect.height = 1080,
+	},
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_BINNER,
+		.in_rect.left = 0,
+		.in_rect.top = 0,
+		.in_rect.width = 1920,
+		.in_rect.height = 1080,
+		.out_rect.left = 0,
+		.out_rect.top = 0,
+		.out_rect.width = 1920,
+		.out_rect.height = 1080,
+	},
+};
+
+static struct crl_register_write_rep ov495_1920x1080_regs[] = {
+	{0x3516, CRL_REG_LEN_08BIT, 0x00},
+	{0x354d, CRL_REG_LEN_08BIT, 0x10},
+	{0x354a, CRL_REG_LEN_08BIT, 0x1d},
+	{0x0500, CRL_REG_LEN_08BIT, 0x00},
+	{0x30c0, CRL_REG_LEN_08BIT, 0xe2},
+	{0x0000, CRL_REG_LEN_DELAY, 0x0a},
+
+	{0x3516, CRL_REG_LEN_08BIT, 0x00},
+	{0x354d, CRL_REG_LEN_08BIT, 0x10},
+	{0x354a, CRL_REG_LEN_08BIT, 0x1d},
+	{0x0500, CRL_REG_LEN_08BIT, 0x01},
+	{0x30c0, CRL_REG_LEN_08BIT, 0xe2},
+	{0x0000, CRL_REG_LEN_DELAY, 0x0a},
+};
+
+static struct crl_register_write_rep ov495_1280x1080_regs[] = {
+	{0x3516, CRL_REG_LEN_08BIT, 0x00},
+	{0x354d, CRL_REG_LEN_08BIT, 0x10},
+	{0x354a, CRL_REG_LEN_08BIT, 0x1d},
+	{0x7800, CRL_REG_LEN_08BIT, 0x00},
+	{0x0500, CRL_REG_LEN_08BIT, 0x00},
+	{0x0501, CRL_REG_LEN_08BIT, 0x01},
+	{0x0502, CRL_REG_LEN_08BIT, 0x01},
+	{0x0503, CRL_REG_LEN_08BIT, 0x40},
+	{0x0504, CRL_REG_LEN_08BIT, 0x00},
+	{0x0505, CRL_REG_LEN_08BIT, 0x00},
+	{0x0506, CRL_REG_LEN_08BIT, 0x05},
+	{0x0507, CRL_REG_LEN_08BIT, 0x00},
+	{0x0508, CRL_REG_LEN_08BIT, 0x04},
+	{0x0509, CRL_REG_LEN_08BIT, 0x38},
+	{0x30c0, CRL_REG_LEN_08BIT, 0xc3},
+	{0x0000, CRL_REG_LEN_DELAY, 0x0a},
+};
+
+static struct crl_mode_rep ov495_modes[] = {
+	{
+		.sd_rects_items = ARRAY_SIZE(ov495_1280_1080_rects),
+		.sd_rects = ov495_1280_1080_rects,
+		.binn_hor = 1,
+		.binn_vert = 1,
+		.scale_m = 1,
+		.width = 1280,
+		.height = 1080,
+		.min_llp = 2250,
+		.min_fll = 1320,
+		.mode_regs_items = ARRAY_SIZE(ov495_1280x1080_regs),
+		.mode_regs = ov495_1280x1080_regs,
+	},
+	{
+		.sd_rects_items = ARRAY_SIZE(ov495_1920_1080_rects),
+		.sd_rects = ov495_1920_1080_rects,
+		.binn_hor = 1,
+		.binn_vert = 1,
+		.scale_m = 1,
+		.width = 1920,
+		.height = 1080,
+		.min_llp = 2250,
+		.min_fll = 1320,
+		.mode_regs_items = ARRAY_SIZE(ov495_1920x1080_regs),
+		.mode_regs = ov495_1920x1080_regs,
+	},
+};
+
+static struct crl_sensor_subdev_config ov495_sensor_subdevs[] = {
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_BINNER,
+		.name = "ov495 binner",
+	},
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_PIXEL_ARRAY,
+		.name = "ov495 pixel array",
+	}
+};
+
+static struct crl_sensor_limits ov495_sensor_limits = {
+	.x_addr_min = 0,
+	.y_addr_min = 0,
+	.x_addr_max = 1920,
+	.y_addr_max = 1080,
+	.min_frame_length_lines = 240,
+	.max_frame_length_lines = 65535,
+	.min_line_length_pixels = 320,
+	.max_line_length_pixels = 32752,
+};
+
+static struct crl_csi_data_fmt ov495_crl_csi_data_fmt[] = {
+	{
+		.code = MEDIA_BUS_FMT_YUYV8_1X16,
+		.pixel_order = CRL_PIXEL_ORDER_IGNORE,
+		.bits_per_pixel = 16,
+	},
+	{
+		.code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.pixel_order = CRL_PIXEL_ORDER_IGNORE,
+		.bits_per_pixel = 16,
+	},
+};
+
+static struct crl_v4l2_ctrl ov495_v4l2_ctrls[] = {
+	{
+		.sd_type = CRL_SUBDEV_TYPE_BINNER,
+		.op_type = CRL_V4L2_CTRL_SET_OP,
+		.context = SENSOR_IDLE,
+		.ctrl_id = V4L2_CID_LINK_FREQ,
+		.name = "V4L2_CID_LINK_FREQ",
+		.type = CRL_V4L2_CTRL_TYPE_MENU_INT,
+		.data.v4l2_int_menu.def = 0,
+		.data.v4l2_int_menu.max = 0,
+		.data.v4l2_int_menu.menu = 0,
+		.flags = 0,
+		.impact = CRL_IMPACTS_NO_IMPACT,
+		.regs_items = 0,
+		.regs = 0,
+		.dep_items = 0,
+		.dep_ctrls = 0,
+	},
+	{
+		.sd_type = CRL_SUBDEV_TYPE_PIXEL_ARRAY,
+		.op_type = CRL_V4L2_CTRL_GET_OP,
+		.context = SENSOR_POWERED_ON,
+		.ctrl_id = V4L2_CID_PIXEL_RATE,
+		.name = "V4L2_CID_PIXEL_RATE_PA",
+		.type = CRL_V4L2_CTRL_TYPE_INTEGER,
+		.data.std_data.min = 0,
+		.data.std_data.max = INT_MAX,
+		.data.std_data.step = 1,
+		.data.std_data.def = 0,
+		.flags = 0,
+		.impact = CRL_IMPACTS_NO_IMPACT,
+		.regs_items = 0,
+		.regs = 0,
+		.dep_items = 0,
+		.dep_ctrls = 0,
+	},
+	{
+		.sd_type = CRL_SUBDEV_TYPE_BINNER,
+		.op_type = CRL_V4L2_CTRL_GET_OP,
+		.context = SENSOR_POWERED_ON,
+		.ctrl_id = V4L2_CID_PIXEL_RATE,
+		.name = "V4L2_CID_PIXEL_RATE_CSI",
+		.type = CRL_V4L2_CTRL_TYPE_INTEGER,
+		.data.std_data.min = 0,
+		.data.std_data.max = INT_MAX,
+		.data.std_data.step = 1,
+		.data.std_data.def = 0,
+		.flags = 0,
+		.impact = CRL_IMPACTS_NO_IMPACT,
+		.regs_items = 0,
+		.regs = 0,
+		.dep_items = 0,
+		.dep_ctrls = 0,
+	},
+};
+
+struct crl_sensor_configuration ov495_crl_configuration = {
+
+	.subdev_items = ARRAY_SIZE(ov495_sensor_subdevs),
+	.subdevs = ov495_sensor_subdevs,
+
+	.pll_config_items = ARRAY_SIZE(ov495_pll_configurations),
+	.pll_configs = ov495_pll_configurations,
+
+	.id_reg_items = ARRAY_SIZE(ov495_sensor_detect_regset),
+	.id_regs = ov495_sensor_detect_regset,
+
+	.sensor_limits = &ov495_sensor_limits,
+
+	.modes_items = ARRAY_SIZE(ov495_modes),
+	.modes = ov495_modes,
+
+	.streamon_regs_items = 0,
+	.streamon_regs = 0,
+
+	.streamoff_regs_items = 0,
+	.streamoff_regs = 0,
+
+	.v4l2_ctrls_items = ARRAY_SIZE(ov495_v4l2_ctrls),
+	.v4l2_ctrl_bank = ov495_v4l2_ctrls,
+
+	.csi_fmts_items = ARRAY_SIZE(ov495_crl_csi_data_fmt),
+	.csi_fmts = ov495_crl_csi_data_fmt,
+
+};
+
+#endif  /* __CRLMODULE_OV495_CONFIGURATION_H_ */
diff --git a/drivers/media/i2c/crlmodule/crlmodule-data.c b/drivers/media/i2c/crlmodule/crlmodule-data.c
index e0aca47..13eeecc 100755
--- a/drivers/media/i2c/crlmodule/crlmodule-data.c
+++ b/drivers/media/i2c/crlmodule/crlmodule-data.c
@@ -33,6 +33,7 @@
 #include "crl_ar023z_configuration.h"
 #include "crl_ov2775_configuration.h"
 #include "crl_ox03a10_configuration.h"
+#include "crl_ov495_configuration.h"
 
 static const struct crlmodule_sensors supported_sensors[] = {
 	{ "i2c-OVTIF858:00", "ov13858", &ov13858_crl_configuration},
@@ -80,6 +81,7 @@ static const struct crlmodule_sensors supported_sensors[] = {
 	{ "AR023Z", "ar023z", &ar023z_crl_configuration },
 	{ "OV2775", "ov2775", &ov2775_crl_configuration },
 	{ "OX03A10", "ox03a10", &ox03a10_crl_configuration },
+	{ "OV495", "ov495", &ov495_crl_configuration},
 };
 
 /*
diff --git a/drivers/media/i2c/ti960-reg.h b/drivers/media/i2c/ti960-reg.h
index 260c178..0f34651 100644
--- a/drivers/media/i2c/ti960-reg.h
+++ b/drivers/media/i2c/ti960-reg.h
@@ -9,6 +9,11 @@ struct ti960_register_write {
 	u8 val;
 };
 
+struct ti960_register_devid {
+	u8 reg;
+	u8 val_expected;
+};
+
 static const struct ti960_register_write ti960_frame_sync_settings[2][5] = {
 	{
 		{0x18, 0x00}, /* Disable frame sync. */
@@ -151,6 +156,9 @@ static const struct ti960_register_write ti960_init_settings_2[] = {
 	{0xb2, 0x04},
 	{0xb1, 0x04},
 	{0xb2, 0x04},
+};
+
+static const struct ti960_register_write ti960_init_settings_3[] = {
 	{0x4c, 0x01},
 	{0x32, 0x01},
 	{0x33, 0x03},
@@ -166,6 +174,15 @@ static const struct ti960_register_write ti953_init_settings_2[] = {
 	{0x0e, 0xf0},
 };
 
+static const struct ti960_register_devid ti953_FPD3_RX_ID[] = {
+	{0xf0, 0x5f},
+	{0xf1, 0x55},
+	{0xf2, 0x42},
+	{0xf3, 0x39},
+	{0xf4, 0x35},
+	{0xf5, 0x33},
+};
+
 /* register definition */
 #define TI960_DEVID		0x0
 #define TI960_RESET		0x1
@@ -173,12 +190,15 @@ static const struct ti960_register_write ti953_init_settings_2[] = {
 #define TI960_FS_CTL		0x18
 #define TI960_FWD_CTL1		0x20
 #define TI960_RX_PORT_SEL	0x4c
+#define TI960_SER_ALIAS_ID	0x5c
 #define TI960_SLAVE_ID0		0x5d
 #define TI960_SLAVE_ALIAS_ID0	0x65
 #define TI960_PORT_CONFIG	0x6d
 #define TI960_BC_GPIO_CTL0	0x6e
+#define TI960_BC_GPIO_CTL1	0x6f
 #define TI960_RAW10_ID		0x70
 #define TI960_RAW12_ID		0x71
+#define TI960_CSI_VC_MAP	0x72
 #define TI960_PORT_CONFIG2	0x7c
 #define TI960_CSI_CTL           0x33
 
@@ -200,6 +220,10 @@ static const struct ti960_register_write ti953_init_settings_2[] = {
 #define TI960_GPIO1_FSIN	0xa0
 #define TI960_GPIO0_MASK	0x0f
 #define TI960_GPIO1_MASK	0xf0
+#define TI960_GPIO2_FSIN	0x0a
+#define TI960_GPIO3_FSIN	0xa0
+#define TI960_GPIO2_MASK	0x0f
+#define TI960_GPIO3_MASK	0xf0
 #define TI960_MIPI_800MBPS	0x2
 #define TI960_MIPI_1600MBPS	0x0
 #define TI960_CSI_ENABLE	0x1
diff --git a/drivers/media/i2c/ti960.c b/drivers/media/i2c/ti960.c
index 198f37f..f406f5a 100644
--- a/drivers/media/i2c/ti960.c
+++ b/drivers/media/i2c/ti960.c
@@ -8,6 +8,7 @@
 #include <linux/wait.h>
 #include <linux/delay.h>
 #include <linux/platform_device.h>
+#include <linux/version.h>
 
 #include <media/media-device.h>
 #include <media/media-entity.h>
@@ -24,6 +25,7 @@ struct ti960_subdev {
 	unsigned short fsin_gpio;
 	unsigned short phy_i2c_addr;
 	unsigned short alias_i2c_addr;
+	unsigned short ser_i2c_addr;
 	char sd_name[16];
 };
 
@@ -75,6 +77,8 @@ static const u8 ti960_op_sys_clock_reg_val[] = {
  *    orders must be defined.
  */
 static const struct ti960_csi_data_format va_csi_data_formats[] = {
+	{ MEDIA_BUS_FMT_YUYV8_1X16, 16, 16, PIXEL_ORDER_GBRG, 0x1e },
+	{ MEDIA_BUS_FMT_UYVY8_1X16, 16, 16, PIXEL_ORDER_GBRG, 0x1e },
 	{ MEDIA_BUS_FMT_SGRBG16_1X16, 16, 16, PIXEL_ORDER_GRBG, 0x2e },
 	{ MEDIA_BUS_FMT_SRGGB16_1X16, 16, 16, PIXEL_ORDER_RGGB, 0x2e },
 	{ MEDIA_BUS_FMT_SBGGR16_1X16, 16, 16, PIXEL_ORDER_BGGR, 0x2e },
@@ -90,6 +94,8 @@ static const struct ti960_csi_data_format va_csi_data_formats[] = {
 };
 
 static const uint32_t ti960_supported_codes_pad[] = {
+	MEDIA_BUS_FMT_YUYV8_1X16,
+	MEDIA_BUS_FMT_UYVY8_1X16,
 	MEDIA_BUS_FMT_SBGGR16_1X16,
 	MEDIA_BUS_FMT_SGBRG16_1X16,
 	MEDIA_BUS_FMT_SGRBG16_1X16,
@@ -121,13 +127,14 @@ static struct regmap_config ti960_reg_config16 = {
 };
 
 static int ti953_reg_write(struct ti960 *va, unsigned short rx_port,
-	unsigned char reg, unsigned char val)
+	unsigned short ser_alias, unsigned char reg, unsigned char val)
 {
 	int ret;
 	int retry, timeout = 10;
 	struct i2c_client *client = v4l2_get_subdevdata(&va->sd);
-	unsigned short ser_alias = va->pdata->subdev_info[rx_port].ser_alias;
 
+	dev_dbg(va->sd.dev, "%s port %d, ser_alias %x, reg %x, val %x",
+		__func__, rx_port, ser_alias, reg, val);
 	client->addr = ser_alias;
 	for (retry = 0; retry < timeout; retry++) {
 		ret = i2c_smbus_write_byte_data(client, reg, val);
@@ -149,6 +156,56 @@ static int ti953_reg_write(struct ti960 *va, unsigned short rx_port,
 	return 0;
 }
 
+static int ti953_reg_read(struct ti960 *va, unsigned short rx_port,
+	unsigned short ser_alias, unsigned char reg, unsigned char *val)
+{
+	int retry, timeout = 10;
+	struct i2c_client *client = v4l2_get_subdevdata(&va->sd);
+
+	client->addr = ser_alias;
+	for (retry = 0; retry < timeout; retry++) {
+		*val = i2c_smbus_read_byte_data(client, reg);
+		if (*val < 0)
+			usleep_range(5000, 6000);
+		else
+			break;
+	}
+
+	client->addr = TI960_I2C_ADDRESS;
+	if (retry >= timeout) {
+		dev_err(va->sd.dev,
+			"%s:read reg failed: port=%2x, addr=%2x, reg=%2x\n",
+			__func__, rx_port, ser_alias, reg);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static bool ti953_detect(struct ti960 *va, unsigned short rx_port, unsigned short ser_alias)
+{
+	bool ret = false;
+	int i;
+	int rval;
+	unsigned char val;
+
+	for (i = 0; i < ARRAY_SIZE(ti953_FPD3_RX_ID); i++) {
+		rval = ti953_reg_read(va, rx_port, ser_alias,
+			ti953_FPD3_RX_ID[i].reg, &val);
+		if (rval) {
+			dev_err(va->sd.dev, "port %d, ti953 write timeout %d\n", rx_port, rval);
+			break;
+		}
+		if (val != ti953_FPD3_RX_ID[i].val_expected)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(ti953_FPD3_RX_ID))
+		ret = true;
+
+	return ret;
+}
+
 static int ti960_reg_read(struct ti960 *va, unsigned char reg, unsigned int *val)
 {
 	int ret, retry, timeout = 10;
@@ -216,6 +273,20 @@ static int ti960_map_alias_i2c_addr(struct ti960 *va, unsigned short rx_port,
 	return regmap_write(va->regmap8, TI960_SLAVE_ALIAS_ID0, addr);
 }
 
+static int ti960_map_ser_alias_addr(struct ti960 *va, unsigned short rx_port,
+			      unsigned short ser_alias)
+{
+	int rval;
+
+	dev_dbg(va->sd.dev, "%s port %d, ser_alias %x\n", __func__, rx_port, ser_alias);
+	rval = regmap_write(va->regmap8, TI960_RX_PORT_SEL,
+		(rx_port << 4) + (1 << rx_port));
+	if (rval)
+		return rval;
+
+	return regmap_write(va->regmap8, TI960_SER_ALIAS_ID, ser_alias);
+}
+
 static int ti960_fsin_gpio_init(struct ti960 *va, unsigned short rx_port,
 					unsigned short fsin_gpio)
 {
@@ -239,23 +310,48 @@ static int ti960_fsin_gpio_init(struct ti960 *va, unsigned short rx_port,
 	if (rval)
 		return rval;
 
-	rval = regmap_read(va->regmap8, TI960_BC_GPIO_CTL0, &reg_val);
-	if (rval) {
-		dev_dbg(va->sd.dev, "Failed to read gpio status.\n");
-		return rval;
-	}
+	switch (fsin_gpio) {
+	case 0:
+	case 1:
+		rval = regmap_read(va->regmap8, TI960_BC_GPIO_CTL0, &reg_val);
+		if (rval) {
+			dev_dbg(va->sd.dev, "Failed to read gpio status.\n");
+			return rval;
+		}
 
-	if (fsin_gpio == 0) {
-		reg_val &= ~TI960_GPIO0_MASK;
-		reg_val |= TI960_GPIO0_FSIN;
-	} else {
-		reg_val &= ~TI960_GPIO1_MASK;
-		reg_val |= TI960_GPIO1_FSIN;
-	}
+		if (fsin_gpio == 0) {
+			reg_val &= ~TI960_GPIO0_MASK;
+			reg_val |= TI960_GPIO0_FSIN;
+		} else {
+			reg_val &= ~TI960_GPIO1_MASK;
+			reg_val |= TI960_GPIO1_FSIN;
+		}
 
-	rval = regmap_write(va->regmap8, TI960_BC_GPIO_CTL0, reg_val);
-	if (rval)
-		dev_dbg(va->sd.dev, "Failed to set gpio.\n");
+		rval = regmap_write(va->regmap8, TI960_BC_GPIO_CTL0, reg_val);
+		if (rval)
+			dev_dbg(va->sd.dev, "Failed to set gpio.\n");
+		break;
+	case 2:
+	case 3:
+		rval = regmap_read(va->regmap8, TI960_BC_GPIO_CTL1, &reg_val);
+		if (rval) {
+			dev_dbg(va->sd.dev, "Failed to read gpio status.\n");
+			return rval;
+		}
+
+		if (fsin_gpio == 2) {
+			reg_val &= ~TI960_GPIO2_MASK;
+			reg_val |= TI960_GPIO2_FSIN;
+		} else {
+			reg_val &= ~TI960_GPIO3_MASK;
+			reg_val |= TI960_GPIO3_FSIN;
+		}
+
+		rval = regmap_write(va->regmap8, TI960_BC_GPIO_CTL1, reg_val);
+		if (rval)
+			dev_dbg(va->sd.dev, "Failed to set gpio.\n");
+		break;
+	}
 
 	return rval;
 }
@@ -264,14 +360,34 @@ static int ti960_get_routing(struct v4l2_subdev *sd,
 				   struct v4l2_subdev_routing *route)
 {
 	struct ti960 *va = to_ti960(sd);
-	int i;
+	int i, j;
+
+	/* active routing first */
+	j = 0;
+	for (i = 0; i < va->nstreams; ++i) {
+		if (j >= route->num_routes)
+			break;
+		if (!(va->ti960_route[i].flags & V4L2_SUBDEV_ROUTE_FL_ACTIVE))
+			continue;
+		route->routes[j].sink_pad = va->ti960_route[i].sink_pad;
+		route->routes[j].sink_stream = va->ti960_route[i].sink_stream;
+		route->routes[j].source_pad = va->ti960_route[i].source_pad;
+		route->routes[j].source_stream = va->ti960_route[i].source_stream;
+		route->routes[j].flags = va->ti960_route[i].flags;
+		j++;
+	}
 
-	for (i = 0; i < min(va->nstreams, route->num_routes); ++i) {
-		route->routes[i].sink_pad = va->ti960_route[i].sink_pad;
-		route->routes[i].sink_stream = va->ti960_route[i].sink_stream;
-		route->routes[i].source_pad = va->ti960_route[i].source_pad;
-		route->routes[i].source_stream = va->ti960_route[i].source_stream;
-		route->routes[i].flags = va->ti960_route[i].flags;
+	for (i = 0; i < va->nstreams; ++i) {
+		if (j >= route->num_routes)
+			break;
+		if (va->ti960_route[i].flags & V4L2_SUBDEV_ROUTE_FL_ACTIVE)
+			continue;
+		route->routes[j].sink_pad = va->ti960_route[i].sink_pad;
+		route->routes[j].sink_stream = va->ti960_route[i].sink_stream;
+		route->routes[j].source_pad = va->ti960_route[i].source_pad;
+		route->routes[j].source_stream = va->ti960_route[i].source_stream;
+		route->routes[j].flags = va->ti960_route[i].flags;
+		j++;
 	}
 
 	route->num_routes = i;
@@ -490,6 +606,33 @@ static int ti960_open(struct v4l2_subdev *subdev,
 	return 0;
 }
 
+static int ti960_map_subdevs_addr(struct ti960 *va)
+{
+	unsigned short rx_port, phy_i2c_addr, alias_i2c_addr;
+	int i, rval;
+
+	for (i = 0; i < NR_OF_TI960_SINK_PADS; i++) {
+		rx_port = va->sub_devs[i].rx_port;
+		phy_i2c_addr = va->sub_devs[i].phy_i2c_addr;
+		alias_i2c_addr = va->sub_devs[i].alias_i2c_addr;
+
+		if (!phy_i2c_addr || !alias_i2c_addr)
+			continue;
+
+		rval = ti960_map_phy_i2c_addr(va, rx_port, phy_i2c_addr);
+		if (rval)
+			return rval;
+
+		/* set 7bit alias i2c addr */
+		rval = ti960_map_alias_i2c_addr(va, rx_port,
+						alias_i2c_addr << 1);
+		if (rval)
+			return rval;
+	}
+
+	return 0;
+}
+
 static int ti960_registered(struct v4l2_subdev *subdev)
 {
 	struct ti960 *va = to_ti960(subdev);
@@ -506,20 +649,22 @@ static int ti960_registered(struct v4l2_subdev *subdev)
 		if (k >= va->nsinks)
 			break;
 
+		rval = ti960_map_ser_alias_addr(va, info->rx_port,
+				info->ser_alias << 1);
+		if (rval)
+			return rval;
+
+
+		if (!ti953_detect(va, info->rx_port, info->ser_alias))
+			continue;
+
 		/*
 		 * The sensors should not share the same pdata structure.
 		 * Clone the pdata for each sensor.
 		 */
 		memcpy(&va->subdev_pdata[k], pdata, sizeof(*pdata));
-		if (va->subdev_pdata[k].xshutdown != 0 &&
-			va->subdev_pdata[k].xshutdown != 1) {
-			dev_err(va->sd.dev, "xshutdown(%d) must be 0 or 1 to connect.\n",
-				va->subdev_pdata[k].xshutdown);
-			return -EINVAL;
-		}
 
-		/* If 0 is xshutdown, then 1 would be FSIN, vice versa. */
-		va->sub_devs[k].fsin_gpio = 1 - va->subdev_pdata[k].xshutdown;
+		va->sub_devs[k].fsin_gpio = va->subdev_pdata[k].fsin;
 
 		/* Spin sensor subdev suffix name */
 		va->subdev_pdata[k].suffix = info->suffix;
@@ -562,6 +707,7 @@ static int ti960_registered(struct v4l2_subdev *subdev)
 		va->sub_devs[k].rx_port = info->rx_port;
 		va->sub_devs[k].phy_i2c_addr = info->phy_i2c_addr;
 		va->sub_devs[k].alias_i2c_addr = info->board_info.addr;
+		va->sub_devs[k].ser_i2c_addr = info->ser_alias;
 		memcpy(va->sub_devs[k].sd_name,
 				va->subdev_pdata[k].module_name,
 				min(sizeof(va->sub_devs[k].sd_name) - 1,
@@ -597,6 +743,9 @@ static int ti960_registered(struct v4l2_subdev *subdev)
 		}
 		k++;
 	}
+	rval = ti960_map_subdevs_addr(va);
+	if (rval)
+		return rval;
 
 	return 0;
 }
@@ -680,6 +829,8 @@ static bool ti960_broadcast_mode(struct v4l2_subdev *subdev)
 static int ti960_rx_port_config(struct ti960 *va, int sink, int rx_port)
 {
 	int rval;
+	int i;
+	unsigned int csi_vc_map;
 
 	/* Select RX port. */
 	rval = regmap_write(va->regmap8, TI960_RX_PORT_SEL,
@@ -697,36 +848,30 @@ static int ti960_rx_port_config(struct ti960 *va, int sink, int rx_port)
 	}
 
 	/*
-	 * TODO: CSI VC MAPPING.
+	 * CSI VC MAPPING.
 	 */
-
-	return 0;
-}
-
-static int ti960_map_subdevs_addr(struct ti960 *va)
-{
-	unsigned short rx_port, phy_i2c_addr, alias_i2c_addr;
-	int i, rval;
-
-	for (i = 0; i < NR_OF_TI960_SINK_PADS; i++) {
-		rx_port = va->sub_devs[i].rx_port;
-		phy_i2c_addr = va->sub_devs[i].phy_i2c_addr;
-		alias_i2c_addr = va->sub_devs[i].alias_i2c_addr;
-
-		if (!phy_i2c_addr || !alias_i2c_addr)
+	rval = regmap_read(va->regmap8, TI960_CSI_VC_MAP, &csi_vc_map);
+	if (rval < 0) {
+		dev_err(va->sd.dev, "960 reg read ret=%x", rval);
+		return rval;
+	}
+	for (i = 0; i < va->nstreams; ++i) {
+		if (!(va->ti960_route[i].flags & V4L2_SUBDEV_ROUTE_FL_ACTIVE))
 			continue;
-
-		rval = ti960_map_phy_i2c_addr(va, rx_port, phy_i2c_addr);
-		if (rval)
-			return rval;
-
-		/* set 7bit alias i2c addr */
-		rval = ti960_map_alias_i2c_addr(va, rx_port,
-						alias_i2c_addr << 1);
-		if (rval)
-			return rval;
+		if (rx_port != va->ti960_route[i].sink_pad)
+			continue;
+		csi_vc_map &= ~(0x3 << (va->ti960_route[i].sink_stream & 0x3) * 2);
+		csi_vc_map |= (va->ti960_route[i].source_stream & 0x3)
+			<< (va->ti960_route[i].sink_stream & 0x3) * 2;
+	}
+	dev_dbg(va->sd.dev, "%s port %d, csi_vc_map %x",
+		__func__, rx_port, csi_vc_map);
+	rval = regmap_write(va->regmap8, TI960_CSI_VC_MAP,
+		csi_vc_map);
+	if (rval) {
+		dev_err(va->sd.dev, "Failed to set port config.\n");
+		return rval;
 	}
-
 	return 0;
 }
 
@@ -769,7 +914,8 @@ static int ti960_set_stream(struct v4l2_subdev *subdev, int enable)
 	struct v4l2_subdev *sd;
 	int i, j, rval;
 	bool broadcast;
-	unsigned int rx_port;
+	unsigned short rx_port;
+	unsigned short ser_alias;
 	int sd_idx = -1;
 	DECLARE_BITMAP(rx_port_enabled, 32);
 
@@ -794,6 +940,7 @@ static int ti960_set_stream(struct v4l2_subdev *subdev, int enable)
 		if (j < 0)
 			return -EINVAL;
 		rx_port = va->sub_devs[j].rx_port;
+		ser_alias = va->sub_devs[j].ser_i2c_addr;
 		rval = ti960_rx_port_config(va, i, rx_port);
 		if (rval < 0)
 			return rval;
@@ -829,6 +976,18 @@ static int ti960_set_stream(struct v4l2_subdev *subdev, int enable)
 					i, enable);
 				return rval;
 			}
+			/*
+			 * FIXME: workaround for ov495 block issue.
+			 * reset Ser TI953, to avoid ov495 block,
+			 * only do reset for ov495, then it won't break other sensors.
+			 */
+			if (memcmp(va->sub_devs[j].sd_name, "OV495", strlen("OV495")) == 0) {
+				ti953_reg_write(va, rx_port, ser_alias, 0x0e, 0xf0);
+				msleep(50);
+				ti953_reg_write(va, rx_port, ser_alias, 0x0d, 00);
+				msleep(50);
+				ti953_reg_write(va, rx_port, ser_alias, 0x0d, 0x1);
+			}
 
 		}
 	}
@@ -864,6 +1023,20 @@ static int ti960_set_stream(struct v4l2_subdev *subdev, int enable)
 						"Failed to enable frame sync gpio init.\n");
 					return rval;
 				}
+				/*
+				 * FIXME: workaround for ov495 block issue.
+				 * reset Ser TI953, to avoid ov495 block,
+				 * only do reset for ov495, then it won't break other sensors.
+				 */
+				if (memcmp(va->sub_devs[i].sd_name, "OV495", strlen("OV495")) == 0) {
+					rx_port = va->sub_devs[i].rx_port;
+					ser_alias = va->sub_devs[i].ser_i2c_addr;
+					ti953_reg_write(va, rx_port, ser_alias, 0x0e, 0xf0);
+					msleep(50);
+					ti953_reg_write(va, rx_port, ser_alias, 0x0d, 00);
+					msleep(50);
+					ti953_reg_write(va, rx_port, ser_alias, 0x0d, 0x1);
+				}
 			}
 		}
 
@@ -959,7 +1132,7 @@ static const struct v4l2_ctrl_config ti960_controls[] = {
 		.max = ARRAY_SIZE(ti960_op_sys_clock) - 1,
 		.min =  0,
 		.step  = 0,
-		.def = 0,
+		.def = 1,
 		.qmenu_int = ti960_op_sys_clock,
 	},
 	{
@@ -1059,11 +1232,88 @@ static int ti960_register_subdev(struct ti960 *va)
 	return rval;
 }
 
+struct slave_register_devid {
+	u16 reg;
+	u8 val_expected;
+};
+
+#define OV495_I2C_PHY_ADDR	0x48
+#define OV495_I2C_ALIAS_ADDR	0x30
+
+static const struct slave_register_devid ov495_devid[] = {
+	{0x3000, 0x51},
+	{0x3001, 0x49},
+	{0x3002, 0x56},
+	{0x3003, 0x4f},
+};
+
+/*
+ * read sensor id reg of 16 bit addr, and 8 bit val
+ */
+static int slave_id_read(struct i2c_client *client, u8 i2c_addr,
+				u16 reg, u8 *val)
+{
+	struct i2c_msg msg[2];
+	unsigned char data[2];
+	int rval;
+
+	/* override i2c_addr */
+	msg[0].addr = i2c_addr;
+	msg[0].flags = 0;
+	data[0] = (u8) (reg >> 8);
+	data[1] = (u8) (reg & 0xff);
+	msg[0].buf = data;
+	msg[0].len = 2;
+
+	msg[1].addr = i2c_addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+	msg[1].len = 1;
+
+	rval = i2c_transfer(client->adapter, msg, 2);
+
+	if (rval < 0)
+		return rval;
+
+	*val = data[0];
+
+	return 0;
+}
+
+static bool slave_detect(struct ti960 *va, u8 i2c_addr,
+		const struct slave_register_devid *slave_devid, u8 len)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&va->sd);
+	int i;
+	int rval;
+	unsigned char val;
+
+	for (i = 0; i < len; i++) {
+		rval = slave_id_read(client, i2c_addr,
+			slave_devid[i].reg, &val);
+		if (rval) {
+			dev_err(va->sd.dev, "slave id read fail %d\n", rval);
+			break;
+		}
+		if (val != slave_devid[i].val_expected)
+			break;
+	}
+
+	if (i == len)
+		return true;
+
+	return false;
+}
+
 static int ti960_init(struct ti960 *va)
 {
 	unsigned int reset_gpio = va->pdata->reset_gpio;
 	int i, rval;
 	unsigned int val;
+	int m;
+	int rx_port = 0;
+	int ser_alias = 0;
+	bool ov495_detected;
 
 	gpio_set_value(reset_gpio, 1);
 	usleep_range(2000, 3000);
@@ -1089,6 +1339,11 @@ static int ti960_init(struct ti960 *va)
 	}
 	usleep_range(10000, 11000);
 
+	/*
+	 * fixed value of sensor phy, ser_alias, port config for ti960 each port,
+	 * not yet known sensor platform data here.
+	 */
+	ser_alias = 0x58;
 	for (i = 0; i < ARRAY_SIZE(ti960_init_settings); i++) {
 		rval = regmap_write(va->regmap8,
 			ti960_init_settings[i].reg,
@@ -1102,10 +1357,46 @@ static int ti960_init(struct ti960 *va)
 	}
 
 	/* wait for ti953 ready */
-	usleep_range(200000, 300000);
+	msleep(200);
+
+	for (i = 0; i < NR_OF_TI960_SINK_PADS; i++) {
+		unsigned short rx_port, phy_i2c_addr, alias_i2c_addr;
+
+		rx_port = i;
+		phy_i2c_addr = OV495_I2C_PHY_ADDR;
+		alias_i2c_addr = OV495_I2C_ALIAS_ADDR;
+
+		rval = ti960_map_phy_i2c_addr(va, rx_port, phy_i2c_addr);
+		if (rval)
+			return rval;
+
+		rval = ti960_map_alias_i2c_addr(va, rx_port,
+						alias_i2c_addr << 1);
+		if (rval)
+			return rval;
+
+		ov495_detected = slave_detect(va, alias_i2c_addr,
+					ov495_devid, ARRAY_SIZE(ov495_devid));
+
+		/* unmap to clear i2c addr space */
+		rval = ti960_map_phy_i2c_addr(va, rx_port, 0);
+		if (rval)
+			return rval;
+
+		rval = ti960_map_alias_i2c_addr(va, rx_port, 0);
+		if (rval)
+			return rval;
+
+		if (ov495_detected) {
+			dev_info(va->sd.dev, "ov495 detected on port %d\n", rx_port);
+			break;
+		}
+	}
 
 	for (i = 0; i < ARRAY_SIZE(ti953_init_settings); i++) {
-		rval = ti953_reg_write(va, 0,
+		if (ov495_detected)
+			break;
+		rval = ti953_reg_write(va, rx_port, ser_alias,
 			ti953_init_settings[i].reg,
 			ti953_init_settings[i].val);
 		if (rval) {
@@ -1114,20 +1405,38 @@ static int ti960_init(struct ti960 *va)
 		}
 	}
 
-	for (i = 0; i < ARRAY_SIZE(ti960_init_settings_2); i++) {
+	for (m = 0; m < ARRAY_SIZE(ti960_init_settings_2); m++) {
 		rval = regmap_write(va->regmap8,
-			ti960_init_settings_2[i].reg,
-			ti960_init_settings_2[i].val);
+			ti960_init_settings_2[m].reg,
+			ti960_init_settings_2[m].val);
 		if (rval) {
 			dev_err(va->sd.dev,
 				"Failed to write TI960 init setting 2, reg %2x, val %2x\n",
-				ti960_init_settings_2[i].reg, ti960_init_settings_2[i].val);
-			return rval;
+				ti960_init_settings_2[m].reg, ti960_init_settings_2[m].val);
+			break;
+		}
+	}
+
+	rval = regmap_write(va->regmap8, TI960_RX_PORT_SEL,
+		(rx_port << 4) + (1 << rx_port));
+	if (rval)
+		return rval;
+	for (m = 1; m < ARRAY_SIZE(ti960_init_settings_3); m++) {
+		rval = regmap_write(va->regmap8,
+			ti960_init_settings_3[m].reg,
+			ti960_init_settings_3[m].val);
+		if (rval) {
+			dev_err(va->sd.dev,
+				"Failed to write TI960 init setting 2, reg %2x, val %2x\n",
+				ti960_init_settings_3[m].reg, ti960_init_settings_3[m].val);
+			break;
 		}
 	}
 
 	for (i = 0; i < ARRAY_SIZE(ti953_init_settings_2); i++) {
-		rval = ti953_reg_write(va, 0,
+		if (ov495_detected)
+			break;
+		rval = ti953_reg_write(va, rx_port, ser_alias,
 			ti953_init_settings_2[i].reg,
 			ti953_init_settings_2[i].val);
 		if (rval) {
@@ -1137,9 +1446,11 @@ static int ti960_init(struct ti960 *va)
 	}
 
 	/* reset and power for ti953 */
-	ti953_reg_write(va, 0, 0x0d, 00);
-	usleep_range(50000, 60000);
-	ti953_reg_write(va, 0, 0x0d, 0x3);
+	if (!ov495_detected) {
+		ti953_reg_write(va, 0, ser_alias, 0x0d, 00);
+		msleep(50);
+		ti953_reg_write(va, 0, ser_alias, 0x0d, 0x3);
+	}
 
 	rval = ti960_map_subdevs_addr(va);
 	if (rval)
@@ -1150,6 +1461,46 @@ static int ti960_init(struct ti960 *va)
 
 static void ti960_gpio_set(struct gpio_chip *chip, unsigned int gpio, int value)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0)
+	struct i2c_client *client = to_i2c_client(chip->dev);
+#else
+	struct i2c_client *client = to_i2c_client(chip->parent);
+#endif
+	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
+	struct ti960 *va = to_ti960(subdev);
+	unsigned int reg_val;
+	int rx_port, gpio_port;
+	int ret;
+
+	if (gpio >= NR_OF_TI960_GPIOS)
+		return;
+
+	rx_port = gpio / NR_OF_GPIOS_PER_PORT;
+	gpio_port = gpio % NR_OF_GPIOS_PER_PORT;
+
+	ret = regmap_write(va->regmap8, TI960_RX_PORT_SEL,
+			  (rx_port << 4) + (1 << rx_port));
+	if (ret) {
+		dev_dbg(&client->dev, "Failed to select RX port.\n");
+		return;
+	}
+	ret = regmap_read(va->regmap8, TI960_BC_GPIO_CTL0, &reg_val);
+	if (ret) {
+		dev_dbg(&client->dev, "Failed to read gpio status.\n");
+		return;
+	}
+
+	if (gpio_port == 0) {
+		reg_val &= ~TI960_GPIO0_MASK;
+		reg_val |= value ? TI960_GPIO0_HIGH : TI960_GPIO0_LOW;
+	} else {
+		reg_val &= ~TI960_GPIO1_MASK;
+		reg_val |= value ? TI960_GPIO1_HIGH : TI960_GPIO1_LOW;
+	}
+
+	ret = regmap_write(va->regmap8, TI960_BC_GPIO_CTL0, reg_val);
+	if (ret)
+		dev_dbg(&client->dev, "Failed to set gpio.\n");
 }
 
 static int ti960_gpio_direction_output(struct gpio_chip *chip,
@@ -1162,7 +1513,7 @@ static int ti960_probe(struct i2c_client *client,
 			const struct i2c_device_id *devid)
 {
 	struct ti960 *va;
-	int i, rval = 0;
+	int i, j, k, l, rval = 0;
 
 	if (client->dev.platform_data == NULL)
 		return -ENODEV;
@@ -1201,12 +1552,17 @@ static int ti960_probe(struct i2c_client *client,
 	if (!va->ti960_route)
 		return -ENOMEM;
 
-	for (i = 0; i < va->nstreams; i++) {
-		va->ti960_route[i].sink_pad = i / 2;
-		va->ti960_route[i].sink_stream = i % 2;
-		va->ti960_route[i].source_pad = TI960_PAD_SOURCE;
-		va->ti960_route[i].source_stream = i % 2;
-		va->ti960_route[i].flags = MEDIA_PAD_FL_MULTIPLEX;
+	/* routing for virtual channel supports */
+	l = 0;
+	for (i = 0; i < NR_OF_TI960_SINK_PADS; i++)
+		for (j = 0; j < NR_OF_TI960_VCS_PER_SINK_PAD; j++)
+			for (k = 0; k < NR_OF_TI960_VCS_SOURCE_PAD; k++) {
+				va->ti960_route[l].sink_pad = i;
+				va->ti960_route[l].sink_stream = j;
+				va->ti960_route[l].source_pad = TI960_PAD_SOURCE;
+				va->ti960_route[l].source_stream = k;
+				va->ti960_route[l].flags = MEDIA_PAD_FL_MULTIPLEX;
+				l++;
 	}
 
 	va->regmap8 = devm_regmap_init_i2c(client,
diff --git a/drivers/media/i2c/ti964.c b/drivers/media/i2c/ti964.c
index 215564f8..3af5c68 100644
--- a/drivers/media/i2c/ti964.c
+++ b/drivers/media/i2c/ti964.c
@@ -343,10 +343,11 @@ static int ti964_get_frame_desc(struct v4l2_subdev *sd,
 	int i;
 
 	desc->type = V4L2_MBUS_FRAME_DESC_TYPE_CSI2;
+	desc->num_entries = min_t(int, va->nstreams, V4L2_FRAME_DESC_ENTRY_MAX);
 
-	for (i = 0; i < min_t(int, va->nstreams, desc->num_entries); i++) {
+	for (i = 0; i < desc->num_entries; i++) {
 		struct v4l2_mbus_framefmt *ffmt =
-			&va->ffmts[i][TI964_PAD_SOURCE];
+			&va->ffmts[TI964_PAD_SOURCE][i];
 		const struct ti964_csi_data_format *csi_format =
 			ti964_validate_csi_data_format(ffmt->code);
 
diff --git a/drivers/media/pci/intel/ici/Makefile b/drivers/media/pci/intel/ici/Makefile
index 59a2561..91bb500 100644
--- a/drivers/media/pci/intel/ici/Makefile
+++ b/drivers/media/pci/intel/ici/Makefile
@@ -6,7 +6,7 @@ srcpath := $(srctree)
 endif
 
 ifdef CONFIG_VIDEO_INTEL_ICI
-ccflags-y += -DHAS_DUAL_CMD_CTX_SUPPORT=0 -DIPU_VC_SUPPORT -DIPU_HAS_ISA -DIPU_PSYS_LEGACY -Wframe-larger-than=4096
+ccflags-y += -DHAS_DUAL_CMD_CTX_SUPPORT=0 -Wframe-larger-than=4096
 
 
 # work-around to re-use ipu4-css and libintel-ipu4_ici.c together when
diff --git a/drivers/media/pci/intel/ici/libintel-ipu4_ici.c b/drivers/media/pci/intel/ici/libintel-ipu4_ici.c
index b4fc334..7511ecf 100644
--- a/drivers/media/pci/intel/ici/libintel-ipu4_ici.c
+++ b/drivers/media/pci/intel/ici/libintel-ipu4_ici.c
@@ -180,10 +180,6 @@ struct ipu_fw_isys_resp_info_abi *ipu_fw_isys_get_resp(
 	response->process_group_light.addr =
 		apiresp.process_group_light.addr;
 	response->acc_id = apiresp.acc_id;
-#ifdef IPU_OTF_SUPPORT
-	response->frame_counter = apiresp.frame_counter;
-	response->written_direct = apiresp.written_direct;
-#endif
 
 	return response;
 }
@@ -250,9 +246,6 @@ static void output_pin_info_abi_to_api(
 	api->payload_buf_size = abi->payload_buf_size;
 	api->send_irq = abi->send_irq;
 	api->ft = abi->ft;
-#ifdef IPU_OTF_SUPPORT
-	api->link_id = abi->link_id;
-#endif
 	api->reserve_compression = abi->reserve_compression;
 }
 
diff --git a/drivers/media/pci/intel/ipu-bus.c b/drivers/media/pci/intel/ipu-bus.c
index a50b6ab..30e5033 100644
--- a/drivers/media/pci/intel/ipu-bus.c
+++ b/drivers/media/pci/intel/ipu-bus.c
@@ -372,6 +372,7 @@ struct ipu_bus_device *ipu_bus_add_device(struct pci_dev *pdev,
 				      IPU_MMU_ADDRESS_BITS :
 				      IPU_MMU_ADDRESS_BITS_NON_SECURE);
 	adev->dev.dma_mask = &adev->dma_mask;
+	adev->dev.coherent_dma_mask = adev->dma_mask;
 	adev->iommu = iommu;
 	adev->ctrl = ctrl;
 	adev->pdata = pdata;
diff --git a/drivers/media/pci/intel/ipu-buttress.c b/drivers/media/pci/intel/ipu-buttress.c
index b823c0f..d19e965 100644
--- a/drivers/media/pci/intel/ipu-buttress.c
+++ b/drivers/media/pci/intel/ipu-buttress.c
@@ -404,10 +404,10 @@ irqreturn_t ipu_buttress_isr(int irq, void *isp_ptr)
 	irqreturn_t ret = IRQ_NONE;
 	u32 disable_irqs = 0;
 	u32 irq_status;
-#ifdef CONFIG_VIDEO_INTEL_IPU4P
-	u32 reg_irq_sts = BUTTRESS_REG_ISR_STATUS;
-#else
+#ifdef CONFIG_VIDEO_INTEL_IPU4
 	u32 reg_irq_sts = BUTTRESS_REG_ISR_ENABLED_STATUS;
+#else
+	u32 reg_irq_sts = BUTTRESS_REG_ISR_STATUS;
 #endif
 	unsigned int i;
 
diff --git a/drivers/media/pci/intel/ipu-cpd.c b/drivers/media/pci/intel/ipu-cpd.c
index dca0323..87028a6 100644
--- a/drivers/media/pci/intel/ipu-cpd.c
+++ b/drivers/media/pci/intel/ipu-cpd.c
@@ -7,8 +7,10 @@
 #include "ipu.h"
 #include "ipu-cpd.h"
 
+#ifdef CONFIG_VIDEO_INTEL_IPU_FW_LIB
 #include <ia_css_fw_pkg_release.h>
 
+#endif
 /* 15 entries + header*/
 #define MAX_PKG_DIR_ENT_CNT		16
 /* 2 qword per entry/header */
@@ -46,10 +48,12 @@
 #define ipu_cpd_get_metadata(cpd) ipu_cpd_get_entry(cpd, CPD_METADATA_IDX)
 #define ipu_cpd_get_moduledata(cpd) ipu_cpd_get_entry(cpd, CPD_MODULEDATA_IDX)
 
+#ifdef CONFIG_VIDEO_INTEL_IPU_FW_LIB
 static bool fw_version_check = true;
 module_param(fw_version_check, bool, 0444);
 MODULE_PARM_DESC(fw_version_check, "enable/disable checking firmware version");
 
+#endif
 static const struct ipu_cpd_metadata_cmpnt *
 ipu_cpd_metadata_get_cmpnt(struct ipu_device *isp,
 			   const void *metadata,
@@ -349,6 +353,7 @@ static int ipu_cpd_validate_moduledata(struct ipu_device *isp,
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_VIDEO_INTEL_IPU_FW_LIB
 	if (fw_version_check && mod_hdr->fw_pkg_date != IA_CSS_FW_PKG_RELEASE) {
 		dev_err(&isp->pdev->dev,
 			"Moduledata and library version mismatch (%x != %x)\n",
@@ -361,6 +366,9 @@ static int ipu_cpd_validate_moduledata(struct ipu_device *isp,
 		 mod_hdr->fw_pkg_date, IA_CSS_FW_PKG_RELEASE);
 
 	dev_info(&isp->pdev->dev, "CSS release: %x\n", IA_CSS_FW_PKG_RELEASE);
+#else
+	dev_info(&isp->pdev->dev, "FW version: %x\n", mod_hdr->fw_pkg_date);
+#endif
 	rval = ipu_cpd_validate_cpd(isp, moduledata +
 				    mod_hdr->hdr_len,
 				    moduledata_size -
diff --git a/drivers/media/pci/intel/ipu-cpd.h b/drivers/media/pci/intel/ipu-cpd.h
index c91ae33..7033e90 100644
--- a/drivers/media/pci/intel/ipu-cpd.h
+++ b/drivers/media/pci/intel/ipu-cpd.h
@@ -37,8 +37,14 @@ struct __packed ipu_cpd_hdr {
 	u8 hdr_ver;
 	u8 ent_ver;
 	u8 hdr_len;
+#if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
 	u8 chksm;
 	u32 name;
+#else
+	u8 rsvd;
+	u32 sub_partition_name;
+	u32 chksm;
+#endif
 };
 
 struct __packed ipu_cpd_ent {
diff --git a/drivers/media/pci/intel/ipu-fw-com.c b/drivers/media/pci/intel/ipu-fw-com.c
index 78c5c92..4ddf111 100644
--- a/drivers/media/pci/intel/ipu-fw-com.c
+++ b/drivers/media/pci/intel/ipu-fw-com.c
@@ -126,8 +126,10 @@ enum regmem_id {
 	SYSCOM_COMMAND_REG = 3,
 	/* Store interrupt status - updated by SP */
 	SYSCOM_IRQ_REG = 4,
+	/* Store VTL0_ADDR_MASK in trusted secure regision - provided by host.*/
+	SYSCOM_VTL0_ADDR_MASK = 5,
 	/* first syscom queue pointer register */
-	SYSCOM_QPR_BASE_REG = 5
+	SYSCOM_QPR_BASE_REG = 6
 };
 
 enum message_direction {
diff --git a/drivers/media/pci/intel/ipu-fw-isys.c b/drivers/media/pci/intel/ipu-fw-isys.c
index ca0bdba..304bcae 100644
--- a/drivers/media/pci/intel/ipu-fw-isys.c
+++ b/drivers/media/pci/intel/ipu-fw-isys.c
@@ -499,6 +499,10 @@ ipu_fw_isys_dump_stream_cfg(struct device *dev,
 			stream_cfg->output_pins[i].send_irq);
 		dev_dbg(dev, "Reserve compression %d\n",
 			stream_cfg->output_pins[i].reserve_compression);
+		dev_dbg(dev, "snoopable %d\n",
+			stream_cfg->output_pins[i].snoopable);
+		dev_dbg(dev, "sensor type %d\n",
+			stream_cfg->output_pins[i].sensor_type);
 		dev_dbg(dev, "----------------\n");
 	}
 
@@ -554,7 +558,4 @@ void ipu_fw_isys_dump_frame_buff_set(struct device *dev,
 	dev_dbg(dev, "send_irq_capture_ack 0x%x\n", buf->send_irq_capture_ack);
 	dev_dbg(dev, "send_irq_capture_done 0x%x\n", buf->send_irq_capture_done);
 #endif
-#ifdef IPU_OTF_SUPPORT
-	dev_dbg(dev, "frame_counter 0x%x\n", buf->frame_counter);
-#endif
 }
diff --git a/drivers/media/pci/intel/ipu-fw-isys.h b/drivers/media/pci/intel/ipu-fw-isys.h
index 1106202..4056736 100644
--- a/drivers/media/pci/intel/ipu-fw-isys.h
+++ b/drivers/media/pci/intel/ipu-fw-isys.h
@@ -16,7 +16,11 @@
 #define IPU_MAX_OPINS ((IPU_MAX_IPINS) + 2)
 
 /* Max number of supported virtual streams */
+#if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
 #define IPU_STREAM_ID_MAX 8
+#else
+#define IPU_STREAM_ID_MAX 16
+#endif
 
 /* Aligned with the approach of having one dedicated per stream */
 #define IPU_N_MAX_MSG_SEND_QUEUES (IPU_STREAM_ID_MAX)
@@ -541,6 +545,8 @@ struct ipu_fw_isys_output_pin_info_abi {
 	u8 ft;
 	u8 reserved;
 	u8 reserve_compression;
+	u8 snoopable;
+	u32 sensor_type;
 };
 
 /**
@@ -563,12 +569,6 @@ struct ipu_fw_isys_param_pin_abi {
  *		     (enum ipu_fw_isys_mipi_store_mode)
  * @bits_per_pix: native bits per pixel
  * @mapped_dt: actual data type from sensor
-#if !defined(CONFIG_VIDEO_INTEL_IPU4) && !defined(CONFIG_VIDEO_INTEL_IPU4P)
- * @crop_first_and_last_lines    Control whether to crop the
- *                              first and last line of the
- *                              input image. Crop done by HW
- *                              device.
-#endif
  */
 struct ipu_fw_isys_input_pin_info_abi {
 	struct ipu_fw_isys_resolution_abi input_res;
@@ -576,9 +576,6 @@ struct ipu_fw_isys_input_pin_info_abi {
 	u8 mipi_store_mode;
 	u8 bits_per_pix;
 	u8 mapped_dt;
-#if !defined(CONFIG_VIDEO_INTEL_IPU4) && !defined(CONFIG_VIDEO_INTEL_IPU4P)
-	u8 crop_first_and_last_lines;
-#endif
 };
 
 /**
diff --git a/drivers/media/pci/intel/ipu-fw-psys.h b/drivers/media/pci/intel/ipu-fw-psys.h
index 187a20a..1738f6c 100644
--- a/drivers/media/pci/intel/ipu-fw-psys.h
+++ b/drivers/media/pci/intel/ipu-fw-psys.h
@@ -280,7 +280,11 @@ struct ipu_fw_generic_process {
 struct ipu_fw_resource_definitions {
 	u32 num_cells;
 	u32 num_cells_type;
+#if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
 	const u32 *cells;
+#else
+	const u8 *cells;
+#endif
 	u32 num_dev_channels;
 	const u16 *dev_channels;
 
@@ -292,7 +296,11 @@ struct ipu_fw_resource_definitions {
 	const u16 *dfms;
 
 	u32 cell_mem_row;
+#if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
 	const enum ipu_mem_id *cell_mem;
+#else
+	const u8 *cell_mem;
+#endif
 	struct ipu_fw_generic_process process;
 };
 
diff --git a/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c b/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
index 1292349..c031626 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
@@ -23,6 +23,8 @@ static const u32 csi2_be_soc_supported_codes_pad[] = {
 	MEDIA_BUS_FMT_Y10_1X10,
 	MEDIA_BUS_FMT_RGB565_1X16,
 	MEDIA_BUS_FMT_RGB888_1X24,
+	/* YUV420 plannar */
+	MEDIA_BUS_FMT_UYVY8_2X8,
 	MEDIA_BUS_FMT_UYVY8_1X16,
 	MEDIA_BUS_FMT_YUYV8_1X16,
 	MEDIA_BUS_FMT_SBGGR14_1X14,
@@ -192,6 +194,7 @@ static void csi2_be_soc_set_ffmt(struct v4l2_subdev *sd,
 		ffmt->height = r->height;
 		ffmt->code = sink_ffmt->code;
 		ffmt->field = sink_ffmt->field;
+
 	}
 }
 
@@ -296,8 +299,12 @@ int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
 		snprintf(csi2_be_soc->av[i].vdev.name,
 			 sizeof(csi2_be_soc->av[i].vdev.name),
 			 IPU_ISYS_ENTITY_PREFIX " BE SOC capture %d", i);
+		/*
+		 * Pin type could be overwritten for YUV422 to I420 case, at
+		 * set_format phase
+		 */
 		csi2_be_soc->av[i].aq.css_pin_type =
-		    IPU_FW_ISYS_PIN_TYPE_RAW_SOC;
+			IPU_FW_ISYS_PIN_TYPE_RAW_SOC;
 		csi2_be_soc->av[i].isys = isys;
 		csi2_be_soc->av[i].pfmts = ipu_isys_pfmts_be_soc;
 
diff --git a/drivers/media/pci/intel/ipu-isys-csi2-be.c b/drivers/media/pci/intel/ipu-isys-csi2-be.c
index deaf2a5..028c2de 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2-be.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be.c
@@ -255,7 +255,6 @@ int ipu_isys_csi2_be_init(struct ipu_isys_csi2_be *csi2_be,
 	csi2_be->asd.pad[CSI2_BE_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
 	csi2_be->asd.valid_tgts[CSI2_BE_PAD_SOURCE].crop = true;
 	csi2_be->asd.set_ffmt = csi2_be_set_ffmt;
-	csi2_be->asd.isys = isys;
 
 	BUILD_BUG_ON(ARRAY_SIZE(csi2_be_supported_codes) != NR_OF_CSI2_BE_PADS);
 	csi2_be->asd.supported_codes = csi2_be_supported_codes;
diff --git a/drivers/media/pci/intel/ipu-isys-csi2.c b/drivers/media/pci/intel/ipu-isys-csi2.c
index 4667df0..9a71ce5 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2.c
@@ -28,6 +28,7 @@ static const u32 csi2_supported_codes_pad_sink[] = {
 	MEDIA_BUS_FMT_RGB888_1X24,
 	MEDIA_BUS_FMT_UYVY8_1X16,
 	MEDIA_BUS_FMT_YUYV8_1X16,
+	MEDIA_BUS_FMT_YUYV10_1X20,
 	MEDIA_BUS_FMT_SBGGR10_1X10,
 	MEDIA_BUS_FMT_SGBRG10_1X10,
 	MEDIA_BUS_FMT_SGRBG10_1X10,
@@ -57,6 +58,7 @@ static const u32 csi2_supported_codes_pad_source[] = {
 	MEDIA_BUS_FMT_RGB888_1X24,
 	MEDIA_BUS_FMT_UYVY8_1X16,
 	MEDIA_BUS_FMT_YUYV8_1X16,
+	MEDIA_BUS_FMT_YUYV10_1X20,
 	MEDIA_BUS_FMT_SBGGR10_1X10,
 	MEDIA_BUS_FMT_SGBRG10_1X10,
 	MEDIA_BUS_FMT_SGRBG10_1X10,
@@ -136,7 +138,9 @@ static int ipu_get_frame_desc_entry_by_dt(struct v4l2_subdev *sd,
 					  struct v4l2_mbus_frame_desc_entry
 					  *entry, u8 data_type)
 {
-	struct v4l2_mbus_frame_desc desc;
+	struct v4l2_mbus_frame_desc desc = {
+		.num_entries = V4L2_FRAME_DESC_ENTRY_MAX,
+	};
 	int rval, i;
 
 	rval = v4l2_subdev_call(sd, pad, get_frame_desc, 0, &desc);
@@ -644,7 +648,6 @@ void ipu_isys_csi2_cleanup(struct ipu_isys_csi2 *csi2)
 	ipu_isys_subdev_cleanup(&csi2->asd);
 	for (i = 0; i < NR_OF_CSI2_SOURCE_PADS; i++)
 		ipu_isys_video_cleanup(&csi2->av[i]);
-	
 #ifdef IPU_META_DATA_SUPPORT
 	ipu_isys_video_cleanup(&csi2->av_meta);
 #endif
@@ -874,8 +877,8 @@ void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
 	trace_ipu_sof_seqid(ev.u.frame_sync.frame_sequence, csi2->index, vc);
 	v4l2_event_queue(vdev, &ev);
 	dev_dbg(&csi2->isys->adev->dev,
-		"sof_event::csi2-%i sequence: %i, vc: %d, stream_id: %d\n",
-		csi2->index, ev.u.frame_sync.frame_sequence, vc, ip->stream_id);
+		"sof_event::csi2-%i CPU-timestamp:%lld, sequence:%i, vc:%d, stream_id:%d\n",
+		csi2->index, ktime_get_ns(), ev.u.frame_sync.frame_sequence, vc, ip->stream_id);
 }
 
 void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
@@ -903,7 +906,7 @@ void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
 	if (ip) {
 		frame_sequence = atomic_read(&ip->sequence);
 
-		trace_ipu_eof_seqid(frame_sequence, csi2->index, vc);
+	trace_ipu_eof_seqid(frame_sequence, csi2->index, vc);
 
 		dev_dbg(&csi2->isys->adev->dev,
 			"eof_event::csi2-%i sequence: %i, vc: %d, stream_id: %d\n",
diff --git a/drivers/media/pci/intel/ipu-isys-media.h b/drivers/media/pci/intel/ipu-isys-media.h
index 823324e..b09d240 100644
--- a/drivers/media/pci/intel/ipu-isys-media.h
+++ b/drivers/media/pci/intel/ipu-isys-media.h
@@ -87,5 +87,75 @@ static inline bool media_entity_enum_test(struct media_entity_enum *ent_enum,
 #define media_graph_walk_cleanup(g) media_entity_graph_walk_cleanup(g)
 #endif
 
+#ifndef MEDIA_IOC_REQUEST_CMD
+
+struct __packed media_request_cmd {
+	__u32 cmd;
+	__u32 request;
+	__u32 flags;
+};
+
+struct __packed media_event_request_complete {
+	__u32 id;
+};
+
+#define MEDIA_EVENT_TYPE_REQUEST_COMPLETE	1
+
+struct __packed media_event {
+	__u32 type;
+	__u32 sequence;
+	__u32 reserved[4];
+
+	union {
+		struct media_event_request_complete req_complete;
+	};
+};
+
+enum media_device_request_state {
+	MEDIA_DEVICE_REQUEST_STATE_IDLE,
+	MEDIA_DEVICE_REQUEST_STATE_QUEUED,
+	MEDIA_DEVICE_REQUEST_STATE_DELETED,
+	MEDIA_DEVICE_REQUEST_STATE_COMPLETE,
+};
+
+struct media_kevent {
+	struct list_head list;
+	struct media_event ev;
+};
+
+struct media_device_request {
+	u32 id;
+	struct media_device *mdev;
+	struct file *filp;
+	struct media_kevent *kev;
+	struct kref kref;
+	struct list_head list;
+	struct list_head fh_list;
+	enum media_device_request_state state;
+	struct list_head data;
+	u32 flags;
+};
+
+static inline struct media_device_request *
+media_device_request_find(struct media_device *mdev, u16 reqid)
+{
+	return NULL;
+}
+
+static inline void media_device_request_get(struct media_device_request *req)
+{
+}
+
+static inline void media_device_request_put(struct media_device_request *req)
+{
+}
+
+static inline void
+media_device_request_complete(struct media_device *mdev,
+			      struct media_device_request *req)
+{
+}
+
+#endif
 
 #endif /* IPU_ISYS_MEDIA_H */
diff --git a/drivers/media/pci/intel/ipu-isys-queue.c b/drivers/media/pci/intel/ipu-isys-queue.c
index 1f6f769..9653c97 100644
--- a/drivers/media/pci/intel/ipu-isys-queue.c
+++ b/drivers/media/pci/intel/ipu-isys-queue.c
@@ -493,11 +493,14 @@ void ipu_isys_buffer_list_to_ipu_fw_isys_frame_buff_set(
 
 	set->send_irq_sof = 1;
 	set->send_resp_sof = 1;
-	set->send_irq_eof = 1;
-	set->send_resp_eof = 1;
 #if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
 	set->send_irq_capture_ack = 1;
 	set->send_irq_capture_done = 1;
+	set->send_irq_eof = 1;
+	set->send_resp_eof = 1;
+#else
+	set->send_irq_eof = 0;
+	set->send_resp_eof = 0;
 #endif
 
 	list_for_each_entry(ib, &bl->head, head) {
@@ -1159,8 +1162,8 @@ ipu_isys_buf_calc_sequence_time(struct ipu_isys_buffer *ib,
 	vbuf->vb2_buf.timestamp = ns;
 	vbuf->sequence = sequence;
 
-	dev_dbg(&av->isys->adev->dev, "buffer: %s: buffer done %u\n",
-		av->vdev.name, vb->index);
+	dev_dbg(&av->isys->adev->dev, "buffer: %s: buffer done, CPU-timestamp:%lld, sequence:%d, vc:%d, index:%d, vbuf timestamp:%lld, endl\n",
+		av->vdev.name, ktime_get_ns(), sequence, ip->vc, vb->index, vbuf->vb2_buf.timestamp);
 #endif
 }
 
@@ -1329,11 +1332,14 @@ int ipu_isys_req_prepare(struct media_device *mdev,
 
 	set->send_irq_sof = 1;
 	set->send_resp_sof = 1;
-	set->send_irq_eof = 1;
-	set->send_resp_eof = 1;
 #if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
 	set->send_irq_capture_ack = 1;
 	set->send_irq_capture_done = 1;
+	set->send_irq_eof = 1;
+	set->send_resp_eof = 1;
+#else
+	set->send_irq_eof = 0;
+	set->send_resp_eof = 0;
 #endif
 
 	spin_lock_irqsave(&ireq->lock, flags);
diff --git a/drivers/media/pci/intel/ipu-isys-queue.h b/drivers/media/pci/intel/ipu-isys-queue.h
index 4162b05..5138077 100644
--- a/drivers/media/pci/intel/ipu-isys-queue.h
+++ b/drivers/media/pci/intel/ipu-isys-queue.h
@@ -13,6 +13,7 @@
 #include <media/videobuf2-v4l2.h>
 #endif
 
+#include "ipu-isys-media.h"
 
 struct ipu_isys_video;
 struct ipu_isys_pipeline;
diff --git a/drivers/media/pci/intel/ipu-isys-subdev.c b/drivers/media/pci/intel/ipu-isys-subdev.c
index 745c109..4b4b055 100644
--- a/drivers/media/pci/intel/ipu-isys-subdev.c
+++ b/drivers/media/pci/intel/ipu-isys-subdev.c
@@ -17,6 +17,8 @@ unsigned int ipu_isys_mbus_code_to_bpp(u32 code)
 	switch (code) {
 	case MEDIA_BUS_FMT_RGB888_1X24:
 		return 24;
+	case MEDIA_BUS_FMT_YUYV10_1X20:
+		return 20;
 	case MEDIA_BUS_FMT_Y10_1X10:
 	case MEDIA_BUS_FMT_RGB565_1X16:
 	case MEDIA_BUS_FMT_UYVY8_1X16:
@@ -59,6 +61,8 @@ unsigned int ipu_isys_mbus_code_to_mipi(u32 code)
 		return IPU_ISYS_MIPI_CSI2_TYPE_RGB565;
 	case MEDIA_BUS_FMT_RGB888_1X24:
 		return IPU_ISYS_MIPI_CSI2_TYPE_RGB888;
+	case MEDIA_BUS_FMT_YUYV10_1X20:
+		return IPU_ISYS_MIPI_CSI2_TYPE_YUV422_10;
 	case MEDIA_BUS_FMT_UYVY8_1X16:
 	case MEDIA_BUS_FMT_YUYV8_1X16:
 		return IPU_ISYS_MIPI_CSI2_TYPE_YUV422_8;
@@ -219,7 +223,7 @@ static int target_valid(struct v4l2_subdev *sd, unsigned int target,
 	}
 }
 
-void ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
+int ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0)
 				   struct v4l2_subdev_fh *cfg,
 #else
@@ -231,16 +235,36 @@ void ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 				   unsigned int pad, unsigned int which)
 {
 	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
-	struct v4l2_mbus_framefmt *ffmts[sd->entity.num_pads];
-	struct v4l2_rect *crops[sd->entity.num_pads];
-	struct v4l2_rect *compose[sd->entity.num_pads];
+	struct v4l2_mbus_framefmt **ffmts = NULL;
+	struct v4l2_rect **crops = NULL;
+	struct v4l2_rect **compose = NULL;
 	unsigned int i;
+	int rval = 0;
 
 	if (tgt == IPU_ISYS_SUBDEV_PROP_TGT_NR_OF)
-		return;
+		return 0;
 
 	if (WARN_ON(pad >= sd->entity.num_pads))
-		return;
+		return -EINVAL;
+
+	ffmts = kcalloc(sd->entity.num_pads,
+			sizeof(*ffmts), GFP_KERNEL);
+	if (!ffmts) {
+		rval = -ENOMEM;
+		goto out_subdev_fmt_propagate;
+	}
+	crops = kcalloc(sd->entity.num_pads,
+			sizeof(*crops), GFP_KERNEL);
+	if (!crops) {
+		rval = -ENOMEM;
+		goto out_subdev_fmt_propagate;
+	}
+	compose = kcalloc(sd->entity.num_pads,
+			sizeof(*compose), GFP_KERNEL);
+	if (!compose) {
+		rval = -ENOMEM;
+		goto out_subdev_fmt_propagate;
+	}
 
 	for (i = 0; i < sd->entity.num_pads; i++) {
 		ffmts[i] = __ipu_isys_get_ffmt(sd, cfg, i, 0, which);
@@ -256,24 +280,26 @@ void ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 		crops[pad]->top = 0;
 		crops[pad]->width = ffmt->width;
 		crops[pad]->height = ffmt->height;
-		ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt, crops[pad],
+		rval = ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt, crops[pad],
 					      tgt + 1, pad, which);
-		return;
+		goto out_subdev_fmt_propagate;
 	case IPU_ISYS_SUBDEV_PROP_TGT_SINK_CROP:
 		if (WARN_ON(sd->entity.pads[pad].flags & MEDIA_PAD_FL_SOURCE))
-			return;
+			goto out_subdev_fmt_propagate;
 
 		compose[pad]->left = 0;
 		compose[pad]->top = 0;
 		compose[pad]->width = r->width;
 		compose[pad]->height = r->height;
-		ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt,
+		rval = ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt,
 					      compose[pad], tgt + 1,
 					      pad, which);
-		return;
+		goto out_subdev_fmt_propagate;
 	case IPU_ISYS_SUBDEV_PROP_TGT_SINK_COMPOSE:
-		if (WARN_ON(sd->entity.pads[pad].flags & MEDIA_PAD_FL_SOURCE))
-			return;
+		if (WARN_ON(sd->entity.pads[pad].flags & MEDIA_PAD_FL_SOURCE)) {
+			rval = -EINVAL;
+			goto out_subdev_fmt_propagate;
+		}
 
 		/* 1:n and 1:1 case: only propagate to the first source pad */
 		if (asd->nsinks == 1 && asd->nsources >= 1) {
@@ -281,10 +307,12 @@ void ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 			    compose[asd->nsinks]->top = 0;
 			compose[asd->nsinks]->width = r->width;
 			compose[asd->nsinks]->height = r->height;
-			ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt,
+			rval = ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt,
 						      compose[asd->nsinks],
 						      tgt + 1, asd->nsinks,
 						      which);
+			if (rval)
+				goto out_subdev_fmt_propagate;
 			/* n:n case: propagate according to route info */
 		} else if (asd->nsinks == asd->nsources && asd->nsources > 1) {
 			for (i = asd->nsinks; i < sd->entity.num_pads; i++)
@@ -296,10 +324,12 @@ void ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 				compose[i]->top = 0;
 				compose[i]->width = r->width;
 				compose[i]->height = r->height;
-				ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt,
+				rval = ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt,
 							      compose[i],
 							      tgt + 1, i,
 							      which);
+				if (rval)
+					goto out_subdev_fmt_propagate;
 			}
 			/* n:m case: propagate to all source pad */
 		} else if (asd->nsinks != asd->nsources && asd->nsources > 1 &&
@@ -313,25 +343,29 @@ void ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 				compose[i]->top = 0;
 				compose[i]->width = r->width;
 				compose[i]->height = r->height;
-				ipu_isys_subdev_fmt_propagate(sd, cfg,
+				rval = ipu_isys_subdev_fmt_propagate(sd, cfg,
 							      ffmt,
 							      compose[i],
 							      tgt + 1, i,
 							      which);
+				if (rval)
+					goto out_subdev_fmt_propagate;
 			}
 		}
-		return;
+		goto out_subdev_fmt_propagate;
 	case IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_COMPOSE:
-		if (WARN_ON(sd->entity.pads[pad].flags & MEDIA_PAD_FL_SINK))
-			return;
+		if (WARN_ON(sd->entity.pads[pad].flags & MEDIA_PAD_FL_SINK)) {
+			rval = -EINVAL;
+			goto out_subdev_fmt_propagate;
+		}
 
 		crops[pad]->left = 0;
 		crops[pad]->top = 0;
 		crops[pad]->width = r->width;
 		crops[pad]->height = r->height;
-		ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt,
+		rval = ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt,
 					      crops[pad], tgt + 1, pad, which);
-		return;
+		goto out_subdev_fmt_propagate;
 	case IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP:{
 			struct v4l2_subdev_format fmt = {
 				.which = which,
@@ -352,12 +386,18 @@ void ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 			};
 
 			asd->set_ffmt(sd, cfg, &fmt);
-			return;
+			goto out_subdev_fmt_propagate;
 		}
 	}
+
+out_subdev_fmt_propagate:
+	kfree(ffmts);
+	kfree(crops);
+	kfree(compose);
+	return rval;
 }
 
-void ipu_isys_subdev_set_ffmt_default(struct v4l2_subdev *sd,
+int ipu_isys_subdev_set_ffmt_default(struct v4l2_subdev *sd,
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0)
 				      struct v4l2_subdev_fh *cfg,
 #else
@@ -379,7 +419,6 @@ void ipu_isys_subdev_set_ffmt_default(struct v4l2_subdev *sd,
 		ffmt->height = sink_ffmt->height;
 		ffmt->code = sink_ffmt->code;
 		ffmt->field = sink_ffmt->field;
-		return;
 	}
 
 	ffmt->width = fmt->format.width;
@@ -387,7 +426,7 @@ void ipu_isys_subdev_set_ffmt_default(struct v4l2_subdev *sd,
 	ffmt->code = fmt->format.code;
 	ffmt->field = fmt->format.field;
 
-	ipu_isys_subdev_fmt_propagate(sd, cfg, &fmt->format, NULL,
+	return ipu_isys_subdev_fmt_propagate(sd, cfg, &fmt->format, NULL,
 				      IPU_ISYS_SUBDEV_PROP_TGT_SINK_FMT,
 				      fmt->pad, fmt->which);
 }
@@ -694,10 +733,8 @@ int ipu_isys_subdev_set_sel(struct v4l2_subdev *sd,
 	sel->r.height = clamp(sel->r.height, IPU_ISYS_MIN_HEIGHT, r->height);
 	*__ipu_isys_get_selection(sd, cfg, sel->target, sel->pad,
 				  sel->which) = sel->r;
-	ipu_isys_subdev_fmt_propagate(sd, cfg, NULL, &sel->r, tgt,
+	return ipu_isys_subdev_fmt_propagate(sd, cfg, NULL, &sel->r, tgt,
 				      sel->pad, sel->which);
-
-	return 0;
 }
 
 int ipu_isys_subdev_get_sel(struct v4l2_subdev *sd,
diff --git a/drivers/media/pci/intel/ipu-isys-subdev.h b/drivers/media/pci/intel/ipu-isys-subdev.h
index 6b08cf5..034b356 100644
--- a/drivers/media/pci/intel/ipu-isys-subdev.h
+++ b/drivers/media/pci/intel/ipu-isys-subdev.h
@@ -16,6 +16,7 @@
 #define IPU_ISYS_MIPI_CSI2_TYPE_BLANKING	0x11
 #define IPU_ISYS_MIPI_CSI2_TYPE_EMBEDDED8	0x12
 #define IPU_ISYS_MIPI_CSI2_TYPE_YUV422_8	0x1e
+#define IPU_ISYS_MIPI_CSI2_TYPE_YUV422_10	0x1f
 #define IPU_ISYS_MIPI_CSI2_TYPE_RGB565	0x22
 #define IPU_ISYS_MIPI_CSI2_TYPE_RGB888	0x24
 #define IPU_ISYS_MIPI_CSI2_TYPE_RAW6	0x28
@@ -120,7 +121,7 @@ u32 ipu_isys_subdev_code_to_uncompressed(u32 sink_code);
 
 enum ipu_isys_subdev_pixelorder ipu_isys_subdev_get_pixelorder(u32 code);
 
-void ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
+int ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0)
 				   struct v4l2_subdev_fh *cfg,
 #else
@@ -131,7 +132,7 @@ void ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 				   enum isys_subdev_prop_tgt tgt,
 				   unsigned int pad, unsigned int which);
 
-void ipu_isys_subdev_set_ffmt_default(struct v4l2_subdev *sd,
+int ipu_isys_subdev_set_ffmt_default(struct v4l2_subdev *sd,
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0)
 				      struct v4l2_subdev_fh *cfg,
 #else
diff --git a/drivers/media/pci/intel/ipu-isys-tpg.c b/drivers/media/pci/intel/ipu-isys-tpg.c
index 5fe0048..e7400e0 100644
--- a/drivers/media/pci/intel/ipu-isys-tpg.c
+++ b/drivers/media/pci/intel/ipu-isys-tpg.c
@@ -3,7 +3,9 @@
 
 #include <linux/device.h>
 #include <linux/module.h>
+#if IS_ENABLED(CONFIG_VIDEO_CRLMODULE)
 #include <linux/crlmodule.h>
+#endif
 
 #include <media/media-entity.h>
 #include <media/v4l2-device.h>
@@ -57,6 +59,7 @@ static int ipu_isys_tpg_s_ctrl(struct v4l2_ctrl *ctrl)
 	case V4L2_CID_VBLANK:
 		writel(ctrl->val, tpg->base + MIPI_GEN_REG_SYNG_VBLANK_CYC);
 		break;
+#if IS_ENABLED(CONFIG_VIDEO_CRLMODULE)
 	case V4L2_CID_LINE_LENGTH_PIXELS:
 		if (ctrl->val > tpg->asd.ffmt[TPG_PAD_SOURCE][0].width)
 			writel(ctrl->val -
@@ -69,6 +72,7 @@ static int ipu_isys_tpg_s_ctrl(struct v4l2_ctrl *ctrl)
 				   tpg->asd.ffmt[TPG_PAD_SOURCE][0].height,
 				   tpg->base + MIPI_GEN_REG_SYNG_VBLANK_CYC);
 		break;
+#endif
 	case V4L2_CID_TEST_PATTERN:
 		writel(ctrl->val, tpg->base + MIPI_GEN_REG_TPG_MODE);
 		break;
@@ -118,6 +122,7 @@ static void ipu_isys_tpg_init_controls(struct v4l2_subdev *sd)
 {
 	struct ipu_isys_tpg *tpg = to_ipu_isys_tpg(sd);
 	int hblank;
+#if IS_ENABLED(CONFIG_VIDEO_CRLMODULE)
 	struct v4l2_ctrl_config cfg = {
 		.ops = &ipu_isys_tpg_ctrl_ops,
 		.type = V4L2_CTRL_TYPE_INTEGER,
@@ -127,6 +132,7 @@ static void ipu_isys_tpg_init_controls(struct v4l2_subdev *sd)
 		.qmenu = NULL,
 		.elem_size = 0,
 	};
+#endif
 
 	hblank = 1024;
 
@@ -138,6 +144,7 @@ static void ipu_isys_tpg_init_controls(struct v4l2_subdev *sd)
 					&ipu_isys_tpg_ctrl_ops,
 					V4L2_CID_VBLANK, 8, 65535, 1, 1024);
 
+#if IS_ENABLED(CONFIG_VIDEO_CRLMODULE)
 	cfg.id = V4L2_CID_LINE_LENGTH_PIXELS;
 	cfg.name = "Line Length Pixels";
 	cfg.def = 1024 + 4096;
@@ -149,6 +156,7 @@ static void ipu_isys_tpg_init_controls(struct v4l2_subdev *sd)
 	cfg.def = 1024 + 3072;
 	tpg->fll = v4l2_ctrl_new_custom(&tpg->asd.ctrl_handler, &cfg, NULL);
 
+#endif
 	tpg->pixel_rate = v4l2_ctrl_new_std(&tpg->asd.ctrl_handler,
 					    &ipu_isys_tpg_ctrl_ops,
 					    V4L2_CID_PIXEL_RATE, 0, 0, 1, 0);
@@ -237,10 +245,6 @@ static int subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
 			   struct v4l2_event_subscription *sub)
 {
 	switch (sub->type) {
-#ifdef IPU_TPG_SOF
-	case V4L2_EVENT_FRAME_SYNC:
-		return v4l2_event_subscribe(fh, sub, 10, NULL);
-#endif
 	case V4L2_EVENT_CTRL:
 		return v4l2_ctrl_subscribe_event(fh, sub);
 	default:
diff --git a/drivers/media/pci/intel/ipu-isys-tpg.h b/drivers/media/pci/intel/ipu-isys-tpg.h
index 4a2a23d..65b8e21 100644
--- a/drivers/media/pci/intel/ipu-isys-tpg.h
+++ b/drivers/media/pci/intel/ipu-isys-tpg.h
@@ -78,8 +78,10 @@ struct ipu_isys_tpg {
 
 	struct v4l2_ctrl *hblank;
 	struct v4l2_ctrl *vblank;
+#if IS_ENABLED(CONFIG_VIDEO_CRLMODULE)
 	struct v4l2_ctrl *llp;
 	struct v4l2_ctrl *fll;
+#endif
 	struct v4l2_ctrl *pixel_rate;
 	struct v4l2_ctrl *store_csi2_header;
 };
@@ -87,10 +89,6 @@ struct ipu_isys_tpg {
 #define to_ipu_isys_tpg(sd)		\
 	container_of(to_ipu_isys_subdev(sd), \
 	struct ipu_isys_tpg, asd)
-#ifdef IPU_TPG_SOF
-void ipu_isys_tpg_sof_event(struct ipu_isys_tpg *tpg);
-extern const struct v4l2_subdev_core_ops tpg_sd_core_ops;
-#endif
 int ipu_isys_tpg_init(struct ipu_isys_tpg *tpg,
 		      struct ipu_isys *isys,
 		      void __iomem *base, void __iomem *sel,
diff --git a/drivers/media/pci/intel/ipu-isys-video.c b/drivers/media/pci/intel/ipu-isys-video.c
index 27b8b8f..776ed0d 100644
--- a/drivers/media/pci/intel/ipu-isys-video.c
+++ b/drivers/media/pci/intel/ipu-isys-video.c
@@ -50,8 +50,10 @@ const struct ipu_isys_pixelformat ipu_isys_pfmts_be_soc[] = {
 	 IPU_FW_ISYS_FRAME_FORMAT_UYVY},
 	{V4L2_PIX_FMT_YUYV, 16, 16, 0, MEDIA_BUS_FMT_YUYV8_1X16,
 	 IPU_FW_ISYS_FRAME_FORMAT_YUYV},
-	{V4L2_PIX_FMT_NV16, 16, 16, 8, MEDIA_BUS_FMT_YUYV8_1X16,
+	{V4L2_PIX_FMT_NV16, 16, 16, 8, MEDIA_BUS_FMT_UYVY8_1X16,
 	 IPU_FW_ISYS_FRAME_FORMAT_NV16},
+	{V4L2_PIX_FMT_YUV420, 12, 0, 8, MEDIA_BUS_FMT_UYVY8_2X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_YUV420},
 	{V4L2_PIX_FMT_XRGB32, 32, 32, 0, MEDIA_BUS_FMT_RGB565_1X16,
 	 IPU_FW_ISYS_FRAME_FORMAT_RGBA888},
 	{V4L2_PIX_FMT_XBGR32, 32, 32, 0, MEDIA_BUS_FMT_RGB888_1X24,
@@ -163,6 +165,11 @@ static int video_open(struct file *file)
 	struct ipu_isys *isys = av->isys;
 	struct ipu_bus_device *adev = to_ipu_bus_device(&isys->adev->dev);
 	struct ipu_device *isp = adev->isp;
+#ifdef IPU_IRQ_POLL
+	const struct sched_param param = {
+			.sched_priority = MAX_USER_RT_PRIO / 2,
+	};
+#endif
 	int rval;
 
 	mutex_lock(&isys->mutex);
@@ -227,6 +234,18 @@ static int video_open(struct file *file)
 		ipu_fw_isys_cleanup(isys);
 	}
 
+#ifdef IPU_IRQ_POLL
+	isys->isr_thread = kthread_run(ipu_isys_isr_run,
+				       av->isys,
+				       IPU_ISYS_ENTITY_PREFIX);
+
+	if (IS_ERR(isys->isr_thread)) {
+		rval = PTR_ERR(isys->isr_thread);
+		goto out_ipu_pipeline_pm_use;
+	}
+
+	sched_setscheduler(isys->isr_thread, SCHED_FIFO, &param);
+#endif
 
 	rval = ipu_fw_isys_init(av->isys, num_stream_support);
 	if (rval < 0)
@@ -237,6 +256,11 @@ static int video_open(struct file *file)
 	return 0;
 
 out_lib_init:
+#ifdef IPU_IRQ_POLL
+	kthread_stop(isys->isr_thread);
+
+out_ipu_pipeline_pm_use:
+#endif /* IPU_IRQ_POLL */
 	isys->video_opened--;
 	mutex_unlock(&isys->mutex);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
@@ -263,6 +287,9 @@ static int video_release(struct file *file)
 	mutex_lock(&av->isys->mutex);
 
 	if (!--av->isys->video_opened) {
+#ifdef IPU_IRQ_POLL
+		kthread_stop(av->isys->isr_thread);
+#endif
 		ipu_fw_isys_close(av->isys);
 		if (av->isys->fwcom) {
 			av->isys->reset_needed = true;
@@ -622,39 +649,6 @@ static long ipu_isys_vidioc_private(struct file *file, void *fh,
 	int ret = 0;
 
 	switch (cmd) {
-#ifdef IPU_OTF_SUPPORT
-	case VIDIOC_IPU_SET_LINK_ID: {
-		struct ipu_isys_pipeline *ip = &av->ip;
-		u8 link_id = *(u8 *) arg;
-
-		if (ip->streaming) {
-			dev_err(&av->isys->adev->dev,
-				"Could not set link id while streaming\n");
-			return -EBUSY;
-		}
-
-		dev_dbg(&av->isys->adev->dev, "set link id %d\n", link_id);
-		if (link_id != 0 || link_id >= N_IPU_FW_ISYS_LINK_ID)
-			return -EINVAL;
-
-		av->link_id = link_id;
-		break;
-	}
-
-	case VIDIOC_IPU_SET_FRAME_COUNTER: {
-		struct ipu_frame_counter *fc = (struct ipu_frame_counter *)arg;
-
-		if (!av->link_id)
-			return 0;
-
-		dev_dbg(&av->isys->adev->dev, "set frame counter %d\n",
-			fc->frame_counter);
-		ret = ipu_isys_queue_prepare_frame_counter(av,
-							   fc->frame_counter,
-							   fc->index);
-		break;
-	}
-#endif
 	case VIDIOC_IPU_GET_DRIVER_VERSION:
 		*(u32 *)arg = IPU_DRIVER_VERSION;
 		break;
@@ -757,7 +751,7 @@ static int link_validate(struct media_link *link)
 
 	if (ip->external) {
 		struct v4l2_mbus_frame_desc desc = {
-			.num_entries = IPU_ISYS_MAX_STREAMS,
+			.num_entries = V4L2_FRAME_DESC_ENTRY_MAX,
 		};
 
 		sd = media_entity_to_v4l2_subdev(ip->external->entity);
@@ -998,7 +992,6 @@ void ipu_isys_prepare_firmware_stream_cfg_default(
 {
 	struct ipu_isys_pipeline *ip =
 	    to_ipu_isys_pipeline(av->vdev.entity.pipe);
-
 	struct ipu_isys_queue *aq = &av->aq;
 	struct ipu_fw_isys_output_pin_info_abi *pin_info;
 	int pin = cfg->nof_output_pins++;
@@ -1472,7 +1465,11 @@ int ipu_isys_video_prepare_streaming(struct ipu_isys_video *av,
 
 	/* Gather all entities in the graph. */
 	mutex_lock(&mdev->graph_mutex);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
+	media_graph_walk_start(&graph, &av->vdev.entity);
+#else
 	media_graph_walk_start(&graph, &av->vdev.entity.pads[0]);
+#endif
 	while ((entity = media_graph_walk_next(&graph)))
 		media_entity_enum_set(&ip->entity_enum, entity);
 
@@ -1578,7 +1575,9 @@ int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 		if (ip->csi2) {
 			if (ip->csi2->stream_count == 1) {
 				v4l2_subdev_call(esd, video, s_stream, state);
+#if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
 				ipu_isys_csi2_wait_last_eof(ip->csi2);
+#endif
 			}
 		} else {
 			v4l2_subdev_call(esd, video, s_stream, state);
@@ -1592,7 +1591,11 @@ int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 				      ip->
 #endif
 				      graph,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
+				      &av->vdev.entity);
+#else
 				      &av->vdev.entity.pads[0]);
+#endif
 
 	while ((entity = media_graph_walk_next(&
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
@@ -1676,7 +1679,11 @@ int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 				      ip->
 #endif
 				      graph,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
+				      &av->vdev.entity);
+#else
 				      &av->vdev.entity.pads[0]);
+#endif
 
 	while (state && (entity2 = media_graph_walk_next(&
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
diff --git a/drivers/media/pci/intel/ipu-isys.c b/drivers/media/pci/intel/ipu-isys.c
index 2f65fc1..51a5fc5 100644
--- a/drivers/media/pci/intel/ipu-isys.c
+++ b/drivers/media/pci/intel/ipu-isys.c
@@ -411,27 +411,27 @@ static int isys_register_ext_subdev(struct ipu_isys *isys,
 	struct v4l2_subdev *sd;
 	struct i2c_client *client;
 	int rval;
-       int bus;
+	int bus;
 
 #ifdef I2C_WA
-       bus = ipu_get_i2c_bus_id(sd_info->i2c.i2c_adapter_id);
-       if (bus < 0) {
-               dev_err(&isys->adev->dev, "Failed to find adapter!");
-               return -ENOENT;
-       }
+	bus = ipu_get_i2c_bus_id(sd_info->i2c.i2c_adapter_id);
+	if (bus < 0) {
+		dev_err(&isys->adev->dev, "Failed to find adapter!");
+		return -ENOENT;
+	}
 #else
-        bus = sd_info->i2c.i2c_adapter_id;
+	bus = sd_info->i2c.i2c_adapter_id;
 #endif
-        adapter = i2c_get_adapter(bus);
-        if (!adapter) {
+	adapter = i2c_get_adapter(bus);
+	if (!adapter) {
 		dev_warn(&isys->adev->dev, "can't find adapter\n");
 		return -ENOENT;
 	}
 
-        dev_info(&isys->adev->dev,
-                 "creating new i2c subdev for %s (address %2.2x, bus %d)",
-                 sd_info->i2c.board_info.type, sd_info->i2c.board_info.addr,
-                 bus);
+	dev_info(&isys->adev->dev,
+		 "creating new i2c subdev for %s (address %2.2x, bus %d)",
+		 sd_info->i2c.board_info.type, sd_info->i2c.board_info.addr,
+		 bus);
 
 	if (sd_info->csi2) {
 		dev_info(&isys->adev->dev, "sensor device on CSI port: %d\n",
@@ -562,6 +562,7 @@ static void isys_register_ext_subdevs(struct ipu_isys *isys)
                         isys_register_ext_subdev(isys, *sd_info, false);
         } else {
 		dev_info(&isys->adev->dev, "no subdevice info provided\n");
+		return;
 	}
 
         /* Handle real ACPI stuff */
@@ -701,11 +702,11 @@ static int isys_register_subdevices(struct ipu_isys *isys)
 			for (k = CSI2_BE_SOC_PAD_SINK(0);
 			     k < NR_OF_CSI2_BE_SOC_SINK_PADS; k++) {
 				rval =
-                                    media_create_pad_link(&isys->csi2[i].asd.sd.
-                                                          entity, j,
-                                                          &isys->csi2_be_soc.
-                                                          asd.sd.entity, k,
-                                                          MEDIA_LNK_FL_DYNAMIC);
+				    media_create_pad_link(&isys->csi2[i].asd.sd.
+							  entity, j,
+							  &isys->csi2_be_soc.
+							  asd.sd.entity, k,
+							  MEDIA_LNK_FL_DYNAMIC);
 				if (rval) {
 					dev_info(&isys->adev->dev,
 						 "can't create link csi2->be_soc\n");
@@ -763,9 +764,11 @@ static struct media_device_ops isys_mdev_ops = {
 #else
 	.link_notify = v4l2_pipeline_link_notify,
 #endif
+#ifdef MEDIA_IOC_REQUEST_CMD
 	.req_alloc = ipu_isys_req_alloc,
 	.req_free = ipu_isys_req_free,
 	.req_queue = ipu_isys_req_queue,
+#endif /* MEDIA_IOC_REQUEST_CMD */
 };
 
 static int isys_register_devices(struct ipu_isys *isys)
@@ -1155,16 +1158,17 @@ static int isys_probe(struct ipu_bus_device *adev)
 	struct ipu_mmu *mmu = dev_get_drvdata(adev->iommu);
 	struct ipu_isys *isys;
 	struct ipu_device *isp = adev->isp;
+#if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
 	const u32 trace_size = IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE;
 	dma_addr_t *trace_dma_addr;
-
-	const struct firmware *uninitialized_var(fw);
-	int rval = 0;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
 	struct dma_attrs attrs;
 #else
 	unsigned long attrs;
 #endif
+#endif
+	const struct firmware *uninitialized_var(fw);
+	int rval = 0;
 
 	trace_printk("B|%d|TMWK\n", current->pid);
 
@@ -1289,6 +1293,7 @@ static int isys_probe(struct ipu_bus_device *adev)
 
 	if (isys->short_packet_source == IPU_ISYS_SHORT_PACKET_FROM_TUNIT) {
 		mutex_destroy(&isys->short_packet_tracing_mutex);
+#if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
 		dma_free_attrs(&adev->dev, trace_size,
 			       isys->short_packet_trace_buffer,
 			       isys->short_packet_trace_buffer_dma_addr,
@@ -1297,6 +1302,7 @@ static int isys_probe(struct ipu_bus_device *adev)
 #else
 			       attrs);
 #endif
+#endif
 	}
 
 	return rval;
@@ -1479,10 +1485,6 @@ int isys_isr_one(struct ipu_bus_device *adev)
 
 		break;
 	case IPU_FW_ISYS_RESP_TYPE_FRAME_SOF:
-#ifdef IPU_TPG_SOF
-		if (pipe->tpg)
-			ipu_isys_tpg_sof_event(pipe->tpg);
-#endif
 		pipe->seq[pipe->seq_index].sequence =
 		    atomic_read(&pipe->sequence) - 1;
 		pipe->seq[pipe->seq_index].timestamp = ts;
diff --git a/drivers/media/pci/intel/ipu-isys.h b/drivers/media/pci/intel/ipu-isys.h
index b362f86..cd18a226 100644
--- a/drivers/media/pci/intel/ipu-isys.h
+++ b/drivers/media/pci/intel/ipu-isys.h
@@ -13,6 +13,7 @@
 #include <uapi/linux/ipu-isys.h>
 
 #include "ipu.h"
+#include "ipu-isys-media.h"
 #include "ipu-isys-csi2.h"
 #include "ipu-isys-csi2-be.h"
 #include "ipu-isys-tpg.h"
@@ -103,6 +104,10 @@ struct ipu_isys {
 	struct ipu_isys_pipeline *pipes[IPU_ISYS_MAX_STREAMS];
 	void *fwcom;
 	unsigned int line_align;
+#ifdef IPU_IRQ_POLL
+	/* for polling for events if interrupt delivery isn't available */
+	struct task_struct *isr_thread;
+#endif
 	bool reset_needed;
 	bool icache_prefetch;
 	bool csi2_cse_ipc_not_supported;
diff --git a/drivers/media/pci/intel/ipu-psys.c b/drivers/media/pci/intel/ipu-psys.c
index 7118f47..0346f48 100644
--- a/drivers/media/pci/intel/ipu-psys.c
+++ b/drivers/media/pci/intel/ipu-psys.c
@@ -13,6 +13,9 @@
 #include <linux/mm.h>
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
+#if defined(CONFIG_VIDEO_INTEL_IPU_ACRN) && defined(CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE)
+#include <linux/syscalls.h>
+#endif
 #include <linux/version.h>
 #include <linux/poll.h>
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
@@ -72,17 +75,15 @@ static struct fw_init_task {
 	struct ipu_psys *psys;
 } fw_init_task;
 
+#ifdef IPU_IRQ_POLL
+static int ipu_psys_isr_run(void *data);
+#endif
 static void ipu_psys_remove(struct ipu_bus_device *adev);
 
 static struct bus_type ipu_psys_bus = {
 	.name = IPU_PSYS_NAME,
 };
 
-static struct ipu_psys_capability caps = {
-	.version = 1,
-	.driver = "ipu-psys",
-};
-
 struct ipu_psys_pg *__get_pg_buf(struct ipu_psys *psys, size_t pg_size)
 {
 	struct ipu_psys_pg *kpg;
@@ -163,6 +164,13 @@ static int ipu_psys_get_userpages(struct ipu_dma_buf_attach *attach)
 	if (!sgt)
 		return -ENOMEM;
 
+	if (attach->npages != 0) {
+		pages = attach->pages;
+		npages = attach->npages;
+		attach->vma_is_io = 1;
+		goto skip_pages;
+	}
+
 	if (array_size <= PAGE_SIZE)
 		pages = kzalloc(array_size, GFP_KERNEL);
 	else
@@ -219,6 +227,10 @@ static int ipu_psys_get_userpages(struct ipu_dma_buf_attach *attach)
 	}
 	up_read(&current->mm->mmap_sem);
 
+	attach->pages = pages;
+	attach->npages = npages;
+
+skip_pages:
 	ret = sg_alloc_table_from_pages(sgt, pages, npages,
 					start & ~PAGE_MASK, attach->len,
 					GFP_KERNEL);
@@ -226,8 +238,6 @@ static int ipu_psys_get_userpages(struct ipu_dma_buf_attach *attach)
 		goto error;
 
 	attach->sgt = sgt;
-	attach->pages = pages;
-	attach->npages = npages;
 
 	return 0;
 
@@ -467,6 +477,11 @@ static int ipu_psys_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 
 	fh->psys = psys;
+
+#if defined(CONFIG_VIDEO_INTEL_IPU_ACRN) && defined(CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE)
+	fh->vfops = &psys_vfops;
+#endif
+
 	file->private_data = fh;
 
 	mutex_init(&fh->mutex);
@@ -516,8 +531,9 @@ static int ipu_psys_release(struct inode *inode, struct file *file)
 	struct ipu_psys *psys = inode_to_ipu_psys(inode);
 	struct ipu_psys_fh *fh = file->private_data;
 	struct ipu_psys_kbuffer *kbuf, *kbuf0;
-
-	ipu_psys_fh_deinit(fh);
+#if defined(CONFIG_VIDEO_INTEL_IPU_ACRN) && defined(CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE)
+	struct ipu_dma_buf_attach *ipu_attach;
+#endif
 
 	mutex_lock(&fh->mutex);
 	/* clean up buffers */
@@ -527,11 +543,12 @@ static int ipu_psys_release(struct inode *inode, struct file *file)
 			   /* Unmap and release buffers */
 			if (kbuf->dbuf && kbuf->db_attach) {
 				struct dma_buf *dbuf;
-#ifdef CONFIG_VIDEO_INTEL_IPU_MOCK
-				ipu_fw_psys_unregister_ctx_addr(kbuf->kaddr,
-								kbuf->dma_addr);
-#endif
 				kbuf->valid = false;
+#if defined(CONFIG_VIDEO_INTEL_IPU_ACRN) && defined(CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE)
+				ipu_attach = kbuf->db_attach->priv;
+				if (ipu_attach->vma_is_io)
+					ksys_close(kbuf->fd);
+#endif
 				dma_buf_vunmap(kbuf->dbuf, kbuf->kaddr);
 				dma_buf_unmap_attachment(kbuf->db_attach,
 							 kbuf->sgt,
@@ -550,7 +567,6 @@ static int ipu_psys_release(struct inode *inode, struct file *file)
 		}
 	}
 	mutex_unlock(&fh->mutex);
-	mutex_destroy(&fh->mutex);
 
 	mutex_lock(&psys->mutex);
 	list_del(&fh->list);
@@ -562,6 +578,9 @@ static int ipu_psys_release(struct inode *inode, struct file *file)
 	}
 #endif
 	mutex_unlock(&psys->mutex);
+
+	ipu_psys_fh_deinit(fh);
+	mutex_destroy(&fh->mutex);
 	kfree(fh);
 
 	return 0;
@@ -866,7 +885,7 @@ static long ipu_psys_ioctl(struct file *file, unsigned int cmd,
 		err = ipu_psys_unmapbuf(arg, fh);
 		break;
 	case IPU_IOC_QUERYCAP:
-		karg.caps = caps;
+		karg.caps = fh->psys->caps;
 		break;
 	case IPU_IOC_GETBUF:
 		err = ipu_psys_getbuf(&karg.buf, fh);
@@ -1034,7 +1053,7 @@ static int cpd_fw_reload(struct ipu_device *isp)
 		dev_info(&isp->pdev->dev, "Old FW removed\n");
 	}
 
-	rval = request_firmware(&isp->cpd_fw, isp->cpd_fw_name,
+	rval = request_cpd_fw(&isp->cpd_fw, isp->cpd_fw_name,
 				&isp->pdev->dev);
 	if (rval) {
 		dev_err(&isp->pdev->dev, "Requesting firmware(%s) failed\n",
@@ -1426,9 +1445,9 @@ static int ipu_psys_probe(struct ipu_bus_device *adev)
 	isp->pkg_dir_dma_addr = psys->pkg_dir_dma_addr;
 	isp->pkg_dir_size = psys->pkg_dir_size;
 
-	caps.pg_count = ipu_cpd_pkg_dir_get_num_entries(psys->pkg_dir);
+	psys->caps.pg_count = ipu_cpd_pkg_dir_get_num_entries(psys->pkg_dir);
 
-	dev_info(&adev->dev, "pkg_dir entry count:%d\n", caps.pg_count);
+	dev_info(&adev->dev, "pkg_dir entry count:%d\n", psys->caps.pg_count);
 	if (async_fw_init) {
 		INIT_DELAYED_WORK((struct delayed_work *)&fw_init_task,
 				  run_fw_init_work);
@@ -1455,8 +1474,8 @@ static int ipu_psys_probe(struct ipu_bus_device *adev)
 	}
 
 	/* Add the hw stepping information to caps */
-	strlcpy(caps.dev_model, IPU_MEDIA_DEV_MODEL_NAME,
-		sizeof(caps.dev_model));
+	strlcpy(psys->caps.dev_model, IPU_MEDIA_DEV_MODEL_NAME,
+		sizeof(psys->caps.dev_model));
 
 	pm_runtime_allow(&adev->dev);
 	pm_runtime_enable(&adev->dev);
@@ -1608,6 +1627,39 @@ static irqreturn_t psys_isr_threaded(struct ipu_bus_device *adev)
 	return status ? IRQ_HANDLED : IRQ_NONE;
 }
 
+#ifdef IPU_IRQ_POLL
+static int ipu_psys_isr_run(void *data)
+{
+	struct ipu_psys *psys = data;
+	int r;
+
+	while (!kthread_should_stop()) {
+		usleep_range(100, 500);
+#ifdef CONFIG_PM
+		if (!READ_ONCE(psys->power))
+			continue;
+#endif
+		r = mutex_trylock(&psys->mutex);
+		if (!r)
+			continue;
+#ifdef CONFIG_PM
+		r = pm_runtime_get_sync(&psys->adev->dev);
+		if (r < 0) {
+			pm_runtime_put(&psys->adev->dev);
+			mutex_unlock(&psys->mutex);
+			continue;
+		}
+#endif
+		ipu_psys_handle_events(psys);
+
+		pm_runtime_mark_last_busy(&psys->adev->dev);
+		pm_runtime_put_autosuspend(&psys->adev->dev);
+		mutex_unlock(&psys->mutex);
+	}
+
+	return 0;
+}
+#endif /* IPU_IRQ_POLL */
 
 static struct ipu_bus_driver ipu_psys_driver = {
 	.probe = ipu_psys_probe,
diff --git a/drivers/media/pci/intel/ipu-psys.h b/drivers/media/pci/intel/ipu-psys.h
index 26dc8a1..aea2d50 100644
--- a/drivers/media/pci/intel/ipu-psys.h
+++ b/drivers/media/pci/intel/ipu-psys.h
@@ -10,6 +10,9 @@
 #include "ipu.h"
 #include "ipu-pdata.h"
 #include "ipu-fw-psys.h"
+#if defined(CONFIG_VIDEO_INTEL_IPU_ACRN) && defined(CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE)
+#include "ipu-psys-virt.h"
+#endif
 #include "ipu-platform-psys.h"
 
 #define IPU_PSYS_PG_POOL_SIZE 16
@@ -20,7 +23,7 @@
 #define IPU_PSYS_CLOSE_TIMEOUT_US   50
 #define IPU_PSYS_CLOSE_TIMEOUT (100000 / IPU_PSYS_CLOSE_TIMEOUT_US)
 #define IPU_PSYS_WORK_QUEUE		system_power_efficient_wq
-#define IPU_MAX_RESOURCES 32
+#define IPU_MAX_RESOURCES 128
 
 /* Opaque structure. Do not access fields. */
 struct ipu_resource {
@@ -76,6 +79,7 @@ struct ipu_psys_resource_alloc {
 
 struct task_struct;
 struct ipu_psys {
+	struct ipu_psys_capability caps;
 	struct cdev cdev;
 	struct device dev;
 
@@ -93,6 +97,9 @@ struct ipu_psys {
 	struct ia_css_syscom_context *dev_ctx;
 	struct ia_css_syscom_config *syscom_config;
 	struct ia_css_psys_server_init *server_init;
+#ifdef IPU_IRQ_POLL
+	struct task_struct *isr_thread;
+#endif
 	struct task_struct *sched_cmd_thread;
 	struct work_struct watchdog_work;
 	wait_queue_head_t sched_cmd_wq;
@@ -115,12 +122,15 @@ struct ipu_psys {
 };
 
 struct ipu_psys_fh {
+#if defined(CONFIG_VIDEO_INTEL_IPU_ACRN) && defined(CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE)
+	const struct psys_fops_virt *vfops;
+#endif
 	struct ipu_psys *psys;
 	struct mutex mutex;	/* Protects bufmap & kcmds fields */
 	struct list_head list;
 	struct list_head bufmap;
 	wait_queue_head_t wait;
-       struct ipu_psys_scheduler sched;
+	struct ipu_psys_scheduler sched;
 };
 
 struct ipu_psys_pg {
@@ -135,11 +145,7 @@ struct ipu_psys_pg {
 struct ipu_psys_kcmd {
 	struct ipu_psys_fh *fh;
 	struct list_head list;
-#ifndef IPU_PSYS_LEGACY
-       struct ipu_psys_buffer_set *kbuf_set;
-#else
 	struct list_head started_list;
-#endif
 	enum ipu_psys_cmd_state state;
 	void *pg_manifest;
 	size_t pg_manifest_size;
diff --git a/drivers/media/pci/intel/ipu.c b/drivers/media/pci/intel/ipu.c
index e59a281..322ddfb 100644
--- a/drivers/media/pci/intel/ipu.c
+++ b/drivers/media/pci/intel/ipu.c
@@ -315,6 +315,38 @@ static void ipu_configure_vc_mechanism(struct ipu_device *isp)
 	writel(val, isp->base + BUTTRESS_REG_BTRS_CTRL);
 }
 
+int request_cpd_fw(const struct firmware **firmware_p, const char *name,
+		 struct device *device)
+{
+	const struct firmware *fw;
+	struct firmware *tmp;
+	int ret;
+
+	ret = request_firmware(&fw, name, device);
+	if (ret)
+		return ret;
+
+	if (is_vmalloc_addr(fw->data)) {
+		*firmware_p = fw;
+	} else {
+		tmp = kzalloc(sizeof(struct firmware), GFP_KERNEL);
+		if (!tmp)
+			return -ENOMEM;
+		tmp->size = fw->size;
+		tmp->data = vmalloc(fw->size);
+		if (!tmp->data) {
+			kfree(tmp);
+			return -ENOMEM;
+		}
+		memcpy((void *)tmp->data, fw->data, fw->size);
+		*firmware_p = tmp;
+		release_firmware(fw);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(request_cpd_fw);
+
 static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	struct ipu_device *isp;
@@ -332,6 +364,7 @@ static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (!isp)
 		return -ENOMEM;
 
+	dev_set_name(&pdev->dev, "intel-ipu");
 	isp->pdev = pdev;
 	INIT_LIST_HEAD(&isp->devices);
 
@@ -411,7 +444,7 @@ static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 
 	dev_info(&pdev->dev, "cpd file name: %s\n", isp->cpd_fw_name);
 
-	rval = request_firmware(&isp->cpd_fw, isp->cpd_fw_name, &pdev->dev);
+	rval = request_cpd_fw(&isp->cpd_fw, isp->cpd_fw_name, &pdev->dev);
 	if (rval) {
 		dev_err(&isp->pdev->dev, "Requesting signed firmware failed\n");
 		trace_printk("E|TMWK\n");
diff --git a/drivers/media/pci/intel/ipu.h b/drivers/media/pci/intel/ipu.h
index 173517c..5229671 100644
--- a/drivers/media/pci/intel/ipu.h
+++ b/drivers/media/pci/intel/ipu.h
@@ -95,4 +95,7 @@ void ipu_configure_spc(struct ipu_device *isp,
 		       const struct ipu_hw_variants *hw_variant,
 		       int pkg_dir_idx, void __iomem *base, u64 *pkg_dir,
 		       dma_addr_t pkg_dir_dma_addr);
+int request_cpd_fw(const struct firmware **firmware_p, const char *name,
+		   struct device *device);
+
 #endif /* IPU_H */
diff --git a/drivers/media/pci/intel/ipu4/Makefile b/drivers/media/pci/intel/ipu4/Makefile
index f4fefe4..4545438 100644
--- a/drivers/media/pci/intel/ipu4/Makefile
+++ b/drivers/media/pci/intel/ipu4/Makefile
@@ -8,7 +8,6 @@ endif
 ifdef CONFIG_VIDEO_INTEL_IPU4
 ccflags-y += -DHAS_DUAL_CMD_CTX_SUPPORT=0
 ccflags-y += -DIPU_META_DATA_SUPPORT -DI2C_WA
-ccflags-y += -DIPU_VC_SUPPORT -DIPU_HAS_ISA -DIPU_PSYS_LEGACY
 
 intel-ipu4-objs				+= ../ipu.o \
 					   ../ipu-bus.o \
diff --git a/drivers/media/pci/intel/ipu4/ipu-platform-isys-csi2-reg.h b/drivers/media/pci/intel/ipu4/ipu-platform-isys-csi2-reg.h
index f19372b..2d1c5a4 100644
--- a/drivers/media/pci/intel/ipu4/ipu-platform-isys-csi2-reg.h
+++ b/drivers/media/pci/intel/ipu4/ipu-platform-isys-csi2-reg.h
@@ -60,6 +60,9 @@
 #define CSI2_IRQ_FE_VC(chn)	(0x20000 << ((chn) * 4))
 #define CSI2_IRQ_LS_VC(chn)	(0x40000 << ((chn) * 4))
 #define CSI2_IRQ_LE_VC(chn)	(0x80000 << ((chn) * 4))
+#define CSI2_REG_CL0_IBUFCTL_EN_FLUSH_FOR_IDRAIN	0x6002c
+#define CSI2_REG_CL1_IBUFCTL_EN_FLUSH_FOR_IDRAIN	0x6802c
+#define IPU_REG_ISYS_IBUFCTL_EN_FLUSH_FOR_IDRAIN	0xb602c
 #endif /* CONFIG_VIDEO_INTEL_IPU4P */
 
 #ifdef CONFIG_VIDEO_INTEL_IPU4
diff --git a/drivers/media/pci/intel/ipu4/ipu-platform.h b/drivers/media/pci/intel/ipu4/ipu-platform.h
index 924cb2e..3295612 100644
--- a/drivers/media/pci/intel/ipu4/ipu-platform.h
+++ b/drivers/media/pci/intel/ipu4/ipu-platform.h
@@ -5,6 +5,7 @@
 #define IPU_PLATFORM_H
 
 #define IPU_NAME			"intel-ipu4"
+#define IPU_ISYS_NUM_STREAMS            8       /* Max 8 */
 
 #ifdef CONFIG_VIDEO_INTEL_IPU4
 #define IPU_CPD_FIRMWARE_NAME	"ipu4_cpd_b0.bin"
@@ -29,8 +30,6 @@
 #define IPU_HW_BXT_P_D0_REV	0xb
 #define IPU_HW_BXT_P_E0_REV	0xc
 
-#define IPU_ISYS_NUM_STREAMS            8       /* Max 8 */
-
 /* BXTP E0 has icache bug fixed */
 #define is_ipu_hw_bxtp_e0(isp)			\
 	({ typeof(isp) __isp = (isp); \
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/Makefile.isyslib b/drivers/media/pci/intel/ipu4/ipu4-css/Makefile.isyslib
index c99c9a8..33a3df8 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/Makefile.isyslib
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/Makefile.isyslib
@@ -10,11 +10,6 @@ IPU_ISYSLIB_ROOT = $(srcpath)/$(src)/$(IPU_ISYSLIB_ROOT_REL)
 include $(srcpath)/$(src)/ipu4-css/Makefile.ipu4isys_inc
 include $(srcpath)/$(src)/ipu4-css/Makefile.ipu4isys_src
 
-#
-# copy wrapper here only for isys usage, psys would use the original one
-#
-$(shell cp -f $(srcpath)/$(src)/../ipu-wrapper.c $(srcpath)/$(src)/ipu4-css/ipu-wrapper.c)
-
 intel-ipu4-isys-csslib-objs := \
 			ipu4-css/libintel-ipu4.o \
 			$(IPU_ISYSLIB_SRC)
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/ia_css_fw_pkg_release.h b/drivers/media/pci/intel/ipu4/ipu4-css/ia_css_fw_pkg_release.h
index 50ec8e9..408726c 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/ia_css_fw_pkg_release.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/ia_css_fw_pkg_release.h
@@ -11,4 +11,4 @@
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */
-#define IA_CSS_FW_PKG_RELEASE  0x20181107
+#define IA_CSS_FW_PKG_RELEASE  0x20181222
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/ipu-wrapper.c b/drivers/media/pci/intel/ipu4/ipu4-css/ipu-wrapper.c
new file mode 120000
index 00000000..3167dda
--- /dev/null
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/ipu-wrapper.c
@@ -0,0 +1 @@
+../../ipu-wrapper.c
\ No newline at end of file
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isys_fw_bridged_types.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isys_fw_bridged_types.h
index dc42fe5..5e47fe7 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isys_fw_bridged_types.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isys_fw_bridged_types.h
@@ -61,6 +61,7 @@ struct ia_css_isys_resolution_comm {
  * @out_buf_id: Points to output pin buffer - buffer identifier
  * @addr: Points to output pin buffer - CSS Virtual Address
  * @compress: Request frame compression (1), or  not (0)
+ * This must be the same as ia_css_isys_output_pin_info_comm::reserve_compression
  */
 struct ia_css_isys_output_pin_payload_comm {
 	aligned_uint64(ia_css_return_token, out_buf_id);
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isysapi_proxy_region_defs.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isysapi_proxy_region_defs.h
index 1d1dbf3..c002b33 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isysapi_proxy_region_defs.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isysapi_proxy_region_defs.h
@@ -110,13 +110,4 @@ struct ia_css_proxy_write_region_description ipu4p_b0_reg_write_desc[N_IPU4P_B0_
 
 #endif /*defined(IPU4P_B0_PROXY_INT)*/
 
-/*
- */
-
-
-
-/*
- */
-
-
 #endif /* __IA_CSS_ISYSAPI_PROXY_REGION_DEFS_H */
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isysapi_types.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isysapi_types.h
index dafc345..481a7dc 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isysapi_types.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isysapi_types.h
@@ -89,6 +89,7 @@ struct ia_css_isys_resolution {
  * @out_buf_id: Points to output pin buffer - buffer identifier
  * @addr: Points to output pin buffer - CSS Virtual Address
  * @compressed: Request frame compression (1), or  not (0)
+ * This must be the same as ia_css_isys_output_pin_info::reserve_compression
  */
 struct ia_css_isys_output_pin_payload {
 	ia_css_return_token out_buf_id;
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/support/assert_support.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/support/assert_support.h
index dac974b..f904a49 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/support/assert_support.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/support/assert_support.h
@@ -33,6 +33,16 @@
 
 #define IA_CSS_ASSERT(expr) assert(expr)
 
+#ifdef __KLOCWORK__
+/* Klocwork does not see that assert will lead to abortion
+ * as there is no good way to tell this to KW and the code
+ * should not depend on assert to function (actually the assert
+ * could be disabled in a release build) it was decided to
+ * disable the assert for KW scans (by defining NDEBUG)
+ */
+#define NDEBUG
+#endif /* __KLOCWORK__ */
+
 /**
  * The following macro can help to test the size of a struct at compile
  * time rather than at run-time. It does not work for all compilers; see
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/Makefile b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/Makefile
index 2321e29..b1549d4 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/Makefile
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/Makefile
@@ -26,7 +26,7 @@ IPU_PSYSLIB_ROOT = $(srcpath)/$(src)/$(IPU_PSYSLIB_ROOT_REL)
 
 ccflags-y += -I$(srcpath)/$(src)/../../../
 ccflags-y += -I$(srcpath)/$(src)/../../
-ccflags-y += -DHAS_DUAL_CMD_CTX_SUPPORT=0 -DHAS_LATE_BINDING_SUPPORT=0 -DIPU_PSYS_LEGACY
+ccflags-y += -DHAS_DUAL_CMD_CTX_SUPPORT=0 -DHAS_LATE_BINDING_SUPPORT=0
 
 IPU_PSYSLIB_SRC += libcsspsys2600.o
 
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/DSS_V2_program_group/ia_css_fw_pkg_release.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/DSS_V2_program_group/ia_css_fw_pkg_release.h
index 50ec8e9..408726c 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/DSS_V2_program_group/ia_css_fw_pkg_release.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/DSS_V2_program_group/ia_css_fw_pkg_release.h
@@ -11,4 +11,4 @@
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */
-#define IA_CSS_FW_PKG_RELEASE  0x20181107
+#define IA_CSS_FW_PKG_RELEASE  0x20181222
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/support/assert_support.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/support/assert_support.h
index dac974b..f904a49 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/support/assert_support.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/support/assert_support.h
@@ -33,6 +33,16 @@
 
 #define IA_CSS_ASSERT(expr) assert(expr)
 
+#ifdef __KLOCWORK__
+/* Klocwork does not see that assert will lead to abortion
+ * as there is no good way to tell this to KW and the code
+ * should not depend on assert to function (actually the assert
+ * could be disabled in a release build) it was decided to
+ * disable the assert for KW scans (by defining NDEBUG)
+ */
+#define NDEBUG
+#endif /* __KLOCWORK__ */
+
 /**
  * The following macro can help to test the size of a struct at compile
  * time rather than at run-time. It does not work for all compilers; see
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/vied_parameters/vied_parameters.mk b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/vied_parameters/vied_parameters.mk
index 5e89033..834a1a4 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/vied_parameters/vied_parameters.mk
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/vied_parameters/vied_parameters.mk
@@ -72,6 +72,5 @@ VIED_PARAMETERS_FW_CPPFLAGS +=  $(VIED_PARAMETERS_SUPPORT_CPPFLAGS)
 #For IPU interface
 include $(MODULES_DIR)/fw_abi_common_types/cpu/fw_abi_cpu_types.mk
 VIED_PARAMETERS_HOST_CPPFLAGS += $(FW_ABI_COMMON_TYPES_HOST_CPPFLAGS)
-endif
 
 VIED_PARAMETERS_FW_CPPFLAGS   += $(FW_ABI_COMMON_TYPES_FW_CPPFLAGS)
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/libcsspsys2600.c b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/libcsspsys2600.c
index ee13b8e..3889393 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/libcsspsys2600.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/libcsspsys2600.c
@@ -249,13 +249,15 @@ int ipu_fw_psys_pg_get_protocol(
 }
 EXPORT_SYMBOL_GPL(ipu_fw_psys_pg_get_protocol);
 
+static int libcsspsys2600_init(void);
 int ipu_fw_psys_open(struct ipu_psys *psys)
 {
 	bool opened;
 	int retry = IPU_PSYS_OPEN_RETRY;
 
-	ipu_wrapper_init(PSYS_MMID, &psys->adev->dev,
-				psys->pdata->base);
+	ipu_wrapper_init(PSYS_MMID, &psys->adev->dev, psys->pdata->base);
+	/* When fw psys open, make sure csslib init first */
+	libcsspsys2600_init();
 
 	server_init->icache_prefetch_sp = psys->icache_prefetch_sp;
 	server_init->icache_prefetch_isp = psys->icache_prefetch_isp;
@@ -266,6 +268,7 @@ int ipu_fw_psys_open(struct ipu_psys *psys)
 			"psys library open failed\n");
 		return -ENODEV;
 	}
+
 	do {
 		opened = ia_css_psys_open_is_ready(psys_syscom);
 		if (opened)
@@ -412,9 +415,13 @@ int ipu_fw_psys_get_program_manifest_by_process(
 }
 EXPORT_SYMBOL_GPL(ipu_fw_psys_get_program_manifest_by_process);
 
-static int __init libcsspsys2600_init(void)
+static int libcsspsys2600_init(void)
 {
 	int rval;
+	static bool csslib_init;
+
+	if (csslib_init)
+		return 0;
 
 	syscom_buffer = kzalloc(ia_css_sizeof_psys(NULL), GFP_KERNEL);
 	if (!syscom_buffer)
@@ -447,6 +454,7 @@ static int __init libcsspsys2600_init(void)
 					IPU_DEVICE_SP2600_CONTROL_REGS);
 	syscom_config->dmem_addr = ipu_device_cell_memory_address(SPC0,
 					IPU_DEVICE_SP2600_CONTROL_DMEM);
+	csslib_init = true;
 
 	return 0;
 
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/libintel-ipu4.c b/drivers/media/pci/intel/ipu4/ipu4-css/libintel-ipu4.c
index a7128898..d770c09 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/libintel-ipu4.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/libintel-ipu4.c
@@ -56,9 +56,11 @@ int ipu_fw_isys_close(struct ipu_isys *isys)
 	 * some time as the FW must stop its actions including code fetch
 	 * to SP icache.
 	 */
+	mutex_lock(&isys->lib_mutex);
 	spin_lock_irqsave(&isys->power_lock, flags);
-	rval = ipu_lib_call(device_close, isys);
+	rval = ipu_lib_call_notrace_unlocked(device_close, isys);
 	spin_unlock_irqrestore(&isys->power_lock, flags);
+	mutex_unlock(&isys->lib_mutex);
 	if (rval)
 		dev_err(dev, "Device close failure: %d\n", rval);
 
@@ -180,10 +182,6 @@ struct ipu_fw_isys_resp_info_abi *ipu_fw_isys_get_resp(
 	response->process_group_light.addr =
 		apiresp.process_group_light.addr;
 	response->acc_id = apiresp.acc_id;
-#ifdef IPU_OTF_SUPPORT
-	response->frame_counter = apiresp.frame_counter;
-	response->written_direct = apiresp.written_direct;
-#endif
 
 	return response;
 }
@@ -250,9 +248,6 @@ static void output_pin_info_abi_to_api(
 	api->payload_buf_size = abi->payload_buf_size;
 	api->send_irq = abi->send_irq;
 	api->ft = abi->ft;
-#ifdef IPU_OTF_SUPPORT
-	api->link_id = abi->link_id;
-#endif
 	api->reserve_compression = abi->reserve_compression;
 }
 
diff --git a/drivers/media/pci/intel/ipu4/ipu4-isys.c b/drivers/media/pci/intel/ipu4/ipu4-isys.c
index 30cc42d..c11ced2 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-isys.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-isys.c
@@ -6,6 +6,7 @@
 #include "ipu.h"
 #include "ipu-platform-regs.h"
 #include "ipu-platform-buttress-regs.h"
+#include "ipu-platform-isys-csi2-reg.h"
 #include "ipu-trace.h"
 #include "ipu-isys.h"
 #include "ipu-isys-video.h"
@@ -146,6 +147,28 @@ void isys_setup_hw(struct ipu_isys *isys)
 #endif
 
 #ifdef CONFIG_VIDEO_INTEL_IPU4P
+/*
+ * For new HW, extra common register (en_flush_for_idrain)added to the IBufCtrl
+ * of ISL_IS and CSI that enables the feature to send a DMA command with flush
+ * when draining. This means that a DMA command is send with the flush bit
+ * set(read post write check is performed) when a drain request comes in and
+ * iwake is enabled for that SID proc.
+ * This results in that all data is moved out of the system when the IDone is
+ * given back. Default the feature is off, to keep behavior as is when nothing
+ * is written, writing 0x1 to the register (reg 11 in common reg bank,
+ * addr ibuf_base + 0x2C) to enable this feature.
+ */
+static int ipu4p_isys_flush_idrain_en(struct ipu_isys *isys)
+{
+	void __iomem *base = isys->pdata->base;
+
+	writel(1, base + CSI2_REG_CL0_IBUFCTL_EN_FLUSH_FOR_IDRAIN);
+	writel(1, base + CSI2_REG_CL1_IBUFCTL_EN_FLUSH_FOR_IDRAIN);
+	writel(1, base + IPU_REG_ISYS_IBUFCTL_EN_FLUSH_FOR_IDRAIN);
+
+	return 0;
+}
+
 static void ipu4p_isys_irq_cfg(struct ipu_isys *isys)
 {
 	void __iomem *base = isys->pdata->base;
@@ -179,18 +202,19 @@ static void ipu4p_isys_bb_cfg(struct ipu_isys *isys)
 {
 	void __iomem *isp_base = isys->adev->isp->base;
 	unsigned int i, val;
-	unsigned int bbconfig[4][3] = {
-		{4, 15, 0xf},
-		{6, 15, 0x15},
-		{12, 15, 0xf},
-		{14, 15, 0x15},
+	unsigned int bbconfig[4][4] = {
+		{4, 13, 32, 0xf},
+		{6, 13, 32, 0x15},
+		{12, 13, 32, 0xf},
+		{14, 13, 32, 0x15},
 	};
 
 	/* Config building block */
 	for (i = 0; i < 4; i++) {
 		unsigned int bb = bbconfig[i][0];
 		unsigned int crc = bbconfig[i][1];
-		unsigned int afe = bbconfig[i][2];
+		unsigned int drc = bbconfig[i][2];
+		unsigned int afe = bbconfig[i][3];
 
 		val = readl(isp_base + BUTTRESS_REG_CPHYX_DLL_OVRD(bb));
 		val &= ~0x7e;
@@ -199,8 +223,7 @@ static void ipu4p_isys_bb_cfg(struct ipu_isys *isys)
 		writel(val, isp_base + BUTTRESS_REG_CPHYX_DLL_OVRD(bb));
 		val = readl(isp_base + BUTTRESS_REG_DPHYX_DLL_OVRD(bb));
 		val |= 1;
-		writel(val, isp_base + BUTTRESS_REG_DPHYX_DLL_OVRD(bb));
-		val &= ~1;
+		val |= drc << 1;
 		writel(val, isp_base + BUTTRESS_REG_DPHYX_DLL_OVRD(bb));
 		val = afe | (2 << 29);
 		writel(val, isp_base + BUTTRESS_REG_BBX_AFE_CONFIG(bb));
@@ -224,6 +247,7 @@ void isys_setup_hw(struct ipu_isys *isys)
 	ipu4p_isys_irq_cfg(isys);
 	ipu4p_isys_port_cfg(isys);
 	ipu4p_isys_bb_cfg(isys);
+	ipu4p_isys_flush_idrain_en(isys);
 }
 #endif
 
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/Makefile.isyslib b/drivers/media/pci/intel/ipu4/ipu4p-css/Makefile.isyslib
index f0b540d..d0816c5 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/Makefile.isyslib
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/Makefile.isyslib
@@ -10,11 +10,6 @@ IPU_ISYSLIB_ROOT = $(srcpath)/$(src)/$(IPU_ISYSLIB_ROOT_REL)
 include $(srcpath)/$(src)/ipu4p-css/Makefile.ipu4pisys_inc
 include $(srcpath)/$(src)/ipu4p-css/Makefile.ipu4pisys_src
 
-#
-# copy wrapper here only for isys usage, psys would use the original one
-#
-$(shell cp -f $(srcpath)/$(src)/../ipu-wrapper.c $(srcpath)/$(src)/ipu4p-css/ipu-wrapper.c)
-
 intel-ipu4p-isys-csslib-objs := \
 		ipu4p-css/libintel-ipu4p.o \
 		$(IPU_ISYSLIB_SRC)
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/ia_css_fw_pkg_release.h b/drivers/media/pci/intel/ipu4/ipu4p-css/ia_css_fw_pkg_release.h
index cb20a68..408726c 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/ia_css_fw_pkg_release.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/ia_css_fw_pkg_release.h
@@ -11,4 +11,4 @@
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */
-#define IA_CSS_FW_PKG_RELEASE  0x20180615
+#define IA_CSS_FW_PKG_RELEASE  0x20181222
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/ipu-wrapper.c b/drivers/media/pci/intel/ipu4/ipu4p-css/ipu-wrapper.c
new file mode 120000
index 00000000..3167dda
--- /dev/null
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/ipu-wrapper.c
@@ -0,0 +1 @@
+../../ipu-wrapper.c
\ No newline at end of file
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/cpd_binary/ia_css_fw_pkg_release.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/cpd_binary/ia_css_fw_pkg_release.h
index cb20a68..408726c 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/cpd_binary/ia_css_fw_pkg_release.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/cpd_binary/ia_css_fw_pkg_release.h
@@ -11,4 +11,4 @@
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */
-#define IA_CSS_FW_PKG_RELEASE  0x20180615
+#define IA_CSS_FW_PKG_RELEASE  0x20181222
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/interface/ia_css_isysapi.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/interface/ia_css_isysapi.h
index 5f10f72..abbc8b8 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/interface/ia_css_isysapi.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/interface/ia_css_isysapi.h
@@ -15,11 +15,6 @@
 #ifndef __IA_CSS_ISYSAPI_H
 #define __IA_CSS_ISYSAPI_H
 
-/**
- * errno.h specified error codes to be used
- * URL:http://man7.org/linux/man-pages/man3/errno.3.html>
- */
-
 
 /* The following is needed for the function arguments */
 #include "ia_css_isysapi_types.h"
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/support/assert_support.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/support/assert_support.h
index dac974b..f904a49 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/support/assert_support.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/support/assert_support.h
@@ -33,6 +33,16 @@
 
 #define IA_CSS_ASSERT(expr) assert(expr)
 
+#ifdef __KLOCWORK__
+/* Klocwork does not see that assert will lead to abortion
+ * as there is no good way to tell this to KW and the code
+ * should not depend on assert to function (actually the assert
+ * could be disabled in a release build) it was decided to
+ * disable the assert for KW scans (by defining NDEBUG)
+ */
+#define NDEBUG
+#endif /* __KLOCWORK__ */
+
 /**
  * The following macro can help to test the size of a struct at compile
  * time rather than at run-time. It does not work for all compilers; see
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/Makefile b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/Makefile
index 629899d..ca82d1f 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/Makefile
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/Makefile
@@ -27,7 +27,7 @@ IPU_PSYSLIB_ROOT = $(srcpath)/$(src)/$(IPU_PSYSLIB_ROOT_REL)
 
 ccflags-y += -I$(srcpath)/$(src)/../../../
 ccflags-y += -I$(srcpath)/$(src)/../../
-ccflags-y += -DHAS_DUAL_CMD_CTX_SUPPORT=0 -DHAS_LATE_BINDING_SUPPORT=0 -DIPU_PSYS_LEGACY
+ccflags-y += -DHAS_DUAL_CMD_CTX_SUPPORT=0 -DHAS_LATE_BINDING_SUPPORT=0
 
 IPU_PSYSLIB_SRC += libcsspsys2600.o
 
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/CNL_program_group/ia_css_fw_pkg_release.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/CNL_program_group/ia_css_fw_pkg_release.h
index cb20a68..408726c 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/CNL_program_group/ia_css_fw_pkg_release.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/CNL_program_group/ia_css_fw_pkg_release.h
@@ -11,4 +11,4 @@
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */
-#define IA_CSS_FW_PKG_RELEASE  0x20180615
+#define IA_CSS_FW_PKG_RELEASE  0x20181222
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/ICL_program_group/ia_css_fw_pkg_release.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/ICL_program_group/ia_css_fw_pkg_release.h
index cb20a68..408726c 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/ICL_program_group/ia_css_fw_pkg_release.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/ICL_program_group/ia_css_fw_pkg_release.h
@@ -11,4 +11,4 @@
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */
-#define IA_CSS_FW_PKG_RELEASE  0x20180615
+#define IA_CSS_FW_PKG_RELEASE  0x20181222
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/config/psys/subsystem_cnlB0.mk b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/config/psys/subsystem_cnlB0.mk
index 42bc023..be397a0 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/config/psys/subsystem_cnlB0.mk
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/config/psys/subsystem_cnlB0.mk
@@ -56,6 +56,9 @@ HAS_64KB_GDC_MEM                = 1
 # define for enabling mmu_stream_id_lut support
 ENABLE_MMU_STREAM_ID_LUT = 1
 
+# define for enabling rgbir related chnages in devproxy
+HAS_RGBIR = 1
+
 # Specification for Psys server's fixed globals' locations
 REGMEM_OFFSET				= 0
 REGMEM_SECURE_OFFSET			= 4096
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/support/assert_support.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/support/assert_support.h
index dac974b..f904a49 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/support/assert_support.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/support/assert_support.h
@@ -33,6 +33,16 @@
 
 #define IA_CSS_ASSERT(expr) assert(expr)
 
+#ifdef __KLOCWORK__
+/* Klocwork does not see that assert will lead to abortion
+ * as there is no good way to tell this to KW and the code
+ * should not depend on assert to function (actually the assert
+ * could be disabled in a release build) it was decided to
+ * disable the assert for KW scans (by defining NDEBUG)
+ */
+#define NDEBUG
+#endif /* __KLOCWORK__ */
+
 /**
  * The following macro can help to test the size of a struct at compile
  * time rather than at run-time. It does not work for all compilers; see
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/libcsspsys2600.c b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/libcsspsys2600.c
index af0e41e..805d154 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/libcsspsys2600.c
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/libcsspsys2600.c
@@ -257,6 +257,7 @@ int ipu_fw_psys_pg_get_protocol(
 }
 EXPORT_SYMBOL_GPL(ipu_fw_psys_pg_get_protocol);
 
+static int libcsspsys2600_init(void);
 int ipu_fw_psys_open(struct ipu_psys *psys)
 {
 	bool opened;
@@ -264,6 +265,8 @@ int ipu_fw_psys_open(struct ipu_psys *psys)
 
 	ipu_wrapper_init(PSYS_MMID, &psys->adev->dev,
 				psys->pdata->base);
+	/* When fw psys open, make sure csslib init first */
+	libcsspsys2600_init();
 
 	server_init->icache_prefetch_sp = psys->icache_prefetch_sp;
 	server_init->icache_prefetch_isp = psys->icache_prefetch_isp;
@@ -420,9 +423,13 @@ int ipu_fw_psys_get_program_manifest_by_process(
 }
 EXPORT_SYMBOL_GPL(ipu_fw_psys_get_program_manifest_by_process);
 
-static int __init libcsspsys2600_init(void)
+static int libcsspsys2600_init(void)
 {
 	int rval;
+	static bool csslib_init;
+
+	if (csslib_init)
+		return 0;
 
 	syscom_buffer = kzalloc(ia_css_sizeof_psys(NULL), GFP_KERNEL);
 	if (!syscom_buffer)
@@ -455,6 +462,7 @@ static int __init libcsspsys2600_init(void)
 					IPU_DEVICE_SP2600_CONTROL_REGS);
 	syscom_config->dmem_addr = ipu_device_cell_memory_address(SPC0,
 					IPU_DEVICE_SP2600_CONTROL_DMEM);
+	csslib_init = true;
 
 	return 0;
 
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/libintel-ipu4p.c b/drivers/media/pci/intel/ipu4/ipu4p-css/libintel-ipu4p.c
index cb6fd04..242bab2 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/libintel-ipu4p.c
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/libintel-ipu4p.c
@@ -56,9 +56,11 @@ int ipu_fw_isys_close(struct ipu_isys *isys)
 	 * some time as the FW must stop its actions including code fetch
 	 * to SP icache.
 	 */
+	mutex_lock(&isys->lib_mutex);
 	spin_lock_irqsave(&isys->power_lock, flags);
-	rval = ipu_lib_call(device_close, isys);
+	rval = ipu_lib_call_notrace_unlocked(device_close, isys);
 	spin_unlock_irqrestore(&isys->power_lock, flags);
+	mutex_unlock(&isys->lib_mutex);
 	if (rval)
 		dev_err(dev, "Device close failure: %d\n", rval);
 
@@ -181,10 +183,6 @@ struct ipu_fw_isys_resp_info_abi *ipu_fw_isys_get_resp(
 	response->process_group_light.addr =
 		apiresp.process_group_light.addr;
 	response->acc_id = apiresp.acc_id;
-#ifdef IPU_OTF_SUPPORT
-	response->frame_counter = apiresp.frame_counter;
-	response->written_direct = apiresp.written_direct;
-#endif
 
 	return response;
 }
@@ -249,9 +247,6 @@ static void output_pin_info_abi_to_api(
 	api->payload_buf_size = abi->payload_buf_size;
 	api->send_irq = abi->send_irq;
 	api->ft = abi->ft;
-#ifdef IPU_OTF_SUPPORT
-	api->link_id = abi->link_id;
-#endif
 	api->reserve_compression = abi->reserve_compression;
 }
 
diff --git a/include/media/crlmodule.h b/include/media/crlmodule.h
index ead1beb..91650c1 100644
--- a/include/media/crlmodule.h
+++ b/include/media/crlmodule.h
@@ -29,7 +29,9 @@ struct crlmodule_platform_data {
 	unsigned int lanes;		/* Number of CSI-2 lanes */
 	const s64 *op_sys_clock;
 
-	int xshutdown;			/* gpio */
+	/* specify gpio pins of Deser for PWDN, FSIN. */
+	int xshutdown;
+	int fsin;
 	struct crl_custom_gpio custom_gpio[CRL_MAX_CUSTOM_GPIO_AMOUNT];
 	char module_name[16]; /* module name from ACPI */
 	int crl_irq_pin;
diff --git a/include/media/ti960.h b/include/media/ti960.h
index 60e134f..fe655c2 100644
--- a/include/media/ti960.h
+++ b/include/media/ti960.h
@@ -19,11 +19,16 @@
 #define PIXEL_ORDER_BGGR	2
 #define PIXEL_ORDER_GBRG	3
 
-#define NR_OF_TI960_STREAMS	4
+#define NR_OF_TI960_VCS_PER_SINK_PAD 2
+#define NR_OF_TI960_VCS_SOURCE_PAD 4
 #define NR_OF_TI960_SOURCE_PADS	1
 #define NR_OF_TI960_SINK_PADS	4
 #define NR_OF_TI960_PADS \
 	(NR_OF_TI960_SOURCE_PADS + NR_OF_TI960_SINK_PADS)
+/* 4port * 2vc/port * 8 stream total */
+#define NR_OF_TI960_STREAMS	\
+	(NR_OF_TI960_SINK_PADS * NR_OF_TI960_VCS_PER_SINK_PAD \
+	* NR_OF_TI960_VCS_SOURCE_PAD)
 #define NR_OF_GPIOS_PER_PORT	2
 #define NR_OF_TI960_GPIOS	\
 	(NR_OF_TI960_SINK_PADS * NR_OF_GPIOS_PER_PORT)
diff --git a/include/uapi/linux/crlmodule.h b/include/uapi/linux/crlmodule.h
index 8bcb8c9..f13d278 100644
--- a/include/uapi/linux/crlmodule.h
+++ b/include/uapi/linux/crlmodule.h
@@ -73,4 +73,7 @@ struct crl_registers_info {
 /* Set HDR mode exposure ratio */
 #define CRL_CID_EXPOSURE_HDR_RATIO	(V4L2_CID_CRLMODULE_BASE + 24)
 
+/* choose hcg/lcg for linear analog */
+#define CRL_CID_ANALOG_LINEAR_CG	(V4L2_CID_CRLMODULE_BASE + 25)
+
 #endif /* UAPI_LINUX_CRLMODULE_H */
-- 
2.7.4

