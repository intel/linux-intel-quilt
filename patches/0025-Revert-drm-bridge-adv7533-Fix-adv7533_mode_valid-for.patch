From af43c00a84a0e6ac9ebf594dce239724dc4a0620 Mon Sep 17 00:00:00 2001
From: Ranjan Dutta <ranjan.dutta@intel.com>
Date: Tue, 20 Jun 2023 05:27:49 +0800
Subject: [PATCH 25/30] Revert "drm/bridge: adv7533: Fix adv7533_mode_valid for
 adv7533 and adv7535"

This reverts commit f8d28cecf2100e2fd0677812a1af70f6cf2e10fb.
---
 drivers/gpu/drm/bridge/adv7511/adv7533.c | 25 +++++++++++++-----------
 1 file changed, 14 insertions(+), 11 deletions(-)

diff --git a/drivers/gpu/drm/bridge/adv7511/adv7533.c b/drivers/gpu/drm/bridge/adv7511/adv7533.c
index e0bdedf22390c..f304a5ff8e596 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7533.c
+++ b/drivers/gpu/drm/bridge/adv7511/adv7533.c
@@ -103,19 +103,22 @@ void adv7533_dsi_power_off(struct adv7511 *adv)
 enum drm_mode_status adv7533_mode_valid(struct adv7511 *adv,
 					const struct drm_display_mode *mode)
 {
-	unsigned long max_lane_freq;
+	int lanes;
 	struct mipi_dsi_device *dsi = adv->dsi;
-	u8 bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);
 
-	/* Check max clock for either 7533 or 7535 */
-	if (mode->clock > (adv->type == ADV7533 ? 80000 : 148500))
-		return MODE_CLOCK_HIGH;
-
-	/* Check max clock for each lane */
-	max_lane_freq = (adv->type == ADV7533 ? 800000 : 891000);
-
-	if (mode->clock * bpp > max_lane_freq * adv->num_dsi_lanes)
-		return MODE_CLOCK_HIGH;
+	if (mode->clock > 80000)
+		lanes = 4;
+	else
+		lanes = 3;
+
+	/*
+	 * TODO: add support for dynamic switching of lanes
+	 * by using the bridge pre_enable() op . Till then filter
+	 * out the modes which shall need different number of lanes
+	 * than what was configured in the device tree.
+	 */
+	if (lanes != dsi->lanes)
+		return MODE_BAD;
 
 	return MODE_OK;
 }
-- 
2.25.1

