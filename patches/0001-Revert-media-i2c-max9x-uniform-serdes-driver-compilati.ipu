From 2e94f5756fed15080864a4cf953b6ef279e4fa38 Mon Sep 17 00:00:00 2001
From: "Shahidan, Muhammad Shahmil" <muhammad.shahmil.shahidan@intel.com>
Date: Tue, 4 Nov 2025 14:28:23 +0800
Subject: [PATCH 1/2] Revert "media: i2c: max9x: uniform serdes driver
 compilation"

This reverts commit 9e46b764cbbd8def4373a51b40bf7abd62c736e3.

Signed-off-by: Shahidan, Muhammad Shahmil <muhammad.shahmil.shahidan@intel.com>
---
 drivers/media/i2c/isx031.c        |  4 ++--
 drivers/media/i2c/max9x/max9295.c |  9 +++++----
 drivers/media/i2c/max9x/max9296.c |  2 +-
 drivers/media/i2c/max9x/serdes.c  | 22 ++++++++++++++++------
 4 files changed, 24 insertions(+), 13 deletions(-)

diff --git a/drivers/media/i2c/isx031.c b/drivers/media/i2c/isx031.c
index 2d669e964b08..e613cdb06b83 100644
--- a/drivers/media/i2c/isx031.c
+++ b/drivers/media/i2c/isx031.c
@@ -370,7 +370,7 @@ static int isx031_set_driver_mode(struct isx031 *isx031)
 	if (mode < 0)
 		return mode;
 
-	ret = isx031_write_reg_retry(isx031, ISX031_REG_MODE_SELECT, 1, (u32)mode);
+	ret = isx031_write_reg_retry(isx031, ISX031_REG_MODE_SELECT, 1, mode);
 	return ret;
 }
 
@@ -411,7 +411,7 @@ static int isx031_mode_transit(struct isx031 *isx031, int state)
 		return ret;
 	}
 	ret = isx031_write_reg(isx031, ISX031_REG_MODE_SET_F, 1,
-			       (u32)mode);
+			mode);
 	if (ret) {
 		dev_err(&client->dev, "failed to transit mode from 0x%x to 0x%x",
 			cur_mode, mode);
diff --git a/drivers/media/i2c/max9x/max9295.c b/drivers/media/i2c/max9x/max9295.c
index 8fbd4215e110..a5bacc3684a9 100644
--- a/drivers/media/i2c/max9x/max9295.c
+++ b/drivers/media/i2c/max9x/max9295.c
@@ -177,7 +177,7 @@ static int max9295_setup_gpio(struct max9x_common *common)
 {
 	struct device *dev = common->dev;
 	int ret;
-	struct max9x_gpio_pdata *gpio_pdata = NULL;
+	struct max9x_gpio_pdata *gpio_pdata;
 
 	if (dev->platform_data) {
 		struct max9x_pdata *pdata = dev->platform_data;
@@ -697,14 +697,15 @@ static int max9295_remap_reset(struct max9x_common *common)
 	struct device *dev = common->dev;
 	struct max9x_pdata *pdata = dev->platform_data;
 	u32 phys_addr = pdata->phys_addr ? pdata->phys_addr :
-			common->client->addr;
+					   common->client->addr;
 	u32 virt_addr = common->client->addr;
 
 	dev_info(dev, "Remap reset address from 0x%02x to 0x%02x", virt_addr,
 		 phys_addr);
 
-	TRY(ret, regmap_update_bits(common->map, MAX9295_REG0, MAX9295_REG0_DEV_ADDR_FIELD,
-				    FIELD_PREP(MAX9295_REG0_DEV_ADDR_FIELD, phys_addr)));
+	TRY(ret, regmap_update_bits(
+			 common->map, MAX9295_REG0, MAX9295_REG0_DEV_ADDR_FIELD,
+			 FIELD_PREP(MAX9295_REG0_DEV_ADDR_FIELD, phys_addr)));
 
 	return 0;
 }
diff --git a/drivers/media/i2c/max9x/max9296.c b/drivers/media/i2c/max9x/max9296.c
index a28aa190364d..41074d60cc01 100644
--- a/drivers/media/i2c/max9x/max9296.c
+++ b/drivers/media/i2c/max9x/max9296.c
@@ -730,7 +730,7 @@ static int max9296_deisolate_serial_link(struct max9x_common *common, unsigned i
 		link_cfg = MAX9296_LINK_B;
 	else {
 		dev_err(dev, "No link was detected");
-		return -EINVAL;
+		return -1;
 	}
 
 	dev_dbg(dev, "Deisolate link %d (link_cfg=%d)", link, link_cfg);
diff --git a/drivers/media/i2c/max9x/serdes.c b/drivers/media/i2c/max9x/serdes.c
index 8c1db87ed8c2..fce930a1fdea 100644
--- a/drivers/media/i2c/max9x/serdes.c
+++ b/drivers/media/i2c/max9x/serdes.c
@@ -133,7 +133,7 @@ static const struct of_device_id max9x_of_match[] = {
 MODULE_DEVICE_TABLE(of, max9x_of_match);
 
 static const struct i2c_device_id max9x_id[] = {
-	{ "max9x", 0 },
+	{ "max9x", MAX9296 },
 	{ "max9296", MAX9296 },
 	{ "max96724", MAX96724 },
 	{ "max9295", MAX9295 },
@@ -841,7 +841,6 @@ void max9x_destroy(struct max9x_common *common)
 	/* unregister devices? */
 
 	v4l2_async_unregister_subdev(&common->v4l.sd);
-	v4l2_subdev_cleanup(&common->v4l.sd);
 	media_entity_cleanup(&common->v4l.sd.entity);
 
 	i2c_mux_del_adapters(common->muxc);
@@ -1484,7 +1483,10 @@ static struct v4l2_mbus_framefmt *__max9x_get_ffmt(struct v4l2_subdev *sd,
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
 		return v4l2_subdev_state_get_format(v4l2_state, fmt->pad, fmt->stream);
 
-	return &common->v4l.ffmts[fmt->pad];
+	if (fmt->pad >= 0 && fmt->pad < common->v4l.num_pads)
+		return &common->v4l.ffmts[fmt->pad];
+
+	return ERR_PTR(-EINVAL);
 }
 
 static int max9x_get_fmt(struct v4l2_subdev *sd,
@@ -1560,7 +1562,7 @@ static int max9x_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,
 	for_each_active_route(&state->routing, route) {
 		if (route->source_pad != pad)
 			continue;
-		if (unlikely(route->sink_pad >= common->v4l.num_pads)) {
+		if (route->sink_pad >= common->v4l.num_pads) {
 			ret = -EINVAL;
 			dev_err(common->dev, "Found invalid route sink_pad!");
 			goto out_unlock;
@@ -2090,7 +2092,7 @@ int max9x_disable_serial_link(struct max9x_common *common, unsigned int link_id)
 	struct device *dev = common->dev;
 	int ret;
 
-	if (unlikely(link_id >= common->num_serial_links))
+	if (link_id >= common->num_serial_links)
 		return 0;
 
 	serial_link = &common->serial_link[link_id];
@@ -2411,9 +2413,13 @@ static int max9x_parse_subdev_pdata(struct max9x_common *common,
 int max9x_select_i2c_chan(struct i2c_mux_core *muxc, u32 chan_id)
 {
 	struct max9x_common *common = i2c_mux_priv(muxc);
+	struct i2c_client *client = common->serial_link[chan_id].remote.client;
 	int ret = 0;
 	unsigned long timeout = jiffies + msecs_to_jiffies(10000);
 
+	dev_dbg(common->dev, "try to select %d for %s", chan_id,
+		client ? dev_name(&client->dev) : "");
+
 	if (unlikely(chan_id > common->num_serial_links))
 		return -EINVAL;
 
@@ -2427,7 +2433,7 @@ int max9x_select_i2c_chan(struct i2c_mux_core *muxc, u32 chan_id)
 		usleep_range(1000, 1050);
 
 		if (time_is_before_jiffies(timeout)) {
-			dev_warn(common->dev, "select %d TIMEOUT", chan_id);
+			dev_dbg(common->dev, "select %d TIMEOUT", chan_id);
 			return -ETIMEDOUT;
 		}
 	} while (1);
@@ -2445,8 +2451,12 @@ int max9x_select_i2c_chan(struct i2c_mux_core *muxc, u32 chan_id)
 int max9x_deselect_i2c_chan(struct i2c_mux_core *muxc, u32 chan_id)
 {
 	struct max9x_common *common = i2c_mux_priv(muxc);
+	struct i2c_client *client = common->serial_link[chan_id].remote.client;
 	int ret = 0;
 
+	dev_dbg(common->dev, "try to deselect %d for %s", chan_id,
+		client ? dev_name(&client->dev) : "");
+
 	if (unlikely(chan_id > common->num_serial_links))
 		return -EINVAL;
 
-- 
2.43.0

