From 37612e8e45f575a29f13fb6e61154f1b25034df9 Mon Sep 17 00:00:00 2001
From: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date: Wed, 9 May 2018 17:14:11 +0100
Subject: [PATCH 1640/2367] ASoC: SOF: Intel: Add HDA controller for Intel DSP

Support HDA controller operations for DSP and provide space for future
DSP HDA FW integration.

Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
---
 sound/soc/sof/intel/hda-ctrl.c | 133 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 133 insertions(+)
 create mode 100644 sound/soc/sof/intel/hda-ctrl.c

diff --git a/sound/soc/sof/intel/hda-ctrl.c b/sound/soc/sof/intel/hda-ctrl.c
new file mode 100644
index 00000000..57b877b
--- /dev/null
+++ b/sound/soc/sof/intel/hda-ctrl.c
@@ -0,0 +1,133 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * Copyright(c) 2017 Intel Corporation. All rights reserved.
+ *
+ * Authors: Liam Girdwood <liam.r.girdwood@linux.intel.com>
+ *	    Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
+ *	    Jeeja KP <jeeja.kp@intel.com>
+ *	    Rander Wang <rander.wang@intel.com>
+ *          Keyon Jie <yang.jie@linux.intel.com>
+ */
+
+/*
+ * Hardware interface for generic Intel audio DSP HDA IP
+ */
+
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/firmware.h>
+#include <linux/pci.h>
+#include <sound/hdaudio_ext.h>
+#include <sound/sof.h>
+#include <sound/pcm_params.h>
+#include <linux/pm_runtime.h>
+
+#include "../sof-priv.h"
+#include "../ops.h"
+#include "hda.h"
+
+/*
+ * HDA Operations.
+ */
+
+int hda_dsp_ctrl_link_reset(struct snd_sof_dev *sdev)
+{
+	unsigned long timeout;
+	u32 gctl = 0;
+
+	/* reset the HDA controller */
+	snd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, SOF_HDA_GCTL,
+				SOF_HDA_GCTL_RESET, 0);
+
+	/* wait for reset */
+	timeout = jiffies + msecs_to_jiffies(HDA_DSP_CTRL_RESET_TIMEOUT);
+	while (time_before(jiffies, timeout)) {
+		usleep_range(500, 1000);
+		gctl = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, SOF_HDA_GCTL);
+		if ((gctl & SOF_HDA_GCTL_RESET) == 0)
+			goto clear;
+	}
+
+	/* reset failed */
+	dev_err(sdev->dev, "error: failed to reset HDA controller gctl 0x%x\n",
+		gctl);
+	return -EIO;
+
+clear:
+	/* wait for codec */
+	usleep_range(500, 1000);
+
+	/* now take controller out of reset */
+	snd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, SOF_HDA_GCTL,
+				SOF_HDA_GCTL_RESET, SOF_HDA_GCTL_RESET);
+
+	/* wait for controller to be ready */
+	timeout = jiffies + msecs_to_jiffies(HDA_DSP_CTRL_RESET_TIMEOUT);
+	while (time_before(jiffies, timeout)) {
+		gctl = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, SOF_HDA_GCTL);
+		if ((gctl & SOF_HDA_GCTL_RESET) == 1)
+			return 0;
+		usleep_range(500, 1000);
+	}
+
+	/* reset failed */
+	dev_err(sdev->dev, "error: failed to ready HDA controller gctl 0x%x\n",
+		gctl);
+	return -EIO;
+}
+
+int hda_dsp_ctrl_get_caps(struct snd_sof_dev *sdev)
+{
+	u32 cap, offset, feature;
+	int ret = -ENODEV, count = 0;
+
+	offset = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, SOF_HDA_LLCH);
+
+	do {
+		cap = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, offset);
+
+		dev_dbg(sdev->dev, "checking for capabilities at offset 0x%x\n",
+			offset & SOF_HDA_CAP_NEXT_MASK);
+
+		feature = (cap & SOF_HDA_CAP_ID_MASK) >> SOF_HDA_CAP_ID_OFF;
+
+		switch (feature) {
+		case SOF_HDA_PP_CAP_ID:
+			dev_dbg(sdev->dev, "found DSP capability at 0x%x\n",
+				offset);
+			sdev->bar[HDA_DSP_PP_BAR] = sdev->bar[HDA_DSP_HDA_BAR] +
+				offset;
+			ret = 0;
+			break;
+		case SOF_HDA_SPIB_CAP_ID:
+			dev_dbg(sdev->dev, "found SPIB capability at 0x%x\n",
+				offset);
+			sdev->bar[HDA_DSP_SPIB_BAR] =
+				sdev->bar[HDA_DSP_HDA_BAR] + offset;
+			break;
+		case SOF_HDA_DRSM_CAP_ID:
+			dev_dbg(sdev->dev, "found DRSM capability at 0x%x\n",
+				offset);
+			sdev->bar[HDA_DSP_DRSM_BAR] =
+				sdev->bar[HDA_DSP_HDA_BAR] + offset;
+			break;
+		default:
+			dev_vdbg(sdev->dev, "found capability %d at 0x%x\n",
+				 feature, offset);
+			break;
+		}
+
+		offset = cap & SOF_HDA_CAP_NEXT_MASK;
+	} while (count++ <= SOF_HDA_MAX_CAPS && offset);
+
+	return ret;
+}
+
-- 
2.7.4

