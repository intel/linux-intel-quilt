From 24175f76aa35e4f58b99df48141646034a1014c3 Mon Sep 17 00:00:00 2001
From: Mika Westerberg <mika.westerberg@linux.intel.com>
Date: Thu, 22 Oct 2020 13:22:06 +0300
Subject: [PATCH 18/20] thunderbolt: Allow disabling XDomain protocol

This allows user to disable XDomain protocol completely, for example for
security reasons or if the user simply does not plan to use any of the
peer-to-peer functionality Thunderbolt/USB4. XDomain is enabled by
default but this adds Kconfig option that can be used to remove most of
the XDomain code from the driver module.

We also add a command line option that can be used to disable XDomain
functionality even if otherwise enabled by the distro kernel
configuration for example.

Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
---
 drivers/net/Kconfig           |   3 +-
 drivers/thunderbolt/Kconfig   |  10 ++
 drivers/thunderbolt/Makefile  |   5 +-
 drivers/thunderbolt/domain.c  |   4 +-
 drivers/thunderbolt/icm.c     |   6 +-
 drivers/thunderbolt/tb.c      |   3 +
 drivers/thunderbolt/tb.h      |  75 ++++++++++---
 drivers/thunderbolt/xdomain.c |   4 +
 include/linux/thunderbolt.h   | 194 +++++++++++++++++++---------------
 9 files changed, 200 insertions(+), 104 deletions(-)

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index c3dbe64e628e..78061792a941 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -555,7 +555,8 @@ config FUJITSU_ES
 
 config USB4_NET
 	tristate "Networking over USB4 and Thunderbolt cables"
-	depends on USB4 && INET
+	depends on USB4 && USB4_XDOMAIN
+	depends on INET
 	help
 	  Select this if you want to create network between two computers
 	  over a USB4 and Thunderbolt cables. The driver supports Apple
diff --git a/drivers/thunderbolt/Kconfig b/drivers/thunderbolt/Kconfig
index 4bfec8a28064..4adba40dbb17 100644
--- a/drivers/thunderbolt/Kconfig
+++ b/drivers/thunderbolt/Kconfig
@@ -18,6 +18,15 @@ menuconfig USB4
 
 if USB4
 
+config USB4_XDOMAIN
+	bool "Enable XDomain (peer-to-peer) support"
+	default y
+	help
+	  Enables peer-to-peer communication between domains. This is
+	  needed for running services such as networking over Thunderbolt
+	  cable. Even if enabled here, it is still possible to disable
+	  XDomain protocol by passing 'xdomain=0' as module parameter.
+
 config USB4_DEBUGFS_WRITE
 	bool "Enable write by debugfs to configuration spaces (DANGEROUS)"
 	help
@@ -33,6 +42,7 @@ config USB4_KUNIT_TEST
 
 config USB4_DMA_TEST
 	tristate "DMA traffic test driver"
+	depends on USB4_XDOMAIN
 	depends on DEBUG_FS
 	help
 	  This allows sending and receiving DMA traffic through loopback
diff --git a/drivers/thunderbolt/Makefile b/drivers/thunderbolt/Makefile
index 7aa48f6c41d9..82379155ac53 100644
--- a/drivers/thunderbolt/Makefile
+++ b/drivers/thunderbolt/Makefile
@@ -1,9 +1,10 @@
 # SPDX-License-Identifier: GPL-2.0-only
 obj-${CONFIG_USB4} := thunderbolt.o
 thunderbolt-objs := nhi.o nhi_ops.o ctl.o tb.o switch.o cap.o path.o tunnel.o eeprom.o
-thunderbolt-objs += domain.o dma_port.o icm.o property.o xdomain.o lc.o tmu.o usb4.o
-thunderbolt-objs += nvm.o retimer.o quirks.o
+thunderbolt-objs += domain.o dma_port.o icm.o lc.o tmu.o usb4.o nvm.o retimer.o
+thunderbolt-objs += quirks.o
 
+thunderbolt-${CONFIG_USB4_XDOMAIN} += property.o xdomain.o
 thunderbolt-${CONFIG_ACPI} += acpi.o
 thunderbolt-$(CONFIG_DEBUG_FS) += debugfs.o
 thunderbolt-${CONFIG_USB4_KUNIT_TEST} += test.o
diff --git a/drivers/thunderbolt/domain.c b/drivers/thunderbolt/domain.c
index c273220cbc50..d86ae642d3dd 100644
--- a/drivers/thunderbolt/domain.c
+++ b/drivers/thunderbolt/domain.c
@@ -395,7 +395,9 @@ static bool tb_domain_event_cb(void *data, enum tb_cfg_pkg_type type,
 	switch (type) {
 	case TB_CFG_PKG_XDOMAIN_REQ:
 	case TB_CFG_PKG_XDOMAIN_RESP:
-		return tb_xdomain_handle_request(tb, type, buf, size);
+		if (tb_xdomain_enabled)
+			return tb_xdomain_handle_request(tb, type, buf, size);
+		break;
 
 	default:
 		tb->cm_ops->handle_event(tb, type, buf, size);
diff --git a/drivers/thunderbolt/icm.c b/drivers/thunderbolt/icm.c
index 977ba91f4d0e..b5e74bc7bdd5 100644
--- a/drivers/thunderbolt/icm.c
+++ b/drivers/thunderbolt/icm.c
@@ -1667,10 +1667,12 @@ static void icm_handle_notification(struct work_struct *work)
 			icm->device_disconnected(tb, n->pkg);
 			break;
 		case ICM_EVENT_XDOMAIN_CONNECTED:
-			icm->xdomain_connected(tb, n->pkg);
+			if (tb_xdomain_enabled)
+				icm->xdomain_connected(tb, n->pkg);
 			break;
 		case ICM_EVENT_XDOMAIN_DISCONNECTED:
-			icm->xdomain_disconnected(tb, n->pkg);
+			if (tb_xdomain_enabled)
+				icm->xdomain_disconnected(tb, n->pkg);
 			break;
 		case ICM_EVENT_RTD3_VETO:
 			icm->rtd3_veto(tb, n->pkg);
diff --git a/drivers/thunderbolt/tb.c b/drivers/thunderbolt/tb.c
index 5a5b73ec449f..9558c1dad33d 100644
--- a/drivers/thunderbolt/tb.c
+++ b/drivers/thunderbolt/tb.c
@@ -179,6 +179,9 @@ static void tb_scan_xdomain(struct tb_port *port)
 	struct tb_xdomain *xd;
 	u64 route;
 
+	if (!tb_xdomain_enabled)
+		return;
+
 	route = tb_downstream_route(port);
 	xd = tb_xdomain_find_by_route(tb, route);
 	if (xd) {
diff --git a/drivers/thunderbolt/tb.h b/drivers/thunderbolt/tb.h
index b3edaea95a8d..50d3eb9d3d61 100644
--- a/drivers/thunderbolt/tb.h
+++ b/drivers/thunderbolt/tb.h
@@ -602,8 +602,6 @@ extern struct device_type tb_switch_type;
 
 int tb_domain_init(void);
 void tb_domain_exit(void);
-int tb_xdomain_init(void);
-void tb_xdomain_exit(void);
 
 struct tb *tb_domain_alloc(struct tb_nhi *nhi, size_t privsize);
 int tb_domain_add(struct tb *tb);
@@ -936,6 +934,12 @@ static inline u64 tb_downstream_route(struct tb_port *port)
 	       | ((u64) port->port << (port->sw->config.depth * 8));
 }
 
+#ifdef CONFIG_USB4_XDOMAIN
+extern bool tb_xdomain_enabled;
+
+int tb_xdomain_init(void);
+void tb_xdomain_exit(void);
+
 bool tb_xdomain_handle_request(struct tb *tb, enum tb_cfg_pkg_type type,
 			       const void *buf, size_t size);
 struct tb_xdomain *tb_xdomain_alloc(struct tb *tb, struct device *parent,
@@ -944,19 +948,6 @@ struct tb_xdomain *tb_xdomain_alloc(struct tb *tb, struct device *parent,
 void tb_xdomain_add(struct tb_xdomain *xd);
 void tb_xdomain_remove(struct tb_xdomain *xd);
 
-static inline struct tb_xdomain *tb_xdomain_get(struct tb_xdomain *xd)
-{
-	if (xd)
-		get_device(&xd->dev);
-	return xd;
-}
-
-static inline void tb_xdomain_put(struct tb_xdomain *xd)
-{
-	if (xd)
-		put_device(&xd->dev);
-}
-
 struct tb_xdomain *tb_xdomain_find_by_link_depth(struct tb *tb, u8 link,
 						 u8 depth);
 struct tb_xdomain *tb_xdomain_find_by_uuid(struct tb *tb, const uuid_t *uuid);
@@ -973,6 +964,60 @@ tb_xdomain_find_by_route_locked(struct tb *tb, u64 route)
 
 	return xd;
 }
+#else
+#define tb_xdomain_enabled	false
+
+static inline int tb_xdomain_init(void) { return 0; }
+static inline void tb_xdomain_exit(void) { }
+
+static inline bool tb_xdomain_handle_request(struct tb *tb,
+					     enum tb_cfg_pkg_type type,
+					     const void *buf, size_t size)
+{
+	return true;
+}
+
+static inline struct tb_xdomain *
+tb_xdomain_alloc(struct tb *tb, struct device *parent, u64 route,
+		 const uuid_t *local_uuid, const uuid_t *remote_uuid)
+{
+	return NULL;
+}
+
+static inline void tb_xdomain_add(struct tb_xdomain *xd) { }
+static inline void tb_xdomain_remove(struct tb_xdomain *xd) { }
+
+static inline struct tb_xdomain *
+tb_xdomain_find_by_link_depth(struct tb *tb, u8 link, u8 depth)
+{
+	return NULL;
+}
+
+static inline struct tb_xdomain *tb_xdomain_find_by_uuid(struct tb *tb,
+							 const uuid_t *uuid)
+{
+	return NULL;
+}
+
+static inline struct tb_xdomain *tb_xdomain_find_by_route(struct tb *tb,
+							  u64 route)
+{
+	return NULL;
+}
+#endif
+
+static inline struct tb_xdomain *tb_xdomain_get(struct tb_xdomain *xd)
+{
+	if (xd)
+		get_device(&xd->dev);
+	return xd;
+}
+
+static inline void tb_xdomain_put(struct tb_xdomain *xd)
+{
+	if (xd)
+		put_device(&xd->dev);
+}
 
 int tb_retimer_scan(struct tb_port *port);
 void tb_retimer_remove_all(struct tb_port *port);
diff --git a/drivers/thunderbolt/xdomain.c b/drivers/thunderbolt/xdomain.c
index d07c8d7d305b..f761b8b1e6b0 100644
--- a/drivers/thunderbolt/xdomain.c
+++ b/drivers/thunderbolt/xdomain.c
@@ -30,6 +30,10 @@ struct xdomain_request_work {
 	struct tb *tb;
 };
 
+bool tb_xdomain_enabled = true;
+module_param_named(xdomain, tb_xdomain_enabled, bool, 0444);
+MODULE_PARM_DESC(xdomain, "allow XDomain protocol (default: true)");
+
 /* Serializes access to the properties and protocol handlers below */
 static DEFINE_MUTEX(xdomain_lock);
 
diff --git a/include/linux/thunderbolt.h b/include/linux/thunderbolt.h
index ff7deab8f758..6c9c02f7897d 100644
--- a/include/linux/thunderbolt.h
+++ b/include/linux/thunderbolt.h
@@ -86,17 +86,6 @@ struct tb {
 	unsigned long privdata[];
 };
 
-extern struct bus_type tb_bus_type;
-extern struct device_type tb_service_type;
-extern struct device_type tb_xdomain_type;
-
-#define TB_LINKS_PER_PHY_PORT	2
-
-static inline unsigned int tb_phy_port_from_link(unsigned int link)
-{
-	return (link - 1) / TB_LINKS_PER_PHY_PORT;
-}
-
 /**
  * struct tb_property_dir - XDomain property directory
  * @uuid: Directory UUID or %NULL if root directory
@@ -142,34 +131,6 @@ struct tb_property {
 	} value;
 };
 
-struct tb_property_dir *tb_property_parse_dir(const u32 *block,
-					      size_t block_len);
-ssize_t tb_property_format_dir(const struct tb_property_dir *dir, u32 *block,
-			       size_t block_len);
-struct tb_property_dir *tb_property_create_dir(const uuid_t *uuid);
-void tb_property_free_dir(struct tb_property_dir *dir);
-int tb_property_add_immediate(struct tb_property_dir *parent, const char *key,
-			      u32 value);
-int tb_property_add_data(struct tb_property_dir *parent, const char *key,
-			 const void *buf, size_t buflen);
-int tb_property_add_text(struct tb_property_dir *parent, const char *key,
-			 const char *text);
-int tb_property_add_dir(struct tb_property_dir *parent, const char *key,
-			struct tb_property_dir *dir);
-void tb_property_remove(struct tb_property *tb_property);
-struct tb_property *tb_property_find(struct tb_property_dir *dir,
-			const char *key, enum tb_property_type type);
-struct tb_property *tb_property_get_next(struct tb_property_dir *dir,
-					 struct tb_property *prev);
-
-#define tb_property_for_each(dir, property)			\
-	for (property = tb_property_get_next(dir, NULL);	\
-	     property;						\
-	     property = tb_property_get_next(dir, property))
-
-int tb_register_property_dir(const char *key, struct tb_property_dir *dir);
-void tb_unregister_property_dir(const char *key, struct tb_property_dir *dir);
-
 /**
  * struct tb_xdomain - Cross-domain (XDomain) connection
  * @dev: XDomain device
@@ -250,6 +211,84 @@ struct tb_xdomain {
 	u8 depth;
 };
 
+/**
+ * struct tb_service - Thunderbolt service
+ * @dev: XDomain device
+ * @id: ID of the service (shown in sysfs)
+ * @key: Protocol key from the properties directory
+ * @prtcid: Protocol ID from the properties directory
+ * @prtcvers: Protocol version from the properties directory
+ * @prtcrevs: Protocol software revision from the properties directory
+ * @prtcstns: Protocol settings mask from the properties directory
+ * @debugfs_dir: Pointer to the service debugfs directory. Always created
+ *		 when debugfs is enabled. Can be used by service drivers to
+ *		 add their own entries under the service.
+ *
+ * Each domain exposes set of services it supports as collection of
+ * properties. For each service there will be one corresponding
+ * &struct tb_service. Service drivers are bound to these.
+ */
+struct tb_service {
+	struct device dev;
+	int id;
+	const char *key;
+	u32 prtcid;
+	u32 prtcvers;
+	u32 prtcrevs;
+	u32 prtcstns;
+	struct dentry *debugfs_dir;
+};
+
+/**
+ * tb_service_driver - Thunderbolt service driver
+ * @driver: Driver structure
+ * @probe: Called when the driver is probed
+ * @remove: Called when the driver is removed (optional)
+ * @shutdown: Called at shutdown time to stop the service (optional)
+ * @id_table: Table of service identifiers the driver supports
+ */
+struct tb_service_driver {
+	struct device_driver driver;
+	int (*probe)(struct tb_service *svc, const struct tb_service_id *id);
+	void (*remove)(struct tb_service *svc);
+	void (*shutdown)(struct tb_service *svc);
+	const struct tb_service_id *id_table;
+};
+
+extern struct bus_type tb_bus_type;
+
+#ifdef CONFIG_USB4_XDOMAIN
+extern struct device_type tb_service_type;
+extern struct device_type tb_xdomain_type;
+
+struct tb_property_dir *tb_property_parse_dir(const u32 *block,
+					      size_t block_len);
+ssize_t tb_property_format_dir(const struct tb_property_dir *dir, u32 *block,
+			       size_t block_len);
+struct tb_property_dir *tb_property_create_dir(const uuid_t *uuid);
+void tb_property_free_dir(struct tb_property_dir *dir);
+int tb_property_add_immediate(struct tb_property_dir *parent, const char *key,
+			      u32 value);
+int tb_property_add_data(struct tb_property_dir *parent, const char *key,
+			 const void *buf, size_t buflen);
+int tb_property_add_text(struct tb_property_dir *parent, const char *key,
+			 const char *text);
+int tb_property_add_dir(struct tb_property_dir *parent, const char *key,
+			struct tb_property_dir *dir);
+void tb_property_remove(struct tb_property *tb_property);
+struct tb_property *tb_property_find(struct tb_property_dir *dir,
+			const char *key, enum tb_property_type type);
+struct tb_property *tb_property_get_next(struct tb_property_dir *dir,
+					 struct tb_property *prev);
+
+#define tb_property_for_each(dir, property)			\
+	for (property = tb_property_get_next(dir, NULL);	\
+	     property;						\
+	     property = tb_property_get_next(dir, property))
+
+int tb_register_property_dir(const char *key, struct tb_property_dir *dir);
+void tb_unregister_property_dir(const char *key, struct tb_property_dir *dir);
+
 int tb_xdomain_lane_bonding_enable(struct tb_xdomain *xd);
 void tb_xdomain_lane_bonding_disable(struct tb_xdomain *xd);
 int tb_xdomain_enable_paths(struct tb_xdomain *xd, u16 transmit_path,
@@ -305,34 +344,6 @@ struct tb_protocol_handler {
 int tb_register_protocol_handler(struct tb_protocol_handler *handler);
 void tb_unregister_protocol_handler(struct tb_protocol_handler *handler);
 
-/**
- * struct tb_service - Thunderbolt service
- * @dev: XDomain device
- * @id: ID of the service (shown in sysfs)
- * @key: Protocol key from the properties directory
- * @prtcid: Protocol ID from the properties directory
- * @prtcvers: Protocol version from the properties directory
- * @prtcrevs: Protocol software revision from the properties directory
- * @prtcstns: Protocol settings mask from the properties directory
- * @debugfs_dir: Pointer to the service debugfs directory. Always created
- *		 when debugfs is enabled. Can be used by service drivers to
- *		 add their own entries under the service.
- *
- * Each domain exposes set of services it supports as collection of
- * properties. For each service there will be one corresponding
- * &struct tb_service. Service drivers are bound to these.
- */
-struct tb_service {
-	struct device dev;
-	int id;
-	const char *key;
-	u32 prtcid;
-	u32 prtcvers;
-	u32 prtcrevs;
-	u32 prtcstns;
-	struct dentry *debugfs_dir;
-};
-
 static inline struct tb_service *tb_service_get(struct tb_service *svc)
 {
 	if (svc)
@@ -358,22 +369,6 @@ static inline struct tb_service *tb_to_service(struct device *dev)
 	return NULL;
 }
 
-/**
- * tb_service_driver - Thunderbolt service driver
- * @driver: Driver structure
- * @probe: Called when the driver is probed
- * @remove: Called when the driver is removed (optional)
- * @shutdown: Called at shutdown time to stop the service (optional)
- * @id_table: Table of service identifiers the driver supports
- */
-struct tb_service_driver {
-	struct device_driver driver;
-	int (*probe)(struct tb_service *svc, const struct tb_service_id *id);
-	void (*remove)(struct tb_service *svc);
-	void (*shutdown)(struct tb_service *svc);
-	const struct tb_service_id *id_table;
-};
-
 #define TB_SERVICE(key, id)				\
 	.match_flags = TBSVC_MATCH_PROTOCOL_KEY |	\
 		       TBSVC_MATCH_PROTOCOL_ID,		\
@@ -397,6 +392,39 @@ static inline struct tb_xdomain *tb_service_parent(struct tb_service *svc)
 {
 	return tb_to_xdomain(svc->dev.parent);
 }
+#else
+static inline int tb_xdomain_disable_paths(struct tb_xdomain *xd)
+{
+	return 0;
+}
+
+static inline bool tb_is_xdomain(const struct device *dev)
+{
+	return false;
+}
+
+static inline struct tb_xdomain *tb_to_xdomain(struct device *dev)
+{
+	return NULL;
+}
+
+static inline bool tb_is_service(const struct device *dev)
+{
+	return false;
+}
+
+static inline struct tb_service *tb_to_service(struct device *dev)
+{
+	return NULL;
+}
+#endif
+
+#define TB_LINKS_PER_PHY_PORT	2
+
+static inline unsigned int tb_phy_port_from_link(unsigned int link)
+{
+	return (link - 1) / TB_LINKS_PER_PHY_PORT;
+}
 
 /**
  * struct tb_nhi - thunderbolt native host interface
-- 
2.27.0

