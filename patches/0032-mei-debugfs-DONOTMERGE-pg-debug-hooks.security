From 0feaf4a1b132c099e8c3f7522f21c824b9632378 Mon Sep 17 00:00:00 2001
From: Alexander Usyskin <alexander.usyskin@intel.com>
Date: Sun, 8 Mar 2015 13:50:38 +0200
Subject: [PATCH 32/77] mei: debugfs: [DONOTMERGE] pg debug hooks

Change-Id: I093b38c61ec828e8ff682a93510eb91085208ece
Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
---
 drivers/misc/mei/debugfs.c | 67 ++++++++++++++++++++++++++++++++++++++
 drivers/misc/mei/hw-me.c   |  5 ++-
 drivers/misc/mei/mei_dev.h | 13 ++++++++
 3 files changed, 84 insertions(+), 1 deletion(-)

diff --git a/drivers/misc/mei/debugfs.c b/drivers/misc/mei/debugfs.c
index d4d7735cadad..6d46d474143e 100644
--- a/drivers/misc/mei/debugfs.c
+++ b/drivers/misc/mei/debugfs.c
@@ -191,6 +191,61 @@ static const struct file_operations mei_dbgfs_fops_reset = {
 	.llseek = generic_file_llseek,
 };
 
+static ssize_t mei_dbgfs_read_pg_enter(struct file *fp, char __user *ubuf,
+				       size_t cnt, loff_t *ppos)
+{
+	struct mei_device *dev = fp->private_data;
+	const size_t bufsz = 1024;
+	char *buf = kzalloc(bufsz, GFP_KERNEL);
+	int pos = 0;
+	int ret;
+
+	if  (!buf)
+		return -ENOMEM;
+
+	mutex_lock(&dev->device_lock);
+	ret = mei_pg_enter_sync(dev);
+	mutex_unlock(&dev->device_lock);
+
+	pos += scnprintf(buf + pos, bufsz - pos, "ret: %d\n", ret);
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations mei_dbgfs_fops_pg_enter = {
+	.open = simple_open,
+	.read = mei_dbgfs_read_pg_enter,
+	.llseek = generic_file_llseek,
+};
+
+static ssize_t mei_dbgfs_read_pg_exit(struct file *fp, char __user *ubuf,
+				      size_t cnt, loff_t *ppos)
+{
+	struct mei_device *dev = fp->private_data;
+	const size_t bufsz = 1024;
+	char *buf = kzalloc(bufsz, GFP_KERNEL);
+	int pos = 0;
+	int ret;
+
+	if  (!buf)
+		return -ENOMEM;
+
+	mutex_lock(&dev->device_lock);
+	ret = mei_pg_exit_sync(dev);
+	mutex_unlock(&dev->device_lock);
+
+	pos += scnprintf(buf + pos, bufsz - pos, "ret: %d\n", ret);
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations mei_dbgfs_fops_pg_exit = {
+	.open = simple_open,
+	.read = mei_dbgfs_read_pg_exit,
+	.llseek = generic_file_llseek,
+};
 /**
  * mei_dbgfs_deregister - Remove the debugfs files and directories
  *
@@ -253,6 +308,18 @@ int mei_dbgfs_register(struct mei_device *dev, const char *name)
 		dev_err(dev->dev, "reset: registration failed\n");
 		goto err;
 	}
+	f = debugfs_create_file("pg_enter", 0400, dir,
+				dev, &mei_dbgfs_fops_pg_enter);
+	if (!f) {
+		dev_err(dev->dev, "pg_enter: registration failed\n");
+		goto err;
+	}
+	f = debugfs_create_file("pg_exit", 0400, dir,
+				dev, &mei_dbgfs_fops_pg_exit);
+	if (!f) {
+		dev_err(dev->dev, "pg_exit: registration failed\n");
+		goto err;
+	}
 
 	return 0;
 err:
diff --git a/drivers/misc/mei/hw-me.c b/drivers/misc/mei/hw-me.c
index 3c32cd88c24b..9c8ec4577051 100644
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@ -1335,7 +1335,10 @@ static const struct mei_hw_ops mei_me_hw_ops = {
 
 	.rdbuf_full_slots = mei_me_count_full_read_slots,
 	.read_hdr = mei_me_mecbrw_read,
-	.read = mei_me_read_slots
+	.read = mei_me_read_slots,
+
+	.pg_enter_sync = mei_me_pg_enter_sync,
+	.pg_exit_sync = mei_me_pg_exit_sync
 };
 
 static bool mei_me_fw_type_nm(struct pci_dev *pdev)
diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h
index 56c1e09d64fd..cda2d6563e27 100644
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -326,6 +326,9 @@ struct mei_hw_ops {
 	u32 (*read_hdr)(const struct mei_device *dev);
 	int (*read)(struct mei_device *dev,
 		     unsigned char *buf, unsigned long len);
+
+	int (*pg_enter_sync)(struct mei_device *dev);
+	int (*pg_exit_sync)(struct mei_device *dev);
 };
 
 /* MEI bus API*/
@@ -744,6 +747,16 @@ static inline int mei_fw_status(struct mei_device *dev,
 	return dev->ops->fw_status(dev, fw_status);
 }
 
+static inline bool mei_pg_enter_sync(struct mei_device *dev)
+{
+	return dev->ops->pg_enter_sync(dev);
+}
+
+static inline bool mei_pg_exit_sync(struct mei_device *dev)
+{
+	return dev->ops->pg_exit_sync(dev);
+}
+
 bool mei_hbuf_acquire(struct mei_device *dev);
 
 bool mei_write_is_idle(struct mei_device *dev);
-- 
2.17.1

