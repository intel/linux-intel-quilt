From 21beede33c65f8742dbfcdb5e012161833758fb5 Mon Sep 17 00:00:00 2001
From: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date: Thu, 3 Sep 2020 17:12:05 +0300
Subject: [PATCH 17/26] NET: m_can: m_can_pci: Fix BUG_ON on unload when
 interface is up

Attempt to unload this driver when interface is up will cause an oops
below:

	# ip link set can0 type can bitrate 1000000 dbitrate 2000000 fd on
	# ip link set can0 up
	# rmmod m_can_pci

	kernel BUG at drivers/pci/msi.c:375!
	...
	Call Trace:
	 pci_disable_msi+0x102/0x140
	 pci_free_irq_vectors+0x16/0x20
	 m_can_pci_remove+0x40/0x60 [m_can_pci]

This is due the interrupt requested by the m_can core is not released
before calling pci_free_irq_vectors(). Since interrupt will be freed when
calling m_can_class_unregister() so fix the issue by moving
pci_free_irq_vectors() after m_can_class_unregister().

Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
---
 drivers/net/can/m_can/m_can_pci.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/net/can/m_can/m_can_pci.c b/drivers/net/can/m_can/m_can_pci.c
index c7f1dc1f5820..d6a16c9864a3 100644
--- a/drivers/net/can/m_can/m_can_pci.c
+++ b/drivers/net/can/m_can/m_can_pci.c
@@ -166,8 +166,8 @@ static void m_can_pci_remove(struct pci_dev *pci)
 	/* Disable interrupt control at CAN wrapper IP */
 	writel(0x0, priv->base + CTL_CSR_INT_CTL_OFFSET);
 
-	pci_free_irq_vectors(pci);
 	m_can_class_unregister(mcan_class);
+	pci_free_irq_vectors(pci);
 }
 
 static __maybe_unused int m_can_pci_suspend(struct device *dev)
-- 
2.27.0

