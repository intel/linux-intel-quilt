From 107815c1ce793954c5becd2ece701bf86be509d2 Mon Sep 17 00:00:00 2001
From: Cezary Rojewski <cezary.rojewski@intel.com>
Date: Fri, 26 Oct 2018 15:48:27 +0200
Subject: [PATCH 012/154] ASoC: Intel: Skylake: Generic firmware recovery on
 IPC timeout
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Whenever IPC routine returns an error, there are steps which driver
should take depending on error code returned. Timeout is the most basic
case and recommendation is to simply reload firmware.

Current implementation handles only timeouts occurring during boot as
reloading firmware in other cases shouldn't be done without resending
firmware configuration. Recovery will be expanded upon in future
releases.

Change-Id: Idf3fe75a2d5bd54394de55322f75e6a3ce98eedc
Signed-off-by: PawelX Dogiel <pawelx.dogiel@intel.com>
Signed-off-by: Cezary Rojewski <cezary.rojewski@intel.com>
Signed-off-by: Paweł Harłoziński <pawel.harlozinski@intel.com>
---
 sound/soc/intel/skylake/skl-sst-ipc.c | 53 ++++++++++++++++++++-------
 sound/soc/intel/skylake/skl-sst-ipc.h |  3 ++
 2 files changed, 43 insertions(+), 13 deletions(-)

diff --git a/sound/soc/intel/skylake/skl-sst-ipc.c b/sound/soc/intel/skylake/skl-sst-ipc.c
index 0e1c9f62dbd2..320605e0724b 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.c
+++ b/sound/soc/intel/skylake/skl-sst-ipc.c
@@ -639,6 +639,33 @@ void skl_ipc_free(struct sst_generic_ipc *ipc)
 	sst_ipc_fini(ipc);
 }
 
+int skl_ipc_tx_message_wait(struct sst_generic_ipc *ipc, u64 header,
+		void *tx_data, size_t tx_bytes, u64 *reply,
+		void *rx_data, size_t rx_bytes)
+{
+	struct skl_dev *skl = container_of(ipc, struct skl_dev, ipc);
+	int ret;
+
+	ret = sst_ipc_tx_message_wait(ipc, header,
+		tx_data, tx_bytes, reply,
+		rx_data, rx_bytes);
+
+	if (ret == -ETIMEDOUT && skl->is_first_boot) {
+		skl->enable_miscbdcge(ipc->dev, false);
+		skl->clock_power_gating(ipc->dev, false);
+
+		ret = skl->dsp_ops->init_fw(ipc->dev, skl);
+
+		skl->enable_miscbdcge(ipc->dev, true);
+		skl->clock_power_gating(ipc->dev, true);
+
+		dev_warn(ipc->dev, "Recover from IPC timeout: %d\n", ret);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(skl_ipc_tx_message_wait);
+
 int skl_ipc_create_pipeline(struct sst_generic_ipc *ipc,
 		u16 ppl_mem_size, u8 ppl_type, u8 instance_id, u8 lp_mode)
 {
@@ -656,7 +683,7 @@ int skl_ipc_create_pipeline(struct sst_generic_ipc *ipc,
 	header.extension = IPC_PPL_LP_MODE(lp_mode);
 
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
+	ret = skl_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
 			NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: create pipeline fail, err: %d\n", ret);
@@ -679,7 +706,7 @@ int skl_ipc_delete_pipeline(struct sst_generic_ipc *ipc, u8 instance_id)
 	header.primary |= IPC_INSTANCE_ID(instance_id);
 
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
+	ret = skl_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
 			NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: delete pipeline failed, err %d\n", ret);
@@ -704,7 +731,7 @@ int skl_ipc_set_pipeline_state(struct sst_generic_ipc *ipc,
 	header.primary |= IPC_PPL_STATE(state);
 
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
+	ret = skl_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
 			NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: set pipeline state failed, err: %d\n", ret);
@@ -728,7 +755,7 @@ skl_ipc_save_pipeline(struct sst_generic_ipc *ipc, u8 instance_id, int dma_id)
 
 	header.extension = IPC_DMA_ID(dma_id);
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
+	ret = skl_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
 			NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: save pipeline failed, err: %d\n", ret);
@@ -751,7 +778,7 @@ int skl_ipc_restore_pipeline(struct sst_generic_ipc *ipc, u8 instance_id)
 	header.primary |= IPC_INSTANCE_ID(instance_id);
 
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
+	ret = skl_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
 			NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: restore  pipeline failed, err: %d\n", ret);
@@ -777,7 +804,7 @@ int skl_ipc_set_dx(struct sst_generic_ipc *ipc, u8 instance_id,
 
 	dev_dbg(ipc->dev, "In %s primary =%x ext=%x\n", __func__,
 			 header.primary, header.extension);
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header,
+	ret = skl_ipc_tx_message_wait(ipc, *ipc_header,
 				dx, sizeof(*dx), NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: set dx failed, err %d\n", ret);
@@ -814,7 +841,7 @@ int skl_ipc_init_instance(struct sst_generic_ipc *ipc,
 
 	dev_dbg(ipc->dev, "In %s primary =%x ext=%x\n", __func__,
 			 header.primary, header.extension);
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, param_data,
+	ret = skl_ipc_tx_message_wait(ipc, *ipc_header, param_data,
 			msg->param_data_size, NULL, NULL, 0);
 
 	if (ret < 0) {
@@ -847,7 +874,7 @@ int skl_ipc_bind_unbind(struct sst_generic_ipc *ipc,
 
 	dev_dbg(ipc->dev, "In %s hdr=%x ext=%x\n", __func__, header.primary,
 			 header.extension);
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
+	ret = skl_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
 			NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: bind/unbind failed\n");
@@ -876,7 +903,7 @@ int skl_ipc_load_modules(struct sst_generic_ipc *ipc,
 	header.primary |= IPC_GLB_TYPE(IPC_GLB_LOAD_MULTIPLE_MODS);
 	header.primary |= IPC_LOAD_MODULE_CNT(module_cnt);
 
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, data,
+	ret = skl_ipc_tx_message_wait(ipc, *ipc_header, data,
 				(sizeof(u16) * module_cnt), NULL, NULL, 0);
 	if (ret < 0)
 		dev_err(ipc->dev, "ipc: load modules failed :%d\n", ret);
@@ -897,7 +924,7 @@ int skl_ipc_unload_modules(struct sst_generic_ipc *ipc, u8 module_cnt,
 	header.primary |= IPC_GLB_TYPE(IPC_GLB_UNLOAD_MULTIPLE_MODS);
 	header.primary |= IPC_LOAD_MODULE_CNT(module_cnt);
 
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, data,
+	ret = skl_ipc_tx_message_wait(ipc, *ipc_header, data,
 				(sizeof(u16) * module_cnt), NULL, NULL, 0);
 	if (ret < 0)
 		dev_err(ipc->dev, "ipc: unload modules failed :%d\n", ret);
@@ -937,7 +964,7 @@ int skl_ipc_set_large_config(struct sst_generic_ipc *ipc,
 			header.primary, header.extension);
 		dev_dbg(ipc->dev, "transmitting offset: %#x, size: %#x\n",
 			(unsigned)data_offset, (unsigned)tx_size);
-		ret = sst_ipc_tx_message_wait(ipc, *ipc_header,
+		ret = skl_ipc_tx_message_wait(ipc, *ipc_header,
 					  ((char *)param) + data_offset,
 					  tx_size, NULL, NULL, 0);
 		if (ret < 0) {
@@ -992,7 +1019,7 @@ int skl_ipc_get_large_config(struct sst_generic_ipc *ipc,
 	header.extension |= IPC_FINAL_BLOCK(1);
 	header.extension |= IPC_INITIAL_BLOCK(1);
 
-	ret = sst_ipc_tx_message_wait(ipc, *(u64 *)(&header),
+	ret = skl_ipc_tx_message_wait(ipc, *(u64 *)(&header),
 			tlv, tlv ? *bytes : 0, &reply,
 			buf, SKL_ADSP_W1_SZ);
 	if (ret < 0) {
@@ -1025,7 +1052,7 @@ int skl_sst_ipc_load_library(struct sst_generic_ipc *ipc,
 	header.primary |= IPC_MOD_ID(dma_id);
 
 	if (wait)
-		ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
+		ret = skl_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
 					NULL, NULL, 0);
 	else
 		ret = sst_ipc_tx_message_nowait(ipc, *ipc_header, NULL, 0);
diff --git a/sound/soc/intel/skylake/skl-sst-ipc.h b/sound/soc/intel/skylake/skl-sst-ipc.h
index a70247d6148c..b1ea2a45dec4 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.h
+++ b/sound/soc/intel/skylake/skl-sst-ipc.h
@@ -121,6 +121,9 @@ struct skl_ipc_d0ix_msg {
 
 irqreturn_t skl_dsp_irq_thread_handler(int irq, void *context);
 
+int skl_ipc_tx_message_wait(struct sst_generic_ipc *ipc, u64 header,
+	void *tx_data, size_t tx_bytes, u64 *reply,
+	void *rx_data, size_t rx_bytes);
 int skl_ipc_create_pipeline(struct sst_generic_ipc *sst_ipc,
 		u16 ppl_mem_size, u8 ppl_type, u8 instance_id, u8 lp_mode);
 
-- 
2.17.1

