From a3a078a953d5c1c09e2087a7cfc2632c9a608f67 Mon Sep 17 00:00:00 2001
From: Junxiao Chang <junxiao.chang@intel.com>
Date: Wed, 25 Jun 2025 11:24:39 +0800
Subject: [PATCH 17/17] drm/i915: no waiting for page flip in vpp case

VPP needs to skip page flip waiting for better performance - This
should be for vpp case only. If user inputs command
"echo 0 > /proc/sys/kernel/pageflip_wait", it doesn't wait for
page flip anymore.

Signed-off-by: Junxiao Chang <junxiao.chang@intel.com>
---
 drivers/gpu/drm/i915/display/intel_display.c | 52 +++++++++++++++++++-
 1 file changed, 51 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/i915/display/intel_display.c b/drivers/gpu/drm/i915/display/intel_display.c
index d6500b39019d2..f6a70e734a716 100644
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@ -138,6 +138,10 @@ static void hsw_set_transconf(const struct intel_crtc_state *crtc_state);
 static void bdw_set_pipe_misc(struct intel_dsb *dsb,
 			      const struct intel_crtc_state *crtc_state);
 
+#ifdef CONFIG_SYSCTL
+static unsigned int sysctl_pageflip_wait = 1;
+#endif /* CONFIG_SYSCTL */
+
 /* returns HPLL frequency in kHz */
 int vlv_get_hpll_vco(struct drm_i915_private *dev_priv)
 {
@@ -7452,7 +7456,15 @@ static void intel_atomic_commit_tail(struct intel_atomic_state *state)
 	 * - switch over to the vblank wait helper in the core after that since
 	 *   we don't need out special handling any more.
 	 */
-	drm_atomic_helper_wait_for_flip_done(dev, &state->base);
+	/* FIXME: VPP team need to optimize multiple display performance
+	 * by skipping flip waiting. This might introduce display corruption
+	 * issue. Only if user echo 0 to /proc/sys/kernel/pageflip_wait, wait
+	 * is skipped.
+	 */
+#ifdef CONFIG_SYSCTL
+	if (sysctl_pageflip_wait)
+#endif /* CONFIG_SYSCTL */
+		drm_atomic_helper_wait_for_flip_done(dev, &state->base);
 
 	for_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {
 		if (new_crtc_state->do_async_flip)
@@ -8162,6 +8174,41 @@ static const struct intel_display_funcs i9xx_display_funcs = {
 	.fixup_initial_plane_config = i9xx_fixup_initial_plane_config,
 };
 
+#ifdef CONFIG_SYSCTL
+static int pageflip_wait_migration_handler(const struct ctl_table *table, int write,
+			    void *buffer, size_t *lenp, loff_t *ppos)
+{
+	int ret;
+
+	ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+	if (write) {
+		if (!sysctl_pageflip_wait)
+			pr_info("no page flip waiting for vpp testing\n");
+		else
+			pr_info("waiting for page flip, ignore vpp case\n");
+	}
+	return ret;
+}
+
+static struct ctl_table pageflip_wait_sysctl[] = {
+	{
+		.procname	= "pageflip_wait",
+		.data		= &sysctl_pageflip_wait,
+		.maxlen		= sizeof(unsigned int),
+		.mode		= 0644,
+		.proc_handler	= pageflip_wait_migration_handler,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_ONE,
+	},
+};
+
+static int pageflip_wait_sysctl_init(void)
+{
+	register_sysctl("kernel", pageflip_wait_sysctl);
+	return 0;
+}
+#endif /* CONFIG_SYSCTL */
+
 /**
  * intel_init_display_hooks - initialize the display modesetting hooks
  * @dev_priv: device private
@@ -8180,6 +8227,9 @@ void intel_init_display_hooks(struct drm_i915_private *dev_priv)
 	} else {
 		dev_priv->display.funcs.display = &i9xx_display_funcs;
 	}
+#ifdef CONFIG_SYSCTL
+	pageflip_wait_sysctl_init();
+#endif /* CONFIG_SYSCTL */
 }
 
 int intel_initial_commit(struct drm_device *dev)
-- 
2.34.1

