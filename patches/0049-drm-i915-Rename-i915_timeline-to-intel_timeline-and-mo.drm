From 9880737c4fe6c3d2e0baf329eb39a75ec50e6dab Mon Sep 17 00:00:00 2001
From: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date: Fri, 21 Jun 2019 08:08:10 +0100
Subject: [PATCH 049/406] drm/i915: Rename i915_timeline to intel_timeline and
 move under gt

Move all timeline code under gt and rename to intel_gt prefix.

Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
Link: https://patchwork.freedesktop.org/patch/msgid/20190621070811.7006-32-tvrtko.ursulin@linux.intel.com
---
 drivers/gpu/drm/i915/Makefile                 |   2 +-
 drivers/gpu/drm/i915/Makefile.header-test     |   1 -
 drivers/gpu/drm/i915/gem/i915_gem_context.c   |  10 +-
 .../gpu/drm/i915/gem/i915_gem_context_types.h |   4 +-
 drivers/gpu/drm/i915/gem/i915_gem_pm.c        |   2 +-
 drivers/gpu/drm/i915/gt/intel_engine.h        |   4 +-
 drivers/gpu/drm/i915/gt/intel_engine_cs.c     |  14 +-
 drivers/gpu/drm/i915/gt/intel_engine_types.h  |   4 +-
 drivers/gpu/drm/i915/gt/intel_lrc.c           |  10 +-
 drivers/gpu/drm/i915/gt/intel_reset.c         |   2 +-
 drivers/gpu/drm/i915/gt/intel_ringbuffer.c    |  18 +--
 .../{i915_timeline.c => gt/intel_timeline.c}  | 108 ++++++++--------
 drivers/gpu/drm/i915/gt/intel_timeline.h      |  93 +++++++++++++
 .../intel_timeline_types.h}                   |   6 +-
 drivers/gpu/drm/i915/gt/mock_engine.c         |  10 +-
 .../selftest_timeline.c}                      | 122 +++++++++---------
 .../i915/{ => gt}/selftests/mock_timeline.c   |   6 +-
 .../i915/{ => gt}/selftests/mock_timeline.h   |   6 +-
 drivers/gpu/drm/i915/i915_drv.h               |   2 +-
 drivers/gpu/drm/i915/i915_gem.c               |   8 +-
 drivers/gpu/drm/i915/i915_gem_gtt.h           |   2 +-
 drivers/gpu/drm/i915/i915_request.c           |  14 +-
 drivers/gpu/drm/i915/i915_request.h           |   8 +-
 drivers/gpu/drm/i915/i915_timeline.h          |  93 -------------
 .../drm/i915/selftests/i915_live_selftests.h  |   2 +-
 .../drm/i915/selftests/i915_mock_selftests.h  |   2 +-
 .../gpu/drm/i915/selftests/mock_gem_device.c  |   6 +-
 27 files changed, 279 insertions(+), 280 deletions(-)
 rename drivers/gpu/drm/i915/{i915_timeline.c => gt/intel_timeline.c} (82%)
 create mode 100644 drivers/gpu/drm/i915/gt/intel_timeline.h
 rename drivers/gpu/drm/i915/{i915_timeline_types.h => gt/intel_timeline_types.h} (93%)
 rename drivers/gpu/drm/i915/{selftests/i915_timeline.c => gt/selftest_timeline.c} (87%)
 rename drivers/gpu/drm/i915/{ => gt}/selftests/mock_timeline.c (72%)
 rename drivers/gpu/drm/i915/{ => gt}/selftests/mock_timeline.h (53%)
 delete mode 100644 drivers/gpu/drm/i915/i915_timeline.h

diff --git a/drivers/gpu/drm/i915/Makefile b/drivers/gpu/drm/i915/Makefile
index 6b399e881660..c8162d2efc79 100644
--- a/drivers/gpu/drm/i915/Makefile
+++ b/drivers/gpu/drm/i915/Makefile
@@ -81,6 +81,7 @@ gt-y += \
 	gt/intel_ringbuffer.o \
 	gt/intel_mocs.o \
 	gt/intel_sseu.o \
+	gt/intel_timeline.o \
 	gt/intel_workarounds.o
 gt-$(CONFIG_DRM_I915_SELFTEST) += \
 	gt/mock_engine.o
@@ -126,7 +127,6 @@ i915-y += \
 	  i915_query.o \
 	  i915_request.o \
 	  i915_scheduler.o \
-	  i915_timeline.o \
 	  i915_trace_points.o \
 	  i915_vma.o \
 	  intel_wopcm.o
diff --git a/drivers/gpu/drm/i915/Makefile.header-test b/drivers/gpu/drm/i915/Makefile.header-test
index 5a688c7603ea..1e4e402d5e51 100644
--- a/drivers/gpu/drm/i915/Makefile.header-test
+++ b/drivers/gpu/drm/i915/Makefile.header-test
@@ -12,7 +12,6 @@ header-test-$(CONFIG_DRM_I915_WERROR) := \
 	i915_priolist_types.h \
 	i915_reg.h \
 	i915_scheduler_types.h \
-	i915_timeline_types.h \
 	i915_utils.h \
 	intel_csr.h \
 	intel_drv.h \
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_context.c b/drivers/gpu/drm/i915/gem/i915_gem_context.c
index fb691535fbf2..628673d1d7f8 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_context.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_context.c
@@ -316,7 +316,7 @@ static void i915_gem_context_free(struct i915_gem_context *ctx)
 	mutex_destroy(&ctx->engines_mutex);
 
 	if (ctx->timeline)
-		i915_timeline_put(ctx->timeline);
+		intel_timeline_put(ctx->timeline);
 
 	kfree(ctx->name);
 	put_pid(ctx->pid);
@@ -528,9 +528,9 @@ i915_gem_create_context(struct drm_i915_private *dev_priv, unsigned int flags)
 	}
 
 	if (flags & I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE) {
-		struct i915_timeline *timeline;
+		struct intel_timeline *timeline;
 
-		timeline = i915_timeline_create(&dev_priv->gt, NULL);
+		timeline = intel_timeline_create(&dev_priv->gt, NULL);
 		if (IS_ERR(timeline)) {
 			context_close(ctx);
 			return ERR_CAST(timeline);
@@ -2015,8 +2015,8 @@ static int clone_timeline(struct i915_gem_context *dst,
 		GEM_BUG_ON(src->timeline == dst->timeline);
 
 		if (dst->timeline)
-			i915_timeline_put(dst->timeline);
-		dst->timeline = i915_timeline_get(src->timeline);
+			intel_timeline_put(dst->timeline);
+		dst->timeline = intel_timeline_get(src->timeline);
 	}
 
 	return 0;
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_context_types.h b/drivers/gpu/drm/i915/gem/i915_gem_context_types.h
index cc513410eeef..0ee61482ef94 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_context_types.h
+++ b/drivers/gpu/drm/i915/gem/i915_gem_context_types.h
@@ -26,7 +26,7 @@ struct pid;
 struct drm_i915_private;
 struct drm_i915_file_private;
 struct i915_address_space;
-struct i915_timeline;
+struct intel_timeline;
 struct intel_ring;
 
 struct i915_gem_engines {
@@ -77,7 +77,7 @@ struct i915_gem_context {
 	struct i915_gem_engines __rcu *engines;
 	struct mutex engines_mutex; /* guards writes to engines */
 
-	struct i915_timeline *timeline;
+	struct intel_timeline *timeline;
 
 	/**
 	 * @vm: unique address space (GTT)
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_pm.c b/drivers/gpu/drm/i915/gem/i915_gem_pm.c
index 914b5d4112bb..2b782117d799 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_pm.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_pm.c
@@ -38,7 +38,7 @@ static void i915_gem_park(struct drm_i915_private *i915)
 		i915_gem_batch_pool_fini(&engine->batch_pool);
 	}
 
-	i915_timelines_park(i915);
+	intel_timelines_park(i915);
 	i915_vma_parked(i915);
 
 	i915_globals_park();
diff --git a/drivers/gpu/drm/i915/gt/intel_engine.h b/drivers/gpu/drm/i915/gt/intel_engine.h
index 9bb6ff76680e..557b08b13feb 100644
--- a/drivers/gpu/drm/i915/gt/intel_engine.h
+++ b/drivers/gpu/drm/i915/gt/intel_engine.h
@@ -14,7 +14,7 @@
 #include "i915_reg.h"
 #include "i915_request.h"
 #include "i915_selftest.h"
-#include "i915_timeline.h"
+#include "gt/intel_timeline.h"
 #include "intel_engine_types.h"
 #include "intel_gpu_commands.h"
 #include "intel_workarounds.h"
@@ -200,7 +200,7 @@ intel_write_status_page(struct intel_engine_cs *engine, int reg, u32 value)
 
 struct intel_ring *
 intel_engine_create_ring(struct intel_engine_cs *engine,
-			 struct i915_timeline *timeline,
+			 struct intel_timeline *timeline,
 			 int size);
 int intel_ring_pin(struct intel_ring *ring);
 void intel_ring_reset(struct intel_ring *ring, u32 tail);
diff --git a/drivers/gpu/drm/i915/gt/intel_engine_cs.c b/drivers/gpu/drm/i915/gt/intel_engine_cs.c
index 372080b94b47..671dadda9d48 100644
--- a/drivers/gpu/drm/i915/gt/intel_engine_cs.c
+++ b/drivers/gpu/drm/i915/gt/intel_engine_cs.c
@@ -724,7 +724,7 @@ void intel_engines_set_scheduler_caps(struct drm_i915_private *i915)
 
 struct measure_breadcrumb {
 	struct i915_request rq;
-	struct i915_timeline timeline;
+	struct intel_timeline timeline;
 	struct intel_ring ring;
 	u32 cs[1024];
 };
@@ -740,9 +740,9 @@ static int measure_breadcrumb_dw(struct intel_engine_cs *engine)
 	if (!frame)
 		return -ENOMEM;
 
-	if (i915_timeline_init(&frame->timeline,
-			       engine->gt,
-			       engine->status_page.vma))
+	if (intel_timeline_init(&frame->timeline,
+				engine->gt,
+				engine->status_page.vma))
 		goto out_frame;
 
 	INIT_LIST_HEAD(&frame->ring.request_list);
@@ -757,17 +757,17 @@ static int measure_breadcrumb_dw(struct intel_engine_cs *engine)
 	frame->rq.ring = &frame->ring;
 	frame->rq.timeline = &frame->timeline;
 
-	dw = i915_timeline_pin(&frame->timeline);
+	dw = intel_timeline_pin(&frame->timeline);
 	if (dw < 0)
 		goto out_timeline;
 
 	dw = engine->emit_fini_breadcrumb(&frame->rq, frame->cs) - frame->cs;
 	GEM_BUG_ON(dw & 1); /* RING_TAIL must be qword aligned */
 
-	i915_timeline_unpin(&frame->timeline);
+	intel_timeline_unpin(&frame->timeline);
 
 out_timeline:
-	i915_timeline_fini(&frame->timeline);
+	intel_timeline_fini(&frame->timeline);
 out_frame:
 	kfree(frame);
 	return dw;
diff --git a/drivers/gpu/drm/i915/gt/intel_engine_types.h b/drivers/gpu/drm/i915/gt/intel_engine_types.h
index fb65e96fa36b..7e056114344e 100644
--- a/drivers/gpu/drm/i915/gt/intel_engine_types.h
+++ b/drivers/gpu/drm/i915/gt/intel_engine_types.h
@@ -20,7 +20,7 @@
 #include "i915_pmu.h"
 #include "i915_priolist_types.h"
 #include "i915_selftest.h"
-#include "i915_timeline_types.h"
+#include "gt/intel_timeline_types.h"
 #include "intel_sseu.h"
 #include "intel_wakeref.h"
 #include "intel_workarounds_types.h"
@@ -68,7 +68,7 @@ struct intel_ring {
 	struct i915_vma *vma;
 	void *vaddr;
 
-	struct i915_timeline *timeline;
+	struct intel_timeline *timeline;
 	struct list_head request_list;
 	struct list_head active_link;
 
diff --git a/drivers/gpu/drm/i915/gt/intel_lrc.c b/drivers/gpu/drm/i915/gt/intel_lrc.c
index 415fdf2eb997..3abcec3e4e0e 100644
--- a/drivers/gpu/drm/i915/gt/intel_lrc.c
+++ b/drivers/gpu/drm/i915/gt/intel_lrc.c
@@ -3005,13 +3005,13 @@ populate_lr_context(struct intel_context *ce,
 	return ret;
 }
 
-static struct i915_timeline *
+static struct intel_timeline *
 get_timeline(struct i915_gem_context *ctx, struct intel_gt *gt)
 {
 	if (ctx->timeline)
-		return i915_timeline_get(ctx->timeline);
+		return intel_timeline_get(ctx->timeline);
 	else
-		return i915_timeline_create(gt, NULL);
+		return intel_timeline_create(gt, NULL);
 }
 
 static int execlists_context_deferred_alloc(struct intel_context *ce,
@@ -3021,7 +3021,7 @@ static int execlists_context_deferred_alloc(struct intel_context *ce,
 	struct i915_vma *vma;
 	u32 context_size;
 	struct intel_ring *ring;
-	struct i915_timeline *timeline;
+	struct intel_timeline *timeline;
 	int ret;
 
 	if (ce->state)
@@ -3054,7 +3054,7 @@ static int execlists_context_deferred_alloc(struct intel_context *ce,
 	ring = intel_engine_create_ring(engine,
 					timeline,
 					ce->gem_context->ring_size);
-	i915_timeline_put(timeline);
+	intel_timeline_put(timeline);
 	if (IS_ERR(ring)) {
 		ret = PTR_ERR(ring);
 		goto error_deref_obj;
diff --git a/drivers/gpu/drm/i915/gt/intel_reset.c b/drivers/gpu/drm/i915/gt/intel_reset.c
index 983301bdc0a1..6f2668e13c63 100644
--- a/drivers/gpu/drm/i915/gt/intel_reset.c
+++ b/drivers/gpu/drm/i915/gt/intel_reset.c
@@ -858,7 +858,7 @@ void i915_gem_set_wedged(struct drm_i915_private *i915)
 static bool __i915_gem_unset_wedged(struct drm_i915_private *i915)
 {
 	struct i915_gpu_error *error = &i915->gpu_error;
-	struct i915_timeline *tl;
+	struct intel_timeline *tl;
 
 	if (!test_bit(I915_WEDGED, &error->flags))
 		return true;
diff --git a/drivers/gpu/drm/i915/gt/intel_ringbuffer.c b/drivers/gpu/drm/i915/gt/intel_ringbuffer.c
index 9a748be0ce0c..aa483bba04bf 100644
--- a/drivers/gpu/drm/i915/gt/intel_ringbuffer.c
+++ b/drivers/gpu/drm/i915/gt/intel_ringbuffer.c
@@ -1156,7 +1156,7 @@ int intel_ring_pin(struct intel_ring *ring)
 	if (atomic_fetch_inc(&ring->pin_count))
 		return 0;
 
-	ret = i915_timeline_pin(ring->timeline);
+	ret = intel_timeline_pin(ring->timeline);
 	if (ret)
 		goto err_unpin;
 
@@ -1194,7 +1194,7 @@ int intel_ring_pin(struct intel_ring *ring)
 err_ring:
 	i915_vma_unpin(vma);
 err_timeline:
-	i915_timeline_unpin(ring->timeline);
+	intel_timeline_unpin(ring->timeline);
 err_unpin:
 	atomic_dec(&ring->pin_count);
 	return ret;
@@ -1231,7 +1231,7 @@ void intel_ring_unpin(struct intel_ring *ring)
 	ring->vma->obj->pin_global--;
 	i915_vma_unpin(ring->vma);
 
-	i915_timeline_unpin(ring->timeline);
+	intel_timeline_unpin(ring->timeline);
 }
 
 static struct i915_vma *create_ring_vma(struct i915_ggtt *ggtt, int size)
@@ -1267,7 +1267,7 @@ static struct i915_vma *create_ring_vma(struct i915_ggtt *ggtt, int size)
 
 struct intel_ring *
 intel_engine_create_ring(struct intel_engine_cs *engine,
-			 struct i915_timeline *timeline,
+			 struct intel_timeline *timeline,
 			 int size)
 {
 	struct drm_i915_private *i915 = engine->i915;
@@ -1283,7 +1283,7 @@ intel_engine_create_ring(struct intel_engine_cs *engine,
 
 	kref_init(&ring->ref);
 	INIT_LIST_HEAD(&ring->request_list);
-	ring->timeline = i915_timeline_get(timeline);
+	ring->timeline = intel_timeline_get(timeline);
 
 	ring->size = size;
 	/* Workaround an erratum on the i830 which causes a hang if
@@ -1313,7 +1313,7 @@ void intel_ring_free(struct kref *ref)
 	i915_vma_close(ring->vma);
 	i915_vma_put(ring->vma);
 
-	i915_timeline_put(ring->timeline);
+	intel_timeline_put(ring->timeline);
 	kfree(ring);
 }
 
@@ -2269,11 +2269,11 @@ int intel_ring_submission_setup(struct intel_engine_cs *engine)
 
 int intel_ring_submission_init(struct intel_engine_cs *engine)
 {
-	struct i915_timeline *timeline;
+	struct intel_timeline *timeline;
 	struct intel_ring *ring;
 	int err;
 
-	timeline = i915_timeline_create(engine->gt, engine->status_page.vma);
+	timeline = intel_timeline_create(engine->gt, engine->status_page.vma);
 	if (IS_ERR(timeline)) {
 		err = PTR_ERR(timeline);
 		goto err;
@@ -2281,7 +2281,7 @@ int intel_ring_submission_init(struct intel_engine_cs *engine)
 	GEM_BUG_ON(timeline->has_initial_breadcrumb);
 
 	ring = intel_engine_create_ring(engine, timeline, 32 * PAGE_SIZE);
-	i915_timeline_put(timeline);
+	intel_timeline_put(timeline);
 	if (IS_ERR(ring)) {
 		err = PTR_ERR(ring);
 		goto err;
diff --git a/drivers/gpu/drm/i915/i915_timeline.c b/drivers/gpu/drm/i915/gt/intel_timeline.c
similarity index 82%
rename from drivers/gpu/drm/i915/i915_timeline.c
rename to drivers/gpu/drm/i915/gt/intel_timeline.c
index 3e2c3169dc69..1a3f04458730 100644
--- a/drivers/gpu/drm/i915/i915_timeline.c
+++ b/drivers/gpu/drm/i915/gt/intel_timeline.c
@@ -10,12 +10,12 @@
 
 #include "i915_active.h"
 #include "i915_syncmap.h"
-#include "i915_timeline.h"
+#include "gt/intel_timeline.h"
 
 #define ptr_set_bit(ptr, bit) ((typeof(ptr))((unsigned long)(ptr) | BIT(bit)))
 #define ptr_test_bit(ptr, bit) ((unsigned long)(ptr) & BIT(bit))
 
-struct i915_timeline_hwsp {
+struct intel_timeline_hwsp {
 	struct intel_gt *gt;
 	struct i915_gt_timelines *gt_timelines;
 	struct list_head free_link;
@@ -23,9 +23,9 @@ struct i915_timeline_hwsp {
 	u64 free_bitmap;
 };
 
-struct i915_timeline_cacheline {
+struct intel_timeline_cacheline {
 	struct i915_active active;
-	struct i915_timeline_hwsp *hwsp;
+	struct intel_timeline_hwsp *hwsp;
 	void *vaddr;
 #define CACHELINE_BITS 6
 #define CACHELINE_FREE CACHELINE_BITS
@@ -51,10 +51,10 @@ static struct i915_vma *__hwsp_alloc(struct intel_gt *gt)
 }
 
 static struct i915_vma *
-hwsp_alloc(struct i915_timeline *timeline, unsigned int *cacheline)
+hwsp_alloc(struct intel_timeline *timeline, unsigned int *cacheline)
 {
 	struct i915_gt_timelines *gt = &timeline->gt->timelines;
-	struct i915_timeline_hwsp *hwsp;
+	struct intel_timeline_hwsp *hwsp;
 
 	BUILD_BUG_ON(BITS_PER_TYPE(u64) * CACHELINE_BYTES > PAGE_SIZE);
 
@@ -100,7 +100,7 @@ hwsp_alloc(struct i915_timeline *timeline, unsigned int *cacheline)
 	return hwsp->vma;
 }
 
-static void __idle_hwsp_free(struct i915_timeline_hwsp *hwsp, int cacheline)
+static void __idle_hwsp_free(struct intel_timeline_hwsp *hwsp, int cacheline)
 {
 	struct i915_gt_timelines *gt = hwsp->gt_timelines;
 	unsigned long flags;
@@ -124,7 +124,7 @@ static void __idle_hwsp_free(struct i915_timeline_hwsp *hwsp, int cacheline)
 	spin_unlock_irqrestore(&gt->hwsp_lock, flags);
 }
 
-static void __idle_cacheline_free(struct i915_timeline_cacheline *cl)
+static void __idle_cacheline_free(struct intel_timeline_cacheline *cl)
 {
 	GEM_BUG_ON(!i915_active_is_idle(&cl->active));
 
@@ -138,7 +138,7 @@ static void __idle_cacheline_free(struct i915_timeline_cacheline *cl)
 
 static void __cacheline_retire(struct i915_active *active)
 {
-	struct i915_timeline_cacheline *cl =
+	struct intel_timeline_cacheline *cl =
 		container_of(active, typeof(*cl), active);
 
 	i915_vma_unpin(cl->hwsp->vma);
@@ -146,10 +146,10 @@ static void __cacheline_retire(struct i915_active *active)
 		__idle_cacheline_free(cl);
 }
 
-static struct i915_timeline_cacheline *
-cacheline_alloc(struct i915_timeline_hwsp *hwsp, unsigned int cacheline)
+static struct intel_timeline_cacheline *
+cacheline_alloc(struct intel_timeline_hwsp *hwsp, unsigned int cacheline)
 {
-	struct i915_timeline_cacheline *cl;
+	struct intel_timeline_cacheline *cl;
 	void *vaddr;
 
 	GEM_BUG_ON(cacheline >= BIT(CACHELINE_BITS));
@@ -173,19 +173,19 @@ cacheline_alloc(struct i915_timeline_hwsp *hwsp, unsigned int cacheline)
 	return cl;
 }
 
-static void cacheline_acquire(struct i915_timeline_cacheline *cl)
+static void cacheline_acquire(struct intel_timeline_cacheline *cl)
 {
 	if (cl && i915_active_acquire(&cl->active))
 		__i915_vma_pin(cl->hwsp->vma);
 }
 
-static void cacheline_release(struct i915_timeline_cacheline *cl)
+static void cacheline_release(struct intel_timeline_cacheline *cl)
 {
 	if (cl)
 		i915_active_release(&cl->active);
 }
 
-static void cacheline_free(struct i915_timeline_cacheline *cl)
+static void cacheline_free(struct intel_timeline_cacheline *cl)
 {
 	GEM_BUG_ON(ptr_test_bit(cl->vaddr, CACHELINE_FREE));
 	cl->vaddr = ptr_set_bit(cl->vaddr, CACHELINE_FREE);
@@ -194,9 +194,9 @@ static void cacheline_free(struct i915_timeline_cacheline *cl)
 		__idle_cacheline_free(cl);
 }
 
-int i915_timeline_init(struct i915_timeline *timeline,
-		       struct intel_gt *gt,
-		       struct i915_vma *hwsp)
+int intel_timeline_init(struct intel_timeline *timeline,
+			struct intel_gt *gt,
+			struct i915_vma *hwsp)
 {
 	void *vaddr;
 
@@ -216,7 +216,7 @@ int i915_timeline_init(struct i915_timeline *timeline,
 	timeline->hwsp_cacheline = NULL;
 
 	if (!hwsp) {
-		struct i915_timeline_cacheline *cl;
+		struct intel_timeline_cacheline *cl;
 		unsigned int cacheline;
 
 		hwsp = hwsp_alloc(timeline, &cacheline);
@@ -273,12 +273,12 @@ static void timelines_init(struct intel_gt *gt)
 	i915_gem_shrinker_taints_mutex(gt->i915, &timelines->mutex);
 }
 
-void i915_timelines_init(struct drm_i915_private *i915)
+void intel_timelines_init(struct drm_i915_private *i915)
 {
 	timelines_init(&i915->gt);
 }
 
-static void timeline_add_to_active(struct i915_timeline *tl)
+static void timeline_add_to_active(struct intel_timeline *tl)
 {
 	struct i915_gt_timelines *gt = &tl->gt->timelines;
 
@@ -287,7 +287,7 @@ static void timeline_add_to_active(struct i915_timeline *tl)
 	mutex_unlock(&gt->mutex);
 }
 
-static void timeline_remove_from_active(struct i915_timeline *tl)
+static void timeline_remove_from_active(struct intel_timeline *tl)
 {
 	struct i915_gt_timelines *gt = &tl->gt->timelines;
 
@@ -299,7 +299,7 @@ static void timeline_remove_from_active(struct i915_timeline *tl)
 static void timelines_park(struct intel_gt *gt)
 {
 	struct i915_gt_timelines *timelines = &gt->timelines;
-	struct i915_timeline *timeline;
+	struct intel_timeline *timeline;
 
 	mutex_lock(&timelines->mutex);
 	list_for_each_entry(timeline, &timelines->active_list, link) {
@@ -315,7 +315,7 @@ static void timelines_park(struct intel_gt *gt)
 }
 
 /**
- * i915_timelines_park - called when the driver idles
+ * intel_timelines_park - called when the driver idles
  * @i915: the drm_i915_private device
  *
  * When the driver is completely idle, we know that all of our sync points
@@ -324,12 +324,12 @@ static void timelines_park(struct intel_gt *gt)
  * the fence is signaled and therefore we will not even look them up in the
  * sync point map.
  */
-void i915_timelines_park(struct drm_i915_private *i915)
+void intel_timelines_park(struct drm_i915_private *i915)
 {
 	timelines_park(&i915->gt);
 }
 
-void i915_timeline_fini(struct i915_timeline *timeline)
+void intel_timeline_fini(struct intel_timeline *timeline)
 {
 	GEM_BUG_ON(timeline->pin_count);
 	GEM_BUG_ON(!list_empty(&timeline->requests));
@@ -344,17 +344,17 @@ void i915_timeline_fini(struct i915_timeline *timeline)
 	i915_vma_put(timeline->hwsp_ggtt);
 }
 
-struct i915_timeline *
-i915_timeline_create(struct intel_gt *gt, struct i915_vma *global_hwsp)
+struct intel_timeline *
+intel_timeline_create(struct intel_gt *gt, struct i915_vma *global_hwsp)
 {
-	struct i915_timeline *timeline;
+	struct intel_timeline *timeline;
 	int err;
 
 	timeline = kzalloc(sizeof(*timeline), GFP_KERNEL);
 	if (!timeline)
 		return ERR_PTR(-ENOMEM);
 
-	err = i915_timeline_init(timeline, gt, global_hwsp);
+	err = intel_timeline_init(timeline, gt, global_hwsp);
 	if (err) {
 		kfree(timeline);
 		return ERR_PTR(err);
@@ -365,7 +365,7 @@ i915_timeline_create(struct intel_gt *gt, struct i915_vma *global_hwsp)
 	return timeline;
 }
 
-int i915_timeline_pin(struct i915_timeline *tl)
+int intel_timeline_pin(struct intel_timeline *tl)
 {
 	int err;
 
@@ -391,7 +391,7 @@ int i915_timeline_pin(struct i915_timeline *tl)
 	return err;
 }
 
-static u32 timeline_advance(struct i915_timeline *tl)
+static u32 timeline_advance(struct intel_timeline *tl)
 {
 	GEM_BUG_ON(!tl->pin_count);
 	GEM_BUG_ON(tl->seqno & tl->has_initial_breadcrumb);
@@ -399,17 +399,17 @@ static u32 timeline_advance(struct i915_timeline *tl)
 	return tl->seqno += 1 + tl->has_initial_breadcrumb;
 }
 
-static void timeline_rollback(struct i915_timeline *tl)
+static void timeline_rollback(struct intel_timeline *tl)
 {
 	tl->seqno -= 1 + tl->has_initial_breadcrumb;
 }
 
 static noinline int
-__i915_timeline_get_seqno(struct i915_timeline *tl,
-			  struct i915_request *rq,
-			  u32 *seqno)
+__intel_timeline_get_seqno(struct intel_timeline *tl,
+			   struct i915_request *rq,
+			   u32 *seqno)
 {
-	struct i915_timeline_cacheline *cl;
+	struct intel_timeline_cacheline *cl;
 	unsigned int cacheline;
 	struct i915_vma *vma;
 	void *vaddr;
@@ -495,31 +495,31 @@ __i915_timeline_get_seqno(struct i915_timeline *tl,
 	return err;
 }
 
-int i915_timeline_get_seqno(struct i915_timeline *tl,
-			    struct i915_request *rq,
-			    u32 *seqno)
+int intel_timeline_get_seqno(struct intel_timeline *tl,
+			     struct i915_request *rq,
+			     u32 *seqno)
 {
 	*seqno = timeline_advance(tl);
 
 	/* Replace the HWSP on wraparound for HW semaphores */
 	if (unlikely(!*seqno && tl->hwsp_cacheline))
-		return __i915_timeline_get_seqno(tl, rq, seqno);
+		return __intel_timeline_get_seqno(tl, rq, seqno);
 
 	return 0;
 }
 
-static int cacheline_ref(struct i915_timeline_cacheline *cl,
+static int cacheline_ref(struct intel_timeline_cacheline *cl,
 			 struct i915_request *rq)
 {
 	return i915_active_ref(&cl->active, rq->fence.context, rq);
 }
 
-int i915_timeline_read_hwsp(struct i915_request *from,
-			    struct i915_request *to,
-			    u32 *hwsp)
+int intel_timeline_read_hwsp(struct i915_request *from,
+			     struct i915_request *to,
+			     u32 *hwsp)
 {
-	struct i915_timeline_cacheline *cl = from->hwsp_cacheline;
-	struct i915_timeline *tl = from->timeline;
+	struct intel_timeline_cacheline *cl = from->hwsp_cacheline;
+	struct intel_timeline *tl = from->timeline;
 	int err;
 
 	GEM_BUG_ON(to->timeline == tl);
@@ -542,7 +542,7 @@ int i915_timeline_read_hwsp(struct i915_request *from,
 	return err;
 }
 
-void i915_timeline_unpin(struct i915_timeline *tl)
+void intel_timeline_unpin(struct intel_timeline *tl)
 {
 	GEM_BUG_ON(!tl->pin_count);
 	if (--tl->pin_count)
@@ -561,12 +561,12 @@ void i915_timeline_unpin(struct i915_timeline *tl)
 	__i915_vma_unpin(tl->hwsp_ggtt);
 }
 
-void __i915_timeline_free(struct kref *kref)
+void __intel_timeline_free(struct kref *kref)
 {
-	struct i915_timeline *timeline =
+	struct intel_timeline *timeline =
 		container_of(kref, typeof(*timeline), kref);
 
-	i915_timeline_fini(timeline);
+	intel_timeline_fini(timeline);
 	kfree(timeline);
 }
 
@@ -580,12 +580,12 @@ static void timelines_fini(struct intel_gt *gt)
 	mutex_destroy(&timelines->mutex);
 }
 
-void i915_timelines_fini(struct drm_i915_private *i915)
+void intel_timelines_fini(struct drm_i915_private *i915)
 {
 	timelines_fini(&i915->gt);
 }
 
 #if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)
-#include "selftests/mock_timeline.c"
-#include "selftests/i915_timeline.c"
+#include "gt/selftests/mock_timeline.c"
+#include "gt/selftest_timeline.c"
 #endif
diff --git a/drivers/gpu/drm/i915/gt/intel_timeline.h b/drivers/gpu/drm/i915/gt/intel_timeline.h
new file mode 100644
index 000000000000..e08cebf64833
--- /dev/null
+++ b/drivers/gpu/drm/i915/gt/intel_timeline.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright © 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#ifndef I915_TIMELINE_H
+#define I915_TIMELINE_H
+
+#include <linux/lockdep.h>
+
+#include "i915_active.h"
+#include "i915_syncmap.h"
+#include "gt/intel_timeline_types.h"
+
+int intel_timeline_init(struct intel_timeline *tl,
+			struct intel_gt *gt,
+			struct i915_vma *hwsp);
+void intel_timeline_fini(struct intel_timeline *tl);
+
+struct intel_timeline *
+intel_timeline_create(struct intel_gt *gt, struct i915_vma *global_hwsp);
+
+static inline struct intel_timeline *
+intel_timeline_get(struct intel_timeline *timeline)
+{
+	kref_get(&timeline->kref);
+	return timeline;
+}
+
+void __intel_timeline_free(struct kref *kref);
+static inline void intel_timeline_put(struct intel_timeline *timeline)
+{
+	kref_put(&timeline->kref, __intel_timeline_free);
+}
+
+static inline int __intel_timeline_sync_set(struct intel_timeline *tl,
+					    u64 context, u32 seqno)
+{
+	return i915_syncmap_set(&tl->sync, context, seqno);
+}
+
+static inline int intel_timeline_sync_set(struct intel_timeline *tl,
+					  const struct dma_fence *fence)
+{
+	return __intel_timeline_sync_set(tl, fence->context, fence->seqno);
+}
+
+static inline bool __intel_timeline_sync_is_later(struct intel_timeline *tl,
+						  u64 context, u32 seqno)
+{
+	return i915_syncmap_is_later(&tl->sync, context, seqno);
+}
+
+static inline bool intel_timeline_sync_is_later(struct intel_timeline *tl,
+						const struct dma_fence *fence)
+{
+	return __intel_timeline_sync_is_later(tl, fence->context, fence->seqno);
+}
+
+int intel_timeline_pin(struct intel_timeline *tl);
+int intel_timeline_get_seqno(struct intel_timeline *tl,
+			     struct i915_request *rq,
+			     u32 *seqno);
+void intel_timeline_unpin(struct intel_timeline *tl);
+
+int intel_timeline_read_hwsp(struct i915_request *from,
+			     struct i915_request *until,
+			     u32 *hwsp_offset);
+
+void intel_timelines_init(struct drm_i915_private *i915);
+void intel_timelines_park(struct drm_i915_private *i915);
+void intel_timelines_fini(struct drm_i915_private *i915);
+
+#endif
diff --git a/drivers/gpu/drm/i915/i915_timeline_types.h b/drivers/gpu/drm/i915/gt/intel_timeline_types.h
similarity index 93%
rename from drivers/gpu/drm/i915/i915_timeline_types.h
rename to drivers/gpu/drm/i915/gt/intel_timeline_types.h
index 931585e12d41..9a71aea7a338 100644
--- a/drivers/gpu/drm/i915/i915_timeline_types.h
+++ b/drivers/gpu/drm/i915/gt/intel_timeline_types.h
@@ -16,10 +16,10 @@
 
 struct drm_i915_private;
 struct i915_vma;
-struct i915_timeline_cacheline;
+struct intel_timeline_cacheline;
 struct i915_syncmap;
 
-struct i915_timeline {
+struct intel_timeline {
 	u64 fence_context;
 	u32 seqno;
 
@@ -30,7 +30,7 @@ struct i915_timeline {
 	struct i915_vma *hwsp_ggtt;
 	u32 hwsp_offset;
 
-	struct i915_timeline_cacheline *hwsp_cacheline;
+	struct intel_timeline_cacheline *hwsp_cacheline;
 
 	bool has_initial_breadcrumb;
 
diff --git a/drivers/gpu/drm/i915/gt/mock_engine.c b/drivers/gpu/drm/i915/gt/mock_engine.c
index 423027aa71cd..bf0974b12f3d 100644
--- a/drivers/gpu/drm/i915/gt/mock_engine.c
+++ b/drivers/gpu/drm/i915/gt/mock_engine.c
@@ -33,15 +33,15 @@
 
 struct mock_ring {
 	struct intel_ring base;
-	struct i915_timeline timeline;
+	struct intel_timeline timeline;
 };
 
-static void mock_timeline_pin(struct i915_timeline *tl)
+static void mock_timeline_pin(struct intel_timeline *tl)
 {
 	tl->pin_count++;
 }
 
-static void mock_timeline_unpin(struct i915_timeline *tl)
+static void mock_timeline_unpin(struct intel_timeline *tl)
 {
 	GEM_BUG_ON(!tl->pin_count);
 	tl->pin_count--;
@@ -56,7 +56,7 @@ static struct intel_ring *mock_ring(struct intel_engine_cs *engine)
 	if (!ring)
 		return NULL;
 
-	if (i915_timeline_init(&ring->timeline, engine->gt, NULL)) {
+	if (intel_timeline_init(&ring->timeline, engine->gt, NULL)) {
 		kfree(ring);
 		return NULL;
 	}
@@ -78,7 +78,7 @@ static void mock_ring_free(struct intel_ring *base)
 {
 	struct mock_ring *ring = container_of(base, typeof(*ring), base);
 
-	i915_timeline_fini(&ring->timeline);
+	intel_timeline_fini(&ring->timeline);
 	kfree(ring);
 }
 
diff --git a/drivers/gpu/drm/i915/selftests/i915_timeline.c b/drivers/gpu/drm/i915/gt/selftest_timeline.c
similarity index 87%
rename from drivers/gpu/drm/i915/selftests/i915_timeline.c
rename to drivers/gpu/drm/i915/gt/selftest_timeline.c
index 44d031446f08..193cc564ade2 100644
--- a/drivers/gpu/drm/i915/selftests/i915_timeline.c
+++ b/drivers/gpu/drm/i915/gt/selftest_timeline.c
@@ -8,14 +8,14 @@
 
 #include "gem/i915_gem_pm.h"
 
-#include "i915_random.h"
-#include "i915_selftest.h"
+#include "../selftests/i915_random.h"
+#include "../i915_selftest.h"
 
-#include "igt_flush_test.h"
-#include "mock_gem_device.h"
-#include "mock_timeline.h"
+#include "../selftests/igt_flush_test.h"
+#include "../selftests/mock_gem_device.h"
+#include "selftests/mock_timeline.h"
 
-static struct page *hwsp_page(struct i915_timeline *tl)
+static struct page *hwsp_page(struct intel_timeline *tl)
 {
 	struct drm_i915_gem_object *obj = tl->hwsp_ggtt->obj;
 
@@ -23,7 +23,7 @@ static struct page *hwsp_page(struct i915_timeline *tl)
 	return sg_page(obj->mm.pages->sgl);
 }
 
-static unsigned long hwsp_cacheline(struct i915_timeline *tl)
+static unsigned long hwsp_cacheline(struct intel_timeline *tl)
 {
 	unsigned long address = (unsigned long)page_address(hwsp_page(tl));
 
@@ -35,7 +35,7 @@ static unsigned long hwsp_cacheline(struct i915_timeline *tl)
 struct mock_hwsp_freelist {
 	struct drm_i915_private *i915;
 	struct radix_tree_root cachelines;
-	struct i915_timeline **history;
+	struct intel_timeline **history;
 	unsigned long count, max;
 	struct rnd_state prng;
 };
@@ -46,12 +46,12 @@ enum {
 
 static void __mock_hwsp_record(struct mock_hwsp_freelist *state,
 			       unsigned int idx,
-			       struct i915_timeline *tl)
+			       struct intel_timeline *tl)
 {
 	tl = xchg(&state->history[idx], tl);
 	if (tl) {
 		radix_tree_delete(&state->cachelines, hwsp_cacheline(tl));
-		i915_timeline_put(tl);
+		intel_timeline_put(tl);
 	}
 }
 
@@ -59,14 +59,14 @@ static int __mock_hwsp_timeline(struct mock_hwsp_freelist *state,
 				unsigned int count,
 				unsigned int flags)
 {
-	struct i915_timeline *tl;
+	struct intel_timeline *tl;
 	unsigned int idx;
 
 	while (count--) {
 		unsigned long cacheline;
 		int err;
 
-		tl = i915_timeline_create(&state->i915->gt, NULL);
+		tl = intel_timeline_create(&state->i915->gt, NULL);
 		if (IS_ERR(tl))
 			return PTR_ERR(tl);
 
@@ -77,7 +77,7 @@ static int __mock_hwsp_timeline(struct mock_hwsp_freelist *state,
 				pr_err("HWSP cacheline %lu already used; duplicate allocation!\n",
 				       cacheline);
 			}
-			i915_timeline_put(tl);
+			intel_timeline_put(tl);
 			return err;
 		}
 
@@ -162,21 +162,21 @@ struct __igt_sync {
 	bool set;
 };
 
-static int __igt_sync(struct i915_timeline *tl,
+static int __igt_sync(struct intel_timeline *tl,
 		      u64 ctx,
 		      const struct __igt_sync *p,
 		      const char *name)
 {
 	int ret;
 
-	if (__i915_timeline_sync_is_later(tl, ctx, p->seqno) != p->expected) {
+	if (__intel_timeline_sync_is_later(tl, ctx, p->seqno) != p->expected) {
 		pr_err("%s: %s(ctx=%llu, seqno=%u) expected passed %s but failed\n",
 		       name, p->name, ctx, p->seqno, yesno(p->expected));
 		return -EINVAL;
 	}
 
 	if (p->set) {
-		ret = __i915_timeline_sync_set(tl, ctx, p->seqno);
+		ret = __intel_timeline_sync_set(tl, ctx, p->seqno);
 		if (ret)
 			return ret;
 	}
@@ -204,7 +204,7 @@ static int igt_sync(void *arg)
 		{ "unwrap", UINT_MAX, true, false },
 		{},
 	}, *p;
-	struct i915_timeline tl;
+	struct intel_timeline tl;
 	int order, offset;
 	int ret = -ENODEV;
 
@@ -248,7 +248,7 @@ static unsigned int random_engine(struct rnd_state *rnd)
 static int bench_sync(void *arg)
 {
 	struct rnd_state prng;
-	struct i915_timeline tl;
+	struct intel_timeline tl;
 	unsigned long end_time, count;
 	u64 prng32_1M;
 	ktime_t kt;
@@ -286,7 +286,7 @@ static int bench_sync(void *arg)
 	do {
 		u64 id = i915_prandom_u64_state(&prng);
 
-		__i915_timeline_sync_set(&tl, id, 0);
+		__intel_timeline_sync_set(&tl, id, 0);
 		count++;
 	} while (!time_after(jiffies, end_time));
 	kt = ktime_sub(ktime_get(), kt);
@@ -301,7 +301,7 @@ static int bench_sync(void *arg)
 	while (end_time--) {
 		u64 id = i915_prandom_u64_state(&prng);
 
-		if (!__i915_timeline_sync_is_later(&tl, id, 0)) {
+		if (!__intel_timeline_sync_is_later(&tl, id, 0)) {
 			mock_timeline_fini(&tl);
 			pr_err("Lookup of %llu failed\n", id);
 			return -EINVAL;
@@ -322,7 +322,7 @@ static int bench_sync(void *arg)
 	kt = ktime_get();
 	end_time = jiffies + HZ/10;
 	do {
-		__i915_timeline_sync_set(&tl, count++, 0);
+		__intel_timeline_sync_set(&tl, count++, 0);
 	} while (!time_after(jiffies, end_time));
 	kt = ktime_sub(ktime_get(), kt);
 	pr_info("%s: %lu in-order insertions, %lluns/insert\n",
@@ -332,7 +332,7 @@ static int bench_sync(void *arg)
 	end_time = count;
 	kt = ktime_get();
 	while (end_time--) {
-		if (!__i915_timeline_sync_is_later(&tl, end_time, 0)) {
+		if (!__intel_timeline_sync_is_later(&tl, end_time, 0)) {
 			pr_err("Lookup of %lu failed\n", end_time);
 			mock_timeline_fini(&tl);
 			return -EINVAL;
@@ -356,8 +356,8 @@ static int bench_sync(void *arg)
 		u32 id = random_engine(&prng);
 		u32 seqno = prandom_u32_state(&prng);
 
-		if (!__i915_timeline_sync_is_later(&tl, id, seqno))
-			__i915_timeline_sync_set(&tl, id, seqno);
+		if (!__intel_timeline_sync_is_later(&tl, id, seqno))
+			__intel_timeline_sync_set(&tl, id, seqno);
 
 		count++;
 	} while (!time_after(jiffies, end_time));
@@ -385,8 +385,8 @@ static int bench_sync(void *arg)
 			 */
 			u64 id = (u64)(count & mask) << order;
 
-			__i915_timeline_sync_is_later(&tl, id, 0);
-			__i915_timeline_sync_set(&tl, id, 0);
+			__intel_timeline_sync_is_later(&tl, id, 0);
+			__intel_timeline_sync_set(&tl, id, 0);
 
 			count++;
 		} while (!time_after(jiffies, end_time));
@@ -401,7 +401,7 @@ static int bench_sync(void *arg)
 	return 0;
 }
 
-int i915_timeline_mock_selftests(void)
+int intel_timeline_mock_selftests(void)
 {
 	static const struct i915_subtest tests[] = {
 		SUBTEST(mock_hwsp_freelist),
@@ -443,14 +443,14 @@ static int emit_ggtt_store_dw(struct i915_request *rq, u32 addr, u32 value)
 }
 
 static struct i915_request *
-tl_write(struct i915_timeline *tl, struct intel_engine_cs *engine, u32 value)
+tl_write(struct intel_timeline *tl, struct intel_engine_cs *engine, u32 value)
 {
 	struct i915_request *rq;
 	int err;
 
 	lockdep_assert_held(&tl->gt->i915->drm.struct_mutex); /* lazy rq refs */
 
-	err = i915_timeline_pin(tl);
+	err = intel_timeline_pin(tl);
 	if (err) {
 		rq = ERR_PTR(err);
 		goto out;
@@ -466,26 +466,26 @@ tl_write(struct i915_timeline *tl, struct intel_engine_cs *engine, u32 value)
 		rq = ERR_PTR(err);
 
 out_unpin:
-	i915_timeline_unpin(tl);
+	intel_timeline_unpin(tl);
 out:
 	if (IS_ERR(rq))
 		pr_err("Failed to write to timeline!\n");
 	return rq;
 }
 
-static struct i915_timeline *
-checked_i915_timeline_create(struct drm_i915_private *i915)
+static struct intel_timeline *
+checked_intel_timeline_create(struct drm_i915_private *i915)
 {
-	struct i915_timeline *tl;
+	struct intel_timeline *tl;
 
-	tl = i915_timeline_create(&i915->gt, NULL);
+	tl = intel_timeline_create(&i915->gt, NULL);
 	if (IS_ERR(tl))
 		return tl;
 
 	if (*tl->hwsp_seqno != tl->seqno) {
 		pr_err("Timeline created with incorrect breadcrumb, found %x, expected %x\n",
 		       *tl->hwsp_seqno, tl->seqno);
-		i915_timeline_put(tl);
+		intel_timeline_put(tl);
 		return ERR_PTR(-EINVAL);
 	}
 
@@ -496,7 +496,7 @@ static int live_hwsp_engine(void *arg)
 {
 #define NUM_TIMELINES 4096
 	struct drm_i915_private *i915 = arg;
-	struct i915_timeline **timelines;
+	struct intel_timeline **timelines;
 	struct intel_engine_cs *engine;
 	enum intel_engine_id id;
 	intel_wakeref_t wakeref;
@@ -523,10 +523,10 @@ static int live_hwsp_engine(void *arg)
 			continue;
 
 		for (n = 0; n < NUM_TIMELINES; n++) {
-			struct i915_timeline *tl;
+			struct intel_timeline *tl;
 			struct i915_request *rq;
 
-			tl = checked_i915_timeline_create(i915);
+			tl = checked_intel_timeline_create(i915);
 			if (IS_ERR(tl)) {
 				err = PTR_ERR(tl);
 				goto out;
@@ -534,7 +534,7 @@ static int live_hwsp_engine(void *arg)
 
 			rq = tl_write(tl, engine, count);
 			if (IS_ERR(rq)) {
-				i915_timeline_put(tl);
+				intel_timeline_put(tl);
 				err = PTR_ERR(rq);
 				goto out;
 			}
@@ -548,14 +548,14 @@ static int live_hwsp_engine(void *arg)
 		err = -EIO;
 
 	for (n = 0; n < count; n++) {
-		struct i915_timeline *tl = timelines[n];
+		struct intel_timeline *tl = timelines[n];
 
 		if (!err && *tl->hwsp_seqno != n) {
 			pr_err("Invalid seqno stored in timeline %lu, found 0x%x\n",
 			       n, *tl->hwsp_seqno);
 			err = -EINVAL;
 		}
-		i915_timeline_put(tl);
+		intel_timeline_put(tl);
 	}
 
 	intel_runtime_pm_put(&i915->runtime_pm, wakeref);
@@ -571,7 +571,7 @@ static int live_hwsp_alternate(void *arg)
 {
 #define NUM_TIMELINES 4096
 	struct drm_i915_private *i915 = arg;
-	struct i915_timeline **timelines;
+	struct intel_timeline **timelines;
 	struct intel_engine_cs *engine;
 	enum intel_engine_id id;
 	intel_wakeref_t wakeref;
@@ -596,13 +596,13 @@ static int live_hwsp_alternate(void *arg)
 	count = 0;
 	for (n = 0; n < NUM_TIMELINES; n++) {
 		for_each_engine(engine, i915, id) {
-			struct i915_timeline *tl;
+			struct intel_timeline *tl;
 			struct i915_request *rq;
 
 			if (!intel_engine_can_store_dword(engine))
 				continue;
 
-			tl = checked_i915_timeline_create(i915);
+			tl = checked_intel_timeline_create(i915);
 			if (IS_ERR(tl)) {
 				err = PTR_ERR(tl);
 				goto out;
@@ -610,7 +610,7 @@ static int live_hwsp_alternate(void *arg)
 
 			rq = tl_write(tl, engine, count);
 			if (IS_ERR(rq)) {
-				i915_timeline_put(tl);
+				intel_timeline_put(tl);
 				err = PTR_ERR(rq);
 				goto out;
 			}
@@ -624,14 +624,14 @@ static int live_hwsp_alternate(void *arg)
 		err = -EIO;
 
 	for (n = 0; n < count; n++) {
-		struct i915_timeline *tl = timelines[n];
+		struct intel_timeline *tl = timelines[n];
 
 		if (!err && *tl->hwsp_seqno != n) {
 			pr_err("Invalid seqno stored in timeline %lu, found 0x%x\n",
 			       n, *tl->hwsp_seqno);
 			err = -EINVAL;
 		}
-		i915_timeline_put(tl);
+		intel_timeline_put(tl);
 	}
 
 	intel_runtime_pm_put(&i915->runtime_pm, wakeref);
@@ -647,7 +647,7 @@ static int live_hwsp_wrap(void *arg)
 {
 	struct drm_i915_private *i915 = arg;
 	struct intel_engine_cs *engine;
-	struct i915_timeline *tl;
+	struct intel_timeline *tl;
 	enum intel_engine_id id;
 	intel_wakeref_t wakeref;
 	int err = 0;
@@ -660,7 +660,7 @@ static int live_hwsp_wrap(void *arg)
 	mutex_lock(&i915->drm.struct_mutex);
 	wakeref = intel_runtime_pm_get(&i915->runtime_pm);
 
-	tl = i915_timeline_create(&i915->gt, NULL);
+	tl = intel_timeline_create(&i915->gt, NULL);
 	if (IS_ERR(tl)) {
 		err = PTR_ERR(tl);
 		goto out_rpm;
@@ -668,7 +668,7 @@ static int live_hwsp_wrap(void *arg)
 	if (!tl->has_initial_breadcrumb || !tl->hwsp_cacheline)
 		goto out_free;
 
-	err = i915_timeline_pin(tl);
+	err = intel_timeline_pin(tl);
 	if (err)
 		goto out_free;
 
@@ -688,7 +688,7 @@ static int live_hwsp_wrap(void *arg)
 
 		tl->seqno = -4u;
 
-		err = i915_timeline_get_seqno(tl, rq, &seqno[0]);
+		err = intel_timeline_get_seqno(tl, rq, &seqno[0]);
 		if (err) {
 			i915_request_add(rq);
 			goto out;
@@ -703,7 +703,7 @@ static int live_hwsp_wrap(void *arg)
 		}
 		hwsp_seqno[0] = tl->hwsp_seqno;
 
-		err = i915_timeline_get_seqno(tl, rq, &seqno[1]);
+		err = intel_timeline_get_seqno(tl, rq, &seqno[1]);
 		if (err) {
 			i915_request_add(rq);
 			goto out;
@@ -745,9 +745,9 @@ static int live_hwsp_wrap(void *arg)
 	if (igt_flush_test(i915, I915_WAIT_LOCKED))
 		err = -EIO;
 
-	i915_timeline_unpin(tl);
+	intel_timeline_unpin(tl);
 out_free:
-	i915_timeline_put(tl);
+	intel_timeline_put(tl);
 out_rpm:
 	intel_runtime_pm_put(&i915->runtime_pm, wakeref);
 	mutex_unlock(&i915->drm.struct_mutex);
@@ -781,10 +781,10 @@ static int live_hwsp_recycle(void *arg)
 			continue;
 
 		do {
-			struct i915_timeline *tl;
+			struct intel_timeline *tl;
 			struct i915_request *rq;
 
-			tl = checked_i915_timeline_create(i915);
+			tl = checked_intel_timeline_create(i915);
 			if (IS_ERR(tl)) {
 				err = PTR_ERR(tl);
 				goto out;
@@ -792,14 +792,14 @@ static int live_hwsp_recycle(void *arg)
 
 			rq = tl_write(tl, engine, count);
 			if (IS_ERR(rq)) {
-				i915_timeline_put(tl);
+				intel_timeline_put(tl);
 				err = PTR_ERR(rq);
 				goto out;
 			}
 
 			if (i915_request_wait(rq, 0, HZ / 5) < 0) {
 				pr_err("Wait for timeline writes timed out!\n");
-				i915_timeline_put(tl);
+				intel_timeline_put(tl);
 				err = -EIO;
 				goto out;
 			}
@@ -810,13 +810,13 @@ static int live_hwsp_recycle(void *arg)
 				err = -EINVAL;
 			}
 
-			i915_timeline_put(tl);
+			intel_timeline_put(tl);
 			count++;
 
 			if (err)
 				goto out;
 
-			i915_timelines_park(i915); /* Encourage recycling! */
+			intel_timelines_park(i915); /* Encourage recycling! */
 		} while (!__igt_timeout(end_time, NULL));
 	}
 
@@ -829,7 +829,7 @@ static int live_hwsp_recycle(void *arg)
 	return err;
 }
 
-int i915_timeline_live_selftests(struct drm_i915_private *i915)
+int intel_timeline_live_selftests(struct drm_i915_private *i915)
 {
 	static const struct i915_subtest tests[] = {
 		SUBTEST(live_hwsp_recycle),
diff --git a/drivers/gpu/drm/i915/selftests/mock_timeline.c b/drivers/gpu/drm/i915/gt/selftests/mock_timeline.c
similarity index 72%
rename from drivers/gpu/drm/i915/selftests/mock_timeline.c
rename to drivers/gpu/drm/i915/gt/selftests/mock_timeline.c
index c80ac0fbdd3b..5c549205828a 100644
--- a/drivers/gpu/drm/i915/selftests/mock_timeline.c
+++ b/drivers/gpu/drm/i915/gt/selftests/mock_timeline.c
@@ -4,11 +4,11 @@
  * Copyright © 2017-2018 Intel Corporation
  */
 
-#include "../i915_timeline.h"
+#include "../intel_timeline.h"
 
 #include "mock_timeline.h"
 
-void mock_timeline_init(struct i915_timeline *timeline, u64 context)
+void mock_timeline_init(struct intel_timeline *timeline, u64 context)
 {
 	timeline->gt = NULL;
 	timeline->fence_context = context;
@@ -23,7 +23,7 @@ void mock_timeline_init(struct i915_timeline *timeline, u64 context)
 	INIT_LIST_HEAD(&timeline->link);
 }
 
-void mock_timeline_fini(struct i915_timeline *timeline)
+void mock_timeline_fini(struct intel_timeline *timeline)
 {
 	i915_syncmap_free(&timeline->sync);
 }
diff --git a/drivers/gpu/drm/i915/selftests/mock_timeline.h b/drivers/gpu/drm/i915/gt/selftests/mock_timeline.h
similarity index 53%
rename from drivers/gpu/drm/i915/selftests/mock_timeline.h
rename to drivers/gpu/drm/i915/gt/selftests/mock_timeline.h
index b6deaa61110d..689efc66c908 100644
--- a/drivers/gpu/drm/i915/selftests/mock_timeline.h
+++ b/drivers/gpu/drm/i915/gt/selftests/mock_timeline.h
@@ -7,9 +7,9 @@
 #ifndef __MOCK_TIMELINE__
 #define __MOCK_TIMELINE__
 
-struct i915_timeline;
+struct intel_timeline;
 
-void mock_timeline_init(struct i915_timeline *timeline, u64 context);
-void mock_timeline_fini(struct i915_timeline *timeline);
+void mock_timeline_init(struct intel_timeline *timeline, u64 context);
+void mock_timeline_fini(struct intel_timeline *timeline);
 
 #endif /* !__MOCK_TIMELINE__ */
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 30abf36263f6..fcb26973194e 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -89,7 +89,7 @@
 #include "i915_gpu_error.h"
 #include "i915_request.h"
 #include "i915_scheduler.h"
-#include "i915_timeline.h"
+#include "gt/intel_timeline.h"
 #include "i915_vma.h"
 
 #include "intel_gvt.h"
diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index 895977e0bd34..da3673f7a429 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -909,7 +909,7 @@ wait_for_timelines(struct drm_i915_private *i915,
 		   unsigned int flags, long timeout)
 {
 	struct i915_gt_timelines *gt = &i915->gt.timelines;
-	struct i915_timeline *tl;
+	struct intel_timeline *tl;
 
 	mutex_lock(&gt->mutex);
 	list_for_each_entry(tl, &gt->active_list, link) {
@@ -1487,7 +1487,7 @@ int i915_gem_init(struct drm_i915_private *dev_priv)
 
 	dev_priv->mm.unordered_timeline = dma_fence_context_alloc(1);
 
-	i915_timelines_init(dev_priv);
+	intel_timelines_init(dev_priv);
 
 	ret = i915_gem_init_userptr(dev_priv);
 	if (ret)
@@ -1630,7 +1630,7 @@ int i915_gem_init(struct drm_i915_private *dev_priv)
 
 	if (ret != -EIO) {
 		i915_gem_cleanup_userptr(dev_priv);
-		i915_timelines_fini(dev_priv);
+		intel_timelines_fini(dev_priv);
 	}
 
 	if (ret == -EIO) {
@@ -1694,7 +1694,7 @@ void i915_gem_fini(struct drm_i915_private *dev_priv)
 
 	intel_uc_fini_misc(dev_priv);
 	i915_gem_cleanup_userptr(dev_priv);
-	i915_timelines_fini(dev_priv);
+	intel_timelines_fini(dev_priv);
 
 	i915_gem_drain_freed_objects(dev_priv);
 
diff --git a/drivers/gpu/drm/i915/i915_gem_gtt.h b/drivers/gpu/drm/i915/i915_gem_gtt.h
index e8b9ebe50c4e..028be3b44d07 100644
--- a/drivers/gpu/drm/i915/i915_gem_gtt.h
+++ b/drivers/gpu/drm/i915/i915_gem_gtt.h
@@ -47,7 +47,7 @@
 #include "i915_request.h"
 #include "i915_scatterlist.h"
 #include "i915_selftest.h"
-#include "i915_timeline.h"
+#include "gt/intel_timeline.h"
 
 #define I915_GTT_PAGE_SIZE_4K	BIT_ULL(12)
 #define I915_GTT_PAGE_SIZE_64K	BIT_ULL(16)
diff --git a/drivers/gpu/drm/i915/i915_request.c b/drivers/gpu/drm/i915/i915_request.c
index 0c99694faab7..5ff87c4a0cd5 100644
--- a/drivers/gpu/drm/i915/i915_request.c
+++ b/drivers/gpu/drm/i915/i915_request.c
@@ -607,7 +607,7 @@ request_alloc_slow(struct intel_context *ce, gfp_t gfp)
 struct i915_request *
 __i915_request_create(struct intel_context *ce, gfp_t gfp)
 {
-	struct i915_timeline *tl = ce->ring->timeline;
+	struct intel_timeline *tl = ce->ring->timeline;
 	struct i915_request *rq;
 	u32 seqno;
 	int ret;
@@ -656,7 +656,7 @@ __i915_request_create(struct intel_context *ce, gfp_t gfp)
 		}
 	}
 
-	ret = i915_timeline_get_seqno(tl, rq, &seqno);
+	ret = intel_timeline_get_seqno(tl, rq, &seqno);
 	if (ret)
 		goto err_free;
 
@@ -775,7 +775,7 @@ i915_request_await_start(struct i915_request *rq, struct i915_request *signal)
 		return 0;
 
 	signal = list_prev_entry(signal, ring_link);
-	if (i915_timeline_sync_is_later(rq->timeline, &signal->fence))
+	if (intel_timeline_sync_is_later(rq->timeline, &signal->fence))
 		return 0;
 
 	return i915_sw_fence_await_dma_fence(&rq->submit,
@@ -829,7 +829,7 @@ emit_semaphore_wait(struct i915_request *to,
 		return err;
 
 	/* We need to pin the signaler's HWSP until we are finished reading. */
-	err = i915_timeline_read_hwsp(from, to, &hwsp_offset);
+	err = intel_timeline_read_hwsp(from, to, &hwsp_offset);
 	if (err)
 		return err;
 
@@ -940,7 +940,7 @@ i915_request_await_dma_fence(struct i915_request *rq, struct dma_fence *fence)
 
 		/* Squash repeated waits to the same timelines */
 		if (fence->context != rq->i915->mm.unordered_timeline &&
-		    i915_timeline_sync_is_later(rq->timeline, fence))
+		    intel_timeline_sync_is_later(rq->timeline, fence))
 			continue;
 
 		if (dma_fence_is_i915(fence))
@@ -954,7 +954,7 @@ i915_request_await_dma_fence(struct i915_request *rq, struct dma_fence *fence)
 
 		/* Record the latest fence used against each timeline */
 		if (fence->context != rq->i915->mm.unordered_timeline)
-			i915_timeline_sync_set(rq->timeline, fence);
+			intel_timeline_sync_set(rq->timeline, fence);
 	} while (--nchild);
 
 	return 0;
@@ -1092,7 +1092,7 @@ void i915_request_skip(struct i915_request *rq, int error)
 static struct i915_request *
 __i915_request_add_to_timeline(struct i915_request *rq)
 {
-	struct i915_timeline *timeline = rq->timeline;
+	struct intel_timeline *timeline = rq->timeline;
 	struct i915_request *prev;
 
 	/*
diff --git a/drivers/gpu/drm/i915/i915_request.h b/drivers/gpu/drm/i915/i915_request.h
index bebc1e9b4a5e..b58ceef92e20 100644
--- a/drivers/gpu/drm/i915/i915_request.h
+++ b/drivers/gpu/drm/i915/i915_request.h
@@ -41,8 +41,8 @@
 struct drm_file;
 struct drm_i915_gem_object;
 struct i915_request;
-struct i915_timeline;
-struct i915_timeline_cacheline;
+struct intel_timeline;
+struct intel_timeline_cacheline;
 
 struct i915_capture_list {
 	struct i915_capture_list *next;
@@ -113,7 +113,7 @@ struct i915_request {
 	struct intel_engine_cs *engine;
 	struct intel_context *hw_context;
 	struct intel_ring *ring;
-	struct i915_timeline *timeline;
+	struct intel_timeline *timeline;
 	struct list_head signal_link;
 
 	/*
@@ -176,7 +176,7 @@ struct i915_request {
 	 * inside the timeline's HWSP vma, but it is only valid while this
 	 * request has not completed and guarded by the timeline mutex.
 	 */
-	struct i915_timeline_cacheline *hwsp_cacheline;
+	struct intel_timeline_cacheline *hwsp_cacheline;
 
 	/** Position in the ring of the start of the request */
 	u32 head;
diff --git a/drivers/gpu/drm/i915/i915_timeline.h b/drivers/gpu/drm/i915/i915_timeline.h
deleted file mode 100644
index a454d49f229f..000000000000
--- a/drivers/gpu/drm/i915/i915_timeline.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright © 2016 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- *
- */
-
-#ifndef I915_TIMELINE_H
-#define I915_TIMELINE_H
-
-#include <linux/lockdep.h>
-
-#include "i915_active.h"
-#include "i915_syncmap.h"
-#include "i915_timeline_types.h"
-
-int i915_timeline_init(struct i915_timeline *tl,
-		       struct intel_gt *gt,
-		       struct i915_vma *hwsp);
-void i915_timeline_fini(struct i915_timeline *tl);
-
-struct i915_timeline *
-i915_timeline_create(struct intel_gt *gt, struct i915_vma *global_hwsp);
-
-static inline struct i915_timeline *
-i915_timeline_get(struct i915_timeline *timeline)
-{
-	kref_get(&timeline->kref);
-	return timeline;
-}
-
-void __i915_timeline_free(struct kref *kref);
-static inline void i915_timeline_put(struct i915_timeline *timeline)
-{
-	kref_put(&timeline->kref, __i915_timeline_free);
-}
-
-static inline int __i915_timeline_sync_set(struct i915_timeline *tl,
-					   u64 context, u32 seqno)
-{
-	return i915_syncmap_set(&tl->sync, context, seqno);
-}
-
-static inline int i915_timeline_sync_set(struct i915_timeline *tl,
-					 const struct dma_fence *fence)
-{
-	return __i915_timeline_sync_set(tl, fence->context, fence->seqno);
-}
-
-static inline bool __i915_timeline_sync_is_later(struct i915_timeline *tl,
-						 u64 context, u32 seqno)
-{
-	return i915_syncmap_is_later(&tl->sync, context, seqno);
-}
-
-static inline bool i915_timeline_sync_is_later(struct i915_timeline *tl,
-					       const struct dma_fence *fence)
-{
-	return __i915_timeline_sync_is_later(tl, fence->context, fence->seqno);
-}
-
-int i915_timeline_pin(struct i915_timeline *tl);
-int i915_timeline_get_seqno(struct i915_timeline *tl,
-			    struct i915_request *rq,
-			    u32 *seqno);
-void i915_timeline_unpin(struct i915_timeline *tl);
-
-int i915_timeline_read_hwsp(struct i915_request *from,
-			    struct i915_request *until,
-			    u32 *hwsp_offset);
-
-void i915_timelines_init(struct drm_i915_private *i915);
-void i915_timelines_park(struct drm_i915_private *i915);
-void i915_timelines_fini(struct drm_i915_private *i915);
-
-#endif
diff --git a/drivers/gpu/drm/i915/selftests/i915_live_selftests.h b/drivers/gpu/drm/i915/selftests/i915_live_selftests.h
index d5dc4427d664..2b31a4ee0b4c 100644
--- a/drivers/gpu/drm/i915/selftests/i915_live_selftests.h
+++ b/drivers/gpu/drm/i915/selftests/i915_live_selftests.h
@@ -12,7 +12,7 @@
 selftest(sanitycheck, i915_live_sanitycheck) /* keep first (igt selfcheck) */
 selftest(uncore, intel_uncore_live_selftests)
 selftest(workarounds, intel_workarounds_live_selftests)
-selftest(timelines, i915_timeline_live_selftests)
+selftest(timelines, intel_timeline_live_selftests)
 selftest(requests, i915_request_live_selftests)
 selftest(active, i915_active_live_selftests)
 selftest(objects, i915_gem_object_live_selftests)
diff --git a/drivers/gpu/drm/i915/selftests/i915_mock_selftests.h b/drivers/gpu/drm/i915/selftests/i915_mock_selftests.h
index 510eb176bb2c..b55da4d9ccba 100644
--- a/drivers/gpu/drm/i915/selftests/i915_mock_selftests.h
+++ b/drivers/gpu/drm/i915/selftests/i915_mock_selftests.h
@@ -15,7 +15,7 @@ selftest(scatterlist, scatterlist_mock_selftests)
 selftest(syncmap, i915_syncmap_mock_selftests)
 selftest(uncore, intel_uncore_mock_selftests)
 selftest(engine, intel_engine_cs_mock_selftests)
-selftest(timelines, i915_timeline_mock_selftests)
+selftest(timelines, intel_timeline_mock_selftests)
 selftest(requests, i915_request_mock_selftests)
 selftest(objects, i915_gem_object_mock_selftests)
 selftest(phys, i915_gem_phys_mock_selftests)
diff --git a/drivers/gpu/drm/i915/selftests/mock_gem_device.c b/drivers/gpu/drm/i915/selftests/mock_gem_device.c
index 021ba42a3a00..2741805b56c2 100644
--- a/drivers/gpu/drm/i915/selftests/mock_gem_device.c
+++ b/drivers/gpu/drm/i915/selftests/mock_gem_device.c
@@ -68,7 +68,7 @@ static void mock_device_release(struct drm_device *dev)
 	i915_gem_contexts_fini(i915);
 	mutex_unlock(&i915->drm.struct_mutex);
 
-	i915_timelines_fini(i915);
+	intel_timelines_fini(i915);
 
 	drain_workqueue(i915->wq);
 	i915_gem_drain_freed_objects(i915);
@@ -199,7 +199,7 @@ struct drm_i915_private *mock_gem_device(void)
 
 	i915->gt.awake = true;
 
-	i915_timelines_init(i915);
+	intel_timelines_init(i915);
 
 	mutex_lock(&i915->drm.struct_mutex);
 
@@ -230,7 +230,7 @@ struct drm_i915_private *mock_gem_device(void)
 	mock_engine_free(i915->engine[RCS0]);
 err_unlock:
 	mutex_unlock(&i915->drm.struct_mutex);
-	i915_timelines_fini(i915);
+	intel_timelines_fini(i915);
 	destroy_workqueue(i915->wq);
 err_drv:
 	drm_mode_config_cleanup(&i915->drm);
-- 
2.17.1

