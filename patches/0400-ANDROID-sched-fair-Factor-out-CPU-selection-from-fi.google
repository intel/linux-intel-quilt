From 237996b34375f881033bd8dc0d8fffc54d8d3e17 Mon Sep 17 00:00:00 2001
From: Quentin Perret <quentin.perret@arm.com>
Date: Fri, 31 Aug 2018 11:24:44 +0100
Subject: [PATCH 400/429] ANDROID: sched/fair: Factor out CPU selection from
 find_energy_efficient_cpu

find_energy_efficient_cpu() is composed of two steps; we first look for
the CPU with the max spare capacity in each frequency domain, and then
the impact on energy of each candidate is estimated. In order to make it
easier to implement other CPU selection policies, let's factor the
candidate selection algorithm out of find_energy_efficient_cpu(), and
mark the candidates in a mask. This should result in no functional
difference.

Signed-off-by: Quentin Perret <quentin.perret@arm.com>
Change-Id: I85a28880f01fcd11d7af28f9fbc1fe0cf4f197cf
---
 kernel/sched/fair.c | 104 +++++++++++++++++++++++++++-----------------
 1 file changed, 63 insertions(+), 41 deletions(-)

diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index b2eeafcf0ee0..5d75d80d04d9 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -6541,6 +6541,46 @@ static long compute_energy(struct task_struct *p, int dst_cpu,
 	return energy;
 }
 
+static void select_max_spare_cap_cpus(struct sched_domain *sd, cpumask_t *cpus,
+		struct perf_domain *pd, struct task_struct *p)
+{
+	unsigned long spare_cap, max_spare_cap, util, cpu_cap;
+	int cpu, max_spare_cap_cpu;
+
+	while (pd) {
+		max_spare_cap_cpu = -1;
+		max_spare_cap = 0;
+
+		for_each_cpu_and(cpu, perf_domain_span(pd), sched_domain_span(sd)) {
+			if (!cpumask_test_cpu(cpu, &p->cpus_allowed))
+				continue;
+
+			/* Skip CPUs that will be overutilized. */
+			util = cpu_util_next(cpu, p, cpu);
+			cpu_cap = capacity_of(cpu);
+			if (cpu_cap * 1024 < util * capacity_margin)
+				continue;
+
+			/*
+			 * Find the CPU with the maximum spare capacity in
+			 * the performance domain
+			 */
+			spare_cap = cpu_cap - util;
+			if (spare_cap > max_spare_cap) {
+				max_spare_cap = spare_cap;
+				max_spare_cap_cpu = cpu;
+			}
+		}
+
+		if (max_spare_cap_cpu >= 0)
+			cpumask_set_cpu(max_spare_cap_cpu, cpus);
+
+		pd = pd->next;
+	}
+}
+
+static DEFINE_PER_CPU(cpumask_t, energy_cpus);
+
 /*
  * find_energy_efficient_cpu(): Find most energy-efficient target CPU for the
  * waking task. find_energy_efficient_cpu() looks for the CPU with maximum
@@ -6574,10 +6614,10 @@ static int find_energy_efficient_cpu(struct task_struct *p, int prev_cpu,
 							struct perf_domain *pd)
 {
 	unsigned long prev_energy = ULONG_MAX, best_energy = ULONG_MAX;
-	int cpu, best_energy_cpu = prev_cpu;
-	struct perf_domain *head = pd;
-	unsigned long cpu_cap, util;
+	int weight, cpu, best_energy_cpu = prev_cpu;
+	unsigned long cur_energy;
 	struct sched_domain *sd;
+	cpumask_t *candidates;
 
 	sync_entity_load_avg(&p->se);
 
@@ -6594,48 +6634,30 @@ static int find_energy_efficient_cpu(struct task_struct *p, int prev_cpu,
 	if (!sd)
 		return prev_cpu;
 
-	while (pd) {
-		unsigned long cur_energy, spare_cap, max_spare_cap = 0;
-		int max_spare_cap_cpu = -1;
-
-		for_each_cpu_and(cpu, perf_domain_span(pd), sched_domain_span(sd)) {
-			if (!cpumask_test_cpu(cpu, &p->cpus_allowed))
-				continue;
+	/* Pre-select a set of candidate CPUs. */
+	candidates = this_cpu_ptr(&energy_cpus);
+	cpumask_clear(candidates);
+	select_max_spare_cap_cpus(sd, candidates, pd, p);
 
-			/* Skip CPUs that will be overutilized. */
-			util = cpu_util_next(cpu, p, cpu);
-			cpu_cap = capacity_of(cpu);
-			if (cpu_cap * 1024 < util * capacity_margin)
-				continue;
-
-			/* Always use prev_cpu as a candidate. */
-			if (cpu == prev_cpu) {
-				prev_energy = compute_energy(p, prev_cpu, head);
-				if (prev_energy < best_energy)
-					best_energy = prev_energy;
-				continue;
-			}
+	/* Bail out if there is no candidate, or if the only one is prev_cpu */
+	weight = cpumask_weight(candidates);
+	if (!weight || (weight == 1 && cpumask_first(candidates) == prev_cpu))
+		return prev_cpu;
 
-			/*
-			 * Find the CPU with the maximum spare capacity in
-			 * the performance domain
-			 */
-			spare_cap = cpu_cap - util;
-			if (spare_cap > max_spare_cap) {
-				max_spare_cap = spare_cap;
-				max_spare_cap_cpu = cpu;
-			}
-		}
+	if (cpumask_test_cpu(prev_cpu, &p->cpus_allowed))
+		prev_energy = best_energy = compute_energy(p, prev_cpu, pd);
+	else
+		prev_energy = best_energy = ULONG_MAX;
 
-		/* Evaluate the energy impact of using this CPU. */
-		if (max_spare_cap_cpu >= 0) {
-			cur_energy = compute_energy(p, max_spare_cap_cpu, head);
-			if (cur_energy < best_energy) {
-				best_energy = cur_energy;
-				best_energy_cpu = max_spare_cap_cpu;
-			}
+	/* Select the best candidate energy-wise. */
+	for_each_cpu(cpu, candidates) {
+		if (cpu == prev_cpu)
+			continue;
+		cur_energy = compute_energy(p, cpu, pd);
+		if (cur_energy < best_energy) {
+			best_energy = cur_energy;
+			best_energy_cpu = cpu;
 		}
-		pd = pd->next;
 	}
 
 	/*
-- 
2.19.1

