From 2ab56025c66ad67829ac66fe19f00fec8ad2f25a Mon Sep 17 00:00:00 2001
From: "D, Lakshmi Sowjanya" <lakshmi.sowjanya.d@intel.com>
Date: Thu, 19 Dec 2019 16:42:47 +0530
Subject: [PATCH 15/31] REVERTME: net: stmmac: support for adding offloaded
 clsflower vlan rx filters

This adds flower qdisc support for VLAN priority-based receive hardware
queue-steering, since by default all packets flow into RX HW queue 0.

Example:

To steer VLAN priority 2 packets to RX HW Q2:
    tc qdisc add dev eth0 ingress
    tc filter add dev eth0 parent ffff: protocol 802.1Q flower \
        vlan_prio 2 hw_tc 2

To check if filter got added, and its statistics:
    tc -s -d filter show dev eth0 ingress

Current limitations:
- Removal of ingress qdisc does not erase configuration.
- tc add command can only configure 1 set of VLAN priority to RX HW
  queue at a time.
- Only 4 sets of VLAN priority to RX HW queue can be used at a time.

Signed-off-by: D, Lakshmi Sowjanya <lakshmi.sowjanya.d@intel.com>
Signed-off-by: Wong, Vincent Por Yin <vincent.por.yin.wong@intel.com>
Signed-off-by: Tan, Tee Min <tee.min.tan@intel.com>
---
 drivers/net/ethernet/stmicro/stmmac/dwmac4.h  |  1 +
 .../net/ethernet/stmicro/stmmac/dwmac4_dma.c  |  2 +
 .../net/ethernet/stmicro/stmmac/stmmac_main.c |  9 +++-
 .../net/ethernet/stmicro/stmmac/stmmac_pci.c  |  4 +-
 .../net/ethernet/stmicro/stmmac/stmmac_tc.c   | 41 ++++++++++++++++++-
 5 files changed, 52 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4.h b/drivers/net/ethernet/stmicro/stmmac/dwmac4.h
index ab6bdf83a3de..c1c001535396 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4.h
@@ -37,6 +37,7 @@
 #define GMAC_DEBUG			0x00000114
 #define GMAC_HW_FEATURE0		0x0000011c
 #define GMAC_HW_FEATURE1		0x00000120
+#define GMAC_HWFEAT_L3L4FNUM	GENMASK(30, 27)
 #define GMAC_HW_FEATURE2		0x00000124
 #define GMAC_HW_FEATURE3		0x00000128
 #define GMAC_MDIO_ADDR			0x00000200
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c b/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
index c4c1297f72df..8ab87522cc7e 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
@@ -417,6 +417,8 @@ static void dwmac4_get_hw_feature(void __iomem *ioaddr,
 	dma_cap->aux_snapshot_n =
 		(hw_cap & GMAC_HW_FEAT_AUXSNAPNUM) >> 28;
 
+	dma_cap->l3l4fnum = (hw_cap & GMAC_HWFEAT_L3L4FNUM) >> 27;
+
 	/* MAC HW feature3 */
 	hw_cap = readl(ioaddr + GMAC_HW_FEATURE3);
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 27ead4f63a91..2e57788fed5f 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -5246,11 +5246,15 @@ static int stmmac_setup_tc_block_cb(enum tc_setup_type type, void *type_data,
 {
 	struct stmmac_priv *priv = cb_priv;
 	int ret = -EOPNOTSUPP;
+	struct flow_cls_offload *cls;
+
+	cls = (struct flow_cls_offload *)type_data;
 
 	if (!tc_cls_can_offload_and_chain0(priv->dev, type_data))
 		return ret;
 
-	stmmac_disable_all_queues(priv);
+	if (cls->command == FLOW_CLS_REPLACE)
+		stmmac_disable_all_queues(priv);
 
 	switch (type) {
 	case TC_SETUP_CLSU32:
@@ -5263,7 +5267,8 @@ static int stmmac_setup_tc_block_cb(enum tc_setup_type type, void *type_data,
 		break;
 	}
 
-	stmmac_enable_all_queues(priv);
+	if (cls->command == FLOW_CLS_REPLACE)
+		stmmac_enable_all_queues(priv);
 	return ret;
 }
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
index 60254afc2c82..bc49a96ec6a5 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -183,8 +183,8 @@ static int intel_mgbe_common_data(struct pci_dev *pdev,
 		plat->rx_queues_cfg[i].mode_to_use = MTL_QUEUE_DCB;
 		plat->rx_queues_cfg[i].chan = i;
 
-		/* Disable Priority config by default */
-		plat->rx_queues_cfg[i].use_prio = false;
+		/* Enable Priority config by default */
+		plat->rx_queues_cfg[i].use_prio = true;
 
 		/* Disable RX queues routing by default */
 		plat->rx_queues_cfg[i].pkt_route = 0x0;
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
index 91457d873a07..96f94d9bb38e 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
@@ -496,6 +496,44 @@ static int tc_add_ports_flow(struct stmmac_priv *priv,
 	return 0;
 }
 
+#define STMMAC_TC_H_MIN(h) ((h) & TC_H_MIN_MASK)
+#define STMMAC_TC_H_MIN_PRIORITY	0xFFE0U
+
+static int tc_add_vlan_flow(struct stmmac_priv *priv,
+			    struct flow_cls_offload *cls,
+			    struct stmmac_flow_entry *entry)
+{
+	struct flow_rule *rule = flow_cls_offload_flow_rule(cls);
+	struct flow_dissector *dissector = rule->match.dissector;
+	struct flow_match_vlan match;
+	u32 hw_match;
+	int queue;
+	u32 prio;
+
+	/* Nothing to do here */
+	if (!dissector_uses_key(dissector, FLOW_DISSECTOR_KEY_VLAN))
+		return -EINVAL;
+
+	/* Assumes flower qdisc vlan filter is used for RX flow control only */
+	queue  = STMMAC_TC_H_MIN(cls->classid) - STMMAC_TC_H_MIN_PRIORITY;
+	if (queue < 0 && queue < priv->plat->rx_queues_to_use)
+		return -EINVAL;
+
+	flow_rule_match_vlan(rule, &match);
+
+	hw_match = match.key->vlan_priority & match.mask->vlan_priority;
+	if (hw_match) {
+		/* Write to a single rx_queue register. Only 1 priority-queue
+		 * can be written at a time with a limit of 4 priority-queues
+		 * configured simultaneously
+		 */
+		prio = BIT(match.key->vlan_priority);
+		stmmac_rx_queue_prio(priv, priv->hw, prio, queue);
+	}
+
+	return 0;
+}
+
 static struct stmmac_flow_entry *tc_find_flow(struct stmmac_priv *priv,
 					      struct flow_cls_offload *cls,
 					      bool get_free)
@@ -521,6 +559,7 @@ static struct {
 	{ .fn = tc_add_basic_flow },
 	{ .fn = tc_add_ip4_flow },
 	{ .fn = tc_add_ports_flow },
+	{ .fn = tc_add_vlan_flow },
 };
 
 static int tc_add_flow(struct stmmac_priv *priv,
@@ -538,7 +577,7 @@ static int tc_add_flow(struct stmmac_priv *priv,
 
 	ret = tc_parse_flow_actions(priv, &rule->action, entry);
 	if (ret)
-		return ret;
+		netdev_dbg(priv->dev, "no actions were requested\n");
 
 	for (i = 0; i < ARRAY_SIZE(tc_flow_parsers); i++) {
 		ret = tc_flow_parsers[i].fn(priv, cls, entry);
-- 
2.17.1

