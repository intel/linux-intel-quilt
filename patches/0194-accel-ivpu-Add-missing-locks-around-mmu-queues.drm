From 14a40a777522f2835ef14cce99fff4705d2942bd Mon Sep 17 00:00:00 2001
From: Andrzej Kacprowski <Andrzej.Kacprowski@intel.com>
Date: Tue, 4 Feb 2025 09:46:17 +0100
Subject: [PATCH 0194/1107] accel/ivpu: Add missing locks around mmu queues

Multiple threads were accessing mmu cmd queue simultaneously
causing sporadic failures in ivpu_mmu_cmdq_sync() function.
Protect critical code with mmu mutex.

Reviewed-by: Jacek Lawrynowicz <jacek.lawrynowicz@linux.intel.com>
Signed-off-by: Andrzej Kacprowski <Andrzej.Kacprowski@intel.com>
Signed-off-by: Jacek Lawrynowicz <jacek.lawrynowicz@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20250204084622.2422544-2-jacek.lawrynowicz@linux.intel.com
---
 drivers/accel/ivpu/ivpu_mmu.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/drivers/accel/ivpu/ivpu_mmu.c b/drivers/accel/ivpu/ivpu_mmu.c
index b80bdded9fd7..5ea010568faa 100644
--- a/drivers/accel/ivpu/ivpu_mmu.c
+++ b/drivers/accel/ivpu/ivpu_mmu.c
@@ -895,6 +895,9 @@ static int ivpu_mmu_evtq_disable(struct ivpu_device *vdev)
 
 void ivpu_mmu_discard_events(struct ivpu_device *vdev)
 {
+	struct ivpu_mmu_info *mmu = vdev->mmu;
+
+	mutex_lock(&mmu->lock);
 	/*
 	 * Disable event queue (stop MMU from updating the producer)
 	 * to allow synchronization of consumer and producer indexes
@@ -908,6 +911,8 @@ void ivpu_mmu_discard_events(struct ivpu_device *vdev)
 	ivpu_mmu_evtq_enable(vdev);
 
 	drm_WARN_ON_ONCE(&vdev->drm, vdev->mmu->evtq.cons != vdev->mmu->evtq.prod);
+
+	mutex_unlock(&mmu->lock);
 }
 
 int ivpu_mmu_disable_ssid_events(struct ivpu_device *vdev, u32 ssid)
@@ -920,6 +925,8 @@ int ivpu_mmu_disable_ssid_events(struct ivpu_device *vdev, u32 ssid)
 	if (ssid > IVPU_MMU_CDTAB_ENT_COUNT)
 		return -EINVAL;
 
+	mutex_lock(&mmu->lock);
+
 	entry = cdtab->base + (ssid * IVPU_MMU_CDTAB_ENT_SIZE);
 
 	val = READ_ONCE(entry[0]);
@@ -932,6 +939,8 @@ int ivpu_mmu_disable_ssid_events(struct ivpu_device *vdev, u32 ssid)
 	ivpu_mmu_cmdq_write_cfgi_all(vdev);
 	ivpu_mmu_cmdq_sync(vdev);
 
+	mutex_unlock(&mmu->lock);
+
 	return 0;
 }
 
-- 
2.25.1

