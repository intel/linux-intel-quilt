From 14faf400308d2712497d2bf604a5a095b34db740 Mon Sep 17 00:00:00 2001
From: "K Naduvalath, Sumesh" <sumesh.k.naduvalath@intel.com>
Date: Mon, 27 Jul 2020 14:02:41 +0530
Subject: [PATCH 8/8] ishtp: Multiple fixes for power management and event path

This fix addresses following items -
1. Remove all PM calls.
2. Decouple and offload events processing to ACPI

Signed-off-by: K Naduvalath, Sumesh <sumesh.k.naduvalath@intel.com>
---
 drivers/platform/x86/intel_ishtp_eclite.c | 156 ++++++++--------------
 1 file changed, 58 insertions(+), 98 deletions(-)

diff --git a/drivers/platform/x86/intel_ishtp_eclite.c b/drivers/platform/x86/intel_ishtp_eclite.c
index d2b6faac6d8d..5713634b1f53 100644
--- a/drivers/platform/x86/intel_ishtp_eclite.c
+++ b/drivers/platform/x86/intel_ishtp_eclite.c
@@ -28,11 +28,10 @@
 #define ECL_ISH_WRITE	0x2
 #define ECL_ISH_HEADER_VERSION	0
 
-#define ECL_CL_RX_RING_SIZE	64
-#define ECL_CL_TX_RING_SIZE	32
+#define ECL_CL_RX_RING_SIZE	16
+#define ECL_CL_TX_RING_SIZE	8
 
 #define ECL_DATA_OPR_BUFLEN	384
-#define ECL_EVENTS_NOTIFY	333
 
 #define cmd_opr_offsetof(element)	offsetof(struct opregion_cmd, element)
 #define cl_data_to_dev(opr_dev)	ishtp_device((opr_dev)->cl_device)
@@ -78,11 +77,12 @@ struct ishtp_opregion_dev {
 	struct ishtp_fw_client *fw_client;
 	struct ishtp_cl_rb *rb;
 	struct acpi_handle *acpi_handle;
+	unsigned int dsm_event_id;
 	unsigned int ish_link_ready;
-	unsigned int ish_pm_suspended;
 	unsigned int ish_read_done;
 	wait_queue_head_t read_wait;
 	wait_queue_head_t link_wait;
+	struct work_struct event_work;
 	struct work_struct reset_work;
 };
 
@@ -102,8 +102,8 @@ static const guid_t ecl_acpi_guid =
  * @opr_dev - pointer to opregion device
  *
  * @This function issues a read request to eclite FW and waits until it
- * receives a response. When response is received the read data is copied
- * to opregion buffer.
+ * receives a response. When response is received the read data is copied to
+ * opregion buffer.
  */
 static int ecl_ish_cl_read(struct ishtp_opregion_dev *opr_dev)
 {
@@ -119,38 +119,36 @@ static int ecl_ish_cl_read(struct ishtp_opregion_dev *opr_dev)
 	len = sizeof(header);
 
 	rv = wait_event_interruptible_timeout(opr_dev->link_wait,
-					      (opr_dev->ish_link_ready &&
-					       !opr_dev->ish_pm_suspended),
+					      opr_dev->ish_link_ready,
 					      5 * HZ);
 	if (!rv) {
 		dev_warn(cl_data_to_dev(opr_dev),
-			"[ish_rd] timeout, Link not ready\n");
-		return 0;
+			 "[ish_rd] Timeout, Link not ready\n");
 	}
 
-	dev_dbg(cl_data_to_dev(opr_dev),
-		"[ish_rd] Req: off : %x, len : %x\n",
-		header.offset,
-		header.data_len);
+	opr_dev->ish_read_done = false;
 
-	opr_dev->ish_read_done = 0;
-
-	if (!opr_dev->ish_link_ready || opr_dev->ish_pm_suspended)
-		return 0;
+	if (!opr_dev->ish_link_ready)
+		return -EIO;
 
 	rv = ishtp_cl_send(opr_dev->ecl_ishtp_cl, (uint8_t *)&header, len);
 	if (rv) {
 		dev_err(cl_data_to_dev(opr_dev), "ish-read : send failed\n");
-		return 0;
+		return rv;
 	}
 
+	dev_dbg(cl_data_to_dev(opr_dev),
+		"[ish_rd] Req: off : %x, len : %x\n",
+		header.offset,
+		header.data_len);
+
 	rv = wait_event_interruptible_timeout(opr_dev->read_wait,
 					      opr_dev->ish_read_done,
 					      5 * HZ);
 	if (!rv) {
-		dev_warn(cl_data_to_dev(opr_dev),
-			"[ish_rd] No response from firmware\n");
-		return 0;
+		dev_err(cl_data_to_dev(opr_dev),
+			 "[ish_rd] No response from firmware\n");
+		return -EIO;
 	}
 
 	return 0;
@@ -180,11 +178,15 @@ static int ecl_ish_cl_write(struct ishtp_opregion_dev *opr_dev)
 	       opr_dev->opr_context.data_area.data + message.header.offset,
 	       message.header.data_len);
 
-	if (!opr_dev->ish_link_ready || opr_dev->ish_pm_suspended)
+	if (!opr_dev->ish_link_ready)
 		return 0;
 
-	return ishtp_cl_send(opr_dev->ecl_ishtp_cl, (uint8_t *)&message, len);
+	dev_dbg(cl_data_to_dev(opr_dev),
+		"[ish_wr] off : %x, len : %x\n",
+		message.header.offset,
+		message.header.data_len);
 
+	return ishtp_cl_send(opr_dev->ecl_ishtp_cl, (uint8_t *)&message, len);
 }
 
 static acpi_status
@@ -304,62 +306,53 @@ static int acpi_opregion_init(struct ishtp_opregion_dev *opr_dev)
 	return 0;
 }
 
+static void ecl_acpi_invoke_dsm(struct work_struct *work)
+{
+	struct ishtp_opregion_dev *opr_dev;
+	union acpi_object *obj;
+
+	opr_dev = container_of(work, struct ishtp_opregion_dev, event_work);
+
+	obj = acpi_evaluate_dsm(opr_dev->acpi_handle, &ecl_acpi_guid, 0,
+				opr_dev->dsm_event_id, NULL);
+	if (!obj) {
+		dev_warn(cl_data_to_dev(opr_dev), "_DSM fn call failed\n");
+		return;
+	}
+
+	dev_dbg(cl_data_to_dev(opr_dev), "Exec DSM function code: %d success\n",
+		opr_dev->dsm_event_id);
+
+	ACPI_FREE(obj);
+}
+
 static void ecl_ish_process_rx_data(struct ishtp_opregion_dev *opr_dev)
 {
 	struct ecl_message *message =
 		(struct ecl_message *)opr_dev->rb->buffer.data;
 
 	dev_dbg(cl_data_to_dev(opr_dev),
-		"[ish_rd] Rsp: off : %x, len : %x\n",
+		"[ish_rd] Resp: off : %x, len : %x\n",
 		message->header.offset,
 		message->header.data_len);
 
 	memcpy(opr_dev->opr_context.data_area.data + message->header.offset,
 	       message->payload, message->header.data_len);
 
-	opr_dev->ish_read_done = 1;
+	opr_dev->ish_read_done = true;
 	wake_up_interruptible(&opr_dev->read_wait);
 }
 
 static void ecl_ish_process_rx_event(struct ishtp_opregion_dev *opr_dev)
 {
-	union acpi_object *obj;
-
 	struct ecl_message_header *header =
 		(struct ecl_message_header *)opr_dev->rb->buffer.data;
 
 	dev_dbg(cl_data_to_dev(opr_dev),
-		"[ish_event] Received: %8x\n", header->event);
+		"[ish_ev] Evt received: %8x\n", header->event);
 
-	obj = acpi_evaluate_dsm(opr_dev->acpi_handle, &ecl_acpi_guid, 0,
-				header->event, NULL);
-	if (!obj) {
-		dev_warn(cl_data_to_dev(opr_dev), "_DSM fn call failed\n");
-		return;
-	}
-
-	dev_dbg(cl_data_to_dev(opr_dev), "Exec DSM function code: %d success\n",
-		header->event);
-
-	ACPI_FREE(obj);
-}
-
-static int ecl_ish_cl_enable_events(struct ishtp_opregion_dev *opr_dev,
-				     bool config_enable)
-{
-	struct ecl_message message = { 0 };
-	int len;
-
-	message.header.version = ECL_ISH_HEADER_VERSION;
-	message.header.data_type = ECL_MSG_DATA;
-	message.header.request_type = ECL_ISH_WRITE;
-	message.header.offset = ECL_EVENTS_NOTIFY;
-	message.header.data_len = 1;
-	message.payload[0] = config_enable;
-
-	len = sizeof(struct ecl_message_header) + message.header.data_len;
-
-	return ishtp_cl_send(opr_dev->ecl_ishtp_cl, (uint8_t *)&message, len);
+	opr_dev->dsm_event_id = header->event;
+	schedule_work(&opr_dev->event_work);
 }
 
 static void ecl_ishtp_cl_event_cb(struct ishtp_cl_device *cl_device)
@@ -474,16 +467,17 @@ static void ecl_ishtp_cl_reset_handler(struct work_struct *work)
 		ishtp_cl_free(ecl_ishtp_cl);
 		opr_dev->ecl_ishtp_cl = NULL;
 		dev_err(cl_data_to_dev(opr_dev),
-			"[eclite_rst_handler] Reset failed. Link not ready.\n");
+			"[ish_rst] Reset failed. Link not ready.\n");
 		return;
 	}
 
 	ishtp_register_event_cb(cl_device, ecl_ishtp_cl_event_cb);
 
-	ecl_ish_cl_enable_events(opr_dev, 1);
-
 	opr_dev->ish_link_ready = true;
 
+	dev_err(cl_data_to_dev(opr_dev),
+		"[ish_rst] Reset success. Link ready.\n");
+
 	wake_up_interruptible(&opr_dev->link_wait);
 }
 
@@ -509,8 +503,10 @@ static int ecl_ishtp_cl_probe(struct ishtp_cl_device *cl_device)
 
 	init_waitqueue_head(&opr_dev->read_wait);
 	init_waitqueue_head(&opr_dev->link_wait);
+	INIT_WORK(&opr_dev->event_work, ecl_acpi_invoke_dsm);
 	INIT_WORK(&opr_dev->reset_work, ecl_ishtp_cl_reset_handler);
 
+
 	/* Initialize ish client device */
 	rv = ecl_ishtp_cl_init(ecl_ishtp_cl);
 	if (rv) {
@@ -526,7 +522,6 @@ static int ecl_ishtp_cl_probe(struct ishtp_cl_device *cl_device)
 	ishtp_get_device(cl_device);
 
 	opr_dev->ish_link_ready = true;
-	opr_dev->ish_pm_suspended = false;
 
 	/* Now find ACPI device and init opregion handlers */
 	rv = acpi_opregion_init(opr_dev);
@@ -539,8 +534,6 @@ static int ecl_ishtp_cl_probe(struct ishtp_cl_device *cl_device)
 	/* Reprobe devices depending on ECLite - battery, fan, etc. */
 	acpi_walk_dep_device_list(opr_dev->acpi_handle);
 
-	ecl_ish_cl_enable_events(opr_dev, 1);
-
 	return 0;
 
 err_exit:
@@ -559,8 +552,6 @@ static int ecl_ishtp_cl_remove(struct ishtp_cl_device *cl_device)
 	struct ishtp_opregion_dev *opr_dev =
 		ishtp_get_client_data(ecl_ishtp_cl);
 
-	ecl_ish_cl_enable_events(opr_dev, 0);
-
 	acpi_remove_address_space_handler(opr_dev->acpi_handle,
 					  ECLITE_CMD_OPREGION_ID,
 					  ecl_opregion_cmd_handler);
@@ -570,6 +561,7 @@ static int ecl_ishtp_cl_remove(struct ishtp_cl_device *cl_device)
 					  ecl_opregion_data_handler);
 
 	cancel_work_sync(&opr_dev->reset_work);
+	cancel_work_sync(&opr_dev->event_work);
 
 	ishtp_set_connection_state(ecl_ishtp_cl, ISHTP_CL_DISCONNECTING);
 	ishtp_cl_disconnect(ecl_ishtp_cl);
@@ -591,44 +583,12 @@ static int ecl_ishtp_cl_reset(struct ishtp_cl_device *cl_device)
 	return 0;
 }
 
-static int ecl_ishtp_cl_suspend(struct device *device)
-{
-	struct ishtp_cl_device *cl_device = ishtp_dev_to_cl_device(device);
-	struct ishtp_cl *ecl_ishtp_cl = ishtp_get_drvdata(cl_device);
-	struct ishtp_opregion_dev *opr_dev =
-		ishtp_get_client_data(ecl_ishtp_cl);
-
-	opr_dev->ish_pm_suspended = true;
-	ecl_ish_cl_enable_events(opr_dev, 0);
-
-	return 0;
-}
-
-static int ecl_ishtp_cl_resume(struct device *device)
-{
-	struct ishtp_cl_device *cl_device = ishtp_dev_to_cl_device(device);
-	struct ishtp_cl *ecl_ishtp_cl = ishtp_get_drvdata(cl_device);
-	struct ishtp_opregion_dev *opr_dev =
-		ishtp_get_client_data(ecl_ishtp_cl);
-
-	ecl_ish_cl_enable_events(opr_dev, 1);
-	opr_dev->ish_pm_suspended = false;
-
-	return 0;
-}
-
-static const struct dev_pm_ops ecl_ishtp_pm_ops = {
-	.suspend = ecl_ishtp_cl_suspend,
-	.resume = ecl_ishtp_cl_resume,
-};
-
 static struct ishtp_cl_driver ecl_ishtp_cl_driver = {
 	.name = "ishtp-eclite",
 	.guid = &ecl_ishtp_guid,
 	.probe = ecl_ishtp_cl_probe,
 	.remove = ecl_ishtp_cl_remove,
 	.reset = ecl_ishtp_cl_reset,
-	.driver.pm = &ecl_ishtp_pm_ops,
 };
 
 static int __init ecl_ishtp_init(void)
-- 
2.17.1

