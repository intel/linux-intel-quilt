From 3ecd95655b68cbe229095fe96fa3bf297c9ac3d0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Thu, 16 Jan 2025 22:16:36 +0200
Subject: [PATCH 0596/1107] drm/i915/dsb: Add support for triggering VRR push
 with DSB
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We have at least two options for how to do the
TRANS_PUSH_SEND + commit completion signalling
with the DSB:

Option A)
 1. trigger TRANS_PUSH_SEND
 2. wait for "safe window"
 3. signal the interrupt

In this cases step 2 should not do anything if we were already
between vmin and vmax decision boundaries. Otherwise we'll wait
until the next start of the vblank period.

Option B)
 1. wait for "safe window"
 2. trigger TRANS_PUSH_SEND
 3. signal the interrupt

This option is perhaps a bit less racy, but if we do somehow
screw up and the wait is a nop but the push gets deferred
until the next frame then we'll end up completing the commit
a frame too early.

So for now I'm leaning towards option A since losing the race
won't have any drastic consequences. To deal with the race we
can give the DSB a bit more time to start step 2 before the
hardware has started the vblank termination properly. Often
times it seems to be fast enough to make it in time even without
any extra vblank delay (the push is issued somewhere within a
scanline and it latches on the next scanline).

v2: Use intel_vrr_possible() to determine if we need some
    vblank delay (also avoids adding it for DSI which doens't
    actually program the transcoder registers correctly for it)

Cc: Paz Zcharya <pazz@chromium.org>
Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Reviewed-by: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20250116201637.22486-8-ville.syrjala@linux.intel.com
---
 drivers/gpu/drm/i915/display/intel_display.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/drivers/gpu/drm/i915/display/intel_display.c b/drivers/gpu/drm/i915/display/intel_display.c
index 950505c94224..68d932d9f5c5 100644
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@ -2630,6 +2630,14 @@ static int intel_crtc_vblank_delay(const struct intel_crtc_state *crtc_state)
 	if (intel_crtc_needs_wa_14015401596(crtc_state))
 		vblank_delay = max(vblank_delay, 1);
 
+	/*
+	 * Add a minimal vblank delay to make sure the push
+	 * doesn't race with the "wait for safe window" used
+	 * for frame completion with DSB.
+	 */
+	if (intel_vrr_possible(crtc_state))
+		vblank_delay = max(vblank_delay, 1);
+
 	return vblank_delay;
 }
 
@@ -7727,6 +7735,8 @@ static void intel_atomic_dsb_finish(struct intel_atomic_state *state,
 		intel_crtc_planes_update_arm(new_crtc_state->dsb_commit,
 					     state, crtc);
 
+		intel_vrr_send_push(new_crtc_state->dsb_commit, new_crtc_state);
+
 		if (!new_crtc_state->dsb_color_vblank) {
 			intel_dsb_wait_vblanks(new_crtc_state->dsb_commit, 1);
 			intel_dsb_wait_vblank_delay(state, new_crtc_state->dsb_commit);
-- 
2.25.1

