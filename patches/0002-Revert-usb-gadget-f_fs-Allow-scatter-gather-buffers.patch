From 0e091bc4738dcbe1745890926c4d7e1051745ad5 Mon Sep 17 00:00:00 2001
From: Fei Yang <fei.yang@intel.com>
Date: Wed, 22 May 2019 16:27:35 -0700
Subject: [PATCH 2/2] Revert "usb: gadget: f_fs: Allow scatter-gather buffers"

This reverts commit 772a7a724f69d258025fedd87dde1aafe4171aef.

Revert it due to the adb push issue.

Signed-off-by: Fei Yang <fei.yang@intel.com>
---
 drivers/usb/gadget/function/f_fs.c | 93 +++---------------------------
 1 file changed, 7 insertions(+), 86 deletions(-)

diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c
index 20413c276c61..4c7ce78b41db 100644
--- a/drivers/usb/gadget/function/f_fs.c
+++ b/drivers/usb/gadget/function/f_fs.c
@@ -18,12 +18,9 @@
 #include <linux/pagemap.h>
 #include <linux/export.h>
 #include <linux/hid.h>
-#include <linux/mm.h>
 #include <linux/module.h>
-#include <linux/scatterlist.h>
 #include <linux/sched/signal.h>
 #include <linux/uio.h>
-#include <linux/vmalloc.h>
 #include <asm/unaligned.h>
 
 #include <linux/usb/ccid.h>
@@ -222,8 +219,6 @@ struct ffs_io_data {
 
 	struct usb_ep *ep;
 	struct usb_request *req;
-	struct sg_table sgt;
-	bool use_sg;
 
 	struct ffs_data *ffs;
 };
@@ -755,65 +750,6 @@ static ssize_t ffs_copy_to_iter(void *data, int data_len, struct iov_iter *iter)
 	return ret;
 }
 
-/*
- * allocate a virtually contiguous buffer and create a scatterlist describing it
- * @sg_table	- pointer to a place to be filled with sg_table contents
- * @size	- required buffer size
- */
-static void *ffs_build_sg_list(struct sg_table *sgt, size_t sz)
-{
-	struct page **pages;
-	void *vaddr, *ptr;
-	unsigned int n_pages;
-	int i;
-
-	vaddr = vmalloc(sz);
-	if (!vaddr)
-		return NULL;
-
-	n_pages = PAGE_ALIGN(sz) >> PAGE_SHIFT;
-	pages = kvmalloc_array(n_pages, sizeof(struct page *), GFP_KERNEL);
-	if (!pages) {
-		vfree(vaddr);
-
-		return NULL;
-	}
-	for (i = 0, ptr = vaddr; i < n_pages; ++i, ptr += PAGE_SIZE)
-		pages[i] = vmalloc_to_page(ptr);
-
-	if (sg_alloc_table_from_pages(sgt, pages, n_pages, 0, sz, GFP_KERNEL)) {
-		kvfree(pages);
-		vfree(vaddr);
-
-		return NULL;
-	}
-	kvfree(pages);
-
-	return vaddr;
-}
-
-static inline void *ffs_alloc_buffer(struct ffs_io_data *io_data,
-	size_t data_len)
-{
-	if (io_data->use_sg)
-		return ffs_build_sg_list(&io_data->sgt, data_len);
-
-	return kmalloc(data_len, GFP_KERNEL);
-}
-
-static inline void ffs_free_buffer(struct ffs_io_data *io_data)
-{
-	if (!io_data->buf)
-		return;
-
-	if (io_data->use_sg) {
-		sg_free_table(&io_data->sgt);
-		vfree(io_data->buf);
-	} else {
-		kfree(io_data->buf);
-	}
-}
-
 static void ffs_user_copy_worker(struct work_struct *work)
 {
 	struct ffs_io_data *io_data = container_of(work, struct ffs_io_data,
@@ -841,7 +777,7 @@ static void ffs_user_copy_worker(struct work_struct *work)
 
 	if (io_data->read)
 		kfree(io_data->to_free);
-	ffs_free_buffer(io_data);
+	kfree(io_data->buf);
 	kfree(io_data);
 }
 
@@ -997,7 +933,6 @@ static ssize_t ffs_epfile_io(struct file *file, struct ffs_io_data *io_data)
 		 * earlier
 		 */
 		gadget = epfile->ffs->gadget;
-		io_data->use_sg = gadget->sg_supported && data_len > PAGE_SIZE;
 
 		spin_lock_irq(&epfile->ffs->eps_lock);
 		/* In the meantime, endpoint got disabled or changed. */
@@ -1014,7 +949,7 @@ static ssize_t ffs_epfile_io(struct file *file, struct ffs_io_data *io_data)
 			data_len = usb_ep_align_maybe(gadget, ep->ep, data_len);
 		spin_unlock_irq(&epfile->ffs->eps_lock);
 
-		data = ffs_alloc_buffer(io_data, data_len);
+		data = kmalloc(data_len, GFP_KERNEL);
 		if (unlikely(!data)) {
 			ret = -ENOMEM;
 			goto error_mutex;
@@ -1054,16 +989,8 @@ static ssize_t ffs_epfile_io(struct file *file, struct ffs_io_data *io_data)
 		bool interrupted = false;
 
 		req = ep->req;
-		if (io_data->use_sg) {
-			req->buf = NULL;
-			req->sg	= io_data->sgt.sgl;
-			req->num_sgs = io_data->sgt.nents;
-		} else {
-			req->buf = data;
-		}
-		req->length = data_len;
-
-		io_data->buf = data;
+		req->buf      = data;
+		req->length   = data_len;
 
 		req->context  = &done;
 		req->complete = ffs_epfile_io_complete;
@@ -1097,14 +1024,8 @@ static ssize_t ffs_epfile_io(struct file *file, struct ffs_io_data *io_data)
 	} else if (!(req = usb_ep_alloc_request(ep->ep, GFP_ATOMIC))) {
 		ret = -ENOMEM;
 	} else {
-		if (io_data->use_sg) {
-			req->buf = NULL;
-			req->sg	= io_data->sgt.sgl;
-			req->num_sgs = io_data->sgt.nents;
-		} else {
-			req->buf = data;
-		}
-		req->length = data_len;
+		req->buf      = data;
+		req->length   = data_len;
 
 		io_data->buf = data;
 		io_data->ep = ep->ep;
@@ -1133,7 +1054,7 @@ static ssize_t ffs_epfile_io(struct file *file, struct ffs_io_data *io_data)
 error_mutex:
 	mutex_unlock(&epfile->mutex);
 error:
-	ffs_free_buffer(io_data);
+	kfree(data);
 	return ret;
 }
 
-- 
2.17.1

