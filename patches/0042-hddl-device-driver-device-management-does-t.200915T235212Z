From 77d663b0c8e0f3b7a91ce34e9d6ceed37b449b89 Mon Sep 17 00:00:00 2001
From: lrajasub <lakshmi.bai.raja.subramanian@intel.com>
Date: Sun, 2 Aug 2020 21:12:42 +0530
Subject: [PATCH 42/48] hddl device driver - device management, does the
 handshaking between soc and IA host

Signed-off-by: lrajasub <lakshmi.bai.raja.subramanian@intel.com>
---
 drivers/misc/hddl_device/hddl_device.c | 263 ++++++++++++++++---------
 1 file changed, 166 insertions(+), 97 deletions(-)

diff --git a/drivers/misc/hddl_device/hddl_device.c b/drivers/misc/hddl_device/hddl_device.c
index 13f1f5ba10ee..5b39fe174cc0 100644
--- a/drivers/misc/hddl_device/hddl_device.c
+++ b/drivers/misc/hddl_device/hddl_device.c
@@ -187,25 +187,30 @@ static long hddl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		for (i = 0; i < HDDL_MAX_DEVICE; i++) {
 			for (j = 0; j < HDDL_MAX_BAY_DEVICE; j++) {
 				if (kmb_hddls[i].soc[j].devH.sw_device_id
-						== soft_reset.sw_id) {
-					/* xlink-reset */
-					struct xlink_handle *devH =
-						&kmb_hddls[i].soc[j].devH;
-					rc =  xlink_reset_device(devH);
-
-					printk(KERN_INFO "Value of rc = %d\n", rc);
-					if (rc > 0)
-						printk(KERN_INFO "HDDL : xlink_reset_device failed");
-					else
-						soft_reset.return_id = 1;
-
-					if (copy_to_user((T_SW_ID_SOFT_RESET *) arg,
-							&soft_reset, sizeof(T_SW_ID_SOFT_RESET)))
-						return -EFAULT;
-					/* xlink-rest */
+						!= soft_reset.sw_id) {
+					continue;
 				}
 			}
 		}
+
+		if (kmb_hddls[i].soc[j].devH.sw_device_id == soft_reset.sw_id) {
+			/* xlink-reset */
+			struct xlink_handle *devH =
+				&kmb_hddls[i].soc[j].devH;
+			rc =  xlink_reset_device(devH);
+
+			printk(KERN_INFO "Value of rc = %d\n", rc);
+			if (rc > 0)
+				printk(
+				  KERN_INFO "HDDL : xlink_reset_device failed");
+			else
+				soft_reset.return_id = 1;
+
+			if (copy_to_user((T_SW_ID_SOFT_RESET *) arg,
+				&soft_reset, sizeof(T_SW_ID_SOFT_RESET)))
+				return -EFAULT;
+			/* xlink-rest */
+		}
 		break;
 	case HDDL_READ_SW_ID_DATA:
 		if (copy_from_user(&swid_data, (int32_t *)arg,
@@ -214,20 +219,25 @@ static long hddl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		for (i = 0; i < HDDL_MAX_DEVICE; i++) {
 			for (j = 0; j < HDDL_MAX_BAY_DEVICE; j++) {
 				if (kmb_hddls[i].soc[j].devH.sw_device_id
-					== swid_data.sw_id) {
-					swid_data.board_id = kmb_hddls[i].board_id;
-					swid_data.soc_id = kmb_hddls[i].soc[j].id;
-					swid_data.soc_adaptor_no[0] =
-						kmb_hddls[i].soc[j].adap[0].nr;
-					swid_data.soc_adaptor_no[1] =
-						kmb_hddls[i].soc[j].adap[1].nr;
-					swid_data.return_id = 1;
-				if (copy_to_user((T_SW_ID_HDDL_DATA *) arg,
-					&swid_data, sizeof(T_SW_ID_HDDL_DATA)))
-					return -EFAULT;
+					!= swid_data.sw_id) {
+					continue;
 				}
 			}
 		}
+
+		if (kmb_hddls[i].soc[j].devH.sw_device_id
+			== swid_data.sw_id) {
+			swid_data.board_id = kmb_hddls[i].board_id;
+			swid_data.soc_id = kmb_hddls[i].soc[j].id;
+			swid_data.soc_adaptor_no[0] =
+				kmb_hddls[i].soc[j].adap[0].nr;
+			swid_data.soc_adaptor_no[1] =
+				kmb_hddls[i].soc[j].adap[1].nr;
+			swid_data.return_id = 1;
+			if (copy_to_user((T_SW_ID_HDDL_DATA *) arg,
+					&swid_data, sizeof(T_SW_ID_HDDL_DATA)))
+				return -EFAULT;
+		}
 		break;
 	}
 	return 0;
@@ -251,14 +261,13 @@ void hddl_device_probe(uint32_t sw_device_id)
 	for (j = 0; j < HDDL_MAX_BAY_DEVICE; j++) {
 		if (kmb_hddls[i].soc[j].devH.sw_device_id == sw_device_id) {
 
-			printk("inside probe if-condition sw_device_id %x\n", kmb_hddls[i].soc[j].devH.sw_device_id);
-
 			printk("HDDL: Booting kmb device after reset\n");
 			task_recv = kthread_run(hddl_per_device_connect_thread,
 					(void *)&kmb_hddls[i].soc[j].devH,
 					"hddl_per_device_thread");
 			if (task_recv == NULL)
-				printk(KERN_WARNING "hddl_device_init Thread creation failed");
+				printk(KERN_WARNING
+				    "hddl_device_init Thread creation failed");
 			}
 		}
 	}
@@ -273,44 +282,63 @@ void hddl_device_remove(uint32_t sw_device_id)
 	printk(KERN_INFO "hddl_device_remove = %x\n", sw_device_id);
 
 	for (i = 0; i < HDDL_MAX_DEVICE; i++) {
-	for (j = 0; j < HDDL_MAX_BAY_DEVICE; j++) {
-		if (kmb_hddls[i].soc[j].devH.sw_device_id == sw_device_id) {
-
-			soc = &kmb_hddls[i].soc[j];
-			for (k = 0; k < soc->i2c_slaves_cnt; k++) {
-				printk("i2c_slaves_ext adapter %d", soc->i2c_slaves_ext[k]->adapter->nr);
-				i2c_unregister_device(soc->i2c_slaves_ext[k]);
-			}
-			for (k = 0; k < soc->soc_xlinki2c_cnt; k++) {
-				if (soc->soc_smbus[k]) {
-					printk("soc_smbus adapter %d", soc->soc_smbus[k]->adapter->nr);
-					i2c_unregister_device(soc->soc_smbus[k]);
-				}
-			}
-			for (k = 0; k < soc->soc_xlinki2c_cnt; k++) {
-				if (soc->soc_xlinki2c[k]) {
-					printk("soc_xlinki2c adapter %d", soc->soc_xlinki2c[k]->adapter->nr);
-					i2c_unregister_device(soc->soc_xlinki2c[k]);
-				}
+		for (j = 0; j < HDDL_MAX_BAY_DEVICE; j++) {
+			if (kmb_hddls[i].soc[j].devH.sw_device_id
+				!= sw_device_id) {
+				continue;
 			}
+		}
+	}
 
-			chan_num = HDDL_NODE_XLINK_CHANNEL;
-			printk("chan_num form remove function = %d\n", chan_num);
-
-			for (k = 0; k < 2; k++) {
+	if (kmb_hddls[i].soc[j].devH.sw_device_id == sw_device_id) {
 
-				printk("HDDL : platform_device_unregister = %d\n", k);
-				platform_device_unregister(soc->xlink_i2c_plt_dev[k]);
+		soc = &kmb_hddls[i].soc[j];
+		for (k = 0; k < soc->i2c_slaves_cnt; k++) {
+			printk(
+			  "i2c_slaves_ext adapter %d",
+			  soc->i2c_slaves_ext[k]->adapter->nr);
+			i2c_unregister_device(soc->i2c_slaves_ext[k]);
+		}
+		for (k = 0; k < soc->soc_xlinki2c_cnt; k++) {
+			if (soc->soc_smbus[k]) {
+				printk("soc_smbus adapter %d",
+					soc->soc_smbus[k]->adapter->nr);
+				i2c_unregister_device(
+					soc->soc_smbus[k]);
+			}
+		}
+		for (k = 0; k < soc->soc_xlinki2c_cnt; k++) {
+			if (soc->soc_xlinki2c[k]) {
+				printk(
+				   "soc_xlinki2c adapter %d",
+				    soc->soc_xlinki2c[k]->adapter->nr);
+				i2c_unregister_device(
+					soc->soc_xlinki2c[k]);
 			}
+		}
 
-			rc = xlink_close_channel(&soc->devH, chan_num);
-			printk(KERN_INFO "HDDL:Close Channel Number[%x]: [%u] EC[%d]\n", sw_device_id, chan_num, rc);
+		chan_num = HDDL_NODE_XLINK_CHANNEL;
 
-			rc = xlink_disconnect(&soc->devH);
-			printk(KERN_INFO "HDDL:Disconnect[%x]: EC[%d]\n", sw_device_id, rc);
-			printk("value of rc from remove = %d", rc);
-			}
+		for (k = 0; k < 2; k++) {
+			printk("HDDL: platform_device_unregister = %d\n", k);
+			platform_device_unregister(soc->xlink_i2c_plt_dev[k]);
 		}
+
+		rc = xlink_close_channel(&soc->devH, chan_num);
+		printk(
+		    KERN_INFO
+		    "HDDL:Close Channel Number[%x]: [%u] EC[%d]\n",
+		    sw_device_id,
+		    chan_num,
+		    rc);
+
+		rc = xlink_disconnect(&soc->devH);
+		printk(
+			KERN_INFO
+			"HDDL:Disconnect[%x]: EC[%d]\n",
+			sw_device_id,
+			rc);
+		printk("value of rc from remove = %d", rc);
 	}
 }
 
@@ -323,22 +351,25 @@ uint32_t xlink_device_events[] = {
 };
 
 
-int hddl_device_pcie_event_notify(uint32_t sw_device_id, enum _xlink_device_event_type event_type)
+int hddl_event_notify(uint32_t swdevid, enum _xlink_device_event_type event)
 {
-	printk(KERN_INFO "HDDL:xlink pcie notify[%x]: [%d]\n", sw_device_id, event_type);
-	switch (event_type) {
+	printk(KERN_INFO "HDDL:xlink pcie notify[%x]: [%d]\n", swdevid, event);
+	switch (event) {
 	/*case _NOTIFY_INCOMING_DISCONNECTION:*/
 	case _NOTIFY_DEVICE_DISCONNECTED:
 	case _ERROR_UNEXPECTED_DISCONNECTION:
-		hddl_device_remove(sw_device_id);
+		hddl_device_remove(swdevid);
 		break;
 
 	case _NOTIFY_DEVICE_CONNECTED:
-		hddl_device_probe(sw_device_id);
+		hddl_device_probe(swdevid);
 		break;
 
 	default:
-		printk(KERN_INFO "HDDL:xlink pcie notify - Error[%x]: [%d]\n", sw_device_id, event_type);
+		printk(KERN_INFO
+			"HDDL:pcie notify-Error[%x]:[%d]\n",
+			swdevid,
+			event);
 		break;
 	}
 	return 0;
@@ -348,7 +379,7 @@ int hddl_per_device_connect_thread(void *thread_param)
 {
 	struct kmb *soc;
 	char device_name[XLINK_MAX_DEVICE_NAME_SIZE];
-	uint32_t device_status = 0xFF;
+	uint32_t status = 0xFF;
 	uint32_t board_info;
 	uint32_t board_id_rcvd;
 	uint32_t size = 0;
@@ -381,21 +412,24 @@ int hddl_per_device_connect_thread(void *thread_param)
 		msleep_interruptible(1000);
 	}
 
-	while ((rc = xlink_get_device_status(devH, &device_status)) != X_LINK_SUCCESS) {
+	while ((rc = xlink_get_device_status(devH, &status)) != X_LINK_SUCCESS) {
 
 	}
-	printk(KERN_INFO "HDDL:Device status[%d]: %u\n", rc, device_status);
+	printk(KERN_INFO "HDDL:Device status[%d]: %u\n", rc, status);
 	while ((rc = xlink_connect(devH)) != 0) {
 	}
 
 	chan_num = HDDL_NODE_XLINK_CHANNEL;
-	printk(KERN_INFO "HDDL:Channel Number[%x]: %u\n", devH->sw_device_id, chan_num);
+	printk(KERN_INFO
+		"HDDL:Channel Number[%x]: %u\n",
+		devH->sw_device_id,
+		chan_num);
 
 	xlink_pcie_register_device_event(devH->sw_device_id,
-									xlink_device_events,
-									_NUM_EVENT_TYPE,
-									hddl_device_pcie_event_notify,
-									0);
+				xlink_device_events,
+				_NUM_EVENT_TYPE,
+				hddl_event_notify,
+				0);
 
 
 	while ((rc = xlink_open_channel(devH,
@@ -428,8 +462,12 @@ int hddl_per_device_connect_thread(void *thread_param)
 	(uint8_t *) &board_id_rcvd, &size);
 	xlink_release_data(devH, chan_num, NULL);
 	printk(KERN_INFO
-				"HDDL: [%d]xlink_read_data completed Rcvd Size[%d]\n", rc, size);
-	printk(KERN_INFO "HDDL: Board Info[%x %x]\n", board_info, board_id_rcvd);
+		"HDDL: [%d]xlink_read_data done Rcvd Size[%d]\n", rc, size);
+	printk(
+		KERN_INFO "HDDL: Board Info[%x %x]\n",
+		board_info,
+		board_id_rcvd
+	);
 
 	if (board_info == ~(board_id_rcvd)) {
 		memcpy(&kmb_hddls[board_id].soc[kmb_id].devH, devH,
@@ -447,16 +485,20 @@ int hddl_per_device_connect_thread(void *thread_param)
 
 	ktime_get_real_ts64(&ts);
 	printk(KERN_INFO "S[%llx] NS[%lx]\n", ts.tv_sec, ts.tv_nsec);
-	rc = xlink_write_volatile(devH, chan_num, (uint8_t *) &ts, sizeof(struct timespec64));
-	printk(KERN_INFO "HDDL: Size Transferred[%d] = %ld\n", rc, sizeof(struct timespec64));
+	rc = xlink_write_volatile(
+		devH,
+		chan_num,
+		(uint8_t *) &ts,
+		sizeof(struct timespec64));
+	printk(KERN_INFO "HDDL: Size Transferred[%d] = %ld\n",
+		rc, sizeof(struct timespec64));
 
 	printk(KERN_INFO "HDDL: xlink_read_data to start...\n");
 	size = sizeof(board_id_rcvd);
 	rc = xlink_read_data_to_buffer(devH, chan_num,
 	(uint8_t *)&board_id_rcvd, &size);
 	xlink_release_data(devH, chan_num, NULL);
-	printk(KERN_INFO "HDDL: xlink_read_data completed Rcvd Size[%d][%d]\n",
-	rc, size);
+	printk(KERN_INFO "HDDL: xlink_read_data Done Size[%d][%d]\n", rc, size);
 
 	board_info = ~(board_id_rcvd);
 	printk(KERN_INFO "HDDL: xlink_write_data to start...\n");
@@ -487,15 +529,24 @@ int hddl_per_device_connect_thread(void *thread_param)
 				sizeof(kmb_hddls[board_id].soc[kmb_id]);
 		soc->xlink_i2c_plt_dev[j] =
 		platform_device_register_full(&xlink_i2c_info);
-		soc->adap[j] = *((struct i2c_adapter *)platform_get_drvdata(soc->xlink_i2c_plt_dev[j]));
+		soc->adap[j] =
+			*((struct i2c_adapter *)platform_get_drvdata(
+						soc->xlink_i2c_plt_dev[j]));
 		printk(KERN_INFO "Adapter number = %d\n", soc->adap[j].nr);
 	}
 	#ifndef CONFIG_HDDL_LOCAL_HOST
-	soc->soc_xlinki2c_cnt = sizeof(host_xlinki2c_devices)/sizeof(struct i2c_board_info);
+	soc->soc_xlinki2c_cnt
+	  = sizeof(host_xlinki2c_devices)/sizeof(struct i2c_board_info);
 
-	soc->soc_smbus = kzalloc(sizeof(struct i2c_client *) * (kmb_hddls[board_id].soc[kmb_id].soc_xlinki2c_cnt), GFP_KERNEL);
+	soc->soc_smbus
+		= kzalloc(
+			sizeof(struct i2c_client *) * (soc->soc_xlinki2c_cnt),
+			GFP_KERNEL);
 
-	soc->soc_xlinki2c = kzalloc(sizeof(struct i2c_client *) * (kmb_hddls[board_id].soc[kmb_id].soc_xlinki2c_cnt), GFP_KERNEL);
+	soc->soc_xlinki2c
+		= kzalloc(
+			sizeof(struct i2c_client *) * (soc->soc_xlinki2c_cnt),
+			GFP_KERNEL);
 
 	for (i = 0; i < soc->soc_xlinki2c_cnt; i++) {
 		temp_host_i2c_device = host_xlinki2c_devices[i];
@@ -507,15 +558,18 @@ int hddl_per_device_connect_thread(void *thread_param)
 		} else {
 			/* Slave address range 0x60 -- 0x6F */
 			temp_host_i2c_device.addr =
-						kmb_id + 0x60 + ((board_id - 5) * 3);
+				kmb_id + 0x60 + ((board_id - 5) * 3);
 		}
 		temp_host_i2c_device.platform_data = &(soc->devH.sw_device_id);
 
 		j = 0;
 		while ((temp = i2c_get_adapter(j)) != NULL) {
 			if (strstr(temp->name, "SMBus I801") != NULL) {
-				soc->soc_smbus[i] = i2c_new_device(temp, &temp_host_i2c_device);
-				printk("soc_smbus adapter %d", soc->soc_smbus[i]->adapter->nr);
+				soc->soc_smbus[i]
+				  = i2c_new_device(temp, &temp_host_i2c_device);
+				printk(
+					"soc_smbus adapter %d",
+					soc->soc_smbus[i]->adapter->nr);
 				break;
 			}
 			j++;
@@ -523,7 +577,9 @@ int hddl_per_device_connect_thread(void *thread_param)
 		soc->soc_xlinki2c[i] = i2c_new_device(i2c_get_adapter(
 				soc->adap[1].nr),
 				&temp_host_i2c_device);
-		printk("soc_xlinki2c adapter %d", soc->soc_xlinki2c[i]->adapter->nr);
+		printk(
+			"soc_xlinki2c adapter %d",
+			soc->soc_xlinki2c[i]->adapter->nr);
 
 		printk(KERN_INFO
 			"Host_kmb_tj [%s] %d\n",
@@ -531,9 +587,13 @@ int hddl_per_device_connect_thread(void *thread_param)
 			temp_host_i2c_device.addr);
 	}
 
-	soc->i2c_slaves_cnt = sizeof(soc_i2c_ext_devices)/sizeof(struct i2c_board_info);
+	soc->i2c_slaves_cnt
+		= sizeof(soc_i2c_ext_devices)/sizeof(struct i2c_board_info);
 
-	soc->i2c_slaves_ext = kzalloc(sizeof(struct i2c_client *) * (soc->i2c_slaves_cnt), GFP_KERNEL);
+	soc->i2c_slaves_ext
+		= kzalloc(
+			sizeof(struct i2c_client *) * (soc->i2c_slaves_cnt),
+			GFP_KERNEL);
 
 	mutex_lock(&my_mutex);
 
@@ -541,15 +601,21 @@ int hddl_per_device_connect_thread(void *thread_param)
 		soc->i2c_slaves_ext[i] = i2c_new_device(
 			i2c_get_adapter(soc->adap[0].nr),
 			&soc_i2c_ext_devices[i]);
-		printk("i2c_slaves_ext adapter %d", soc->i2c_slaves_ext[i]->adapter->nr);
+		printk(
+			"i2c_slaves_ext adapter %d",
+			soc->i2c_slaves_ext[i]->adapter->nr);
 
 		ssleep(1);
 	}
 	mutex_unlock(&my_mutex);
 
 	#else
-	soc->soc_xlinki2c_cnt = sizeof(kmb_i2c_devices)/sizeof(struct i2c_board_info);
-	soc->soc_xlinki2c = kzalloc(sizeof(struct i2c_client *) * (soc->soc_xlinki2c_cnt), GFP_KERNEL);
+	soc->soc_xlinki2c_cnt
+	= sizeof(kmb_i2c_devices)/sizeof(struct i2c_board_info);
+	soc->soc_xlinki2c
+	= kzalloc(
+		sizeof(struct i2c_client *) * (soc->soc_xlinki2c_cnt),
+		GFP_KERNEL);
 	for (i = 0; i < soc->soc_xlinki2c_cnt; i++) {
 		soc->soc_xlinki2c[i] = i2c_new_device(
 			i2c_get_adapter(soc->adap[1].nr),
@@ -566,7 +632,7 @@ int hddl_per_device_connect_thread(void *thread_param)
 #define SW_DEVICE_ID_INTERFACE_SHIFT 24U
 #define SW_DEVICE_ID_INTERFACE_MASK  0x7
 #define GET_INTERFACE_FROM_SW_DEVICE_ID(id) \
-		((id >> SW_DEVICE_ID_INTERFACE_SHIFT) & SW_DEVICE_ID_INTERFACE_MASK)
+	((id >> SW_DEVICE_ID_INTERFACE_SHIFT) & SW_DEVICE_ID_INTERFACE_MASK)
 #define SW_DEVICE_ID_IPC_INTERFACE  0x0
 #define SW_DEVICE_ID_PCIE_INTERFACE 0x1
 
@@ -606,13 +672,16 @@ static int hddl_device_thermal_init(void *thread_param)
 
 	for (i = 0; i < num_devices; i++) {
 		struct task_struct *task_recv;
-		if (GET_INTERFACE_FROM_SW_DEVICE_ID(xdevH[i].sw_device_id) == SW_DEVICE_ID_PCIE_INTERFACE) {
+		if (GET_INTERFACE_FROM_SW_DEVICE_ID(xdevH[i].sw_device_id)
+				== SW_DEVICE_ID_PCIE_INTERFACE) {
 			printk(KERN_INFO "HDDL:Booting device...\n");
 			task_recv = kthread_run(hddl_per_device_connect_thread,
 			(void *)&xdevH[i],
 			"hddl_per_device_thread");
 			if (task_recv == NULL)
-				printk(KERN_WARNING "hddl_device_init Thread creation failed");
+				printk(
+					KERN_WARNING
+					"HDDL Thread creation failed");
 		}
 
 	}
-- 
2.17.1

