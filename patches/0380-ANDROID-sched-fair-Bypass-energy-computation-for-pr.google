From 1f866d27ab308dd03813ae6bb44b1fc768f92fd1 Mon Sep 17 00:00:00 2001
From: Quentin Perret <quentin.perret@arm.com>
Date: Thu, 24 May 2018 17:35:02 +0100
Subject: [PATCH 380/404] ANDROID: sched/fair: Bypass energy computation for
 prefer_idle tasks

If the only pre-selected candidate CPU in find_energy_efficient_cpu()
happens to be prev_cpu, there is not point in computing the system
energy since we have nothing to compare it against, so we currently bail
out early. The same logic can be extended when prefer_idle tasks are
routed in the energy-aware wake-up path: if the only candidate is idle
for a prefer_idle task, just select it no matter what the energy impact
is. That should help speeding-up wake-ups of prefer_idle tasks, at least
when find_best_target() is used for them.

Signed-off-by: Quentin Perret <quentin.perret@arm.com>
Change-Id: Idd0e387e4a766061cc05d2584df3a31e4dabfd09
---
 kernel/sched/fair.c | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index 9e5f9c0cd709..637ae1eae58f 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -6985,11 +6985,17 @@ static int find_energy_efficient_cpu(struct task_struct *p, int prev_cpu,
 	else
 		select_max_spare_cap_cpus(sd, candidates, pd, p);
 
-	/* Bail out if there is no candidate, or if the only one is prev_cpu */
+	/* Bail out if no candidate was found. */
 	weight = cpumask_weight(candidates);
-	if (!weight || (weight == 1 && cpumask_first(candidates) == prev_cpu))
+	if (!weight)
 		return prev_cpu;
 
+	/* If there is only one sensible candidate, select it now. */
+	cpu = cpumask_first(candidates);
+	if (weight == 1 && ((schedtune_prefer_idle(p) && idle_cpu(cpu)) ||
+			    (cpu == prev_cpu)))
+		return cpu;
+
 	if (cpumask_test_cpu(prev_cpu, &p->cpus_allowed))
 		prev_energy = best_energy = compute_energy(p, prev_cpu, pd);
 	else
-- 
2.19.1

