From 35ca4100c544600896d154284c28b841c360f291 Mon Sep 17 00:00:00 2001
From: Voon Weifeng <weifeng.voon@intel.com>
Date: Fri, 12 Jun 2020 22:34:36 +0800
Subject: [PATCH 16/27] REVERTME: net: stmmac: do A0 WA based on stepping

The driver will do A0 WA when the cpuinfo stepping is 0.
Please take note that EHL A1 will not able to get the 2 PSE GBE
interface up as the stepping value for A1 is 1.

Signed-off-by: Voon Weifeng <weifeng.voon@intel.com>
---
 .../ethernet/stmicro/stmmac/stmmac_netproxy.c | 16 ++++++++-------
 .../net/ethernet/stmicro/stmmac/stmmac_pci.c  | 20 +++++++++++++++----
 2 files changed, 25 insertions(+), 11 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.c
index 0406f20891db..a0c5fcb2c9aa 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.c
@@ -121,13 +121,15 @@ irqreturn_t netproxy_isr_thread(int irq, void *dev_id)
 	}
 
 err_skb:
-	/* [REVERTME] DMA_CTL_CH(i) Workaround */
-	for (i = 0; i < EHL_PSE_ETH_DMA_TOTAL_CH; i++) {
-		value = readl(priv->ioaddr + EHL_PSE_ETH_DMA_MISC_OFFSET
-			      + i * sizeof(u32));
-		value |= EHL_PSE_ETH_DMA_MISC_DTM_DRAM;
-		writel(value, priv->ioaddr + EHL_PSE_ETH_DMA_MISC_OFFSET
-		       + i * sizeof(u32));
+	if (priv->plat->ehl_ao_wa) {
+		/* [REVERTME] DMA_CTL_CH(i) Workaround */
+		for (i = 0; i < EHL_PSE_ETH_DMA_TOTAL_CH; i++) {
+			value = readl(priv->ioaddr + EHL_PSE_ETH_DMA_MISC_OFFSET
+				      + i * sizeof(u32));
+			value |= EHL_PSE_ETH_DMA_MISC_DTM_DRAM;
+			writel(value, priv->ioaddr + EHL_PSE_ETH_DMA_MISC_OFFSET
+			       + i * sizeof(u32));
+		}
 	}
 
 	priv->networkproxy_exit = 1;
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
index 222d139d9724..1012b579a00c 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -19,6 +19,10 @@
 #include "dwmac4.h"
 #include "stmmac_ptp.h"
 
+#ifdef CONFIG_X86
+#define CPU_STEPPING	boot_cpu_data.x86_stepping
+#endif
+
 /*
  * This struct is used to associate PCI Function of MAC controller on a board,
  * discovered via DMI, with the address of PHY connected to the MAC. The
@@ -397,6 +401,9 @@ static void ehl_pse_work_around(struct pci_dev *pdev,
 	}
 	plat->is_hfpga = 0;
 	plat->ehl_ao_wa = 1;
+
+	if (plat->phy_interface == PHY_INTERFACE_MODE_SGMII)
+		plat->serdes_pse_sgmii_wa = 1;
 }
 
 static int ehl_pse0_common_data(struct pci_dev *pdev,
@@ -412,11 +419,14 @@ static int ehl_pse0_common_data(struct pci_dev *pdev,
 		plat->pmc_art_to_pse_art_ratio = ecx_pmc_art_freq /
 						 pse_art_freq;
 	}
+
+	/* WA needed for EHL A0 */
+	if (CPU_STEPPING == 0)
+		ehl_pse_work_around(pdev, plat);
 #endif
 
 	plat->is_pse = 1;
 	plat->dma_bit_mask = 32;
-	ehl_pse_work_around(pdev, plat);
 
 	if (plat->is_hfpga)
 		plat->clk_ptp_rate = 20000000;
@@ -452,7 +462,6 @@ static int ehl_pse0_sgmii1g_data(struct pci_dev *pdev,
 {
 	plat->phy_interface = PHY_INTERFACE_MODE_SGMII;
 	ehl_sgmii_path_latency_data(plat);
-	plat->serdes_pse_sgmii_wa = 1;
 
 	return ehl_pse0_common_data(pdev, plat);
 }
@@ -474,10 +483,14 @@ static int ehl_pse1_common_data(struct pci_dev *pdev,
 		plat->pmc_art_to_pse_art_ratio = ecx_pmc_art_freq /
 						 pse_art_freq;
 	}
+
+	/* WA needed for EHL A0 */
+	if (CPU_STEPPING == 0)
+		ehl_pse_work_around(pdev, plat);
 #endif
+
 	plat->is_pse = 1;
 	plat->dma_bit_mask = 32;
-	ehl_pse_work_around(pdev, plat);
 
 	if (plat->is_hfpga)
 		plat->clk_ptp_rate = 20000000;
@@ -514,7 +527,6 @@ static int ehl_pse1_sgmii1g_data(struct pci_dev *pdev,
 {
 	plat->phy_interface = PHY_INTERFACE_MODE_SGMII;
 	ehl_sgmii_path_latency_data(plat);
-	plat->serdes_pse_sgmii_wa = 1;
 
 	return ehl_pse1_common_data(pdev, plat);
 }
-- 
2.17.1

