From 1e251fec87d8e5ef0e9363619ba3ee56e7e46d3c Mon Sep 17 00:00:00 2001
From: Traian Schiau <traianx.schiau@intel.com>
Date: Thu, 31 Mar 2016 12:00:49 +0300
Subject: [PATCH 02/62] dvctrace-function: Implement DvC Trace USB Gadget
 function driver

Implement DvC Trace function class driver. Instances of this
function are able to connect to a dvctrace bus source driver.

Signed-off-by: Traian Schiau <traianx.schiau@intel.com>
Signed-off-by: Tian, Baofeng <baofeng.tian@intel.com>
---
 .../ABI/testing/configfs-usb-gadget-dvctrace       |   9 +
 MAINTAINERS                                        |   8 +
 drivers/usb/gadget/Kconfig                         |  11 +
 drivers/usb/gadget/function/Makefile               |   9 +
 drivers/usb/gadget/function/f_dvctrace.c           | 754 +++++++++++++++++++++
 drivers/usb/gadget/function/u_dvctrace.h           |  72 ++
 include/linux/usb/debug.h                          | 189 ++++++
 include/uapi/linux/usb/ch9.h                       |   1 +
 8 files changed, 1053 insertions(+)
 create mode 100644 Documentation/ABI/testing/configfs-usb-gadget-dvctrace
 create mode 100644 drivers/usb/gadget/function/f_dvctrace.c
 create mode 100644 drivers/usb/gadget/function/u_dvctrace.h
 create mode 100644 include/linux/usb/debug.h

diff --git a/Documentation/ABI/testing/configfs-usb-gadget-dvctrace b/Documentation/ABI/testing/configfs-usb-gadget-dvctrace
new file mode 100644
index 0000000..6391096
--- /dev/null
+++ b/Documentation/ABI/testing/configfs-usb-gadget-dvctrace
@@ -0,0 +1,9 @@
+What:		/config/usb-gadget/<gadget>/functions/dvctrace.<name>/source_dev
+Date:		Mar 2015
+KernelVersion:	4.0
+Contact:	Traian Schiau <traianx.schiau@intel.com>
+Description:	(R) The name of the source device paired with this function
+		instance, if upon creation of the instance a source device
+		named <name> exists and is free, the source device will be
+		associated with the current instance, otherwise the first free
+		source device will be used.
diff --git a/MAINTAINERS b/MAINTAINERS
index f64e2bb..22e93c4 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -5029,6 +5029,14 @@ F:	drivers/bus/dvctrace.c
 F:	include/linux/dvctrace.h
 F:	Documentation/ABI/testing/sysfs-bus-dvctrace
 
+DVC_TRACE USB_GADGET DRIVER
+M:	Traian Schiau <traianx.schiau@intel.com>
+S:	Maintained
+F:	drivers/usb/gadget/function/f_dvctrace.c
+F:	drivers/usb/gadget/function/u_dvctrace.h
+F:	include/linux/usb/debug.h
+F:	Documentation/ABI/testing/configfs-usb-gadget-dvctrace
+
 DYNAMIC DEBUG
 M:	Jason Baron <jbaron@akamai.com>
 S:	Maintained
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 31cce78..7974363 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -215,6 +215,10 @@ config USB_F_PRINTER
 config USB_F_TCM
 	tristate
 
+config USB_F_DVCTRACE
+	tristate
+	select DVC_TRACE_BUS
+
 # this first set of drivers all depend on bulk-capable hardware.
 
 config USB_CONFIGFS
@@ -508,6 +512,13 @@ choice
 	  controller, and the relevant drivers for each function declared
 	  by the device.
 
+config USB_CONFIGFS_F_DVCTRACE
+	bool "DvC Trace gadget"
+	depends on USB_CONFIGFS
+	select USB_F_DVCTRACE
+	help
+	  USB gadget DvC Trace support
+
 source "drivers/usb/gadget/legacy/Kconfig"
 
 endchoice
diff --git a/drivers/usb/gadget/function/Makefile b/drivers/usb/gadget/function/Makefile
index 5d3a6cf..2952adb 100644
--- a/drivers/usb/gadget/function/Makefile
+++ b/drivers/usb/gadget/function/Makefile
@@ -50,3 +50,12 @@ usb_f_printer-y			:= f_printer.o
 obj-$(CONFIG_USB_F_PRINTER)	+= usb_f_printer.o
 usb_f_tcm-y			:= f_tcm.o
 obj-$(CONFIG_USB_F_TCM)		+= usb_f_tcm.o
+usb_f_mtp-y                     := f_mtp.o
+obj-$(CONFIG_USB_F_MTP)         += usb_f_mtp.o
+usb_f_ptp-y                     := f_ptp.o
+obj-$(CONFIG_USB_F_PTP)         += usb_f_ptp.o
+usb_f_audio_source-y            := f_audio_source.o
+obj-$(CONFIG_USB_F_AUDIO_SRC)   += usb_f_audio_source.o
+usb_f_accessory-y               := f_accessory.o
+obj-$(CONFIG_USB_F_ACC)         += usb_f_accessory.o
+obj-$(CONFIG_USB_F_DVCTRACE)    += f_dvctrace.o
diff --git a/drivers/usb/gadget/function/f_dvctrace.c b/drivers/usb/gadget/function/f_dvctrace.c
new file mode 100644
index 0000000..dffd061
--- /dev/null
+++ b/drivers/usb/gadget/function/f_dvctrace.c
@@ -0,0 +1,754 @@
+/*
+ * Gadget Driver for DvC.Trace Function
+ *
+ * Copyright (C) 2015, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": %s: " fmt, __func__
+
+#ifdef VERBOSE_DEBUG
+#define DVCT_IN() pr_debug("in\n")
+#else
+#define DVCT_IN() do {} while (0)
+#endif
+
+#include <linux/module.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/usb/debug.h>
+#include "u_dvctrace.h"
+
+enum {
+	DVCT_IAD_DESC_POS,
+	DVCT_CITF_DESC_POS,
+	DVCT_DITF_DESC_POS,
+	DVCT_EP_DESC_POS,
+	DVCT_LS_NULL_DESC_POS, /*Low speed descriptors end with this one*/
+	DVCT_EP_COMP_DESC_POS = DVCT_LS_NULL_DESC_POS,
+	DVCT_LS_DESC_COUNT, /*Count of low speed descriptors*/
+	DVCT_NULL_DESC_POS = DVCT_LS_DESC_COUNT,
+	DVCT_HS_DESC_COUNT,/*Count of super speed descriptors*/
+};
+
+enum {
+	DVCT_STR_IAD_IDX,
+	DVCT_STR_C_ITF_IDX,
+	DVCT_STR_D_ITF_IDX,
+	DVCT_STR_NULL_IDX,	/*always last */
+	DVCT_STR_COUNT,
+};
+
+static int dvct_alloc_desc(struct dvct_function *d_fun)
+{
+	struct dvct_function_desc *desc = &d_fun->desc;
+
+	DVCT_IN();
+
+	desc->fs =
+	    kzalloc(DVCT_LS_DESC_COUNT * sizeof(struct usb_descriptor_header *),
+		    GFP_KERNEL);
+	if (!desc->fs)
+		goto err_fs;
+
+	desc->hs =
+	    kzalloc(DVCT_LS_DESC_COUNT * sizeof(struct usb_descriptor_header *),
+		    GFP_KERNEL);
+	if (!desc->hs)
+		goto err_hs;
+
+	desc->ss =
+	    kzalloc(DVCT_HS_DESC_COUNT * sizeof(struct usb_descriptor_header *),
+		    GFP_KERNEL);
+	if (!desc->ss)
+		goto err_ss;
+
+	/*IAD */
+	desc->iad = kzalloc(sizeof(*desc->iad), GFP_KERNEL);
+	if (!desc->iad)
+		goto err_iad;
+
+	desc->iad->bLength = sizeof(*desc->iad);
+	desc->iad->bDescriptorType = USB_DT_INTERFACE_ASSOCIATION;
+	desc->iad->bInterfaceCount = 2;
+	desc->iad->bFunctionClass = USB_CLASS_DEBUG;
+	desc->iad->bFunctionSubClass = USB_SUBCLASS_DVC_TRACE;
+	desc->iad->bFunctionProtocol = d_fun->source_dev->protocol;
+	/*bFirstInterface - updated on bind */
+
+	desc->fs[DVCT_IAD_DESC_POS] = (struct usb_descriptor_header *)desc->iad;
+	desc->hs[DVCT_IAD_DESC_POS] = (struct usb_descriptor_header *)desc->iad;
+	desc->ss[DVCT_IAD_DESC_POS] = (struct usb_descriptor_header *)desc->iad;
+
+	/*Control interface */
+	desc->c_itf = kzalloc(sizeof(*desc->c_itf), GFP_KERNEL);
+	if (!desc->c_itf)
+		goto err_c_itf;
+
+	desc->c_itf->bLength = USB_DT_INTERFACE_SIZE;
+	desc->c_itf->bDescriptorType = USB_DT_INTERFACE;
+	desc->c_itf->bInterfaceClass = USB_CLASS_DEBUG;
+	desc->c_itf->bInterfaceSubClass = USB_SUBCLASS_DEBUG_CONTROL;
+	desc->c_itf->bInterfaceProtocol = d_fun->source_dev->protocol;
+
+	desc->fs[DVCT_CITF_DESC_POS] =
+	    (struct usb_descriptor_header *)desc->c_itf;
+	desc->hs[DVCT_CITF_DESC_POS] =
+	    (struct usb_descriptor_header *)desc->c_itf;
+	desc->ss[DVCT_CITF_DESC_POS] =
+	    (struct usb_descriptor_header *)desc->c_itf;
+
+	/*Data interface */
+	desc->d_itf = kzalloc(sizeof(*desc->d_itf), GFP_KERNEL);
+	if (!desc->d_itf)
+		goto err_d_itf;
+
+	desc->d_itf->bLength = USB_DT_INTERFACE_SIZE;
+	desc->d_itf->bDescriptorType = USB_DT_INTERFACE;
+	desc->d_itf->bNumEndpoints = 1;
+	desc->d_itf->bInterfaceClass = USB_CLASS_DEBUG;
+	desc->d_itf->bInterfaceSubClass = USB_SUBCLASS_DVC_TRACE;
+	desc->d_itf->bInterfaceProtocol = d_fun->source_dev->protocol;
+
+	desc->fs[DVCT_DITF_DESC_POS] =
+	    (struct usb_descriptor_header *)desc->d_itf;
+	desc->hs[DVCT_DITF_DESC_POS] =
+	    (struct usb_descriptor_header *)desc->d_itf;
+	desc->ss[DVCT_DITF_DESC_POS] =
+	    (struct usb_descriptor_header *)desc->d_itf;
+
+	/*Full Speed ep */
+	desc->fs_ep = kzalloc(sizeof(*desc->fs_ep), GFP_KERNEL);
+	if (!desc->fs_ep)
+		goto err_fs_ep;
+
+	desc->fs_ep->bLength = USB_DT_ENDPOINT_SIZE;
+	desc->fs_ep->bDescriptorType = USB_DT_ENDPOINT;
+	desc->fs_ep->bEndpointAddress = USB_DIR_IN;
+	desc->fs_ep->bmAttributes = USB_ENDPOINT_XFER_BULK;
+	desc->fs_ep->wMaxPacketSize = cpu_to_le16(64);
+
+	desc->fs[DVCT_EP_DESC_POS] =
+	    (struct usb_descriptor_header *)desc->fs_ep;
+
+	/*High Speed ep */
+	desc->hs_ep = kzalloc(sizeof(*desc->hs_ep), GFP_KERNEL);
+	if (!desc->hs_ep)
+		goto err_hs_ep;
+
+	desc->hs_ep->bLength = USB_DT_ENDPOINT_SIZE;
+	desc->hs_ep->bDescriptorType = USB_DT_ENDPOINT;
+	desc->hs_ep->bEndpointAddress = USB_DIR_IN;
+	desc->hs_ep->bmAttributes = USB_ENDPOINT_XFER_BULK;
+	desc->hs_ep->wMaxPacketSize = cpu_to_le16(512);
+
+	desc->hs[DVCT_EP_DESC_POS] =
+	    (struct usb_descriptor_header *)desc->hs_ep;
+
+	/*Super Speed ep */
+	desc->ss_ep = kzalloc(sizeof(*desc->ss_ep), GFP_KERNEL);
+	if (!desc->ss_ep)
+		goto err_ss_ep;
+
+	desc->ss_ep->bLength = USB_DT_ENDPOINT_SIZE;
+	desc->ss_ep->bDescriptorType = USB_DT_ENDPOINT;
+	desc->ss_ep->bEndpointAddress = USB_DIR_IN;
+	desc->ss_ep->bmAttributes = USB_ENDPOINT_XFER_BULK;
+	desc->ss_ep->wMaxPacketSize = cpu_to_le16(1024);
+
+	desc->ss[DVCT_EP_DESC_POS] =
+	    (struct usb_descriptor_header *)desc->ss_ep;
+
+	/*Super Speed ep comp */
+	desc->ss_ep_comp = kzalloc(sizeof(*desc->ss_ep_comp), GFP_KERNEL);
+	if (!desc->ss_ep_comp)
+		goto err_ss_ep_comp;
+
+	desc->ss_ep_comp->bLength = USB_DT_SS_EP_COMP_SIZE;
+	desc->ss_ep_comp->bDescriptorType = USB_DT_SS_ENDPOINT_COMP;
+
+	desc->ss[DVCT_EP_COMP_DESC_POS] =
+	    (struct usb_descriptor_header *)desc->ss_ep_comp;
+
+	/* strings */
+	/*the table */
+	desc->str.language = 0x0409;	/*en-us */
+	desc->str.strings =
+	    kzalloc(DVCT_STR_COUNT * sizeof(struct usb_string), GFP_KERNEL);
+	if (!desc->str.strings)
+		goto err_str;
+
+	 /*IAD*/
+	    desc->str.strings[DVCT_STR_IAD_IDX].s =
+	    kasprintf(GFP_KERNEL, "DvC Trace (%s)",
+		      dev_name(&d_fun->source_dev->device));
+	if (!desc->str.strings[DVCT_STR_IAD_IDX].s)
+		goto err_str_iad;
+
+	/*control */
+	desc->str.strings[DVCT_STR_C_ITF_IDX].s =
+	    kasprintf(GFP_KERNEL, "DvC Trace Control (%s)",
+		      dev_name(&d_fun->source_dev->device));
+	if (!desc->str.strings[DVCT_STR_C_ITF_IDX].s)
+		goto err_str_ctrl;
+
+	/*data */
+	desc->str.strings[DVCT_STR_D_ITF_IDX].s =
+	    kasprintf(GFP_KERNEL, "DvC Trace Data (%s)",
+		      dev_name(&d_fun->source_dev->device));
+	if (!desc->str.strings[DVCT_STR_D_ITF_IDX].s)
+		goto err_str_data;
+
+	return 0;
+/*cleanup*/
+err_str_data:
+	kfree(desc->str.strings[DVCT_STR_C_ITF_IDX].s);
+err_str_ctrl:
+	kfree(desc->str.strings[DVCT_STR_IAD_IDX].s);
+err_str_iad:
+	kfree(desc->str.strings);
+err_str:
+	kfree(desc->ss_ep_comp);
+err_ss_ep_comp:
+	kfree(desc->ss_ep);
+err_ss_ep:
+	kfree(desc->hs_ep);
+err_hs_ep:
+	kfree(desc->fs_ep);
+err_fs_ep:
+	kfree(desc->d_itf);
+err_d_itf:
+	kfree(desc->c_itf);
+err_c_itf:
+	kfree(desc->iad);
+err_iad:
+	kfree(desc->ss);
+err_ss:
+	kfree(desc->hs);
+err_hs:
+	kfree(desc->fs);
+err_fs:
+	pr_err("Failed OFM");
+	return -ENOMEM;
+}
+
+static void dvct_free_desc(struct dvct_function *d_fun)
+{
+	struct dvct_function_desc *desc = &d_fun->desc;
+
+	DVCT_IN();
+
+	kfree(desc->str.strings[DVCT_STR_D_ITF_IDX].s);
+	kfree(desc->str.strings[DVCT_STR_C_ITF_IDX].s);
+	kfree(desc->str.strings[DVCT_STR_IAD_IDX].s);
+	kfree(desc->str.strings);
+	kfree(desc->ss_ep_comp);
+	kfree(desc->ss_ep);
+	kfree(desc->hs_ep);
+	kfree(desc->fs_ep);
+	kfree(desc->d_itf);
+	kfree(desc->c_itf);
+	kfree(desc->iad);
+	kfree(desc->ss);
+	kfree(desc->hs);
+	kfree(desc->fs);
+}
+
+ssize_t dvct_start_transfer(struct dvct_function *d_fun, u8 config)
+{
+	DVCT_IN();
+	if (!dvct_get_status(&d_fun->status, DVCT_MASK_ONLINE))
+		return -EIO;
+
+	d_fun->trace_config = config;
+	return d_fun->source_drv->start_transfer(d_fun->source_dev, config);
+}
+EXPORT_SYMBOL(dvct_start_transfer);
+
+int dvct_stop_transfer(struct dvct_function *d_fun)
+{
+
+	DVCT_IN();
+	if (!dvct_get_status(&d_fun->status, DVCT_MASK_ONLINE))
+		return -EIO;
+
+	if (dvct_get_status(&d_fun->status, DVCT_MASK_TRANS)) {
+		d_fun->trace_config = 0;
+		return d_fun->source_drv->stop_transfer(d_fun->source_dev);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dvct_stop_transfer);
+
+static int dvct_strings_setup(struct usb_composite_dev *cdev,
+				  struct dvct_function *f_fun)
+{
+	int status;
+
+	DVCT_IN();
+	if (!f_fun->desc.str.strings)
+		return -EINVAL;
+
+	status = usb_string_ids_tab(cdev, f_fun->desc.str.strings);
+	if (status < 0)
+		return status;
+
+	f_fun->desc.iad->iFunction =
+	    f_fun->desc.str.strings[DVCT_STR_IAD_IDX].id;
+	f_fun->desc.c_itf->iInterface =
+	    f_fun->desc.str.strings[DVCT_STR_C_ITF_IDX].id;
+	f_fun->desc.d_itf->iInterface =
+	    f_fun->desc.str.strings[DVCT_STR_D_ITF_IDX].id;
+
+	return 0;
+}
+
+static int dvct_setup(struct usb_function *func,
+		      const struct usb_ctrlrequest *ctrl)
+{
+	int status = -EOPNOTSUPP;
+	u16 w_index;
+	u16 w_value;
+	u16 w_length;
+	u8 b_index_value;
+	struct dvct_function *d_fun = to_dvct_function(func);
+
+	DVCT_IN();
+
+	w_index = le16_to_cpu(ctrl->wIndex);
+	w_value = le16_to_cpu(ctrl->wValue);
+	w_length = le16_to_cpu(ctrl->wLength);
+	b_index_value = (u8) (w_index >> 8);
+
+	if (ctrl->bRequestType !=
+	    (USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE))
+		goto done;
+
+	switch (ctrl->bRequest) {
+	case DC_REQUEST_SET_RESET:
+
+		pr_info("SET_RESET v%04x i%04x l%u\n",
+			w_value, w_index, w_length);
+
+		dvct_stop_transfer(d_fun);
+		status = 0;
+		break;
+
+	case DC_REQUEST_SET_TRACE:
+	/* There are some inconsistencies in the spec regarding some of the
+	 * control requests, like SET/GET _TRACE, where even if the message
+	 * is defined as interface specific the wIndex field is used for
+	 * something else, making these request unusable in a "standard"
+	 * composite device.
+	 * To get around this we expect the interface to be specified in
+	 * wIndex 7:0 and any other values in wIndex 15:8.
+	 * A "special" composite implementation is free to treat these setup
+	 * requests "on spec" and call directly dvct_start_transfer and/or
+	 * dvct_stop_transfer (exported in u_dvctrace.h).
+	 */
+		pr_info("SET_TRACE v%04x i%04x l%u\n",
+			w_value, w_index, w_length);
+
+		if (!b_index_value) {
+			dvct_stop_transfer(d_fun);
+			status = 0;
+		} else {
+			status = dvct_start_transfer(d_fun, b_index_value);
+		}
+		break;
+	}
+
+done:
+	if (status >= 0) {
+		d_fun->cdev->req->zero = 0;
+		d_fun->cdev->req->length = 0;
+		status =
+		    usb_ep_queue(d_fun->cdev->gadget->ep0, d_fun->cdev->req,
+				 GFP_ATOMIC);
+		if (status)
+			pr_err("Setup response queue error\n");
+	} else {
+		pr_debug("Unexpected request %02x.%02x v%04x i%04x l%u\n",
+			 ctrl->bRequestType, ctrl->bRequest, w_value, w_index,
+			 w_length);
+	}
+
+	return status;
+}
+
+static int dvct_function_bind(struct usb_configuration *cconfig,
+			      struct usb_function *func)
+{
+	int id, ret;
+	struct usb_ep *ep;
+	struct dvct_function *d_fun = to_dvct_function(func);
+
+	DVCT_IN();
+	d_fun->cdev = cconfig->cdev;
+
+	ret = dvct_strings_setup(d_fun->cdev, d_fun);
+	if (ret)
+		pr_warn("Cannot allocate function string id's\n");
+
+	/* allocate interface ID(s) */
+	id = usb_interface_id(cconfig, func);
+	if (id < 0)
+		return id;
+
+	d_fun->desc.c_itf->bInterfaceNumber = id;
+	d_fun->desc.iad->bFirstInterface = id;
+
+	pr_debug("Setting id %d for dvc-control interface\n", id);
+
+	id = usb_interface_id(cconfig, func);
+	if (id < 0)
+		return id;
+
+	d_fun->desc.d_itf->bInterfaceNumber = id;
+
+	pr_debug("Setting id %d for dvc-trace-data interface\n", id);
+
+	/* allocate endpoints */
+	d_fun->desc.ss_ep->wMaxPacketSize = 0;	/*get the real max */
+	ep = usb_ep_autoconfig_ss(d_fun->cdev->gadget,
+				  d_fun->desc.ss_ep, d_fun->desc.ss_ep_comp);
+
+	if (!ep) {
+		pr_err("usb_ep_autoconfig for ep_in failed\n");
+		return -ENODEV;
+	}
+
+	/*copy over the endpoint parameters */
+	d_fun->desc.hs_ep->bEndpointAddress =
+	    d_fun->desc.ss_ep->bEndpointAddress;
+	d_fun->desc.fs_ep->bEndpointAddress =
+	    d_fun->desc.ss_ep->bEndpointAddress;
+
+	if (le16_to_cpu(d_fun->desc.hs_ep->wMaxPacketSize) >
+	    le16_to_cpu(d_fun->desc.ss_ep->wMaxPacketSize))
+		d_fun->desc.hs_ep->wMaxPacketSize =
+		    d_fun->desc.ss_ep->wMaxPacketSize;
+
+	if (le16_to_cpu(d_fun->desc.fs_ep->wMaxPacketSize) >
+	    le16_to_cpu(d_fun->desc.ss_ep->wMaxPacketSize))
+		d_fun->desc.fs_ep->wMaxPacketSize =
+		    d_fun->desc.ss_ep->wMaxPacketSize;
+
+	pr_info("usb_ep_autoconfig %s, addr 0x%hhx, size ss=%hu hs=%hu fs=%hu\n",
+		ep->name,
+		d_fun->desc.ss_ep->bEndpointAddress,
+		d_fun->desc.ss_ep->wMaxPacketSize,
+		d_fun->desc.hs_ep->wMaxPacketSize,
+		d_fun->desc.fs_ep->wMaxPacketSize);
+
+	ep->driver_data = d_fun;	/* claim the endpoint */
+	d_fun->ep_in = ep;
+
+	ret = d_fun->source_drv->binded(d_fun->source_dev, ep,
+					&d_fun->function);
+
+	return ret;
+}
+
+static void dvct_function_unbind(struct usb_configuration *c,
+				 struct usb_function *func)
+{
+	struct dvct_function *d_fun = to_dvct_function(func);
+
+	DVCT_IN();
+	dvct_clr_status(&d_fun->status, DVCT_MASK_ONLINE);
+	d_fun->online_data = 0;
+	d_fun->online_ctrl = 0;
+
+	d_fun->source_drv->unbinded(d_fun->source_dev);
+}
+
+static int dvct_function_set_alt(struct usb_function *func,
+				 unsigned intf, unsigned alt)
+{
+	struct dvct_function *d_fun = to_dvct_function(func);
+	struct usb_composite_dev *cdev = func->config->cdev;
+	int ret;
+
+	DVCT_IN();
+
+	if (intf == d_fun->desc.c_itf->bInterfaceNumber) {
+		d_fun->online_ctrl = 1;
+		pr_debug("dvc-control interface %u set alt %u\n", intf, alt);
+	}
+
+	if (intf == d_fun->desc.d_itf->bInterfaceNumber) {
+		ret = config_ep_by_speed(cdev->gadget, func, d_fun->ep_in);
+		if (ret) {
+			pr_debug("intf: %d alt: %d ep_by_speed in err %d\n",
+				 intf, alt, ret);
+			return ret;
+		}
+
+		ret = usb_ep_enable(d_fun->ep_in);
+		if (ret) {
+			pr_debug("intf: %d alt: %d ep_enable in err %d\n",
+				 intf, alt, ret);
+			return ret;
+		}
+		d_fun->online_data = 1;
+	}
+
+	pr_info("dvc-trace interface %u set alt %u\n", intf, alt);
+
+	if (unlikely(dvct_get_status(&d_fun->status, DVCT_MASK_TRANS)))
+		dvct_stop_transfer(d_fun);
+
+	if (d_fun->online_data && d_fun->online_ctrl) {
+		dvct_set_status(&d_fun->status, DVCT_MASK_ONLINE);
+		if (d_fun->source_drv->connected)
+			d_fun->source_drv->connected(d_fun->source_dev,
+						     cdev->gadget->speed);
+	}
+	return 0;
+}
+
+static void dvct_function_disable(struct usb_function *func)
+{
+	struct dvct_function *d_fun = to_dvct_function(func);
+	struct usb_composite_dev *cdev;
+
+	DVCT_IN();
+
+	cdev = d_fun->cdev;
+
+	if (dvct_get_status(&d_fun->status, DVCT_MASK_TRANS))
+		dvct_stop_transfer(d_fun);
+
+	usb_ep_disable(d_fun->ep_in);
+
+	d_fun->online_ctrl = 0;
+	d_fun->online_data = 0;
+
+	if (d_fun->source_drv->disconnected)
+		d_fun->source_drv->disconnected(d_fun->source_dev);
+
+	pr_debug("%s disabled\n", d_fun->function.name);
+}
+
+CONFIGFS_ATTR_STRUCT(dvct_function_inst);
+
+static ssize_t dvct_attr_show(struct config_item *item,
+				    struct configfs_attribute *attr, char *page)
+{
+	struct dvct_function_inst *d_inst;
+	struct dvct_function_inst_attribute *d_fun_attr;
+	ssize_t ret = 0;
+
+	DVCT_IN();
+	d_inst = container_of(to_config_group(item), struct dvct_function_inst,
+			      instance.group);
+	d_fun_attr = container_of(attr, struct dvct_function_inst_attribute,
+				  attr);
+
+	if (d_fun_attr->show)
+		ret = d_fun_attr->show(d_inst, page);
+
+	return ret;
+}
+
+static void dvct_attr_release(struct config_item *item)
+{
+	struct dvct_function_inst *d_inst;
+
+	DVCT_IN();
+	d_inst = container_of(to_config_group(item), struct dvct_function_inst,
+			      instance.group);
+	usb_put_function_instance(&d_inst->instance);
+}
+
+static struct configfs_item_operations dvctrace_item_ops = {
+	.release        = dvct_attr_release,
+	.show_attribute = dvct_attr_show,
+};
+
+static ssize_t dvct_device_show(struct dvct_function_inst *d_inst, char *page)
+{
+	return sprintf(page, "%s\n", d_inst->source_dev->name_add);
+}
+
+static struct dvct_function_inst_attribute f_dvctrace_device =
+	__CONFIGFS_ATTR_RO(source_dev, dvct_device_show);
+
+static struct configfs_attribute *dvct_attrs[] = {
+	&f_dvctrace_device.attr,
+	NULL,
+};
+
+static struct config_item_type dvct_func_type = {
+	.ct_item_ops    = &dvctrace_item_ops,
+	.ct_attrs	= dvct_attrs,
+	.ct_owner       = THIS_MODULE,
+};
+
+static void dvct_free_func_inst(struct usb_function_instance *inst)
+{
+	struct dvct_function_inst *d_inst;
+
+	DVCT_IN();
+	d_inst = to_dvct_function_inst(inst);
+
+	spin_lock(&d_inst->source_dev->lock);
+	d_inst->source_dev->instance_taken = 0;
+	spin_unlock(&d_inst->source_dev->lock);
+
+	kfree(d_inst);
+}
+
+static int dvct_set_inst_name(struct usb_function_instance *inst,
+			      const char *name)
+{
+	struct dvct_function_inst *d_inst;
+	struct dvct_source_device *new_src;
+	struct dvct_source_device *old_src;
+
+	DVCT_IN();
+	d_inst = to_dvct_function_inst(inst);
+	old_src = d_inst->source_dev;
+
+	new_src = dvct_source_find_free_by_name(name);
+
+	if (IS_ERR_OR_NULL(new_src))
+		return -ENODEV;
+
+	if (new_src) {
+		spin_lock(&new_src->lock);
+		spin_lock(&old_src->lock);
+
+		d_inst->source_dev = new_src;
+		new_src->instance_taken = 1;
+		old_src->instance_taken = 0;
+
+		spin_unlock(&old_src->lock);
+		spin_unlock(&new_src->lock);
+	}
+	return 0;
+}
+
+static struct usb_function_instance *dvct_alloc_inst(void)
+{
+	struct dvct_function_inst *d_inst;
+	struct dvct_source_device *src_dev = NULL;
+
+	DVCT_IN();
+	/*get the first free source, this will change via set name
+	 * if available */
+	src_dev = dvct_source_find_free();
+
+	if (IS_ERR_OR_NULL(src_dev))
+		return ERR_PTR(-ENODEV);
+
+	d_inst = kzalloc(sizeof(*d_inst), GFP_KERNEL);
+
+	if (!d_inst)
+		return ERR_PTR(-ENOMEM);
+
+	d_inst->instance.free_func_inst = dvct_free_func_inst;
+	d_inst->instance.set_inst_name = dvct_set_inst_name;
+
+	spin_lock(&src_dev->lock);
+	d_inst->source_dev = src_dev;
+	src_dev->instance_taken = 1;
+	spin_unlock(&src_dev->lock);
+
+	config_group_init_type_name(&d_inst->instance.group,
+				    "", &dvct_func_type);
+	return &d_inst->instance;
+}
+
+static void dvct_free_func(struct usb_function *func)
+{
+	struct dvct_function *d_fun = to_dvct_function(func);
+
+	DVCT_IN();
+	d_fun->source_drv->deactivate(d_fun->source_dev);
+
+	spin_lock(&d_fun->source_dev->lock);
+	d_fun->source_dev->function_taken = 0;
+	spin_unlock(&d_fun->source_dev->lock);
+
+	dvct_free_desc(d_fun);
+
+	kfree(d_fun);
+}
+
+static struct usb_function *dvct_alloc_func(struct usb_function_instance *inst)
+{
+	int ret;
+	struct dvct_function *d_fun;
+	struct dvct_function_inst *d_inst = to_dvct_function_inst(inst);
+
+	DVCT_IN();
+	d_fun = kzalloc(sizeof(struct dvct_function), GFP_KERNEL);
+	if (!d_fun)
+		return ERR_PTR(-ENOMEM);
+
+	d_fun->source_dev = d_inst->source_dev;
+	d_fun->source_drv = dvct_source_get_drv(d_fun->source_dev);
+	d_fun->trace_config = 0;
+
+	spin_lock(&d_fun->source_dev->lock);
+	d_fun->source_dev->function_taken = 1;
+	spin_unlock(&d_fun->source_dev->lock);
+
+	ret = d_fun->source_drv->activate(d_fun->source_dev, &d_fun->status);
+	if (ret) {
+		pr_err("Cannot activate source device %d\n", ret);
+		goto err;
+	}
+
+	ret = dvct_alloc_desc(d_fun);
+	if (ret)
+		goto err_des;
+
+	/*String table */
+	d_fun->function.strings =
+		    kzalloc(2 * sizeof(struct usb_gadget_strings), GFP_KERNEL);
+
+	if (!d_fun->function.strings) {
+		ret = -ENOMEM;
+		goto err_string_table;
+	}
+
+	d_fun->function.strings[0] = &d_fun->desc.str;
+
+	d_fun->function.name = "dvctrace";
+	d_fun->function.fs_descriptors = d_fun->desc.fs;
+	d_fun->function.hs_descriptors = d_fun->desc.hs;
+	d_fun->function.ss_descriptors = d_fun->desc.ss;
+	d_fun->function.bind = dvct_function_bind;
+	d_fun->function.unbind = dvct_function_unbind;
+	d_fun->function.set_alt = dvct_function_set_alt;
+	d_fun->function.disable = dvct_function_disable;
+	d_fun->function.free_func = dvct_free_func;
+	d_fun->function.setup = dvct_setup;
+
+	return &d_fun->function;
+
+err_string_table:
+	dvct_free_desc(d_fun);
+err_des:
+	d_fun->source_drv->deactivate(d_fun->source_dev);
+err:
+	kfree(d_fun);
+	return ERR_PTR(ret);
+}
+
+DECLARE_USB_FUNCTION_INIT(dvctrace, dvct_alloc_inst, dvct_alloc_func);
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("DvC-Trace function driver");
+MODULE_AUTHOR("Traian Schiau <traianx.schiau@intel.com>");
diff --git a/drivers/usb/gadget/function/u_dvctrace.h b/drivers/usb/gadget/function/u_dvctrace.h
new file mode 100644
index 0000000..564d6fa
--- /dev/null
+++ b/drivers/usb/gadget/function/u_dvctrace.h
@@ -0,0 +1,72 @@
+
+/*
+ * Gadget Driver for DvC.Trace Function
+ *
+ * Copyright (C) 2015, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __U_DVCTRACE_H
+#define __U_DVCTRACE_H
+
+#include <linux/usb/composite.h>
+#include <linux/dvctrace.h>
+
+struct dvct_function_desc {
+	struct usb_descriptor_header **fs;
+	struct usb_descriptor_header **hs;
+	struct usb_descriptor_header **ss;
+
+	/*special descriptors, update on bind */
+	struct usb_interface_assoc_descriptor *iad;
+	struct usb_interface_descriptor *d_itf;
+	struct usb_interface_descriptor *c_itf;
+	struct usb_endpoint_descriptor *fs_ep;
+	struct usb_endpoint_descriptor *hs_ep;
+	struct usb_endpoint_descriptor *ss_ep;
+	struct usb_ss_ep_comp_descriptor *ss_ep_comp;
+
+	/* strings */
+	struct usb_gadget_strings str;
+};
+
+struct dvct_function {
+	struct usb_function function;
+	struct usb_composite_dev *cdev;
+	struct usb_ep *ep_in;
+
+	u32 online_data:1;	/*set to one when the data itf is set */
+	u32 online_ctrl:1;	/*set to one when the control itf is set */
+	atomic_t status;
+
+	struct dvct_source_device *source_dev;
+	struct dvct_source_driver *source_drv;
+
+	u8 trace_config;
+	struct dvct_function_desc desc;
+};
+
+struct dvct_function_inst {
+	struct usb_function_instance instance;
+	struct dvct_source_device *source_dev;
+};
+
+#define to_dvct_function_inst(inst) \
+	container_of(inst, struct dvct_function_inst, instance)
+
+#define to_dvct_function(func) \
+	container_of(func, struct dvct_function, function)
+
+ssize_t dvct_start_transfer(struct dvct_function *dev, u8 config);
+int dvct_stop_transfer(struct dvct_function *dev);
+
+#endif /*__U_DVCTRACE_H*/
diff --git a/include/linux/usb/debug.h b/include/linux/usb/debug.h
new file mode 100644
index 0000000..074b930
--- /dev/null
+++ b/include/linux/usb/debug.h
@@ -0,0 +1,189 @@
+/*
+ * <linux/usb/debug.h> -- USB Debug Class definitions.
+ *
+ * Usb debug class specific constants, based on:
+ * USB 3.1 Device Class Specification for Debug Devices
+ * Revision 1.0 â€“ July 14, 2015
+ * http://www.usb.org/developers/docs/usb_31_072715.zip
+ *
+ * Copyright (C) 2015, Intel Corporation.
+ *
+ * This software is distributed under the terms of the GNU General Public
+ * License ("GPL") version 2, as published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __LINUX_USB_DEBUG_H
+#define __LINUX_USB_DEBUG_H
+
+#include <linux/types.h>
+
+/*
+ * USB Debug Class Rev. 1.0
+ * Appendix A: Debug-Device-Class Codes
+ * Table 8-2: Debug Interface Sub-Class Code (SC_DEBUG)
+ */
+#define USB_SUBCLASS_DBC		0x02
+#define USB_SUBCLASS_DBC_DFX		0x03
+#define USB_SUBCLASS_DBC_TRACE		0x04
+#define USB_SUBCLASS_DVC_GP		0x05
+#define USB_SUBCLASS_DVC_DFX		0x06
+#define USB_SUBCLASS_DVC_TRACE		0x07
+#define USB_SUBCLASS_DEBUG_CONTROL	0x08
+
+/*
+ * USB Debug Class Rev. 1.0
+ * Appendix A: Debug-Device-Class Codes
+ * Table 8-3: Debug Interface Protocol Code (PC_DEBUG)
+ */
+#define DC_PROTOCOL_CODE_UNDEFINED	0x00
+#define DC_PROTOCOL_VENDOR_OR_GNU	0x01
+
+#define DC_PROTOCOL_GP_VENDOR	0x00
+#define DC_PROTOCOL_GP_GNU	0x01
+
+/*
+ * USB Debug Class Rev. 1.0
+ * 4.4.6 Debug-Unit Descriptor
+ * Table 4-9: Debug Unit Descriptor - bmControl
+ */
+#define DC_CTL_SET_CFG_DATA_SG			(1 << 0)
+#define DC_CTL_SET_CFG_DATA			(1 << 1)
+#define DC_CTL_GET_CFG_DATA			(1 << 2)
+#define DC_CTL_SET_CFG_ADDR			(1 << 3)
+#define DC_CTL_GET_CFG_ADDR			(1 << 4)
+#define DC_CTL_SET_OP_MODE			(1 << 7)
+#define DC_CTL_GET_OP_MODE			(1 << 8)
+#define DC_CTL_SET_BUFF_INFO			(1 << 11)
+#define DC_CTL_GET_BUFF_INFO			(1 << 12)
+#define DC_CTL_SET_RESET			(1 << 13)
+
+
+/*
+ * USB Debug Class Rev. 1.0
+ * Appendix A: Debug-Device-Class Codes
+ * Table 8-6: Debug Class-Specific Descriptor SubTypes
+ */
+#define DC_UNDEFINED			0x00
+#define DC_INPUT_CONNECTION		0x01
+#define DC_OUTPUT_CONNECTION		0x02
+#define DC_DEBUG_UNIT			0x03
+#define DC_DEBUG_ATTRIBUTES		0x04
+
+/*
+ * USB Debug Class Rev. 1.0
+ *
+ * 4.4.4 Input-Connection Descriptor
+ * Table 4-7: Input Connection Descriptor - bConnectionType
+ *
+ * 4.4.5 Output Connection Descriptor
+ * Table 4-8: Output Connection Descriptor - bConnectionType
+ */
+#define DC_CONNECTION_USB			0x00
+#define DC_CONNECTION_DEBUG_CONTROL		0x01
+#define DC_CONNECTION_DEBUG_DATA		0x02
+#define DC_CONNECTION_DEBUG_DATA_CONTROL	0x03
+
+
+/*
+ * USB Debug Class Rev. 1.0
+ * 4.4.6 Debug-Unit Descriptor
+ * Table 4-11: dTraceFormat
+ */
+#define DC_VENDOR_FORMAT(v, f)    (((v)<<24)|(f))
+/*Vendor N/A*/
+#define DC_TRACE_NOT_FORMATED_PASSTHROUGH	DC_VENDOR_FORMAT(0x0, 0x0)
+#define DC_TRACE_NOT_FORMATED_HEADER		DC_VENDOR_FORMAT(0x0, 0x1)
+#define DC_TRACE_NOT_FORMATED_FOOTER		DC_VENDOR_FORMAT(0x0, 0x2)
+#define DC_TRACE_NOT_FORMATED_GUID		DC_VENDOR_FORMAT(0x0, 0x5)
+#define DC_TRACE_NOT_FORMATED_UTF8		DC_VENDOR_FORMAT(0x0, 0x6)
+/*Vendor Intel*/
+#define DC_TRACE_INTEL_FORMATED_VENDOR		DC_VENDOR_FORMAT(0x1, 0x0)
+/*Vendor ARM*/
+#define DC_TRACE_ARM_FORMATED_VENDOR		DC_VENDOR_FORMAT(0x2, 0x0)
+/*Vendor ST*/
+#define DC_TRACE_ST_FORMATED_VENDOR		DC_VENDOR_FORMAT(0x3, 0x0)
+/*Vendor TI*/
+#define DC_TRACE_TI_FORMATED_VENDOR		DC_VENDOR_FORMAT(0x4, 0x0)
+/*Vendor Qualcomm*/
+#define DC_TRACE_QCOMM_FORMATED_VENDOR		DC_VENDOR_FORMAT(0x5, 0x0)
+/*Vendor AMD*/
+#define DC_TRACE_AMD_FORMATED_VENDOR		DC_VENDOR_FORMAT(0x6, 0x0)
+/*Vendor MIPI*/
+#define DC_TRACE_MIPI_FORMATED			DC_VENDOR_FORMAT(0x80, 0x0)
+/*Vendor Nexus*/
+#define DC_TRACE_NEXUS_FORMATED			DC_VENDOR_FORMAT(0x81, 0x0)
+
+/*
+ * USB Debug Class Rev. 1.0
+ * 4.4.6 Debug-Unit Descriptor
+ * Table 4-9: Debug Unit Descriptor - bDebugUnitType
+ */
+#define DC_UNIT_TYPE_UNDEFINED			0x00
+#define DC_UNIT_TYPE_DFX			0x01
+#define DC_UNIT_TYPE_SELECT			0x02
+#define DC_UNIT_TYPE_TRACE_ROUTE		0x03
+#define DC_UNIT_TYPE_TRACE_PROC			0x04
+#define DC_UNIT_TYPE_TRACE_GEN			0x05
+#define DC_UNIT_TYPE_TRACE_SINK			0x06
+#define DC_UNIT_TYPE_CONTROL			0x07
+#define DC_UNIT_TYPE_VENDOR_FIRST		0x40
+#define DC_UNIT_TYPE_VENDOR_LAST		0x5F
+
+/*
+ * USB Debug Class Rev. 1.0
+ * 4.4.6 Debug-Unit Descriptor
+ * Table 4-10: Debug Sub-Unit Type
+ */
+#define DC_UNIT_SUBTYPE_NULL			0x00
+#define DC_UNIT_SUBTYPE_CPU			0x01
+#define DC_UNIT_SUBTYPE_GFX			0x02
+#define DC_UNIT_SUBTYPE_VIDEO			0x03
+#define DC_UNIT_SUBTYPE_IMAGING			0x04
+#define DC_UNIT_SUBTYPE_AUDIO			0x05
+#define DC_UNIT_SUBTYPE_MODEM			0x06
+#define DC_UNIT_SUBTYPE_BLUETOOTH		0x07
+#define DC_UNIT_SUBTYPE_PWR_MGT			0x08
+#define DC_UNIT_SUBTYPE_SECURITY		0x09
+#define DC_UNIT_SUBTYPE_SENSOR			0x0A
+#define DC_UNIT_SUBTYPE_BUSWATCH		0x0B
+#define DC_UNIT_SUBTYPE_LOCATION		0x0C
+#define DC_UNIT_SUBTYPE_TRACEZIP		0x0D
+#define DC_UNIT_SUBTYPE_TAPCTL			0x0E
+#define DC_UNIT_SUBTYPE_MEMACC			0x0F
+#define DC_UNIT_SUBTYPE_OTHER			0x3F
+#define DC_UNIT_SUBTYPE_SWLOGGER		0x40
+#define DC_UNIT_SUBTYPE_SWROUTER		0x41
+#define DC_UNIT_SUBTYPE_SWUNINT			0x42
+#define DC_UNIT_SUBTYPE_SWCFGUNINT		0x43
+#define DC_UNIT_SUBTYPE_SWDEBUGGER		0x44
+#define DC_UNIT_SUBTYPE_VENDOR_FIRST		0x80
+#define DC_UNIT_SUBTYPE_VENDOR_LAST		0xBF
+#define DC_UNIT_SUBTYPE_STANDARDS		0xFF
+
+/*
+ * USB Debug Class Rev. 1.0
+ * Appendix A: Debug-Device-Class Codes
+ * Table 8-5: Debug Class-Specific Commands bRequest
+ */
+/*Set*/
+#define DC_REQUEST_SET_CONFIG_DATA		0x01 /*S 5.4.4 T 5-6*/
+#define DC_REQUEST_SET_CONFIG_DATA_SINGLE	0x02 /*S 5.4.3 T 5-4*/
+#define DC_REQUEST_SET_CONFIG_ADDRESS		0x03 /*S 5.4.6 T 5-8*/
+#define DC_REQUEST_SET_ALT_STACK		0x04 /*S 5.4.8 T 5-10*/
+#define DC_REQUEST_SET_OPERATING_MODE		0x05 /*S 5.4.10 T 5-15*/
+#define DC_REQUEST_SET_TRACE			0x06 /*S 5.4.14 T 5-23*/
+#define DC_REQUEST_SET_BUFFER			0x09 /*S 5.4.16 T 5-25*/
+#define DC_REQUEST_SET_RESET			0x0A /*S 5.4.18 T 5-28f*/
+/*Get*/
+#define DC_REQUEST_GET_CONFIG_DATA		0x81 /*S 5.4.5 T 5-7*/
+#define DC_REQUEST_GET_CONFIG_DATA_SINGLE	0x82
+#define DC_REQUEST_GET_CONFIG_ADDRESS		0x83 /*S 5.4.7 T 5-9*/
+#define DC_REQUEST_GET_ALT_STACK		0x84 /*S 5.4.9 T 5-11*/
+#define DC_REQUEST_GET_OPERATING_MODE		0x85 /*S 5.4.11 T 5-18*/
+#define DC_REQUEST_GET_TRACE			0x86 /*S 5.4.15 T 5-24*/
+#define DC_REQUEST_GET_INFO			0x87 /*S 5.4.12 T 5-19*/
+#define DC_REQUEST_GET_ERROR			0x88 /*S 5.4.13 T 5-21*/
+#define DC_REQUEST_GET_BUFFER			0x89 /*S 5.4.17 T 5-27*/
+
+#endif /* __LINUX_USB_DEBUG_H */
diff --git a/include/uapi/linux/usb/ch9.h b/include/uapi/linux/usb/ch9.h
index d5a5cae..821ff87 100644
--- a/include/uapi/linux/usb/ch9.h
+++ b/include/uapi/linux/usb/ch9.h
@@ -325,6 +325,7 @@ struct usb_device_descriptor {
 #define USB_CLASS_CSCID			0x0b	/* chip+ smart card */
 #define USB_CLASS_CONTENT_SEC		0x0d	/* content security */
 #define USB_CLASS_VIDEO			0x0e
+#define USB_CLASS_DEBUG			0xdc
 #define USB_CLASS_WIRELESS_CONTROLLER	0xe0
 #define USB_CLASS_MISC			0xef
 #define USB_CLASS_APP_SPEC		0xfe
-- 
2.7.4

