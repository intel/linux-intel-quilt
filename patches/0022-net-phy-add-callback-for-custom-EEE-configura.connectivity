From da24dbb8177692b18aeb9c14e3451f313a310027 Mon Sep 17 00:00:00 2001
From: "Vineetha G. Jaya Kumaran" <vineetha.g.jaya.kumaran@intel.com>
Date: Sun, 24 May 2020 19:30:58 +0800
Subject: [PATCH 22/40] net: phy: add callback for custom EEE configuration to
 struct phy_driver

This callback can be used if the generic EEE configuration flow
cannot be used for a particular PHY device.

Signed-off-by: Vineetha G. Jaya Kumaran <vineetha.g.jaya.kumaran@intel.com>
---
 drivers/net/phy/intel-gpy.c | 35 +++++++++++++++++++++++++++++++++++
 drivers/net/phy/phy.c       |  3 +++
 include/linux/phy.h         |  3 +++
 3 files changed, 41 insertions(+)

diff --git a/drivers/net/phy/intel-gpy.c b/drivers/net/phy/intel-gpy.c
index 2a83520a03f4..ff78879c82f5 100644
--- a/drivers/net/phy/intel-gpy.c
+++ b/drivers/net/phy/intel-gpy.c
@@ -38,6 +38,40 @@
 #define GPY_VSPEV2_WOL_AD23	0Xe09		/* WOL addr Byte3:Byte4 */
 #define GPY_VSPEV2_WOL_AD45	0xe0a		/* WOL addr Byte1:Byte2 */
 
+static int gpy_set_eee(struct phy_device *phydev, struct ethtool_eee *data)
+{
+	int cap, old_adv, adv = 0, ret;
+
+	cap = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);
+	if (cap < 0)
+		return cap;
+
+	old_adv = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV);
+	if (old_adv < 0)
+		return old_adv;
+
+	if (data->eee_enabled) {
+		adv = !data->advertised ? cap :
+		      ethtool_adv_to_mmd_eee_adv_t(data->advertised) & cap;
+		adv &= ~phydev->eee_broken_modes;
+	}
+
+	if (old_adv != adv) {
+		ret = phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, adv);
+		if (ret < 0)
+			return ret;
+
+		/* C45 access to restart autonegotiation is not supported
+		 * in the GPY PHYs, hence use C22 access for this.
+		 */
+		ret = genphy_restart_aneg(phydev);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
 static int gpy_config_aneg(struct phy_device *phydev)
 {
 	bool changed = false;
@@ -270,6 +304,7 @@ static struct phy_driver intel_gpy_drivers[] = {
 		.get_features	= genphy_c45_pma_read_abilities,
 		.aneg_done	= genphy_c45_aneg_done,
 		.soft_reset	= genphy_soft_reset,
+		.set_eee	= gpy_set_eee,
 		.ack_interrupt	= gpy_ack_interrupt,
 		.did_interrupt	= gpy_did_interrupt,
 		.config_intr	= gpy_config_intr,
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 35525a671400..5e2a0bc7e115 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -1379,6 +1379,9 @@ int phy_ethtool_set_eee(struct phy_device *phydev, struct ethtool_eee *data)
 	if (!phydev->drv)
 		return -EIO;
 
+	if (phydev->drv->set_eee)
+		return phydev->drv->set_eee(phydev, data);
+
 	/* Get Supported EEE */
 	cap = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);
 	if (cap < 0)
diff --git a/include/linux/phy.h b/include/linux/phy.h
index b35cd65a4694..61d8910d82a8 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -873,6 +873,9 @@ struct phy_driver {
 	int (*get_sqi)(struct phy_device *dev);
 	/** @get_sqi_max: Get the maximum signal quality indication */
 	int (*get_sqi_max)(struct phy_device *dev);
+
+	/* Set EEE properties */
+	int (*set_eee)(struct phy_device *phydev, struct ethtool_eee *data);
 };
 #define to_phy_driver(d) container_of(to_mdio_common_driver(d),		\
 				      struct phy_driver, mdiodrv)
-- 
2.27.0

