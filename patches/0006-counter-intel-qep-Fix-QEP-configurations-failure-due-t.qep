From 4c29d0573fcf8dd5b6df906b1559ab9e2cf8878f Mon Sep 17 00:00:00 2001
From: "Tan, Raymond" <raymond.tan@intel.com>
Date: Tue, 19 Nov 2019 07:35:03 +0800
Subject: [PATCH 06/15] counter: intel-qep: Fix QEP configurations failure due
 to RPM

When the device is in runtime-pm, the MMIO register value will be invalid,
thus reading and writing will have no effect to the device. This patch adds
the pm_runtime_* calls to ensure the device is in correct power state
before any MMIO register programming.

Signed-off-by: Tan, Raymond <raymond.tan@intel.com>
---
 drivers/counter/intel-qep.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/drivers/counter/intel-qep.c b/drivers/counter/intel-qep.c
index 1888e509be35..94d825bfb378 100644
--- a/drivers/counter/intel-qep.c
+++ b/drivers/counter/intel-qep.c
@@ -269,6 +269,8 @@ static int intel_qep_function_set(struct counter_device *counter,
 	struct intel_qep *qep = counter_to_qep(counter);
 	u32 reg;
 
+	pm_runtime_get_sync(qep->dev);
+
 	reg = intel_qep_readl(qep->regs, INTEL_QEPCON);
 	if (function == INTEL_QEP_ENCODER_MODE_SWAPPED)
 		reg |= INTEL_QEPCON_SWPAB;
@@ -276,6 +278,8 @@ static int intel_qep_function_set(struct counter_device *counter,
 		reg &= ~INTEL_QEPCON_SWPAB;
 	intel_qep_writel(qep->regs, INTEL_QEPCON, reg);
 
+	pm_runtime_put(qep->dev);
+
 	return 0;
 }
 
@@ -302,6 +306,8 @@ static int intel_qep_action_set(struct counter_device *counter,
 	struct intel_qep *qep = counter_to_qep(counter);
 	u32 reg;
 
+	pm_runtime_get_sync(qep->dev);
+
 	reg = intel_qep_readl(qep->regs, INTEL_QEPCON);
 
 	if (action == INTEL_QEP_SYNAPSE_ACTION_RISING_EDGE)
@@ -311,6 +317,8 @@ static int intel_qep_action_set(struct counter_device *counter,
 
 	intel_qep_writel(qep->regs, INTEL_QEPCON, reg);
 
+	pm_runtime_put(qep->dev);
+
 	return 0;
 }
 
@@ -381,8 +389,12 @@ static ssize_t ceiling_write(struct counter_device *counter,
 	if (ret < 0)
 		return ret;
 
+	pm_runtime_get_sync(qep->dev);
+
 	intel_qep_writel(qep->regs, INTEL_QEPMAX, max);
 
+	pm_runtime_put(qep->dev);
+
 	return len;
 }
 
@@ -482,6 +494,8 @@ static ssize_t noise_write(struct counter_device *counter, void *priv,
 	if (ret < 0)
 		return ret;
 
+	pm_runtime_get_sync(qep->dev);
+
 	if (max > 0x1fffff)
 		max = 0x1ffff;
 
@@ -495,6 +509,7 @@ static ssize_t noise_write(struct counter_device *counter, void *priv,
 	}
 
 	intel_qep_writel(qep->regs, INTEL_QEPCON, reg);
+	pm_runtime_put(qep->dev);
 	return len;
 }
 
@@ -526,6 +541,8 @@ static ssize_t preset_enable_write(struct counter_device *counter, void *priv,
 	if (ret < 0)
 		return ret;
 
+	pm_runtime_get_sync(qep->dev);
+
 	reg = intel_qep_readl(qep->regs, INTEL_QEPCON);
 
 	if (val)
@@ -534,6 +551,7 @@ static ssize_t preset_enable_write(struct counter_device *counter, void *priv,
 		reg |= INTEL_QEPCON_COUNT_RST_MODE;
 
 	intel_qep_writel(qep->regs, INTEL_QEPCON, reg);
+	pm_runtime_put(qep->dev);
 	return len;
 }
 
-- 
2.27.0

