From 8d43befbe47eb629a2f6ecf3612c2efa324e598e Mon Sep 17 00:00:00 2001
From: "Bandi, Kushal" <kushal.bandi@intel.com>
Date: Mon, 11 Jun 2018 00:48:33 -0700
Subject: [PATCH 1519/2104] pci:intel: Upgrading IPU to mr4_beta_20180506 FW
 release

Change-Id: Ieca03c1fa8e2c1112cd247c32416f44cba9b6b5d
---
 .gitignore                                         |   2 +
 drivers/media/i2c/Makefile                         |   1 -
 drivers/media/i2c/crlmodule/Makefile               |  22 +-
 .../i2c/crlmodule/crl_pixter_stub_configuration.h  | 194 ++++--
 drivers/media/i2c/crlmodule/crlmodule-data.c       |   6 +
 drivers/media/i2c/imx319.c                         |  28 +-
 drivers/media/i2c/imx355.c                         |  28 +-
 drivers/media/i2c/lc898122/Makefile                |  14 +-
 drivers/media/pci/intel/Kconfig                    |  13 +
 drivers/media/pci/intel/Makefile                   |  22 +-
 drivers/media/pci/intel/ici/Makefile               |  70 +-
 drivers/media/pci/intel/ici/ici-isys-csi2-be.c     |   4 +-
 drivers/media/pci/intel/ici/libintel-ipu4_ici.c    |   4 +-
 drivers/media/pci/intel/ipu-fw-isys.h              |   5 +
 drivers/media/pci/intel/ipu-fw-psys.c              |   1 +
 drivers/media/pci/intel/ipu-fw-psys.h              |  73 +-
 drivers/media/pci/intel/ipu-fw-resources.h         |  25 -
 drivers/media/pci/intel/ipu-isys-media.c           |  26 -
 drivers/media/pci/intel/ipu-isys-media.h           |  26 +-
 drivers/media/pci/intel/ipu-isys-queue.h           |   1 -
 drivers/media/pci/intel/ipu-isys-subdev.c          |   3 +-
 drivers/media/pci/intel/ipu-isys-tpg.c             |  11 +
 drivers/media/pci/intel/ipu-isys-tpg.h             |   5 +-
 drivers/media/pci/intel/ipu-isys-video.c           |   2 +-
 drivers/media/pci/intel/ipu-isys-video.h           |   5 +-
 drivers/media/pci/intel/ipu-isys.c                 |   4 +
 drivers/media/pci/intel/ipu-mmu.h                  |   2 -
 drivers/media/pci/intel/ipu-psys-compat32.c        |   2 +-
 drivers/media/pci/intel/ipu-psys.c                 | 741 ++-------------------
 drivers/media/pci/intel/ipu-psys.h                 |  78 ++-
 drivers/media/pci/intel/ipu-resources.h            | 154 -----
 drivers/media/pci/intel/ipu-trace.c                |  32 +-
 drivers/media/pci/intel/ipu-trace.h                |   2 -
 drivers/media/pci/intel/ipu-wrapper.h              |   4 -
 drivers/media/pci/intel/ipu4/Makefile              | 131 ++--
 drivers/media/pci/intel/ipu4/ipu-platform-regs.h   |   5 +
 .../media/pci/intel/ipu4/ipu-platform-resources.h  |  28 +-
 .../media/pci/intel/ipu4/ipu4-css/Makefile.isyslib |  42 +-
 .../intel/ipu4/ipu4-css/ia_css_fw_pkg_release.h    |   2 +-
 .../media/pci/intel/ipu4/ipu4-css/ipu-wrapper.c    | 512 --------------
 .../lib2600/config/isys/subsystem_bxtB0.mk         |  60 ++
 .../fw_abi_common_types/ia_css_terminal_defs.h     |   3 -
 .../isysapi/interface/ia_css_isysapi_types.h       |   1 +
 .../intel/ipu4/ipu4-css/lib2600/isysapi/isysapi.mk |   4 +
 .../lib2600/isysapi/src/ia_css_isys_public.c       |   3 +
 .../lib2600/regmem/interface/regmem_access.h       |  12 +-
 .../ipu4/ipu4-css/lib2600/support/math_support.h   |   1 +
 .../syscom/interface/ia_css_syscom_config.h        |   1 +
 .../ipu4-css/lib2600/syscom/src/ia_css_syscom.c    |   7 +
 .../pci/intel/ipu4/ipu4-css/lib2600psys/Makefile   |   7 +-
 .../DSS_V2_program_group/ia_css_fw_pkg_release.h   |   2 +-
 .../lib2600psys/lib/config/psys/subsystem_bxtB0.mk |  10 +-
 .../lib/fw_abi_common_types/ia_css_terminal_defs.h |   3 -
 .../src/bxt_spctrl_process_group_cmd_impl.c        |  74 +-
 .../data/src/ia_css_program_group_data_impl.h      |   2 +-
 .../psysapi/device/interface/ia_css_psys_device.h  |   3 +-
 .../lib/psysapi/device/src/ia_css_psys_device.c    |   7 +-
 .../interface/ia_css_psys_process_group_cmd_impl.h |  12 +
 .../lib/psysapi/dynamic/src/ia_css_psys_process.c  |   2 +-
 .../lib/regmem/interface/regmem_access.h           |  12 +-
 .../lib2600psys/lib/support/math_support.h         |   1 +
 .../lib/syscom/interface/ia_css_syscom_config.h    |   1 +
 .../lib2600psys/lib/syscom/src/ia_css_syscom.c     |   7 +
 .../ipu4/ipu4-css/lib2600psys/libcsspsys2600.c     |   5 +-
 drivers/media/pci/intel/ipu4/ipu4-fw-resources.c   |   8 +-
 drivers/media/pci/intel/ipu4/ipu4-isys-isa.h       |   6 +-
 drivers/media/pci/intel/ipu4/ipu4-psys.c           | 626 ++++++++++++++++-
 .../media/pci/intel/ipu4/ipu4-resource-tables.c    | 173 -----
 .../{ipu-resources.c => ipu4/ipu4-resources.c}     | 239 ++++++-
 drivers/media/pci/intel/ipu4/ipu4.c                |   6 +-
 .../intel/ipu4/ipu4p-css/Makefile.ipu4pisys_src    |   5 +-
 .../pci/intel/ipu4/ipu4p-css/Makefile.isyslib      |  42 +-
 .../intel/ipu4/ipu4p-css/ia_css_fw_pkg_release.h   |   2 +-
 .../lib2600/config/isys/subsystem_cnlB0.mk         |  73 ++
 .../lib2600/cpd_binary/ia_css_fw_pkg_release.h     |   2 +-
 .../fw_abi_common_types/ia_css_terminal_defs.h     |   3 -
 .../isysapi/interface/ia_css_isysapi_types.h       |   1 +
 .../ipu4/ipu4p-css/lib2600/isysapi/isysapi.mk      |   4 +
 .../lib2600/isysapi/src/ia_css_isys_public.c       |   3 +
 .../lib2600/regmem/interface/regmem_access.h       |  12 +-
 .../ipu4/ipu4p-css/lib2600/support/math_support.h  |   1 +
 .../syscom/interface/ia_css_syscom_config.h        |   1 +
 .../ipu4p-css/lib2600/syscom/src/ia_css_syscom.c   |   7 +
 .../pci/intel/ipu4/ipu4p-css/lib2600psys/Makefile  |   8 +-
 .../lib/CNL_program_group/ia_css_fw_pkg_release.h  |   2 +-
 .../lib/ICL_program_group/ia_css_fw_pkg_release.h  |   2 +-
 .../lib2600psys/lib/config/psys/subsystem_cnlB0.mk |  10 +-
 .../src/bxt_spctrl_process_group_cmd_impl.c        |  17 +-
 .../data/src/ia_css_program_group_data_impl.h      |  11 +-
 .../psysapi/device/interface/ia_css_psys_device.h  |   3 +-
 .../lib/psysapi/device/src/ia_css_psys_device.c    |   7 +-
 .../interface/ia_css_psys_process_group_cmd_impl.h |   3 +-
 .../lib/psysapi/dynamic/src/ia_css_psys_process.c  |   2 +
 .../static/src/ia_css_psys_terminal_manifest.c     |   3 +
 .../lib/regmem/interface/regmem_access.h           |  12 +-
 .../lib2600psys/lib/support/math_support.h         |   1 +
 .../lib/syscom/interface/ia_css_syscom_config.h    |   1 +
 .../lib2600psys/lib/syscom/src/ia_css_syscom.c     |   7 +
 .../ipu4/ipu4p-css/lib2600psys/libcsspsys2600.c    |  21 +-
 .../pci/intel/ipu4/ipu4p-css/libintel-ipu4p.c      |   2 +-
 drivers/media/platform/intel/Kconfig               |   2 +
 drivers/media/platform/intel/Makefile              |  22 +-
 drivers/media/platform/intel/ipu4-bxt-p-pdata.c    |  18 +-
 drivers/media/platform/intel/ipu4p-cnl-rvp-pdata.c |  16 +-
 drivers/media/platform/video-sensor-stub-pdata.c   |  11 -
 drivers/media/platform/video-sensor-stub.c         |   4 +
 106 files changed, 1849 insertions(+), 2120 deletions(-)
 delete mode 100644 drivers/media/pci/intel/ipu-fw-resources.h
 delete mode 100644 drivers/media/pci/intel/ipu-isys-media.c
 delete mode 100644 drivers/media/pci/intel/ipu-resources.h
 delete mode 100644 drivers/media/pci/intel/ipu4/ipu4-css/ipu-wrapper.c
 create mode 100644 drivers/media/pci/intel/ipu4/ipu4-css/lib2600/config/isys/subsystem_bxtB0.mk
 delete mode 100644 drivers/media/pci/intel/ipu4/ipu4-resource-tables.c
 rename drivers/media/pci/intel/{ipu-resources.c => ipu4/ipu4-resources.c} (68%)
 create mode 100644 drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/config/isys/subsystem_cnlB0.mk

diff --git a/.gitignore b/.gitignore
index f6050b8..acc55ac 100644
--- a/.gitignore
+++ b/.gitignore
@@ -122,3 +122,5 @@ all.config
 
 # Kdevelop4
 *.kdev4
+
+out/
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 3183283..90a213d 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -94,7 +94,6 @@ obj-$(CONFIG_VIDEO_IR_I2C)  += ir-kbd-i2c.o
 obj-$(CONFIG_VIDEO_ML86V7667)	+= ml86v7667.o
 obj-$(CONFIG_VIDEO_OV2659)	+= ov2659.o
 obj-$(CONFIG_VIDEO_TC358743)	+= tc358743.o
-
 obj-$(CONFIG_SDR_MAX2175) += max2175.o
 obj-$(CONFIG_VIDEO_LM3643) += lm3643.o
 obj-$(CONFIG_VIDEO_BU64295) += bu64295.o
diff --git a/drivers/media/i2c/crlmodule/Makefile b/drivers/media/i2c/crlmodule/Makefile
index d98a945..c3a1fed 100644
--- a/drivers/media/i2c/crlmodule/Makefile
+++ b/drivers/media/i2c/crlmodule/Makefile
@@ -1,15 +1,13 @@
-#
-#  Copyright (c) 2010 - 2018 Intel Corporation.
-#
-#  This program is free software; you can redistribute it and/or modify it
-#  under the terms and conditions of the GNU General Public License,
-#  version 2, as published by the Free Software Foundation.
-#
-#  This program is distributed in the hope it will be useful, but WITHOUT
-#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-#  more details.
-#
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (c) 2010 - 2018, Intel Corporation.
+
+# force check the compile warning to make sure zero warnings
+# note we may have build issue when gcc upgraded.
+ccflags-y := -Wall -Wextra
+ccflags-y += $(call cc-disable-warning, unused-parameter)
+ccflags-y += $(call cc-disable-warning, implicit-fallthrough)
+ccflags-y += $(call cc-disable-warning, missing-field-initializers)
+ccflags-$(CONFIG_VIDEO_INTEL_IPU_WERROR) += -Werror
 
 crlmodule-objs			+= crlmodule-core.o crlmodule-data.o \
 				   crlmodule-regs.o crlmodule-nvm.o \
diff --git a/drivers/media/i2c/crlmodule/crl_pixter_stub_configuration.h b/drivers/media/i2c/crlmodule/crl_pixter_stub_configuration.h
index 615a71b..ce675aa 100644
--- a/drivers/media/i2c/crlmodule/crl_pixter_stub_configuration.h
+++ b/drivers/media/i2c/crlmodule/crl_pixter_stub_configuration.h
@@ -33,6 +33,17 @@ static struct crl_pll_configuration pixter_stub_pll_configurations[] = {
 		.pll_regs_items = 0,
 		.pll_regs = NULL,
 	},
+	{
+		.input_clk = 24000000,
+		.op_sys_clk = 400000000,
+		.bitsperpixel = 12,
+		.pixel_rate_csi = 800000000,
+		.pixel_rate_pa = 800000000,
+		.comp_items = 0,
+		.ctrl_data = 0,
+		.pll_regs_items = 0,
+		.pll_regs = NULL,
+	},
 };
 
 static struct crl_subdev_rect_rep pixter_stub_720p_rects[] = {
@@ -268,6 +279,72 @@ static struct crl_sensor_subdev_config pixter_stub_b_sensor_subdevs[] = {
 	},
 };
 
+static struct crl_sensor_subdev_config pixter_stub_c_sensor_subdevs[] = {
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_SCALER,
+		.name = "pixter_stubC scaler",
+	},
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_PIXEL_ARRAY,
+		.name = "pixter_stubC pixel array",
+	},
+};
+
+static struct crl_sensor_subdev_config pixter_stub_d_sensor_subdevs[] = {
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_SCALER,
+		.name = "pixter_stubD scaler",
+	},
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_PIXEL_ARRAY,
+		.name = "pixter_stubD pixel array",
+	},
+};
+
+static struct crl_sensor_subdev_config pixter_stub_e_sensor_subdevs[] = {
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_SCALER,
+		.name = "pixter_stubE scaler",
+	},
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_PIXEL_ARRAY,
+		.name = "pixter_stubE pixel array",
+	},
+};
+
+static struct crl_sensor_subdev_config pixter_stub_f_sensor_subdevs[] = {
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_SCALER,
+		.name = "pixter_stubF scaler",
+	},
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_PIXEL_ARRAY,
+		.name = "pixter_stubF pixel array",
+	},
+};
+
+static struct crl_sensor_subdev_config pixter_stub_g_sensor_subdevs[] = {
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_SCALER,
+		.name = "pixter_stubG scaler",
+	},
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_PIXEL_ARRAY,
+		.name = "pixter_stubG pixel array",
+	},
+};
+
+static struct crl_sensor_subdev_config pixter_stub_h_sensor_subdevs[] = {
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_SCALER,
+		.name = "pixter_stubH scaler",
+	},
+	{
+		.subdev_type = CRL_SUBDEV_TYPE_PIXEL_ARRAY,
+		.name = "pixter_stubH pixel array",
+	},
+};
+
 static struct crl_sensor_limits pixter_stub_sensor_limits = {
 	.x_addr_min = 0,
 	.y_addr_min = 0,
@@ -583,78 +660,51 @@ static struct crl_v4l2_ctrl pixter_stub_v4l2_ctrls[] = {
 	},
 };
 
-static struct crl_sensor_configuration pixter_stub_crl_configuration = {
-	.powerup_regs_items = 0,
-	.powerup_regs = NULL,
-
-	.poweroff_regs_items = 0,
-	.poweroff_regs = NULL,
-
-	.id_reg_items = 0,
-	.id_regs = NULL,
-
-	.subdev_items = ARRAY_SIZE(pixter_stub_sensor_subdevs),
-	.subdevs = pixter_stub_sensor_subdevs,
-
-	.sensor_limits = &pixter_stub_sensor_limits,
+#define DEFINE_PIXTER_CRL_CONFIGURATION(port) \
+static struct crl_sensor_configuration pixter_##port##_crl_configuration = { \
+	.powerup_regs_items = 0, \
+	.powerup_regs = NULL, \
+\
+	.poweroff_regs_items = 0, \
+	.poweroff_regs = NULL, \
+\
+	.id_reg_items = 0, \
+	.id_regs = NULL, \
+\
+	.subdev_items = ARRAY_SIZE(pixter_##port##_sensor_subdevs), \
+	.subdevs = pixter_##port##_sensor_subdevs, \
+\
+	.sensor_limits = &pixter_stub_sensor_limits, \
+\
+	.pll_config_items = ARRAY_SIZE(pixter_stub_pll_configurations), \
+	.pll_configs = pixter_stub_pll_configurations, \
+\
+	.modes_items = ARRAY_SIZE(pixter_stub_modes), \
+	.modes = pixter_stub_modes, \
+\
+	.streamon_regs_items = 0, \
+	.streamon_regs = NULL, \
+\
+	.streamoff_regs_items = 0, \
+	.streamoff_regs = NULL, \
+\
+	.v4l2_ctrls_items = ARRAY_SIZE(pixter_stub_v4l2_ctrls), \
+	.v4l2_ctrl_bank = pixter_stub_v4l2_ctrls, \
+\
+	.flip_items = ARRAY_SIZE(pixter_stub_flip_configurations), \
+	.flip_data = pixter_stub_flip_configurations, \
+\
+	.csi_fmts_items = ARRAY_SIZE(pixter_stub_crl_csi_data_fmt), \
+	.csi_fmts = pixter_stub_crl_csi_data_fmt, \
+}
+DEFINE_PIXTER_CRL_CONFIGURATION(stub);
+DEFINE_PIXTER_CRL_CONFIGURATION(stub_b);
+DEFINE_PIXTER_CRL_CONFIGURATION(stub_c);
+DEFINE_PIXTER_CRL_CONFIGURATION(stub_d);
+DEFINE_PIXTER_CRL_CONFIGURATION(stub_e);
+DEFINE_PIXTER_CRL_CONFIGURATION(stub_f);
+DEFINE_PIXTER_CRL_CONFIGURATION(stub_g);
+DEFINE_PIXTER_CRL_CONFIGURATION(stub_h);
 
-	.pll_config_items = ARRAY_SIZE(pixter_stub_pll_configurations),
-	.pll_configs = pixter_stub_pll_configurations,
-
-	.modes_items = ARRAY_SIZE(pixter_stub_modes),
-	.modes = pixter_stub_modes,
-
-	.streamon_regs_items = 0,
-	.streamon_regs = NULL,
-
-	.streamoff_regs_items = 0,
-	.streamoff_regs = NULL,
-
-	.v4l2_ctrls_items = ARRAY_SIZE(pixter_stub_v4l2_ctrls),
-	.v4l2_ctrl_bank = pixter_stub_v4l2_ctrls,
-
-	.flip_items = ARRAY_SIZE(pixter_stub_flip_configurations),
-	.flip_data = pixter_stub_flip_configurations,
-
-	.csi_fmts_items = ARRAY_SIZE(pixter_stub_crl_csi_data_fmt),
-	.csi_fmts = pixter_stub_crl_csi_data_fmt,
-};
-
-static struct crl_sensor_configuration pixter_stub_b_crl_configuration = {
-	.powerup_regs_items = 0,
-	.powerup_regs = NULL,
-
-	.poweroff_regs_items = 0,
-	.poweroff_regs = NULL,
-
-	.id_reg_items = 0,
-	.id_regs = NULL,
-
-	.subdev_items = ARRAY_SIZE(pixter_stub_b_sensor_subdevs),
-	.subdevs = pixter_stub_b_sensor_subdevs,
-
-	.sensor_limits = &pixter_stub_sensor_limits,
-
-	.pll_config_items = ARRAY_SIZE(pixter_stub_pll_configurations),
-	.pll_configs = pixter_stub_pll_configurations,
-
-	.modes_items = ARRAY_SIZE(pixter_stub_modes),
-	.modes = pixter_stub_modes,
-
-	.streamon_regs_items = 0,
-	.streamon_regs = NULL,
-
-	.streamoff_regs_items = 0,
-	.streamoff_regs = NULL,
-
-	.v4l2_ctrls_items = ARRAY_SIZE(pixter_stub_v4l2_ctrls),
-	.v4l2_ctrl_bank = pixter_stub_v4l2_ctrls,
-
-	.flip_items = ARRAY_SIZE(pixter_stub_flip_configurations),
-	.flip_data = pixter_stub_flip_configurations,
-
-	.csi_fmts_items = ARRAY_SIZE(pixter_stub_crl_csi_data_fmt),
-	.csi_fmts = pixter_stub_crl_csi_data_fmt,
-};
 
 #endif  /* __CRLMODULE_PIXTER_STUB_CONFIGURATION_H_ */
diff --git a/drivers/media/i2c/crlmodule/crlmodule-data.c b/drivers/media/i2c/crlmodule/crlmodule-data.c
index 3461028..9c1606f 100755
--- a/drivers/media/i2c/crlmodule/crlmodule-data.c
+++ b/drivers/media/i2c/crlmodule/crlmodule-data.c
@@ -63,6 +63,12 @@ static const struct crlmodule_sensors supported_sensors[] = {
 	{ "IMX290", "imx290", &imx290_crl_configuration},
 	{ "PIXTER_STUB", "pixter_stub", &pixter_stub_crl_configuration},
 	{ "PIXTER_STUB_B", "pixter_stub_b", &pixter_stub_b_crl_configuration},
+	{ "PIXTER_STUB_C", "pixter_stub_c", &pixter_stub_c_crl_configuration},
+	{ "PIXTER_STUB_D", "pixter_stub_d", &pixter_stub_d_crl_configuration},
+	{ "PIXTER_STUB_E", "pixter_stub_e", &pixter_stub_e_crl_configuration},
+	{ "PIXTER_STUB_F", "pixter_stub_f", &pixter_stub_f_crl_configuration},
+	{ "PIXTER_STUB_G", "pixter_stub_g", &pixter_stub_g_crl_configuration},
+	{ "PIXTER_STUB_H", "pixter_stub_h", &pixter_stub_h_crl_configuration},
 	{ "INT3474", "ov2740", &ov2740_crl_configuration },
 	{ "MAGNA", "magna", &magna_crl_configuration },
 	{ "AR023Z", "ar023z", &ar023z_crl_configuration },
diff --git a/drivers/media/i2c/imx319.c b/drivers/media/i2c/imx319.c
index 08e9919..909e927 100644
--- a/drivers/media/i2c/imx319.c
+++ b/drivers/media/i2c/imx319.c
@@ -41,11 +41,12 @@
 #define IMX319_ANA_GAIN_DEFAULT		0
 
 /* Digital gain control */
-#define IMX319_REG_DIGITAL_GAIN		0x020e
-#define IMX319_DGTL_GAIN_MIN		0x100
-#define IMX319_DGTL_GAIN_MAX		0xfff
-#define IMX319_DGTL_GAIN_DEFAULT	0x100
+#define IMX319_REG_DPGA_USE_GLOBAL_GAIN	0x3ff9
+#define IMX319_REG_DIG_GAIN_GLOBAL	0x020e
+#define IMX319_DGTL_GAIN_MIN		256
+#define IMX319_DGTL_GAIN_MAX		4095
 #define IMX319_DGTL_GAIN_STEP		1
+#define IMX319_DGTL_GAIN_DEFAULT	256
 
 /* Test Pattern Control */
 #define IMX319_REG_TEST_PATTERN		0x0600
@@ -1590,9 +1591,9 @@ static const struct imx319_reg mode_1280x720_regs[] = {
 
 static const char * const imx319_test_pattern_menu[] = {
 	"Disabled",
-	"Solid Color",
-	"Color Bars",
-	"Grey Color Bars",
+	"Solid color",
+	"100% color bars",
+	"Fade to gray color bars",
 	"PN9"
 };
 
@@ -1853,14 +1854,22 @@ static int imx319_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 
 static int imx319_update_digital_gain(struct imx319 *imx319, u32 d_gain)
 {
-	return imx319_write_reg(imx319, IMX319_REG_DIGITAL_GAIN,
+	int ret;
+
+	ret = imx319_write_reg(imx319, IMX319_REG_DPGA_USE_GLOBAL_GAIN,
+			       IMX319_REG_VALUE_08BIT, 1);
+	if (ret)
+		return ret;
+
+	/* Digital gain = (d_gain & 0xFF00) + (d_gain & 0xFF)/256 times */
+	return imx319_write_reg(imx319, IMX319_REG_DIG_GAIN_GLOBAL,
 				IMX319_REG_VALUE_16BIT, d_gain);
 }
 
 static int imx319_enable_test_pattern(struct imx319 *imx319, u32 pattern)
 {
 	return imx319_write_reg(imx319, IMX319_REG_TEST_PATTERN,
-				 IMX319_REG_VALUE_08BIT, pattern);
+				 IMX319_REG_VALUE_16BIT, pattern);
 }
 
 static int imx319_set_ctrl(struct v4l2_ctrl *ctrl)
@@ -1892,6 +1901,7 @@ static int imx319_set_ctrl(struct v4l2_ctrl *ctrl)
 	ret = 0;
 	switch (ctrl->id) {
 	case V4L2_CID_ANALOGUE_GAIN:
+		/* Analog gain = 1024/(1024 - ctrl->val) times */
 		ret = imx319_write_reg(imx319, IMX319_REG_ANALOG_GAIN,
 					IMX319_REG_VALUE_16BIT, ctrl->val);
 		break;
diff --git a/drivers/media/i2c/imx355.c b/drivers/media/i2c/imx355.c
index 84efbe1..3681df6 100644
--- a/drivers/media/i2c/imx355.c
+++ b/drivers/media/i2c/imx355.c
@@ -41,11 +41,12 @@
 #define IMX355_ANA_GAIN_DEFAULT		0
 
 /* Digital gain control */
-#define IMX355_REG_DIGITAL_GAIN		0x020e
-#define IMX355_DGTL_GAIN_MIN		0
-#define IMX355_DGTL_GAIN_MAX		3840
-#define IMX355_DGTL_GAIN_DEFAULT	256
+#define IMX355_REG_DPGA_USE_GLOBAL_GAIN	0x3070
+#define IMX355_REG_DIG_GAIN_GLOBAL	0x020e
+#define IMX355_DGTL_GAIN_MIN		256
+#define IMX355_DGTL_GAIN_MAX		4095
 #define IMX355_DGTL_GAIN_STEP		1
+#define IMX355_DGTL_GAIN_DEFAULT	256
 
 /* Test Pattern Control */
 #define IMX355_REG_TEST_PATTERN		0x0600
@@ -818,9 +819,9 @@ static const struct imx355_reg mode_820x616_regs[] = {
 
 static const char * const imx355_test_pattern_menu[] = {
 	"Disabled",
-	"Solid Color",
-	"Color Bars",
-	"Grey Color Bars",
+	"Solid color",
+	"100% color bars",
+	"Fade to gray color bars",
 	"PN9"
 };
 
@@ -1147,14 +1148,22 @@ static int imx355_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 
 static int imx355_update_digital_gain(struct imx355 *imx355, u32 d_gain)
 {
-	return imx355_write_reg(imx355, IMX355_REG_DIGITAL_GAIN,
+	int ret;
+
+	ret = imx355_write_reg(imx355, IMX355_REG_DPGA_USE_GLOBAL_GAIN,
+			       IMX355_REG_VALUE_08BIT, 1);
+	if (ret)
+		return ret;
+
+	/* Digital gain = (d_gain & 0xFF00) + (d_gain & 0xFF)/256 times */
+	return imx355_write_reg(imx355, IMX355_REG_DIG_GAIN_GLOBAL,
 				IMX355_REG_VALUE_16BIT, d_gain);
 }
 
 static int imx355_enable_test_pattern(struct imx355 *imx355, u32 pattern)
 {
 	return imx355_write_reg(imx355, IMX355_REG_TEST_PATTERN,
-				 IMX355_REG_VALUE_08BIT, pattern);
+				 IMX355_REG_VALUE_16BIT, pattern);
 }
 
 static int imx355_set_ctrl(struct v4l2_ctrl *ctrl)
@@ -1186,6 +1195,7 @@ static int imx355_set_ctrl(struct v4l2_ctrl *ctrl)
 	ret = 0;
 	switch (ctrl->id) {
 	case V4L2_CID_ANALOGUE_GAIN:
+		/* Analog gain = 1024/(1024 - ctrl->val) times */
 		ret = imx355_write_reg(imx355, IMX355_REG_ANALOG_GAIN,
 					IMX355_REG_VALUE_16BIT, ctrl->val);
 		break;
diff --git a/drivers/media/i2c/lc898122/Makefile b/drivers/media/i2c/lc898122/Makefile
index cfac363..4ad76ba 100644
--- a/drivers/media/i2c/lc898122/Makefile
+++ b/drivers/media/i2c/lc898122/Makefile
@@ -1,15 +1,5 @@
-#
-#  Copyright (c) 2010 - 2018 Intel Corporation.
-#
-#  This program is free software; you can redistribute it and/or modify it
-#  under the terms and conditions of the GNU General Public License,
-#  version 2, as published by the Free Software Foundation.
-#
-#  This program is distributed in the hope it will be useful, but WITHOUT
-#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-#  more details.
-#
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (c) 2010 - 2018, Intel Corporation.
 
 ifneq ($(EXTERNAL_BUILD), 1)
 srcpath := $(srctree)
diff --git a/drivers/media/pci/intel/Kconfig b/drivers/media/pci/intel/Kconfig
index 9eecd5a..140822f 100644
--- a/drivers/media/pci/intel/Kconfig
+++ b/drivers/media/pci/intel/Kconfig
@@ -44,6 +44,19 @@ config VIDEO_INTEL_IPU_FW_LIB
 	---help---
 	If selected, the firmware hostlib css would be compiled
 
+config VIDEO_INTEL_IPU_WERROR
+	bool "Force GCC to throw an error instead of a warning when compiling"
+	depends on VIDEO_INTEL_IPU
+	depends on EXPERT
+	depends on !COMPILE_TEST
+	default n
+	help
+	  Add -Werror to the build flags for (and only for) intel ipu module.
+	  Do not enable this unless you are writing code for the ipu module.
+
+	  Recommended for driver developers only.
+
+	  If in doubt, say "N".
 config VIDEO_INTEL_ICI
 	bool "Compile for ICI driver"
 	---help---
diff --git a/drivers/media/pci/intel/Makefile b/drivers/media/pci/intel/Makefile
index d6f49e8..63dd58b 100644
--- a/drivers/media/pci/intel/Makefile
+++ b/drivers/media/pci/intel/Makefile
@@ -1,15 +1,13 @@
-#
-#  Copyright (c) 2010 - 2018 Intel Corporation.
-#
-#  This program is free software; you can redistribute it and/or modify it
-#  under the terms and conditions of the GNU General Public License,
-#  version 2, as published by the Free Software Foundation.
-#
-#  This program is distributed in the hope it will be useful, but WITHOUT
-#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-#  more details.
-#
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (c) 2010 - 2018, Intel Corporation.
+
+# force check the compile warning to make sure zero warnings
+# note we may have build issue when gcc upgraded.
+subdir-ccflags-y := -Wall -Wextra
+subdir-ccflags-y += $(call cc-disable-warning, unused-parameter)
+subdir-ccflags-y += $(call cc-disable-warning, implicit-fallthrough)
+subdir-ccflags-y += $(call cc-disable-warning, missing-field-initializers)
+subdir-ccflags-$(CONFIG_VIDEO_INTEL_IPU_WERROR) += -Werror
 
 obj-$(CONFIG_VIDEO_INTEL_ICI)	+= ici/
 ifndef CONFIG_VIDEO_INTEL_ICI
diff --git a/drivers/media/pci/intel/ici/Makefile b/drivers/media/pci/intel/ici/Makefile
index f3f538a..b39fbaa 100644
--- a/drivers/media/pci/intel/ici/Makefile
+++ b/drivers/media/pci/intel/ici/Makefile
@@ -1,31 +1,13 @@
-#
-#  Copyright (c) 2010 - 2018, Intel Corporation.
-#
-#  This program is free software; you can redistribute it and/or modify it
-#  under the terms and conditions of the GNU General Public License,
-#  version 2, as published by the Free Software Foundation.
-#
-#  This program is distributed in the hope it will be useful, but WITHOUT
-#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-#  more details.
-#
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (c) 2010 - 2018, Intel Corporation.
 
 ifneq ($(EXTERNAL_BUILD), 1)
 srcpath := $(srctree)
 endif
 
-#
-#config for bxt-p platform
-#
 ifdef CONFIG_VIDEO_INTEL_ICI
-
-IPU_STEP = bxtB0
 ccflags-y += -DHAS_DUAL_CMD_CTX_SUPPORT=0 -DIPU_VC_SUPPORT -DIPU_HAS_ISA -DIPU_PSYS_LEGACY -Wframe-larger-than=4096
 
-ifndef IPU_STEP
-  $(error No IPU_STEP was defined. Stopping.)
-endif
 
 # work-around to re-use ipu4-css and libintel-ipu4_ici.c together when
 # compiling ICI-ISYS
@@ -33,21 +15,21 @@ $(shell cp -r $(srcpath)/$(src)/../ipu4/ipu4-css/ $(srcpath)/$(src)/)
 $(shell cp -f $(srcpath)/$(src)/libintel-ipu4_ici.c $(srcpath)/$(src)/ipu4-css/libintel-ipu4.c)
 $(shell cp -f $(srcpath)/$(src)/../ipu4/ipu-platform-resources.h $(srcpath)/$(src)/)
 
-intel-ipu4-mod-$(IPU_STEP)-objs			+= \
-						../ipu.o \
-						../ipu-bus.o \
-						ici-dma.o \
-						../ipu-buttress.o \
-						../ipu-trace.o \
-						../ipu-cpd.o \
-						../ipu-fw-com.o \
-						../ipu4/ipu4.o
-
-obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-mod-$(IPU_STEP).o
-intel-ipu4-mmu-$(IPU_STEP)-objs		+= ../ipu-mmu.o
-obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-mmu-$(IPU_STEP).o
-
-ici-isys-mod-$(IPU_STEP)-objs += \
+intel-ipu4-objs			+=../ipu.o \
+				  ../ipu-bus.o \
+				  ici-dma.o \
+				  ../ipu-buttress.o \
+				  ../ipu-trace.o \
+				  ../ipu-cpd.o \
+				  ../ipu-fw-com.o \
+				  ../ipu4/ipu4.o
+
+obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4.o
+
+intel-ipu4-mmu-objs			+= ../ipu-mmu.o
+obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-mmu.o
+
+ici-isys-mod-objs += \
                        ici-isys.o \
                        ici-isys-csi2.o \
                        ici-isys-tpg.o \
@@ -58,24 +40,22 @@ ici-isys-mod-$(IPU_STEP)-objs += \
                        ici-isys-pipeline.o \
                        ici-isys-pipeline-device.o \
                        ici-isys-stream-device.o
-obj-$(CONFIG_VIDEO_INTEL_IPU)          += ici-isys-mod-$(IPU_STEP).o
+obj-$(CONFIG_VIDEO_INTEL_IPU)          += ici-isys-mod.o
 
-intel-ipu4-psys-mod-$(IPU_STEP)-objs	+= \
-					../ipu-psys.o \
-					../ipu-resources.o \
-					../ipu4/ipu4-psys.o \
-					../ipu4/ipu4-resource-tables.o \
+intel-ipu4-psys-objs	+= ../ipu-psys.o \
+			   ../ipu4/ipu4-resources.o \
+			   ../ipu4/ipu4-psys.o \
 
 ifndef CONFIG_VIDEO_INTEL_IPU_FW_LIB
-intel-ipu4-psys-mod-$(IPU_STEP)-objs	+= ipu4-fw-resources.o \
-					../ipu-fw-psys.o
+intel-ipu4-psys-objs	+= ipu4-fw-resources.o \
+			../ipu-fw-psys.o
 endif
 
 ifeq ($(CONFIG_COMPAT),y)
-intel-ipu4-psys-mod-$(IPU_STEP)-objs	+= ../ipu-psys-compat32.o
+intel-ipu4-psys-objs	+= ../ipu-psys-compat32.o
 endif
 
-obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-psys-mod-$(IPU_STEP).o
+obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-psys.o
 
 ifdef CONFIG_VIDEO_INTEL_IPU_FW_LIB
 include $(srcpath)/$(src)/ipu4-css/Makefile.isyslib
diff --git a/drivers/media/pci/intel/ici/ici-isys-csi2-be.c b/drivers/media/pci/intel/ici/ici-isys-csi2-be.c
index 589e257..6841263 100644
--- a/drivers/media/pci/intel/ici/ici-isys-csi2-be.c
+++ b/drivers/media/pci/intel/ici/ici-isys-csi2-be.c
@@ -79,7 +79,7 @@ void ici_csi2_be_set_ffmt(struct ici_isys_subdev *asd,
 {
 	struct ici_framefmt *cur_ffmt =
 		__ici_isys_subdev_get_ffmt(asd, pad);
-
+	int idx=0;
 	if (!cur_ffmt)
 	    return;
 
@@ -108,7 +108,7 @@ void ici_csi2_be_set_ffmt(struct ici_isys_subdev *asd,
 		if (sink_ffmt)
 		    code = sink_ffmt->pixelformat;
 
-		int idx = get_supported_code_index(code);
+		idx = get_supported_code_index(code);
 
 		DEBUGK("%s: source pad %u\n", __func__, pad);
 
diff --git a/drivers/media/pci/intel/ici/libintel-ipu4_ici.c b/drivers/media/pci/intel/ici/libintel-ipu4_ici.c
index ff7404e..cc31663 100644
--- a/drivers/media/pci/intel/ici/libintel-ipu4_ici.c
+++ b/drivers/media/pci/intel/ici/libintel-ipu4_ici.c
@@ -1,4 +1,4 @@
-// SPDX-LIcense_Identifier: GPL-2.0
+// SPDX-License_Identifier: GPL-2.0
 // Copyright (C) 2014 - 2018 Intel Corporation
 
 #include <linux/module.h>
@@ -40,6 +40,7 @@
 									\
 		rval;							\
 	})
+
 static int wrapper_init_done;
 
 int ipu_fw_isys_close(struct ici_isys *isys)
@@ -401,7 +402,6 @@ module_exit(library_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Intel ipu library");
-
 EXPORT_SYMBOL_GPL(ia_css_isys_device_open);
 EXPORT_SYMBOL_GPL(ia_css_isys_device_open_ready);
 EXPORT_SYMBOL_GPL(ia_css_isys_device_close);
diff --git a/drivers/media/pci/intel/ipu-fw-isys.h b/drivers/media/pci/intel/ipu-fw-isys.h
index c957e4a..d5a7e903 100644
--- a/drivers/media/pci/intel/ipu-fw-isys.h
+++ b/drivers/media/pci/intel/ipu-fw-isys.h
@@ -563,6 +563,10 @@ struct ipu_fw_isys_param_pin_abi {
  *		     (enum ipu_fw_isys_mipi_store_mode)
  * @bits_per_pix: native bits per pixel
  * @mapped_dt: actual data type from sensor
+ * @crop_first_and_last_lines    Control whether to crop the
+ *                              first and last line of the
+ *                              input image. Crop done by HW
+ *                              device.
  */
 struct ipu_fw_isys_input_pin_info_abi {
 	struct ipu_fw_isys_resolution_abi input_res;
@@ -570,6 +574,7 @@ struct ipu_fw_isys_input_pin_info_abi {
 	u8 mipi_store_mode;
 	u8 bits_per_pix;
 	u8 mapped_dt;
+	u8 crop_first_and_last_lines;
 };
 
 /**
diff --git a/drivers/media/pci/intel/ipu-fw-psys.c b/drivers/media/pci/intel/ipu-fw-psys.c
index c1d81bc..a8626bc 100644
--- a/drivers/media/pci/intel/ipu-fw-psys.c
+++ b/drivers/media/pci/intel/ipu-fw-psys.c
@@ -51,6 +51,7 @@ int ipu_fw_psys_pg_disown(struct ipu_psys_kcmd *kcmd)
 	return ret;
 }
 
+
 int ipu_fw_psys_pg_abort(struct ipu_psys_kcmd *kcmd)
 {
 	struct ipu_fw_psys_cmd *psys_cmd;
diff --git a/drivers/media/pci/intel/ipu-fw-psys.h b/drivers/media/pci/intel/ipu-fw-psys.h
index c23b567..ddd71d1 100644
--- a/drivers/media/pci/intel/ipu-fw-psys.h
+++ b/drivers/media/pci/intel/ipu-fw-psys.h
@@ -242,9 +242,65 @@ struct ipu_fw_psys_buffer_set {
 	u8 padding[IPU_FW_PSYS_N_PADDING_UINT8_IN_BUFFER_SET_STRUCT];
 };
 
+struct ipu_fw_psys_program_group_manifest {
+	u32 kernel_bitmap[IPU_FW_PSYS_KERNEL_BITMAP_NOF_ELEMS];
+	u32 ID;
+	u16 program_manifest_offset;
+	u16 terminal_manifest_offset;
+	u16 private_data_offset;
+	u16 rbm_manifest_offset;
+	u16 size;
+	u8 alignment;
+	u8 kernel_count;
+	u8 program_count;
+	u8 terminal_count;
+	u8 subgraph_count;
+	u8 reserved[5];
+};
+
+struct ipu_fw_generic_program_manifest {
+	u16 *dev_chn_size;
+	u16 *dev_chn_offset;
+	u16 *ext_mem_size;
+	u16 *ext_mem_offset;
+	u8 cell_id;
+	u8 cells[IPU_FW_PSYS_PROCESS_MAX_CELLS];
+	u8 cell_type_id;
+	u8 *is_dfm_relocatable;
+	u32 *dfm_port_bitmap;
+	u32 *dfm_active_port_bitmap;
+};
+
+struct ipu_fw_generic_process {
+	u16 ext_mem_id;
+	u16 ext_mem_offset;
+	u16 dev_chn_offset;
+	u16 cell_id;
+	u16 dfm_port_bitmap;
+	u16 dfm_active_port_bitmap;
+};
+
+struct ipu_fw_resource_definitions {
+	u32 num_cells;
+	u32 num_cells_type;
+	const u32 *cells;
+	u32 num_dev_channels;
+	const u16 *dev_channels;
+
+	u32 num_ext_mem_types;
+	u32 num_ext_mem_ids;
+	const u16 *ext_mem_ids;
+
+	u32 num_dfm_ids;
+	const u16 *dfms;
+
+	u32 cell_mem_row;
+	const enum ipu_mem_id *cell_mem;
+	struct ipu_fw_generic_process process;
+};
+
 struct ipu_psys_kcmd;
 struct ipu_psys;
-
 int ipu_fw_psys_pg_start(struct ipu_psys_kcmd *kcmd);
 int ipu_fw_psys_pg_disown(struct ipu_psys_kcmd *kcmd);
 int ipu_fw_psys_pg_abort(struct ipu_psys_kcmd *kcmd);
@@ -272,4 +328,19 @@ u64 ipu_fw_psys_pg_get_token(struct ipu_psys_kcmd *kcmd);
 int ipu_fw_psys_pg_get_protocol(struct ipu_psys_kcmd *kcmd);
 int ipu_fw_psys_open(struct ipu_psys *psys);
 int ipu_fw_psys_close(struct ipu_psys *psys);
+
+/* common resource interface for both abi and api mode */
+void ipu_fw_psys_set_process_cell_id(struct ipu_fw_psys_process *ptr, u8 index,
+				     u8 value);
+u8 ipu_fw_psys_get_process_cell_id(struct ipu_fw_psys_process *ptr, u8 index);
+void ipu_fw_psys_set_process_dev_chn_offset(struct ipu_fw_psys_process *ptr,
+					    u16 offset, u16 value);
+void ipu_fw_psys_set_process_ext_mem_offset(struct ipu_fw_psys_process *ptr,
+					    u16 offset, u16 value);
+void ipu_fw_psys_set_process_ext_mem_id(struct ipu_fw_psys_process *ptr,
+					u16 offset, u8 value);
+int ipu_fw_psys_get_program_manifest_by_process(
+	struct ipu_fw_generic_program_manifest *gen_pm,
+	const struct ipu_fw_psys_program_group_manifest *pg_manifest,
+	struct ipu_fw_psys_process *process);
 #endif /* IPU_FW_PSYS_H */
diff --git a/drivers/media/pci/intel/ipu-fw-resources.h b/drivers/media/pci/intel/ipu-fw-resources.h
deleted file mode 100644
index 8a76597..0000000
--- a/drivers/media/pci/intel/ipu-fw-resources.h
+++ /dev/null
@@ -1,25 +0,0 @@
-
-/* SPDX-License_Identifier: GPL-2.0 */
-/* Copyright (C) 2018 Intel Corporation */
-
-#ifndef IPU_FW_RESOURCES_H
-#define IPU_FW_RESOURCES_H
-
-#include "ipu-resources.h"
-
-/* common resource interface for both abi and api mode */
-void ipu_fw_psys_set_process_cell_id(struct ipu_fw_psys_process *ptr, u8 index,
-				     u8 value);
-u8 ipu_fw_psys_get_process_cell_id(struct ipu_fw_psys_process *ptr, u8 index);
-void ipu_fw_psys_set_process_dev_chn_offset(struct ipu_fw_psys_process *ptr,
-					    u16 offset, u16 value);
-void ipu_fw_psys_set_process_ext_mem_offset(struct ipu_fw_psys_process *ptr,
-					    u16 offset, u16 value);
-void ipu_fw_psys_set_process_ext_mem_id(struct ipu_fw_psys_process *ptr,
-					u16 offset, u8 value);
-int ipu_fw_psys_get_program_manifest_by_process(
-	struct ipu_fw_generic_program_manifest *gen_pm,
-	const struct ipu_fw_psys_program_group_manifest *pg_manifest,
-	struct ipu_fw_psys_process *process);
-
-#endif
diff --git a/drivers/media/pci/intel/ipu-isys-media.c b/drivers/media/pci/intel/ipu-isys-media.c
deleted file mode 100644
index 199131f..0000000
--- a/drivers/media/pci/intel/ipu-isys-media.c
+++ /dev/null
@@ -1,26 +0,0 @@
-/* SPDX-License_Identifier: GPL-2.0
- * Copyright (C) 2016 - 2018 Intel Corporation
- * FIXME: update checkpatch script
- */
-
-#include <linux/slab.h>
-#include <media/media-entity.h>
-
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0)
-int media_entity_enum_init(struct media_entity_enum *ent_enum,
-			   struct media_device *mdev)
-{
-	int idx_max = IPU_COMPAT_MAX_ENTITIES;
-
-	ent_enum->bmap = kcalloc(DIV_ROUND_UP(idx_max, BITS_PER_LONG),
-				 sizeof(long), GFP_KERNEL);
-	if (!ent_enum->bmap)
-		return -ENOMEM;
-
-	bitmap_zero(ent_enum->bmap, idx_max);
-
-	ent_enum->idx_max = idx_max;
-	return 0;
-}
-#endif
diff --git a/drivers/media/pci/intel/ipu-isys-media.h b/drivers/media/pci/intel/ipu-isys-media.h
index 30abdd8..1d88e87 100644
--- a/drivers/media/pci/intel/ipu-isys-media.h
+++ b/drivers/media/pci/intel/ipu-isys-media.h
@@ -1,10 +1,11 @@
 /* SPDX-License_Identifier: GPL-2.0 */
 /* Copyright (C) 2016 - 2018 Intel Corporation */
 
-#include <media/media-entity.h>
+#ifndef IPU_ISYS_MEDIA_H
+#define IPU_ISYS_MEDIA_H
 
-#ifndef IPU_ISYS_COMPAT_DEFS_H
-#define IPU_ISYS_COMPAT_DEFS_H
+#include <linux/slab.h>
+#include <media/media-entity.h>
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0)
 #define is_media_entity_v4l2_subdev(e) \
@@ -26,8 +27,21 @@ struct media_entity_enum {
 	int idx_max;
 };
 
-int media_entity_enum_init(struct media_entity_enum *ent_enum,
-			   struct media_device *mdev);
+static inline int media_entity_enum_init(struct media_entity_enum *ent_enum,
+			   struct media_device *mdev)
+{
+	int idx_max = IPU_COMPAT_MAX_ENTITIES;
+
+	ent_enum->bmap = kcalloc(DIV_ROUND_UP(idx_max, BITS_PER_LONG),
+				 sizeof(long), GFP_KERNEL);
+	if (!ent_enum->bmap)
+		return -ENOMEM;
+
+	bitmap_zero(ent_enum->bmap, idx_max);
+
+	ent_enum->idx_max = idx_max;
+	return 0;
+}
 
 static inline void media_entity_enum_cleanup(struct media_entity_enum *ent_enum)
 {
@@ -74,4 +88,4 @@ static inline bool media_entity_enum_test(struct media_entity_enum *ent_enum,
 #endif
 
 
-#endif /* IPU_ISYS_COMPAT_DEFS_H */
+#endif /* IPU_ISYS_MEDIA_H */
diff --git a/drivers/media/pci/intel/ipu-isys-queue.h b/drivers/media/pci/intel/ipu-isys-queue.h
index e70cbc6..2a2e276 100644
--- a/drivers/media/pci/intel/ipu-isys-queue.h
+++ b/drivers/media/pci/intel/ipu-isys-queue.h
@@ -14,7 +14,6 @@
 #endif
 
 
-struct ipu_isys;
 struct ipu_isys_video;
 struct ipu_isys_pipeline;
 struct ipu_fw_isys_resp_info_abi;
diff --git a/drivers/media/pci/intel/ipu-isys-subdev.c b/drivers/media/pci/intel/ipu-isys-subdev.c
index 68be6da..8b34cb7 100644
--- a/drivers/media/pci/intel/ipu-isys-subdev.c
+++ b/drivers/media/pci/intel/ipu-isys-subdev.c
@@ -527,10 +527,9 @@ bool ipu_isys_subdev_has_route(struct media_entity *entity,
 		    ((asd->route[i].sink == pad0 &&
 		      asd->route[i].source == pad1) ||
 		     (asd->route[i].sink == pad1 &&
-		      asd->route[i].source == pad0))) {
+			  asd->route[i].source == pad0))) {
 			if (stream)
 				*stream = i;
-
 			return true;
 		}
 	}
diff --git a/drivers/media/pci/intel/ipu-isys-tpg.c b/drivers/media/pci/intel/ipu-isys-tpg.c
index cc66758..5b8b940 100644
--- a/drivers/media/pci/intel/ipu-isys-tpg.c
+++ b/drivers/media/pci/intel/ipu-isys-tpg.c
@@ -207,6 +207,9 @@ static const struct v4l2_subdev_pad_ops tpg_sd_pad_ops = {
 };
 
 static struct v4l2_subdev_ops tpg_sd_ops = {
+#ifdef IPU_TPG_SOF
+	.core = &tpg_sd_core_ops,
+#endif
 	.video = &tpg_sd_video_ops,
 	.pad = &tpg_sd_pad_ops,
 };
@@ -254,6 +257,14 @@ int ipu_isys_tpg_init(struct ipu_isys_tpg *tpg,
 	if (rval)
 		return rval;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0)
+	tpg->asd.sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+#else
+	tpg->asd.sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+#endif
+#ifdef IPU_TPG_SOF
+	tpg->asd.sd.flags |= V4L2_SUBDEV_FL_HAS_EVENTS;
+#endif
 	tpg->asd.pad[TPG_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
 
 	tpg->asd.source = IPU_FW_ISYS_STREAM_SRC_MIPIGEN_PORT0 + index;
diff --git a/drivers/media/pci/intel/ipu-isys-tpg.h b/drivers/media/pci/intel/ipu-isys-tpg.h
index a76818e..d782e1d 100644
--- a/drivers/media/pci/intel/ipu-isys-tpg.h
+++ b/drivers/media/pci/intel/ipu-isys-tpg.h
@@ -86,7 +86,10 @@ struct ipu_isys_tpg {
 #define to_ipu_isys_tpg(sd)		\
 	container_of(to_ipu_isys_subdev(sd), \
 	struct ipu_isys_tpg, asd)
-
+#ifdef IPU_TPG_SOF
+void ipu_isys_tpg_sof_event(struct ipu_isys_tpg *tpg);
+extern const struct v4l2_subdev_core_ops tpg_sd_core_ops;
+#endif
 int ipu_isys_tpg_init(struct ipu_isys_tpg *tpg,
 		      struct ipu_isys *isys,
 		      void __iomem *base, void __iomem *sel,
diff --git a/drivers/media/pci/intel/ipu-isys-video.c b/drivers/media/pci/intel/ipu-isys-video.c
index 2a2b61b..0debbe3 100644
--- a/drivers/media/pci/intel/ipu-isys-video.c
+++ b/drivers/media/pci/intel/ipu-isys-video.c
@@ -40,7 +40,7 @@ module_param(num_stream_support, uint, 0660);
 MODULE_PARM_DESC(num_stream_support, "IPU project support number of stream");
 
 static bool use_stream_stop;
-module_param(use_stream_stop, bool, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
+module_param(use_stream_stop, bool, 0660);
 MODULE_PARM_DESC(use_stream_stop, "Use STOP command if running in CSI capture mode");
 
 const struct ipu_isys_pixelformat ipu_isys_pfmts_be_soc[] = {
diff --git a/drivers/media/pci/intel/ipu-isys-video.h b/drivers/media/pci/intel/ipu-isys-video.h
index 611cc34..9b7da62 100644
--- a/drivers/media/pci/intel/ipu-isys-video.h
+++ b/drivers/media/pci/intel/ipu-isys-video.h
@@ -18,8 +18,6 @@
 #define IPU_ISYS_MAX_PARALLEL_SOF 2
 
 struct ipu_isys;
-struct ipu_fw_isys_stream_cfg_data;
-struct ipu_isys_csi2_be_raw;
 struct ipu_isys_csi2_be_soc;
 struct ipu_fw_isys_stream_cfg_data_abi;
 
@@ -56,6 +54,9 @@ struct ipu_isys_pipeline {
 	struct ipu_isys_csi2_be *csi2_be;
 	struct ipu_isys_csi2_be_soc *csi2_be_soc;
 	struct ipu_isys_csi2 *csi2;
+#ifdef IPU_TPG_SOF
+	struct ipu_isys_tpg *tpg;
+#endif
 	/*
 	 * Number of capture queues, write access serialised using struct
 	 * ipu_isys.stream_mutex
diff --git a/drivers/media/pci/intel/ipu-isys.c b/drivers/media/pci/intel/ipu-isys.c
index c94c0d6..f106be9 100644
--- a/drivers/media/pci/intel/ipu-isys.c
+++ b/drivers/media/pci/intel/ipu-isys.c
@@ -1346,6 +1346,10 @@ int isys_isr_one(struct ipu_bus_device *adev)
 
 		break;
 	case IPU_FW_ISYS_RESP_TYPE_FRAME_SOF:
+#ifdef IPU_TPG_SOF
+		if (pipe->tpg)
+			ipu_isys_tpg_sof_event(pipe->tpg);
+#endif
 		pipe->seq[pipe->seq_index].sequence =
 		    atomic_read(&pipe->sequence) - 1;
 		pipe->seq[pipe->seq_index].timestamp = ts;
diff --git a/drivers/media/pci/intel/ipu-mmu.h b/drivers/media/pci/intel/ipu-mmu.h
index 4d89cdf..68c8b06 100644
--- a/drivers/media/pci/intel/ipu-mmu.h
+++ b/drivers/media/pci/intel/ipu-mmu.h
@@ -12,8 +12,6 @@
 #define ISYS_MMID 1
 #define PSYS_MMID 0
 
-struct pci_dev;
-
 /*
  * @pgtbl: virtual address of the l1 page table (one page)
  */
diff --git a/drivers/media/pci/intel/ipu-psys-compat32.c b/drivers/media/pci/intel/ipu-psys-compat32.c
index 8d26636..d06e40f 100644
--- a/drivers/media/pci/intel/ipu-psys-compat32.c
+++ b/drivers/media/pci/intel/ipu-psys-compat32.c
@@ -57,7 +57,7 @@ get_ipu_psys_command32(struct ipu_psys_command *kp,
 	compat_uptr_t pgm, bufs;
 
 	if (!access_ok(VERIFY_READ, up,
-		       sizeof(struct ipu_psys_buffer32)) ||
+		       sizeof(struct ipu_psys_command32)) ||
 	    get_user(kp->issue_id, &up->issue_id) ||
 	    get_user(kp->user_token, &up->user_token) ||
 	    get_user(kp->priority, &up->priority) ||
diff --git a/drivers/media/pci/intel/ipu-psys.c b/drivers/media/pci/intel/ipu-psys.c
index 89aee92..66acd73 100644
--- a/drivers/media/pci/intel/ipu-psys.c
+++ b/drivers/media/pci/intel/ipu-psys.c
@@ -38,27 +38,19 @@
 #include "ipu-fw-psys.h"
 #include "ipu-psys.h"
 #include "ipu-platform-regs.h"
-#define CREATE_TRACE_POINTS
-#define IPU_PG_KCMD_TRACE
-#include "ipu-trace-event.h"
 #include "ipu-fw-isys.h"
 #include "ipu-fw-com.h"
 
-static bool early_pg_transfer;
 static bool enable_concurrency = true;
 static bool async_fw_init;
-module_param(early_pg_transfer, bool, 0664);
 module_param(enable_concurrency, bool, 0664);
 module_param(async_fw_init, bool, 0664);
 
-MODULE_PARM_DESC(early_pg_transfer,
-		 "Copy PGs back to user after resource allocation");
 MODULE_PARM_DESC(enable_concurrency,
 		 "Enable concurrent execution of program groups");
 MODULE_PARM_DESC(async_fw_init, "Enable asynchronous firmware initialization");
 
 #define IPU_PSYS_NUM_DEVICES		4
-#define IPU_PSYS_WORK_QUEUE		system_power_efficient_wq
 #define IPU_PSYS_AUTOSUSPEND_DELAY	2000
 
 #ifdef CONFIG_PM
@@ -95,8 +87,43 @@ static struct ipu_psys_capability caps = {
 	.driver = "ipu-psys",
 };
 
-static struct ipu_psys_kbuffer *
-ipu_psys_lookup_kbuffer(struct ipu_psys_fh *fh, int fd)
+struct ipu_psys_pg *__get_pg_buf(struct ipu_psys *psys, size_t pg_size)
+{
+	struct ipu_psys_pg *kpg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&psys->pgs_lock, flags);
+	list_for_each_entry(kpg, &psys->pgs, list) {
+		if (!kpg->pg_size && kpg->size >= pg_size) {
+			kpg->pg_size = pg_size;
+			spin_unlock_irqrestore(&psys->pgs_lock, flags);
+			return kpg;
+		}
+	}
+	spin_unlock_irqrestore(&psys->pgs_lock, flags);
+	/* no big enough buffer available, allocate new one */
+	kpg = kzalloc(sizeof(*kpg), GFP_KERNEL);
+	if (!kpg)
+		return NULL;
+
+	kpg->pg = dma_alloc_attrs(&psys->adev->dev, pg_size,
+				  &kpg->pg_dma_addr, GFP_KERNEL,
+				  DMA_ATTR_NON_CONSISTENT);
+	if (!kpg->pg) {
+		kfree(kpg);
+		return NULL;
+	}
+
+	kpg->pg_size = pg_size;
+	kpg->size = pg_size;
+	spin_lock_irqsave(&psys->pgs_lock, flags);
+	list_add(&kpg->list, &psys->pgs);
+	spin_unlock_irqrestore(&psys->pgs_lock, flags);
+
+	return kpg;
+}
+
+struct ipu_psys_kbuffer *ipu_psys_lookup_kbuffer(struct ipu_psys_fh *fh, int fd)
 {
 	struct ipu_psys_kbuffer *kbuffer;
 
@@ -108,7 +135,7 @@ ipu_psys_lookup_kbuffer(struct ipu_psys_fh *fh, int fd)
 	return NULL;
 }
 
-static struct ipu_psys_kbuffer *
+struct ipu_psys_kbuffer *
 ipu_psys_lookup_kbuffer_by_kaddr(struct ipu_psys_fh *fh, void *kaddr)
 {
 	struct ipu_psys_kbuffer *kbuffer;
@@ -121,7 +148,6 @@ ipu_psys_lookup_kbuffer_by_kaddr(struct ipu_psys_fh *fh, void *kaddr)
 	return NULL;
 }
 
-
 static int ipu_psys_get_userpages(struct ipu_dma_buf_attach *attach)
 {
 	struct vm_area_struct *vma;
@@ -497,44 +523,6 @@ static int ipu_psys_open(struct inode *inode, struct file *file)
 	return -ENOMEM;
 }
 
-/*
- * Called to free up all resources associated with a kcmd.
- * After this the kcmd doesn't anymore exist in the driver.
- */
-static void ipu_psys_kcmd_free(struct ipu_psys_kcmd *kcmd)
-{
-	struct ipu_psys *psys;
-	unsigned long flags;
-
-	if (!kcmd)
-		return;
-
-	psys = kcmd->fh->psys;
-
-	if (!list_empty(&kcmd->list))
-		list_del(&kcmd->list);
-
-	spin_lock_irqsave(&psys->pgs_lock, flags);
-	if (kcmd->kpg) {
-		kcmd->kpg->pg_size = 0;
-	}
-	spin_unlock_irqrestore(&psys->pgs_lock, flags);
-
-	mutex_lock(&kcmd->fh->bs_mutex);
-	if (kcmd->kbuf_set) {
-		kcmd->kbuf_set->buf_set_size = 0;
-	}
-	mutex_unlock(&kcmd->fh->bs_mutex);
-
-	kfree(kcmd->pg_manifest);
-	kfree(kcmd->kbufs);
-	kfree(kcmd->buffers);
-	kfree(kcmd);
-}
-
-static int ipu_psys_kcmd_abort(struct ipu_psys *psys,
-			       struct ipu_psys_kcmd *kcmd, int error);
-
 static int ipu_psys_release(struct inode *inode, struct file *file)
 {
 	struct ipu_psys *psys = inode_to_ipu_psys(inode);
@@ -683,466 +671,6 @@ static int ipu_psys_putbuf(struct ipu_psys_buffer *buf, struct ipu_psys_fh *fh)
 	return 0;
 }
 
-struct ipu_psys_pg *__get_pg_buf(struct ipu_psys *psys, size_t pg_size)
-{
-	struct ipu_psys_pg *kpg;
-	unsigned long flags;
-
-	spin_lock_irqsave(&psys->pgs_lock, flags);
-	list_for_each_entry(kpg, &psys->pgs, list) {
-		if (!kpg->pg_size && kpg->size >= pg_size) {
-			kpg->pg_size = pg_size;
-			spin_unlock_irqrestore(&psys->pgs_lock, flags);
-			return kpg;
-		}
-	}
-	spin_unlock_irqrestore(&psys->pgs_lock, flags);
-	/* no big enough buffer available, allocate new one */
-	kpg = kzalloc(sizeof(*kpg), GFP_KERNEL);
-	if (!kpg)
-		return NULL;
-
-	kpg->pg = dma_alloc_attrs(&psys->adev->dev, pg_size,
-				  &kpg->pg_dma_addr, GFP_KERNEL,
-				  DMA_ATTR_NON_CONSISTENT);
-	if (!kpg->pg) {
-		kfree(kpg);
-		return NULL;
-	}
-
-	kpg->pg_size = pg_size;
-	kpg->size = pg_size;
-	spin_lock_irqsave(&psys->pgs_lock, flags);
-	list_add(&kpg->list, &psys->pgs);
-	spin_unlock_irqrestore(&psys->pgs_lock, flags);
-
-	return kpg;
-}
-
-struct ipu_psys_buffer_set *__get_buf_set(struct ipu_psys_fh *fh,
-					  size_t buf_set_size)
-{
-	struct ipu_psys_buffer_set *kbuf_set;
-
-	mutex_lock(&fh->bs_mutex);
-	list_for_each_entry(kbuf_set, &fh->buf_sets, list) {
-		if (!kbuf_set->buf_set_size && kbuf_set->size >= buf_set_size) {
-			kbuf_set->buf_set_size = buf_set_size;
-			mutex_unlock(&fh->bs_mutex);
-			return kbuf_set;
-		}
-	}
-
-	mutex_unlock(&fh->bs_mutex);
-	/* no big enough buffer available, allocate new one */
-	kbuf_set = kzalloc(sizeof(*kbuf_set), GFP_KERNEL);
-	if (!kbuf_set)
-		return NULL;
-
-	kbuf_set->kaddr = dma_alloc_attrs(&fh->psys->adev->dev,
-					  buf_set_size, &kbuf_set->dma_addr,
-					  GFP_KERNEL, DMA_ATTR_NON_CONSISTENT);
-	if (!kbuf_set->kaddr) {
-		kfree(kbuf_set);
-		return NULL;
-	}
-
-	kbuf_set->buf_set_size = buf_set_size;
-	kbuf_set->size = buf_set_size;
-	mutex_lock(&fh->bs_mutex);
-	list_add(&kbuf_set->list, &fh->buf_sets);
-	mutex_unlock(&fh->bs_mutex);
-
-	return kbuf_set;
-}
-
-struct ipu_psys_kcmd *ipu_psys_copy_cmd(struct ipu_psys_command *cmd,
-					struct ipu_psys_fh *fh)
-{
-	struct ipu_psys *psys = fh->psys;
-	struct ipu_psys_kcmd *kcmd;
-	struct ipu_psys_kbuffer *kpgbuf;
-	unsigned int i;
-	int ret, prevfd = 0;
-
-	if (cmd->bufcount > IPU_MAX_PSYS_CMD_BUFFERS)
-		return NULL;
-
-	if (!cmd->pg_manifest_size ||
-	    cmd->pg_manifest_size > KMALLOC_MAX_CACHE_SIZE)
-		return NULL;
-
-	kcmd = kzalloc(sizeof(*kcmd), GFP_KERNEL);
-	if (!kcmd)
-		return NULL;
-
-	kcmd->state = KCMD_STATE_NEW;
-	kcmd->fh = fh;
-	INIT_LIST_HEAD(&kcmd->list);
-	INIT_LIST_HEAD(&kcmd->started_list);
-
-	mutex_lock(&fh->mutex);
-	kpgbuf = ipu_psys_lookup_kbuffer(fh, cmd->pg);
-	mutex_unlock(&fh->mutex);
-	if (!kpgbuf || !kpgbuf->sgt)
-		goto error;
-
-	kcmd->pg_user = kpgbuf->kaddr;
-	kcmd->kpg = __get_pg_buf(psys, kpgbuf->len);
-	if (!kcmd->kpg)
-		goto error;
-
-	memcpy(kcmd->kpg->pg, kcmd->pg_user, kcmd->kpg->pg_size);
-
-	kcmd->pg_manifest = kzalloc(cmd->pg_manifest_size, GFP_KERNEL);
-	if (!kcmd->pg_manifest)
-		goto error;
-
-	ret = copy_from_user(kcmd->pg_manifest, cmd->pg_manifest,
-			     cmd->pg_manifest_size);
-	if (ret)
-		goto error;
-
-	kcmd->pg_manifest_size = cmd->pg_manifest_size;
-
-	kcmd->user_token = cmd->user_token;
-	kcmd->issue_id = cmd->issue_id;
-	kcmd->priority = cmd->priority;
-	if (kcmd->priority >= IPU_PSYS_CMD_PRIORITY_NUM)
-		goto error;
-
-	kcmd->nbuffers = ipu_fw_psys_pg_get_terminal_count(kcmd);
-	kcmd->buffers = kcalloc(kcmd->nbuffers, sizeof(*kcmd->buffers),
-				GFP_KERNEL);
-	if (!kcmd->buffers)
-		goto error;
-
-	kcmd->kbufs = kcalloc(kcmd->nbuffers, sizeof(kcmd->kbufs[0]),
-			      GFP_KERNEL);
-	if (!kcmd->kbufs)
-		goto error;
-
-
-	if (!cmd->bufcount || kcmd->nbuffers > cmd->bufcount)
-		goto error;
-
-	ret = copy_from_user(kcmd->buffers, cmd->buffers,
-			     kcmd->nbuffers * sizeof(*kcmd->buffers));
-	if (ret)
-		goto error;
-
-	for (i = 0; i < kcmd->nbuffers; i++) {
-		struct ipu_fw_psys_terminal *terminal;
-
-		terminal = ipu_fw_psys_pg_get_terminal(kcmd, i);
-		if (!terminal)
-			continue;
-
-
-		mutex_lock(&fh->mutex);
-		kcmd->kbufs[i] = ipu_psys_lookup_kbuffer(fh,
-							 kcmd->buffers[i].base.
-							 fd);
-		mutex_unlock(&fh->mutex);
-		if (!kcmd->kbufs[i] || !kcmd->kbufs[i]->sgt ||
-		    kcmd->kbufs[i]->len < kcmd->buffers[i].bytes_used)
-			goto error;
-		if ((kcmd->kbufs[i]->flags &
-		     IPU_BUFFER_FLAG_NO_FLUSH) ||
-		    (kcmd->buffers[i].flags &
-		     IPU_BUFFER_FLAG_NO_FLUSH) ||
-		    prevfd == kcmd->buffers[i].base.fd)
-			continue;
-
-		prevfd = kcmd->buffers[i].base.fd;
-		dma_sync_sg_for_device(&psys->adev->dev,
-				       kcmd->kbufs[i]->sgt->sgl,
-				       kcmd->kbufs[i]->sgt->orig_nents,
-				       DMA_BIDIRECTIONAL);
-	}
-
-
-	return kcmd;
-error:
-	ipu_psys_kcmd_free(kcmd);
-
-	dev_dbg(&psys->adev->dev, "failed to copy cmd\n");
-
-	return NULL;
-}
-
-static void ipu_psys_kcmd_run(struct ipu_psys *psys)
-{
-	struct ipu_psys_kcmd *kcmd = list_first_entry(&psys->started_kcmds_list,
-						      struct ipu_psys_kcmd,
-						      started_list);
-	int ret;
-
-	ret = ipu_psys_move_resources(&psys->adev->dev,
-				      &kcmd->resource_alloc,
-				      &psys->resource_pool_started,
-				      &psys->resource_pool_running);
-	if (!ret) {
-		psys->started_kcmds--;
-		psys->active_kcmds++;
-		kcmd->state = KCMD_STATE_RUNNING;
-		list_del(&kcmd->started_list);
-		kcmd->watchdog.expires = jiffies +
-		    msecs_to_jiffies(psys->timeout);
-		add_timer(&kcmd->watchdog);
-		return;
-	}
-
-	if (ret != -ENOSPC || !psys->active_kcmds) {
-		dev_err(&psys->adev->dev,
-			"kcmd %p failed to alloc resources (running (%d, psys->active_kcmds = %d))\n",
-			kcmd, ret, psys->active_kcmds);
-		ipu_psys_kcmd_abort(psys, kcmd, ret);
-		return;
-	}
-}
-
-/*
- * Move kcmd into completed state (due to running finished or failure).
- * Fill up the event struct and notify waiters.
- */
-static void ipu_psys_kcmd_complete(struct ipu_psys *psys,
-				   struct ipu_psys_kcmd *kcmd, int error)
-{
-	struct ipu_psys_fh *fh = kcmd->fh;
-
-	trace_ipu_pg_kcmd(__func__, kcmd->user_token, kcmd->issue_id,
-			  kcmd->priority,
-			  ipu_fw_psys_pg_get_id(kcmd),
-			  ipu_fw_psys_pg_load_cycles(kcmd),
-			  ipu_fw_psys_pg_init_cycles(kcmd),
-			  ipu_fw_psys_pg_processing_cycles(kcmd));
-
-	switch (kcmd->state) {
-	case KCMD_STATE_RUNNING:
-		if (try_to_del_timer_sync(&kcmd->watchdog) < 0) {
-			dev_err(&psys->adev->dev,
-				"could not cancel kcmd timer\n");
-			return;
-		}
-		/* Fall through on purpose */
-	case KCMD_STATE_RUN_PREPARED:
-		ipu_psys_free_resources(&kcmd->resource_alloc,
-					&psys->resource_pool_running);
-		if (psys->started_kcmds)
-			ipu_psys_kcmd_run(psys);
-		if (kcmd->state == KCMD_STATE_RUNNING)
-			psys->active_kcmds--;
-		break;
-	case KCMD_STATE_STARTED:
-		psys->started_kcmds--;
-		list_del(&kcmd->started_list);
-		/* Fall through on purpose */
-	case KCMD_STATE_START_PREPARED:
-		ipu_psys_free_resources(&kcmd->resource_alloc,
-					&psys->resource_pool_started);
-		break;
-	default:
-		break;
-	}
-
-	kcmd->ev.type = IPU_PSYS_EVENT_TYPE_CMD_COMPLETE;
-	kcmd->ev.user_token = kcmd->user_token;
-	kcmd->ev.issue_id = kcmd->issue_id;
-	kcmd->ev.error = error;
-
-	if (kcmd->constraint.min_freq)
-		ipu_buttress_remove_psys_constraint(psys->adev->isp,
-						    &kcmd->constraint);
-
-	if (!early_pg_transfer && kcmd->pg_user && kcmd->kpg->pg) {
-		struct ipu_psys_kbuffer *kbuf;
-
-		kbuf = ipu_psys_lookup_kbuffer_by_kaddr(kcmd->fh,
-							kcmd->pg_user);
-
-		if (kbuf && kbuf->valid)
-			memcpy(kcmd->pg_user,
-			       kcmd->kpg->pg, kcmd->kpg->pg_size);
-		else
-			dev_dbg(&psys->adev->dev,
-				"Skipping already unmapped buffer\n");
-	}
-
-	if (kcmd->state == KCMD_STATE_RUNNING ||
-	    kcmd->state == KCMD_STATE_STARTED) {
-		pm_runtime_mark_last_busy(&psys->adev->dev);
-		pm_runtime_put_autosuspend(&psys->adev->dev);
-	}
-
-	kcmd->state = KCMD_STATE_COMPLETE;
-
-	wake_up_interruptible(&fh->wait);
-}
-
-/*
- * Move kcmd into completed state. If kcmd is currently running,
- * abort it.
- */
-static int ipu_psys_kcmd_abort(struct ipu_psys *psys,
-			       struct ipu_psys_kcmd *kcmd, int error)
-{
-	int ret = 0;
-
-	if (kcmd->state == KCMD_STATE_COMPLETE)
-		return 0;
-
-	if ((kcmd->state == KCMD_STATE_RUNNING ||
-	     kcmd->state == KCMD_STATE_STARTED)) {
-		ret = ipu_fw_psys_pg_abort(kcmd);
-		if (ret) {
-			dev_err(&psys->adev->dev, "failed to abort kcmd!\n");
-			goto out;
-		}
-	}
-
-out:
-	ipu_psys_kcmd_complete(psys, kcmd, ret);
-
-	return ret;
-}
-
-/*
- * Submit kcmd into psys queue. If running fails, complete the kcmd
- * with an error.
- */
-static int ipu_psys_kcmd_start(struct ipu_psys *psys,
-			       struct ipu_psys_kcmd *kcmd)
-{
-	/*
-	 * Found a runnable PG. Move queue to the list tail for round-robin
-	 * scheduling and run the PG. Start the watchdog timer if the PG was
-	 * started successfully. Enable PSYS power if requested.
-	 */
-	int ret;
-
-	if (psys->adev->isp->flr_done) {
-		ipu_psys_kcmd_complete(psys, kcmd, -EIO);
-		return -EIO;
-	}
-
-	ret = pm_runtime_get_sync(&psys->adev->dev);
-	if (ret < 0) {
-		dev_err(&psys->adev->dev, "failed to power on PSYS\n");
-		ipu_psys_kcmd_complete(psys, kcmd, -EIO);
-		pm_runtime_put_noidle(&psys->adev->dev);
-		return ret;
-	}
-
-	if (early_pg_transfer && kcmd->pg_user && kcmd->kpg->pg)
-		memcpy(kcmd->pg_user, kcmd->kpg->pg, kcmd->kpg->pg_size);
-
-	ret = ipu_fw_psys_pg_start(kcmd);
-	if (ret) {
-		dev_err(&psys->adev->dev, "failed to start kcmd!\n");
-		goto error;
-	}
-
-	ipu_fw_psys_pg_dump(psys, kcmd, "run");
-
-	/*
-	 * Starting from scci_master_20151228_1800, pg start api is split into
-	 * two different calls, making driver responsible to flush pg between
-	 * start and disown library calls.
-	 */
-	clflush_cache_range(kcmd->kpg->pg, kcmd->kpg->pg_size);
-	ret = ipu_fw_psys_pg_disown(kcmd);
-	if (ret) {
-		dev_err(&psys->adev->dev, "failed to start kcmd!\n");
-		goto error;
-	}
-
-	trace_ipu_pg_kcmd(__func__, kcmd->user_token, kcmd->issue_id,
-			  kcmd->priority,
-			  ipu_fw_psys_pg_get_id(kcmd),
-			  ipu_fw_psys_pg_load_cycles(kcmd),
-			  ipu_fw_psys_pg_init_cycles(kcmd),
-			  ipu_fw_psys_pg_processing_cycles(kcmd));
-
-	switch (kcmd->state) {
-	case KCMD_STATE_RUN_PREPARED:
-		kcmd->state = KCMD_STATE_RUNNING;
-		psys->active_kcmds++;
-		kcmd->watchdog.expires = jiffies +
-		    msecs_to_jiffies(psys->timeout);
-		add_timer(&kcmd->watchdog);
-		break;
-	case KCMD_STATE_START_PREPARED:
-		kcmd->state = KCMD_STATE_STARTED;
-		psys->started_kcmds++;
-		list_add_tail(&kcmd->started_list, &psys->started_kcmds_list);
-		break;
-	default:
-		WARN_ON(1);
-		ret = -EINVAL;
-		goto error;
-	}
-	return 0;
-
-error:
-	dev_err(&psys->adev->dev, "failed to start process group\n");
-	ipu_psys_kcmd_complete(psys, kcmd, -EIO);
-	return ret;
-}
-
-static int ipu_psys_kcmd_queue(struct ipu_psys *psys,
-			       struct ipu_psys_kcmd *kcmd)
-{
-	int ret;
-
-	if (kcmd->state != KCMD_STATE_NEW) {
-		WARN_ON(1);
-		return -EINVAL;
-	}
-
-	if (!psys->started_kcmds) {
-		ret = ipu_psys_allocate_resources(&psys->adev->dev,
-						  kcmd->kpg->pg,
-						  kcmd->pg_manifest,
-						  &kcmd->resource_alloc,
-						  &psys->resource_pool_running);
-		if (!ret) {
-			kcmd->state = KCMD_STATE_RUN_PREPARED;
-			return ipu_psys_kcmd_start(psys, kcmd);
-		}
-
-		if (ret != -ENOSPC || !psys->active_kcmds) {
-			dev_err(&psys->adev->dev,
-				"kcmd %p failed to alloc resources (running)\n",
-				kcmd);
-			ipu_psys_kcmd_complete(psys, kcmd, ret);
-			/* kcmd_complete doesn't handle PM for KCMD_STATE_NEW */
-			pm_runtime_put(&psys->adev->dev);
-			return -EINVAL;
-		}
-	}
-
-	ret = ipu_psys_allocate_resources(&psys->adev->dev,
-					  kcmd->kpg->pg,
-					  kcmd->pg_manifest,
-					  &kcmd->resource_alloc,
-					  &psys->resource_pool_started);
-	if (!ret) {
-		kcmd->state = KCMD_STATE_START_PREPARED;
-		return ipu_psys_kcmd_start(psys, kcmd);
-	}
-
-	if (ret != -ENOSPC || !psys->started_kcmds) {
-		dev_err(&psys->adev->dev,
-			"kcmd %p failed to alloc resources (started)\n", kcmd);
-		ipu_psys_kcmd_complete(psys, kcmd, ret);
-		/* kcmd_complete doesn't handle PM for KCMD_STATE_NEW */
-		pm_runtime_put(&psys->adev->dev);
-		ret = -EINVAL;
-	}
-	return ret;
-}
-
 /*
  * Schedule next kcmd by finding a runnable kcmd from the highest
  * priority queue in a round-robin fashion versus the client
@@ -1264,7 +792,7 @@ static void ipu_psys_flush_kcmds(struct ipu_psys *psys, int error)
  * by power cycling it. PSYS power must not be acquired
  * except by running kcmds when calling this.
  */
-static void ipu_psys_reset(struct ipu_psys *psys)
+void ipu_psys_reset(struct ipu_psys *psys)
 {
 #ifdef CONFIG_PM
 	struct device *d = &psys->adev->isp->psys_iommu->dev;
@@ -1340,126 +868,6 @@ static void ipu_psys_watchdog_work(struct work_struct *work)
 	mutex_unlock(&psys->mutex);
 }
 
-static void ipu_psys_watchdog(unsigned long data)
-{
-	struct ipu_psys_kcmd *kcmd = (struct ipu_psys_kcmd *)data;
-	struct ipu_psys *psys = kcmd->fh->psys;
-
-	queue_work(IPU_PSYS_WORK_QUEUE, &psys->watchdog_work);
-}
-
-
-static int ipu_psys_config_legacy_pg(struct ipu_psys_kcmd *kcmd)
-{
-	struct ipu_psys *psys = kcmd->fh->psys;
-	unsigned int i;
-	int ret;
-
-	ret = ipu_fw_psys_pg_set_ipu_vaddress(kcmd, kcmd->kpg->pg_dma_addr);
-	if (ret) {
-		ret = -EIO;
-		goto error;
-	}
-
-	for (i = 0; i < kcmd->nbuffers; i++) {
-		struct ipu_fw_psys_terminal *terminal;
-		u32 buffer;
-
-		terminal = ipu_fw_psys_pg_get_terminal(kcmd, i);
-		if (!terminal)
-			continue;
-
-		buffer = (u32) kcmd->kbufs[i]->dma_addr +
-		    kcmd->buffers[i].data_offset;
-
-		ret = ipu_fw_psys_terminal_set(terminal, i, kcmd,
-					       buffer, kcmd->kbufs[i]->len);
-		if (ret == -EAGAIN)
-			continue;
-
-		if (ret) {
-			dev_err(&psys->adev->dev, "Unable to set terminal\n");
-			goto error;
-		}
-	}
-
-	ipu_fw_psys_pg_set_token(kcmd, (u64) kcmd);
-
-	ret = ipu_fw_psys_pg_submit(kcmd);
-	if (ret) {
-		dev_err(&psys->adev->dev, "failed to submit kcmd!\n");
-		goto error;
-	}
-
-	return 0;
-
-error:
-	dev_err(&psys->adev->dev, "failed to config legacy pg\n");
-	return ret;
-}
-
-static int ipu_psys_kcmd_new(struct ipu_psys_command *cmd,
-			     struct ipu_psys_fh *fh)
-{
-	struct ipu_psys *psys = fh->psys;
-	struct ipu_psys_kcmd *kcmd;
-	size_t pg_size;
-	int ret;
-
-	if (psys->adev->isp->flr_done)
-		return -EIO;
-
-	kcmd = ipu_psys_copy_cmd(cmd, fh);
-	if (!kcmd)
-		return -EINVAL;
-
-	ipu_psys_resource_alloc_init(&kcmd->resource_alloc);
-
-	init_timer(&kcmd->watchdog);
-	kcmd->watchdog.data = (unsigned long)kcmd;
-	kcmd->watchdog.function = &ipu_psys_watchdog;
-
-	if (cmd->min_psys_freq) {
-		kcmd->constraint.min_freq = cmd->min_psys_freq;
-		ipu_buttress_add_psys_constraint(psys->adev->isp,
-						 &kcmd->constraint);
-	}
-
-	pg_size = ipu_fw_psys_pg_get_size(kcmd);
-	if (pg_size > kcmd->kpg->pg_size) {
-		dev_dbg(&psys->adev->dev, "pg size mismatch %lu %lu\n",
-			pg_size, kcmd->kpg->pg_size);
-		ret = -EINVAL;
-		goto error;
-	}
-
-	ret = ipu_psys_config_legacy_pg(kcmd);
-
-	if (ret)
-		goto error;
-
-	mutex_lock(&fh->mutex);
-	list_add_tail(&kcmd->list, &fh->kcmds[cmd->priority]);
-	if (!fh->new_kcmd_tail[cmd->priority] && kcmd->state == KCMD_STATE_NEW) {
-		fh->new_kcmd_tail[cmd->priority] = kcmd;
-		/* Kick command scheduler thread */
-		atomic_set(&psys->wakeup_sched_thread_count, 1);
-		wake_up_interruptible(&psys->sched_cmd_wq);
-	}
-	mutex_unlock(&fh->mutex);
-
-	dev_dbg(&psys->adev->dev,
-		"IOC_QCMD: user_token:%llx issue_id:0x%llx pri:%d\n",
-		cmd->user_token, cmd->issue_id, cmd->priority);
-
-	return 0;
-
-error:
-	ipu_psys_kcmd_free(kcmd);
-
-	return ret;
-}
-
 static struct ipu_psys_kcmd *__ipu_get_completed_kcmd(struct ipu_psys *psys,
 						      struct ipu_psys_fh *fh)
 {
@@ -1844,7 +1252,7 @@ static int psys_runtime_pm_resume(struct device *dev)
 		return 0;
 	}
 
-	psys_setup_hw(psys);
+	ipu_psys_setup_hw(psys);
 
 	ipu_trace_restore(&psys->adev->dev);
 
@@ -2054,6 +1462,11 @@ static int ipu_psys_init_debugfs(struct ipu_psys *psys)
 
 	psys->debugfsdir = dir;
 
+#ifdef IPU_PSYS_GPC
+	if (ipu_psys_gpc_init_debugfs(psys))
+		return -ENOMEM;
+#endif
+
 	return 0;
 err:
 	debugfs_remove_recursive(dir);
@@ -2461,70 +1874,6 @@ static void ipu_psys_remove(struct ipu_bus_device *adev)
 	dev_info(&adev->dev, "removed\n");
 }
 
-static bool ipu_psys_kcmd_is_valid(struct ipu_psys *psys,
-				   struct ipu_psys_kcmd *kcmd)
-{
-	struct ipu_psys_fh *fh;
-	struct ipu_psys_kcmd *kcmd0;
-	int p;
-
-	list_for_each_entry(fh, &psys->fhs, list) {
-		mutex_lock(&fh->mutex);
-		for (p = 0; p < IPU_PSYS_CMD_PRIORITY_NUM; p++) {
-			list_for_each_entry(kcmd0, &fh->kcmds[p], list) {
-				if (kcmd0 == kcmd) {
-					mutex_unlock(&fh->mutex);
-					return true;
-				}
-			}
-		}
-		mutex_unlock(&fh->mutex);
-	}
-
-	return false;
-}
-
-static void ipu_psys_handle_events(struct ipu_psys *psys)
-{
-	struct ipu_psys_kcmd *kcmd = NULL;
-	struct ipu_fw_psys_event event;
-	bool error;
-
-	do {
-		memset(&event, 0, sizeof(event));
-		if (!ipu_fw_psys_rcv_event(psys, &event))
-			break;
-
-		error = false;
-		kcmd = (struct ipu_psys_kcmd *)event.token;
-		error = IS_ERR_OR_NULL(kcmd) ? true : false;
-
-		dev_dbg(&psys->adev->dev, "psys received event status:%d\n",
-			event.status);
-
-		if (error) {
-			dev_err(&psys->adev->dev,
-				"no token received, command unknown\n");
-			pm_runtime_put(&psys->adev->dev);
-			ipu_psys_reset(psys);
-			pm_runtime_get(&psys->adev->dev);
-			break;
-		}
-
-		if (ipu_psys_kcmd_is_valid(psys, kcmd))
-			ipu_psys_kcmd_complete(psys, kcmd,
-					       event.status ==
-					       IPU_PSYS_EVENT_CMD_COMPLETE ||
-					       event.status ==
-					       IPU_PSYS_EVENT_FRAGMENT_COMPLETE
-					       ? 0 : -EIO);
-
-		/* Kick command scheduler thread */
-		atomic_set(&psys->wakeup_sched_thread_count, 1);
-		wake_up_interruptible(&psys->sched_cmd_wq);
-	} while (1);
-}
-
 static irqreturn_t psys_isr_threaded(struct ipu_bus_device *adev)
 {
 	struct ipu_psys *psys = ipu_bus_get_drvdata(adev);
diff --git a/drivers/media/pci/intel/ipu-psys.h b/drivers/media/pci/intel/ipu-psys.h
index 1743b01..55a6744 100644
--- a/drivers/media/pci/intel/ipu-psys.h
+++ b/drivers/media/pci/intel/ipu-psys.h
@@ -9,7 +9,6 @@
 
 #include "ipu.h"
 #include "ipu-pdata.h"
-#include "ipu-resources.h"
 #include "ipu-fw-psys.h"
 
 #include <uapi/linux/ipu-psys.h>
@@ -23,9 +22,62 @@
 #define IPU_PSYS_CLOSE_TIMEOUT (100000 / IPU_PSYS_CLOSE_TIMEOUT_US)
 #define IPU_PSYS_BUF_SET_POOL_SIZE 16
 #define IPU_PSYS_BUF_SET_MAX_SIZE 1024
+#define IPU_PSYS_WORK_QUEUE		system_power_efficient_wq
+#define IPU_MAX_RESOURCES 32
+
+/* Opaque structure. Do not access fields. */
+struct ipu_resource {
+	u32 id;
+	int elements;	/* Number of elements available to allocation */
+	unsigned long *bitmap;	/* Allocation bitmap, a bit for each element */
+};
 
-struct task_struct;
+enum ipu_resource_type {
+	IPU_RESOURCE_DEV_CHN = 0,
+	IPU_RESOURCE_EXT_MEM,
+	IPU_RESOURCE_DFM
+};
+
+/* Allocation of resource(s) */
+/* Opaque structure. Do not access fields. */
+struct ipu_resource_alloc {
+	enum ipu_resource_type type;
+	struct ipu_resource *resource;
+	int elements;
+	int pos;
+};
+
+/*
+ * This struct represents all of the currently allocated
+ * resources from IPU model. It is used also for allocating
+ * resources for the next set of PGs to be run on IPU
+ * (ie. those PGs which are not yet being run and which don't
+ * yet reserve real IPU resources).
+ */
+#define IPU_PSYS_RESOURCE_OVERALLOC 2	/* Some room for ABI / ext lib delta */
+struct ipu_psys_resource_pool {
+	u32 cells;	/* Bitmask of cells allocated */
+	struct ipu_resource dev_channels[IPU_FW_PSYS_N_DEV_CHN_ID +
+					 IPU_PSYS_RESOURCE_OVERALLOC];
+	struct ipu_resource ext_memory[IPU_FW_PSYS_N_MEM_ID +
+				       IPU_PSYS_RESOURCE_OVERALLOC];
+	struct ipu_resource dfms[IPU_FW_PSYS_N_DEV_DFM_ID +
+				 IPU_PSYS_RESOURCE_OVERALLOC];
+};
+
+/*
+ * This struct keeps book of the resources allocated for a specific PG.
+ * It is used for freeing up resources from struct ipu_psys_resources
+ * when the PG is released from IPU4 (or model of IPU4).
+ */
+struct ipu_psys_resource_alloc {
+	u32 cells;	/* Bitmask of cells needed */
+	struct ipu_resource_alloc
+	 resource_alloc[IPU_MAX_RESOURCES];
+	int resources;
+};
 
+struct task_struct;
 struct ipu_psys {
 	struct cdev cdev;
 	struct device dev;
@@ -78,6 +130,7 @@ struct ipu_psys_fh {
 	struct list_head buf_sets;
 };
 
+
 struct ipu_psys_pg {
 	struct ipu_fw_psys_process_group *pg;
 	size_t size;
@@ -164,6 +217,25 @@ long ipu_psys_compat_ioctl32(struct file *file, unsigned int cmd,
 			     unsigned long arg);
 #endif
 
-void psys_setup_hw(struct ipu_psys *psys);
+void ipu_psys_setup_hw(struct ipu_psys *psys);
+void ipu_psys_reset(struct ipu_psys *psys);
+void ipu_psys_handle_events(struct ipu_psys *psys);
+int ipu_psys_kcmd_new(struct ipu_psys_command *cmd, struct ipu_psys_fh *fh);
+int ipu_psys_kcmd_queue(struct ipu_psys *psys, struct ipu_psys_kcmd *kcmd);
+void ipu_psys_kcmd_complete(struct ipu_psys *psys,
+			    struct ipu_psys_kcmd *kcmd, int error);
+int ipu_psys_kcmd_abort(struct ipu_psys *psys,
+			struct ipu_psys_kcmd *kcmd, int error);
+void ipu_psys_kcmd_free(struct ipu_psys_kcmd *kcmd);
+struct ipu_psys_pg *__get_pg_buf(struct ipu_psys *psys, size_t pg_size);
+struct ipu_psys_kbuffer *
+ipu_psys_lookup_kbuffer(struct ipu_psys_fh *fh, int fd);
+struct ipu_psys_kbuffer *
+ipu_psys_lookup_kbuffer_by_kaddr(struct ipu_psys_fh *fh, void *kaddr);
+#ifdef IPU_PSYS_GPC
+int ipu_psys_gpc_init_debugfs(struct ipu_psys *psys);
+#endif
+int ipu_psys_resource_pool_init(struct ipu_psys_resource_pool *pool);
+void ipu_psys_resource_pool_cleanup(struct ipu_psys_resource_pool *pool);
 
 #endif /* IPU_PSYS_H */
diff --git a/drivers/media/pci/intel/ipu-resources.h b/drivers/media/pci/intel/ipu-resources.h
deleted file mode 100644
index 39ed8e1..0000000
--- a/drivers/media/pci/intel/ipu-resources.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/* SPDX-License_Identifier: GPL-2.0 */
-/* Copyright (C) 2015 - 2018 Intel Corporation */
-
-#include "ipu-fw-psys.h"
-#include "ipu-platform-resources.h"
-
-#ifndef IPU_RESOURCES_H
-#define IPU_RESOURCES_H
-
-/********** Generic resource handling **********/
-
-extern const u32 ipu_fw_psys_cell_types[];
-extern const u16 ipu_num_dev_channels[];
-extern const u16 ipu_fw_psys_mem_size[];
-
-extern const enum ipu_mem_id ipu_fw_psys_cell_mem
-	[IPU_FW_PSYS_N_CELL_ID][IPU_FW_PSYS_N_DATA_MEM_TYPE_ID];
-extern const struct ipu_resource_definitions *res_defs;
-
-/* Opaque structure. Do not access fields. */
-struct ipu_resource {
-	u32 id;
-	int elements;	/* Number of elements available to allocation */
-	unsigned long *bitmap;	/* Allocation bitmap, a bit for each element */
-};
-
-enum ipu_resource_type {
-	IPU_RESOURCE_DEV_CHN = 0,
-	IPU_RESOURCE_EXT_MEM,
-	IPU_RESOURCE_DFM
-};
-
-/* Allocation of resource(s) */
-/* Opaque structure. Do not access fields. */
-struct ipu_resource_alloc {
-	enum ipu_resource_type type;
-	struct ipu_resource *resource;
-	int elements;
-	int pos;
-};
-
-/********** IPU PSYS-specific resource handling **********/
-
-#define IPU_MAX_RESOURCES 32
-
-struct ipu_fw_psys_program_group_manifest {
-	u32 kernel_bitmap[IPU_FW_PSYS_KERNEL_BITMAP_NOF_ELEMS];
-	u32 ID;
-	u16 program_manifest_offset;
-	u16 terminal_manifest_offset;
-	u16 private_data_offset;
-	u16 rbm_manifest_offset;
-	u16 size;
-	u8 alignment;
-	u8 kernel_count;
-	u8 program_count;
-	u8 terminal_count;
-	u8 subgraph_count;
-	u8 reserved[5];
-};
-
-struct ipu_fw_generic_program_manifest {
-	u16 *dev_chn_size;
-	u16 *dev_chn_offset;
-	u16 *ext_mem_size;
-	u16 *ext_mem_offset;
-	u8 cell_id;
-	u8 cells[IPU_FW_PSYS_PROCESS_MAX_CELLS];
-	u8 cell_type_id;
-	u8 *is_dfm_relocatable;
-	u32 *dfm_port_bitmap;
-	u32 *dfm_active_port_bitmap;
-};
-
-struct ipu_fw_generic_process {
-	u16 ext_mem_id;
-	u16 ext_mem_offset;
-	u16 dev_chn_offset;
-	u16 cell_id;
-	u16 dfm_port_bitmap;
-	u16 dfm_active_port_bitmap;
-};
-
-struct ipu_resource_definitions {
-	u32 num_cells;
-	u32 num_cells_type;
-	const u32 *cells;
-	u32 num_dev_channels;
-	const u16 *dev_channels;
-
-	u32 num_ext_mem_types;
-	u32 num_ext_mem_ids;
-	const u16 *ext_mem_ids;
-
-	u32 num_dfm_ids;
-	const u16 *dfms;
-
-	u32 cell_mem_row;
-	const enum ipu_mem_id *cell_mem;
-	struct ipu_fw_generic_process process;
-};
-
-/*
- * This struct represents all of the currently allocated
- * resources from IPU model. It is used also for allocating
- * resources for the next set of PGs to be run on IPU
- * (ie. those PGs which are not yet being run and which don't
- * yet reserve real IPU resources).
- */
-#define IPU_PSYS_RESOURCE_OVERALLOC 2	/* Some room for ABI / ext lib delta */
-struct ipu_psys_resource_pool {
-	u32 cells;	/* Bitmask of cells allocated */
-	struct ipu_resource dev_channels[IPU_FW_PSYS_N_DEV_CHN_ID +
-					 IPU_PSYS_RESOURCE_OVERALLOC];
-	struct ipu_resource ext_memory[IPU_FW_PSYS_N_MEM_ID +
-				       IPU_PSYS_RESOURCE_OVERALLOC];
-	struct ipu_resource dfms[IPU_FW_PSYS_N_DEV_DFM_ID +
-				 IPU_PSYS_RESOURCE_OVERALLOC];
-};
-
-/*
- * This struct keeps book of the resources allocated for a specific PG.
- * It is used for freeing up resources from struct ipu_psys_resources
- * when the PG is released from IPU4 (or model of IPU4).
- */
-struct ipu_psys_resource_alloc {
-	u32 cells;	/* Bitmask of cells needed */
-	struct ipu_resource_alloc
-	 resource_alloc[IPU_MAX_RESOURCES];
-	int resources;
-};
-
-struct ipu_fw_psys_process_group;
-
-int ipu_psys_resource_pool_init(struct ipu_psys_resource_pool *pool);
-
-void ipu_psys_resource_pool_cleanup(struct ipu_psys_resource_pool *pool);
-
-void ipu_psys_resource_alloc_init(struct ipu_psys_resource_alloc *alloc);
-
-int ipu_psys_allocate_resources(const struct device *dev,
-				struct ipu_fw_psys_process_group *pg,
-				void *pg_manifest,
-				struct ipu_psys_resource_alloc *alloc,
-				struct ipu_psys_resource_pool *pool);
-int ipu_psys_move_resources(const struct device *dev,
-			    struct ipu_psys_resource_alloc *alloc,
-			    struct ipu_psys_resource_pool *source_pool,
-			    struct ipu_psys_resource_pool *target_pool);
-
-void ipu_psys_free_resources(struct ipu_psys_resource_alloc *alloc,
-			     struct ipu_psys_resource_pool *pool);
-
-#endif
diff --git a/drivers/media/pci/intel/ipu-trace.c b/drivers/media/pci/intel/ipu-trace.c
index 1a23fe1..0d8364b 100644
--- a/drivers/media/pci/intel/ipu-trace.c
+++ b/drivers/media/pci/intel/ipu-trace.c
@@ -371,16 +371,28 @@ static int update_register_cache(struct ipu_device *isp, u32 reg, u32 value)
 	int i, range;
 	int rval = -EINVAL;
 
-	if (dctrl->isys.offset &&
-	    reg >= dctrl->isys.offset &&
-	    reg < dctrl->isys.offset + TRACE_REG_MAX_ISYS_OFFSET)
-		sys = &dctrl->isys;
-	else if (dctrl->psys.offset &&
-		 reg >= dctrl->psys.offset &&
-		 reg < dctrl->psys.offset + TRACE_REG_MAX_PSYS_OFFSET)
-		sys = &dctrl->psys;
-	else
-		goto error;
+	if (dctrl->isys.offset == dctrl->psys.offset) {
+		/* For the IPU with uniform address space */
+		if (reg >= IPU_ISYS_OFFSET &&
+			reg < IPU_ISYS_OFFSET + TRACE_REG_MAX_ISYS_OFFSET)
+			sys = &dctrl->isys;
+		else if (reg >= IPU_PSYS_OFFSET &&
+			reg < IPU_PSYS_OFFSET + TRACE_REG_MAX_PSYS_OFFSET)
+			sys = &dctrl->psys;
+		else
+			goto error;
+	} else {
+		if (dctrl->isys.offset &&
+		    reg >= dctrl->isys.offset &&
+		    reg < dctrl->isys.offset + TRACE_REG_MAX_ISYS_OFFSET)
+			sys = &dctrl->isys;
+		else if (dctrl->psys.offset &&
+			 reg >= dctrl->psys.offset &&
+			 reg < dctrl->psys.offset + TRACE_REG_MAX_PSYS_OFFSET)
+			sys = &dctrl->psys;
+		else
+			goto error;
+	}
 
 	blocks = sys->blocks;
 	dev = sys->dev;
diff --git a/drivers/media/pci/intel/ipu-trace.h b/drivers/media/pci/intel/ipu-trace.h
index 8231c9e..4c54436 100644
--- a/drivers/media/pci/intel/ipu-trace.h
+++ b/drivers/media/pci/intel/ipu-trace.h
@@ -5,8 +5,6 @@
 #define IPU_TRACE_H
 #include <linux/debugfs.h>
 
-#define TRACE_REG_MAX_ISYS_OFFSET	0x0fffff
-#define TRACE_REG_MAX_PSYS_OFFSET	0xffffff
 #define TRACE_REG_MAX_BLOCK_SIZE	0x0fff
 
 #define TRACE_REG_END_MARK 0xffff
diff --git a/drivers/media/pci/intel/ipu-wrapper.h b/drivers/media/pci/intel/ipu-wrapper.h
index e9c340a..4441d05 100644
--- a/drivers/media/pci/intel/ipu-wrapper.h
+++ b/drivers/media/pci/intel/ipu-wrapper.h
@@ -11,10 +11,6 @@
 #define PSYS_MMID 0
 
 struct device;
-struct ia_css_env;
-struct ipu_isys_iomem_filter;
-struct iommu_domain;
-struct firmware;
 
 void ipu_wrapper_init(int mmid, struct device *dev, void __iomem *base);
 
diff --git a/drivers/media/pci/intel/ipu4/Makefile b/drivers/media/pci/intel/ipu4/Makefile
index c5e54af..7a20874 100644
--- a/drivers/media/pci/intel/ipu4/Makefile
+++ b/drivers/media/pci/intel/ipu4/Makefile
@@ -1,50 +1,31 @@
-#
-#  Copyright (c) 2010 - 2018, Intel Corporation.
-#
-#  This program is free software; you can redistribute it and/or modify it
-#  under the terms and conditions of the GNU General Public License,
-#  version 2, as published by the Free Software Foundation.
-#
-#  This program is distributed in the hope it will be useful, but WITHOUT
-#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-#  more details.
-#
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (c) 2010 - 2018, Intel Corporation.
 
 ifneq ($(EXTERNAL_BUILD), 1)
 srcpath := $(srctree)
 endif
 
-#
-#config for bxt-p platform
-#
 ifdef CONFIG_VIDEO_INTEL_IPU4
-
-IPU_STEP = bxtB0
 ccflags-y += -DHAS_DUAL_CMD_CTX_SUPPORT=0
 
-ifndef IPU_STEP
-  $(error No IPU_STEP was defined. Stopping.)
-endif
+intel-ipu4-objs				+= ../ipu.o \
+					   ../ipu-bus.o \
+					   ../ipu-dma.o \
+					   ../ipu-buttress.o \
+					   ../ipu-trace.o \
+					   ../ipu-cpd.o \
+					   ../ipu-fw-com.o \
+					   ipu4.o
+
+obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4.o
+
+intel-ipu4-mmu-objs			+= ../ipu-mmu.o
+obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-mmu.o
 
-intel-ipu4-mod-$(IPU_STEP)-objs			+= \
-						../ipu.o \
-						../ipu-bus.o \
-						../ipu-dma.o \
-						../ipu-buttress.o \
-						../ipu-trace.o \
-						../ipu-cpd.o \
-						../ipu-fw-com.o \
-						ipu4.o
-
-obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-mod-$(IPU_STEP).o
-intel-ipu4-mmu-$(IPU_STEP)-objs		+= ../ipu-mmu.o
-obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-mmu-$(IPU_STEP).o
-intel-ipu4-isys-mod-$(IPU_STEP)-objs	+= ../ipu-isys.o \
+intel-ipu4-isys-objs			+= ../ipu-isys.o \
 					   ../ipu-isys-csi2.o \
 					   ipu4-isys.o \
 					   ipu4-isys-csi2.o \
-					   ../ipu-isys-media.o \
 					   ../ipu-isys-csi2-be-soc.o \
 					   ../ipu-isys-csi2-be.o \
 					   ../ipu-fw-isys.o \
@@ -53,24 +34,23 @@ intel-ipu4-isys-mod-$(IPU_STEP)-objs	+= ../ipu-isys.o \
 					   ../ipu-isys-queue.o \
 					   ../ipu-isys-subdev.o \
 					   ../ipu-isys-tpg.o
-obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-isys-mod-$(IPU_STEP).o
 
-intel-ipu4-psys-mod-$(IPU_STEP)-objs	+= \
-					../ipu-psys.o \
-					../ipu-resources.o \
-					ipu4-psys.o \
-					ipu4-resource-tables.o \
+obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-isys.o
+
+intel-ipu4-psys-objs			+= ../ipu-psys.o \
+					   ipu4-psys.o \
+					   ipu4-resources.o \
 
 ifndef CONFIG_VIDEO_INTEL_IPU_FW_LIB
-intel-ipu4-psys-mod-$(IPU_STEP)-objs	+= ipu4-fw-resources.o \
-					../ipu-fw-psys.o
+intel-ipu4-psys-objs			+= ipu4-fw-resources.o \
+					   ../ipu-fw-psys.o
 endif
 
 ifeq ($(CONFIG_COMPAT),y)
-intel-ipu4-psys-mod-$(IPU_STEP)-objs	+= ../ipu-psys-compat32.o
+intel-ipu4-psys-objs			+= ../ipu-psys-compat32.o
 endif
 
-obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-psys-mod-$(IPU_STEP).o
+obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-psys.o
 
 ifdef CONFIG_VIDEO_INTEL_IPU_FW_LIB
 include $(srcpath)/$(src)/ipu4-css/Makefile.isyslib
@@ -80,42 +60,34 @@ endif
 ccflags-y += -I$(srcpath)/$(src)/../../../../../include/
 ccflags-y += -I$(srcpath)/$(src)/../
 ccflags-y += -I$(srcpath)/$(src)/
+ifdef CONFIG_VIDEO_INTEL_IPU_FW_LIB
 ccflags-y += -I$(srcpath)/$(src)/ipu4-css
+endif
 
 ccflags-y += -DPARAMETER_INTERFACE_V2
-
 endif
 
-#
-#config for cnl platform
-#
 ifdef CONFIG_VIDEO_INTEL_IPU4P
-
-IPU_STEP = cnl
 ccflags-y += -DHAS_DUAL_CMD_CTX_SUPPORT=0
 
-ifndef IPU_STEP
-  $(error No IPU_STEP was defined. Stopping.)
-endif
+intel-ipu4p-objs			+= ../ipu.o \
+					   ../ipu-bus.o \
+					   ../ipu-dma.o \
+					   ../ipu-buttress.o \
+					   ../ipu-trace.o \
+					   ../ipu-cpd.o \
+					   ../ipu-fw-com.o \
+					   ipu4.o
+
+obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4p.o
+
+intel-ipu4p-mmu-objs			+= ../ipu-mmu.o
+obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4p-mmu.o
 
-intel-ipu4-mod-$(IPU_STEP)-objs			+= \
-						../ipu.o \
-						../ipu-bus.o \
-						../ipu-dma.o \
-						../ipu-buttress.o \
-						../ipu-trace.o \
-						../ipu-cpd.o \
-						../ipu-fw-com.o \
-						ipu4.o
-
-obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-mod-$(IPU_STEP).o
-intel-ipu4-mmu-$(IPU_STEP)-objs		+= ../ipu-mmu.o
-obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-mmu-$(IPU_STEP).o
-intel-ipu4-isys-mod-$(IPU_STEP)-objs	+= ../ipu-isys.o \
+intel-ipu4p-isys-objs			+= ../ipu-isys.o \
 					   ../ipu-isys-csi2.o \
 					   ipu4-isys.o \
 					   ipu4p-isys-csi2.o \
-					   ../ipu-isys-media.o \
 					   ../ipu-isys-csi2-be-soc.o \
 					   ../ipu-isys-csi2-be.o \
 					   ../ipu-fw-isys.o \
@@ -124,24 +96,22 @@ intel-ipu4-isys-mod-$(IPU_STEP)-objs	+= ../ipu-isys.o \
 					   ../ipu-isys-queue.o \
 					   ../ipu-isys-subdev.o \
 					   ../ipu-isys-tpg.o
-obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-isys-mod-$(IPU_STEP).o
+obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4p-isys.o
 
-intel-ipu4-psys-mod-$(IPU_STEP)-objs	+= \
-					../ipu-psys.o \
-					../ipu-resources.o \
-					ipu4-psys.o \
-					ipu4-resource-tables.o \
+intel-ipu4p-psys-objs			+= ../ipu-psys.o \
+					   ipu4-psys.o \
+					   ipu4-resources.o \
 
 ifndef CONFIG_VIDEO_INTEL_IPU_FW_LIB
-intel-ipu4-psys-mod-$(IPU_STEP)-objs	+= ipu4-fw-resources.o \
-					../ipu-fw-psys.o
+intel-ipu4p-psys-objs			+= ipu4-fw-resources.o \
+					   ../ipu-fw-psys.o
 endif
 
 ifeq ($(CONFIG_COMPAT),y)
-intel-ipu4-psys-mod-$(IPU_STEP)-objs	+= ../ipu-psys-compat32.o
+intel-ipu4p-psys-objs			+= ../ipu-psys-compat32.o
 endif
 
-obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-psys-mod-$(IPU_STEP).o
+obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4p-psys.o
 
 ifdef CONFIG_VIDEO_INTEL_IPU_FW_LIB
 include $(srcpath)/$(src)/ipu4p-css/Makefile.isyslib
@@ -151,8 +121,9 @@ endif
 ccflags-y += -I$(srcpath)/$(src)/../../../../../include/
 ccflags-y += -I$(srcpath)/$(src)/../
 ccflags-y += -I$(srcpath)/$(src)/
+ifdef CONFIG_VIDEO_INTEL_IPU_FW_LIB
 ccflags-y += -I$(srcpath)/$(src)/ipu4p-css
+endif
 
 ccflags-y += -DPARAMETER_INTERFACE_V2
-
 endif
diff --git a/drivers/media/pci/intel/ipu4/ipu-platform-regs.h b/drivers/media/pci/intel/ipu4/ipu-platform-regs.h
index bb16259..7f27273 100644
--- a/drivers/media/pci/intel/ipu4/ipu-platform-regs.h
+++ b/drivers/media/pci/intel/ipu4/ipu-platform-regs.h
@@ -181,6 +181,10 @@
 #define IPU_INFO_ZLW                               BIT(2)
 #define IPU_INFO_STREAM_ID_SET(a)	((a & 0xF) << 4)
 #define IPU_INFO_ADDRESS_SWIZZ                     BIT(8)
+
+/* Trace unit related register definitions */
+#define TRACE_REG_MAX_ISYS_OFFSET	0x0fffff
+#define TRACE_REG_MAX_PSYS_OFFSET	0xffffff
 /* ISYS trace registers - offsets to isys base address */
 /* Trace unit base offset */
 #define TRACE_REG_IS_TRACE_UNIT_BASE			0x07d000
@@ -255,4 +259,5 @@
 #define IPU_REG_PSYS_GPDEV_FWIRQ(n)		(4 * (n) + 0x60100)
 /* CDC Burst collector thresholds for psys - 4 FIFOs i= 0..3 */
 #define IPU_REG_PSYS_CDC_THRESHOLD(i)           (0x60600 + ((i) * 4))
+
 #endif /* IPU_REGS_H */
diff --git a/drivers/media/pci/intel/ipu4/ipu-platform-resources.h b/drivers/media/pci/intel/ipu4/ipu-platform-resources.h
index 26b2725..784a030 100644
--- a/drivers/media/pci/intel/ipu4/ipu-platform-resources.h
+++ b/drivers/media/pci/intel/ipu4/ipu-platform-resources.h
@@ -4,6 +4,8 @@
 #ifndef IPU_PLATFORM_RESOURCES_H
 #define IPU_PLATFORM_RESOURCES_H
 
+#include <linux/kernel.h>
+
 /* ia_css_psys_program_group_private.h */
 /* ia_css_psys_process_group_cmd_impl.h */
 #ifdef CONFIG_VIDEO_INTEL_IPU4P
@@ -201,4 +203,28 @@ struct ipu_fw_psys_process {
 	u8 padding[IPU_FW_PSYS_N_PADDING_UINT8_IN_PROCESS_STRUCT];
 };
 
-#endif
+struct ipu_psys_resource_alloc;
+struct ipu_fw_psys_process_group;
+struct ipu_psys_resource_pool;
+void ipu_psys_resource_alloc_init(struct ipu_psys_resource_alloc *alloc);
+int ipu_psys_allocate_resources(const struct device *dev,
+				struct ipu_fw_psys_process_group *pg,
+				void *pg_manifest,
+				struct ipu_psys_resource_alloc *alloc,
+				struct ipu_psys_resource_pool *pool);
+int ipu_psys_move_resources(const struct device *dev,
+			    struct ipu_psys_resource_alloc *alloc,
+			    struct ipu_psys_resource_pool *source_pool,
+			    struct ipu_psys_resource_pool *target_pool);
+
+void ipu_psys_free_resources(struct ipu_psys_resource_alloc *alloc,
+			     struct ipu_psys_resource_pool *pool);
+
+extern const u32 ipu_fw_psys_cell_types[];
+extern const u16 ipu_fw_num_dev_channels[];
+extern const u16 ipu_fw_psys_mem_size[];
+extern const enum ipu_mem_id ipu_fw_psys_cell_mem
+	[IPU_FW_PSYS_N_CELL_ID][IPU_FW_PSYS_N_DATA_MEM_TYPE_ID];
+extern const struct ipu_fw_resource_definitions *res_defs;
+
+#endif /* IPU_PLATFORM_RESOURCES_H */
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/Makefile.isyslib b/drivers/media/pci/intel/ipu4/ipu4-css/Makefile.isyslib
index 967b821..2659e9b 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/Makefile.isyslib
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/Makefile.isyslib
@@ -15,36 +15,34 @@ include $(srcpath)/$(src)/ipu4-css/Makefile.ipu4isys_src
 #
 $(shell cp -f $(srcpath)/$(src)/../ipu-wrapper.c $(srcpath)/$(src)/ipu4-css/ipu-wrapper.c)
 
-lib2600-mod-$(IPU_STEP)-objs := \
-	ipu4-css/libintel-ipu4.o \
-	../libintel-checker.o \
-	$(IPU_ISYSLIB_SRC)
+intel-ipu4-isys-csslib-objs := \
+			ipu4-css/libintel-ipu4.o \
+			../libintel-checker.o \
+			$(IPU_ISYSLIB_SRC)
 
 ifeq ($(CONFIG_VIDEO_INTEL_IPU), m)
-lib2600-mod-$(IPU_STEP)-objs += ipu4-css/ipu-wrapper.o
+intel-ipu4-isys-csslib-objs += ipu4-css/ipu-wrapper.o
 endif
+obj-$(CONFIG_VIDEO_INTEL_IPU)	+= intel-ipu4-isys-csslib.o
 
-obj-$(CONFIG_VIDEO_INTEL_IPU)	+= lib2600-mod-$(IPU_STEP).o
-
-INCLUDES := \
-	-I$(srcpath)/$(src)/$(IPU_ISYSLIB_ROOT_REL) \
+INCLUDES := -I$(srcpath)/$(src)/$(IPU_ISYSLIB_ROOT_REL) \
 	-I$(srcpath)/$(src) \
 	$(IPU_ISYSLIB_INC)
 
 DEFINES:= -D__HOST__ -D__KERNEL__ -DISYS_FPGA -DPSYS_FPGA
 
- DEFINES += -DSSID=1
- DEFINES += -DMMID=1
- DEFINES += -DPROGNAME=isys_fw
- DEFINES += -DPROGMAP=\"isys_fw.map.h\"
- DEFINES += -DSUBSYSTEM_INCLUDE=\<isys.h\>
- DEFINES += -DCELL=input_system_unis_logic_sp_control_tile_sp
- DEFINES += -DSPMAIN=isys_fw
- DEFINES += -DRUN_INTEGRATION
- DEFINES += -DDEBUG_SP_NCI
- DEFINES += -DCFG_VIED_SUBSYSTEM_ACCESS_LIB_IMPL=1
- DEFINES += -DHRT_ON_VIED_SUBSYSTEM_ACCESS=0
- DEFINES += -DHRT_USE_VIR_ADDRS
- DEFINES += -DHRT_HW
+DEFINES += -DSSID=1
+DEFINES += -DMMID=1
+DEFINES += -DPROGNAME=isys_fw
+DEFINES += -DPROGMAP=\"isys_fw.map.h\"
+DEFINES += -DSUBSYSTEM_INCLUDE=\<isys.h\>
+DEFINES += -DCELL=input_system_unis_logic_sp_control_tile_sp
+DEFINES += -DSPMAIN=isys_fw
+DEFINES += -DRUN_INTEGRATION
+DEFINES += -DDEBUG_SP_NCI
+DEFINES += -DCFG_VIED_SUBSYSTEM_ACCESS_LIB_IMPL=1
+DEFINES += -DHRT_ON_VIED_SUBSYSTEM_ACCESS=0
+DEFINES += -DHRT_USE_VIR_ADDRS
+DEFINES += -DHRT_HW
 
 ccflags-y += $(INCLUDES) $(DEFINES) -fno-common
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/ia_css_fw_pkg_release.h b/drivers/media/pci/intel/ipu4/ipu4-css/ia_css_fw_pkg_release.h
index 4251d2f..795c783 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/ia_css_fw_pkg_release.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/ia_css_fw_pkg_release.h
@@ -11,4 +11,4 @@
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */
-#define IA_CSS_FW_PKG_RELEASE  0x20180412
+#define IA_CSS_FW_PKG_RELEASE  0x20180420
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/ipu-wrapper.c b/drivers/media/pci/intel/ipu4/ipu4-css/ipu-wrapper.c
deleted file mode 100644
index 736f15d..0000000
--- a/drivers/media/pci/intel/ipu4/ipu4-css/ipu-wrapper.c
+++ /dev/null
@@ -1,512 +0,0 @@
-// SPDX-License_Identifier: GPL-2.0
-// Copyright (C) 2013 - 2018 Intel Corporation
-
-#include <asm/cacheflush.h>
-#include <linux/io.h>
-
-#include <linux/delay.h>
-#include <linux/dma-mapping.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-
-#include "ipu-bus.h"
-#include "ipu-dma.h"
-#include "ipu-mmu.h"
-#include "ipu-wrapper.h"
-
-struct wrapper_base {
-	void __iomem *sys_base;
-	const struct dma_map_ops *ops;
-	/* Protect shared memory buffers */
-	spinlock_t lock;
-	struct list_head buffers;
-	u32 css_map_done;
-	struct device *dev;
-};
-
-struct wrapper_base isys;
-struct wrapper_base psys;
-
-struct my_css_memory_buffer_item {
-	struct list_head list;
-	dma_addr_t iova;
-	unsigned long *addr;
-	size_t bytes;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
-	struct dma_attrs attrs;
-#else
-	unsigned long attrs;
-#endif
-};
-
-unsigned long long get_hrt_base_address(void)
-{
-	return 0;
-}
-
-static struct wrapper_base *get_mem_sub_system(int mmid)
-{
-	if (mmid == ISYS_MMID)
-		return &isys;
-
-	if (mmid == PSYS_MMID)
-		return &psys;
-	WARN(1, "Invalid mem subsystem");
-	return NULL;
-}
-
-static struct wrapper_base *get_sub_system(int ssid)
-{
-	if (ssid == ISYS_SSID)
-		return &isys;
-
-	if (ssid == PSYS_SSID)
-		return &psys;
-	WARN(1, "Invalid subsystem");
-	return NULL;
-}
-
-/*
- * Subsystem access functions to access IUNIT MMIO space
- */
-static void *host_addr(int ssid, u32 addr)
-{
-	if (ssid == ISYS_SSID)
-		return isys.sys_base + addr;
-	else if (ssid == PSYS_SSID)
-		return psys.sys_base + addr;
-	/*
-	 * Calling WARN_ON is a bit brutal but better to capture wrong register
-	 * accesses immediately. We have no way to return an error here.
-	 */
-	WARN_ON(1);
-
-	return NULL;
-}
-
-void vied_subsystem_store_32(int ssid, u32 addr, u32 data)
-{
-	writel(data, host_addr(ssid, addr));
-}
-
-void vied_subsystem_store_16(int ssid, u32 addr, u16 data)
-{
-	writew(data, host_addr(ssid, addr));
-}
-
-void vied_subsystem_store_8(int ssid, u32 addr, u8 data)
-{
-	writeb(data, host_addr(ssid, addr));
-}
-
-void vied_subsystem_store(int ssid,
-			  u32 addr, const void *data, unsigned int size)
-{
-	void *dst = host_addr(ssid, addr);
-
-	dev_dbg(get_sub_system(ssid)->dev, "access: %s 0x%x size: %d\n",
-		__func__, addr, size);
-
-	for (; size >= sizeof(u32); size -= sizeof(u32),
-	     dst += sizeof(u32), data += sizeof(u32)) {
-		writel(*(u32 *) data, dst);
-	}
-	if (size >= sizeof(u16)) {
-		writew(*(u16 *) data, dst);
-		size -= sizeof(u16), dst += sizeof(u16), data += sizeof(u16);
-	}
-	if (size)
-		writeb(*(u8 *) data, dst);
-}
-
-u32 vied_subsystem_load_32(int ssid, u32 addr)
-{
-	return readl(host_addr(ssid, addr));
-}
-
-u16 vied_subsystem_load_16(int ssid, u32 addr)
-{
-	return readw(host_addr(ssid, addr));
-}
-
-u8 vied_subsystem_load_8(int ssid, u32 addr)
-{
-	return readb(host_addr(ssid, addr));
-}
-
-void vied_subsystem_load(int ssid, u32 addr, void *data, unsigned int size)
-{
-	void *src = host_addr(ssid, addr);
-
-	dev_dbg(get_sub_system(ssid)->dev, "access: %s 0x%x size: %d\n",
-		__func__, addr, size);
-
-	for (; size >= sizeof(u32); size -= sizeof(u32),
-	     src += sizeof(u32), data += sizeof(u32))
-		*(u32 *) data = readl(src);
-	if (size >= sizeof(u16)) {
-		*(u16 *) data = readw(src);
-		size -= sizeof(u16), src += sizeof(u16), data += sizeof(u16);
-	}
-	if (size)
-		*(u8 *) data = readb(src);
-}
-
-/*
- * Initialize base address for subsystem
- */
-void vied_subsystem_access_initialize(int system)
-{
-}
-
-/*
- * Shared memory access codes written by Dash Biswait,
- * copied from FPGA environment
- */
-
-/**
- * \brief Initialize the shared memory interface administration on the host.
- * \param mmid: id of ddr memory
- * \param host_ddr_addr: physical address of memory as seen from host
- * \param memory_size: size of ddr memory in bytes
- * \param ps: size of page in bytes (for instance 4096)
- */
-int shared_memory_allocation_initialize(int mmid, u64 host_ddr_addr,
-					size_t memory_size, size_t ps)
-{
-	return 0;
-}
-
-/**
- * \brief De-initialize the shared memory interface administration on the host.
- *
- */
-void shared_memory_allocation_uninitialize(int mmid)
-{
-}
-
-/**
- * \brief Initialize the shared memory interface administration on the host.
- * \param ssid: id of subsystem
- * \param mmid: id of ddr memory
- * \param mmu_ps: size of page in bits
- * \param mmu_pnrs: page numbers
- * \param ddr_addr: base address
- * \param inv_tlb: invalidate tbl
- * \param sbt: set l1 base address
- */
-int shared_memory_map_initialize(int ssid, int mmid, size_t mmu_ps,
-				 size_t mmu_pnrs, u64 ddr_addr,
-				 int inv_tlb, int sbt)
-{
-	return 0;
-}
-
-/**
- * \brief De-initialize the shared memory interface administration on the host.
- */
-void shared_memory_map_uninitialize(int ssid, int mmid)
-{
-}
-
-static u8 alloc_cookie;
-
-/**
- * \brief Allocate (DDR) shared memory space and return a host virtual address.
- * \Returns NULL when insufficient memory available
- */
-u64 shared_memory_alloc(int mmid, size_t bytes)
-{
-	struct wrapper_base *mine = get_mem_sub_system(mmid);
-	struct my_css_memory_buffer_item *buf;
-	unsigned long flags;
-
-	dev_dbg(mine->dev, "%s: in, size: %zu\n", __func__, bytes);
-
-	if (!bytes)
-		return (unsigned long)&alloc_cookie;
-
-	might_sleep();
-
-	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
-	if (!buf)
-		return 0;
-
-	/*alloc using ipu dma driver */
-	buf->bytes = PAGE_ALIGN(bytes);
-
-	buf->addr = dma_alloc_attrs(mine->dev, buf->bytes, &buf->iova,
-				    GFP_KERNEL,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
-				    NULL
-#else
-				    0
-#endif
-	    );
-	if (!buf->addr) {
-		kfree(buf);
-		return 0;
-	}
-
-	spin_lock_irqsave(&mine->lock, flags);
-	list_add(&buf->list, &mine->buffers);
-	spin_unlock_irqrestore(&mine->lock, flags);
-
-	return (unsigned long)buf->addr;
-}
-
-/**
- * \brief Free (DDR) shared memory space.
- */
-void shared_memory_free(int mmid, u64 addr)
-{
-	struct wrapper_base *mine = get_mem_sub_system(mmid);
-	struct my_css_memory_buffer_item *buf = NULL;
-	unsigned long flags;
-
-	if ((void *)addr == &alloc_cookie)
-		return;
-
-	might_sleep();
-
-	dev_dbg(mine->dev, "looking for iova %8.8llx\n", addr);
-
-	spin_lock_irqsave(&mine->lock, flags);
-	list_for_each_entry(buf, &mine->buffers, list) {
-		dev_dbg(mine->dev, "buffer addr %8.8lx\n", (long)buf->addr);
-		if ((long)buf->addr != addr)
-			continue;
-
-		dev_dbg(mine->dev, "found it!\n");
-		list_del(&buf->list);
-		spin_unlock_irqrestore(&mine->lock, flags);
-		dma_free_attrs(mine->dev, buf->bytes, buf->addr, buf->iova,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
-			       &buf->attrs
-#else
-			       buf->attrs
-#endif
-		    );
-		kfree(buf);
-		return;
-	}
-	dev_warn(mine->dev, "Can't find mem object %8.8llx\n", addr);
-	spin_unlock_irqrestore(&mine->lock, flags);
-}
-
-/**
- * \brief Convert a host virtual address to a CSS virtual address and
- * \update the MMU.
- */
-u32 shared_memory_map(int ssid, int mmid, u64 addr)
-{
-	struct wrapper_base *mine = get_mem_sub_system(mmid);
-	struct my_css_memory_buffer_item *buf = NULL;
-	unsigned long flags;
-
-	if ((void *)addr == &alloc_cookie)
-		return 0;
-
-	spin_lock_irqsave(&mine->lock, flags);
-	list_for_each_entry(buf, &mine->buffers, list) {
-		dev_dbg(mine->dev, "%s %8.8lx\n", __func__, (long)buf->addr);
-		if ((long)buf->addr != addr)
-			continue;
-
-		dev_dbg(mine->dev, "mapped!!\n");
-		spin_unlock_irqrestore(&mine->lock, flags);
-		return buf->iova;
-	}
-	dev_err(mine->dev, "Can't find mapped object %8.8llx\n", addr);
-	spin_unlock_irqrestore(&mine->lock, flags);
-	return 0;
-}
-
-/**
- * \brief Free a CSS virtual address and update the MMU.
- */
-void shared_memory_unmap(int ssid, int mmid, u32 addr)
-{
-}
-
-/**
- * \brief Store a byte into (DDR) shared memory space using a host
- * \virtual address
- */
-void shared_memory_store_8(int mmid, u64 addr, u8 data)
-{
-	dev_dbg(get_mem_sub_system(mmid)->dev,
-		"access: %s: Enter addr = 0x%llx data = 0x%x\n",
-		__func__, addr, data);
-
-	*((u8 *) addr) = data;
-	/*Invalidate the cache lines to flush the content to ddr. */
-	clflush_cache_range((void *)addr, sizeof(u8));
-}
-
-/**
- * \brief Store a 16-bit word into (DDR) shared memory space using a host
- * \virtual address
- */
-void shared_memory_store_16(int mmid, u64 addr, u16 data)
-{
-	dev_dbg(get_mem_sub_system(mmid)->dev,
-		"access: %s: Enter addr = 0x%llx data = 0x%x\n",
-		__func__, addr, data);
-
-	*((u16 *) addr) = data;
-	/*Invalidate the cache lines to flush the content to ddr. */
-	clflush_cache_range((void *)addr, sizeof(u16));
-}
-
-/**
- * \brief Store a 32-bit word into (DDR) shared memory space using a host
- * \virtual address
- */
-void shared_memory_store_32(int mmid, u64 addr, u32 data)
-{
-	dev_dbg(get_mem_sub_system(mmid)->dev,
-		"access: %s: Enter addr = 0x%llx data = 0x%x\n",
-		__func__, addr, data);
-
-	*((u32 *) addr) = data;
-	/* Invalidate the cache lines to flush the content to ddr. */
-	clflush_cache_range((void *)addr, sizeof(u32));
-}
-
-/**
- * \brief Store a number of bytes into (DDR) shared memory space using a host
- * \virtual address
- */
-void shared_memory_store(int mmid, u64 addr, const void *data, size_t bytes)
-{
-	dev_dbg(get_mem_sub_system(mmid)->dev,
-		"access: %s: Enter addr = 0x%lx bytes = 0x%lx\n", __func__,
-		(unsigned long)addr, bytes);
-
-	if (!data) {
-		dev_err(get_mem_sub_system(mmid)->dev,
-			"%s: data ptr is null\n", __func__);
-	} else {
-		const u8 *pdata = data;
-		u8 *paddr = (u8 *) addr;
-		size_t i = 0;
-
-		for (; i < bytes; ++i)
-			*paddr++ = *pdata++;
-
-		/* Invalidate the cache lines to flush the content to ddr. */
-		clflush_cache_range((void *)addr, bytes);
-	}
-}
-
-/**
- * \brief Set a number of bytes of (DDR) shared memory space to 0 using a host
- * \virtual address
- */
-void shared_memory_zero(int mmid, u64 addr, size_t bytes)
-{
-	dev_dbg(get_mem_sub_system(mmid)->dev,
-		"access: %s: Enter addr = 0x%llx data = 0x%lx\n",
-		__func__, addr, bytes);
-
-	memset((void *)addr, 0, bytes);
-	clflush_cache_range((void *)addr, bytes);
-}
-
-/**
- * \brief Load a byte from (DDR) shared memory space using a host
- * \virtual address
- */
-u8 shared_memory_load_8(int mmid, u64 addr)
-{
-	u8 data = 0;
-
-	dev_dbg(get_mem_sub_system(mmid)->dev,
-		"access: %s: Enter addr = 0x%llx\n", __func__, addr);
-
-	/* Invalidate the cache lines to flush the content to ddr. */
-	clflush_cache_range((void *)addr, sizeof(u8));
-	data = *(u8 *) addr;
-	return data;
-}
-
-/**
- * \brief Load a 16-bit word from (DDR) shared memory space using a host
- * \virtual address
- */
-u16 shared_memory_load_16(int mmid, u64 addr)
-{
-	u16 data = 0;
-
-	dev_dbg(get_mem_sub_system(mmid)->dev,
-		"access: %s: Enter addr = 0x%llx\n", __func__, addr);
-
-	/* Invalidate the cache lines to flush the content to ddr. */
-	clflush_cache_range((void *)addr, sizeof(u16));
-	data = *(u16 *) addr;
-	return data;
-}
-
-/**
- * \brief Load a 32-bit word from (DDR) shared memory space using a host
- * \virtual address
- */
-u32 shared_memory_load_32(int mmid, u64 addr)
-{
-	u32 data = 0;
-
-	dev_dbg(get_mem_sub_system(mmid)->dev,
-		"access: %s: Enter addr = 0x%llx\n", __func__, addr);
-
-	/* Invalidate the cache lines to flush the content to ddr. */
-	clflush_cache_range((void *)addr, sizeof(u32));
-	data = *(u32 *) addr;
-	return data;
-}
-
-/**
- * \brief Load a number of bytes from (DDR) shared memory space using a host
- * \virtual address
- */
-void shared_memory_load(int mmid, u64 addr, void *data, size_t bytes)
-{
-	dev_dbg(get_mem_sub_system(mmid)->dev,
-		"access: %s: Enter addr = 0x%lx bytes = 0x%lx\n", __func__,
-		(unsigned long)addr, bytes);
-
-	if (!data) {
-		dev_err(get_mem_sub_system(mmid)->dev,
-			"%s: data ptr is null\n", __func__);
-
-	} else {
-		u8 *pdata = data;
-		u8 *paddr = (u8 *) addr;
-		size_t i = 0;
-
-		/* Invalidate the cache lines to flush the content to ddr. */
-		clflush_cache_range((void *)addr, bytes);
-		for (; i < bytes; ++i)
-			*pdata++ = *paddr++;
-	}
-}
-
-static int init_wrapper(struct wrapper_base *sys)
-{
-	INIT_LIST_HEAD(&sys->buffers);
-	spin_lock_init(&sys->lock);
-	return 0;
-}
-
-/*
- * Wrapper driver set base address for library use
- */
-void ipu_wrapper_init(int mmid, struct device *dev, void __iomem *base)
-{
-	struct wrapper_base *sys = get_mem_sub_system(mmid);
-
-	init_wrapper(sys);
-	sys->dev = dev;
-	sys->sys_base = base;
-}
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/config/isys/subsystem_bxtB0.mk b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/config/isys/subsystem_bxtB0.mk
new file mode 100644
index 0000000..da14203
--- /dev/null
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/config/isys/subsystem_bxtB0.mk
@@ -0,0 +1,60 @@
+# # #
+# Support for Intel Camera Imaging ISP subsystem.
+# Copyright (c) 2010 - 2018, Intel Corporation.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details
+#
+
+############################################################################
+# This file is used to specify versions and properties of ISYS firmware
+# components. Please note that these are subsystem specific. System specific
+# properties should go to system_$IPU_SYSVER.mk. Also the device versions
+# should be defined under "devices" or should be taken from the SDK.
+############################################################################
+
+############################################################################
+# FIRMWARE RELATED VARIABLES
+############################################################################
+
+# Activate loading params and storing stats DDR<->REGs with DMA
+ISYS_USE_ISA_DMA                 = 1
+# Used in ISA module
+ISYS_ISL_DPC_DPC_V2              = 0
+
+# Specification for Isys server's fixed globals' locations
+REGMEM_OFFSET				= 0	# Starting from 0
+REGMEM_SIZE				= 34
+REGMEM_WORD_BYTES			= 4
+FW_LOAD_NO_OF_REQUEST_OFFSET		= 136	# Taken from REGMEM_OFFSET + REGMEM_SIZE_BYTES
+FW_LOAD_NO_OF_REQUEST_SIZE_BYTES	= 4
+
+# Workarounds:
+
+# This WA is not to pipeline store frame commands for SID processors that control a Str2Vec (ISA output)
+WA_HSD1304553438                 = 1
+
+# Larger than specified frames that complete mid-line
+WA_HSD1209062354		 = 1
+
+# WA to disable clock gating for the devices in the CSI receivers needed for using the mipi_pkt_gen device
+WA_HSD1805168877		 = 0
+
+# Support IBUF soft-reset at stream start
+SOFT_RESET_IBUF_STREAM_START_SUPPORT = 1
+
+############################################################################
+# TESTING RELATED VARIABLES
+############################################################################
+
+# TODO: This define should be entirely removed.
+# Used in mipi_capture
+ISYS_DISABLE_VERIFY_RECEIVED_SOF_EOF     = 0
+
+ISYS_ACCESS_BLOCKER_VERSION      = v1
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/fw_abi_common_types/ia_css_terminal_defs.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/fw_abi_common_types/ia_css_terminal_defs.h
index f2cf330..dbf1cf9 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/fw_abi_common_types/ia_css_terminal_defs.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/fw_abi_common_types/ia_css_terminal_defs.h
@@ -71,9 +71,6 @@ typedef enum ia_css_terminal_type {
  * Dimensions of the data objects. Note that a C-style
  * data order is assumed. Data stored by row.
  */
-/* A strange problem with hivecc compiler forces this
- * enum to be explicitly initialized for the moment
- */
 typedef enum ia_css_dimension {
 	/**< The number of columns, i.e. the size of the row */
 	IA_CSS_COL_DIMENSION = 0,
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isysapi_types.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isysapi_types.h
index 2cdc28d..cc00cb6 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isysapi_types.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/interface/ia_css_isysapi_types.h
@@ -71,6 +71,7 @@ struct ia_css_isys_device_cfg_data {
 	struct ia_css_isys_buffer_partition buffer_partition;
 	struct ia_css_driver_proxy_config driver_proxy;
 	bool secure;
+	unsigned vtl0_addr_mask; /* only applicable in 'secure' case */
 };
 
 /**
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/isysapi.mk b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/isysapi.mk
index 50da4e4..0d06298 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/isysapi.mk
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/isysapi.mk
@@ -14,6 +14,8 @@
 #
 # MODULE is ISYSAPI
 
+include $(MODULES_DIR)/config/isys/subsystem_$(IPU_SYSVER).mk
+
 ISYSAPI_DIR=$${MODULES_DIR}/isysapi
 
 ISYSAPI_INTERFACE=$(ISYSAPI_DIR)/interface
@@ -61,6 +63,8 @@ ISYSAPI_FW_CPPFLAGS += -I$(HIVESDK)/include/ipu
 
 ISYSAPI_FW_CPPFLAGS += -DWA_HSD1805168877=$(WA_HSD1805168877)
 
+ISYSAPI_HOST_CPPFLAGS += -DREGMEM_OFFSET=$(REGMEM_OFFSET)
+
 ifeq ($(ISYS_HAS_DUAL_CMD_CTX_SUPPORT), 1)
 ISYSAPI_HOST_CPPFLAGS += -DHAS_DUAL_CMD_CTX_SUPPORT=$(ISYS_HAS_DUAL_CMD_CTX_SUPPORT)
 ISYSAPI_FW_CPPFLAGS += -DHAS_DUAL_CMD_CTX_SUPPORT=$(ISYS_HAS_DUAL_CMD_CTX_SUPPORT)
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/src/ia_css_isys_public.c b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/src/ia_css_isys_public.c
index 6983f98..1c56da1 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/src/ia_css_isys_public.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/isysapi/src/ia_css_isys_public.c
@@ -218,6 +218,9 @@ static int isys_context_create(
 	/* parameters size */
 	sys.specific_size = sizeof(isys_fw_cfg);
 	sys.secure = config->secure;
+	if (config->secure) {
+		sys.vtl0_addr_mask = config->vtl0_addr_mask;
+	}
 
 	IA_CSS_TRACE_0(ISYSAPI, VERBOSE,
 		"isys_context_create || call ia_css_syscom_open()\n");
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/regmem/interface/regmem_access.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/regmem/interface/regmem_access.h
index 78b28ce..3fc8958 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/regmem/interface/regmem_access.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/regmem/interface/regmem_access.h
@@ -28,10 +28,20 @@ enum regmem_id {
 	SYSCOM_COMMAND_REG	= 3,
 	/* Store interrupt status - updated by SP */
 	SYSCOM_IRQ_REG		= 4,
+	/* Store VTL0_ADDR_MASK in trusted secure regision - provided by host.*/
+	SYSCOM_VTL0_ADDR_MASK	= 5,
 	/* first syscom queue pointer register */
-	SYSCOM_QPR_BASE_REG	= 5
+	SYSCOM_QPR_BASE_REG	= 6
 };
 
+#if HAS_DUAL_CMD_CTX_SUPPORT
+/* Bit 0: for untrusted non-secure DRV driver on VTL0
+ * Bit 1: for trusted secure TEE driver on VTL1
+ */
+#define SYSCOM_IRQ_VTL0_MASK 0x1
+#define SYSCOM_IRQ_VTL1_MASK 0x2
+#endif
+
 STORAGE_CLASS_INLINE unsigned int
 regmem_load_32(unsigned int mem_address, unsigned int reg, unsigned int ssid);
 
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/support/math_support.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/support/math_support.h
index 337fbd8..633f86f 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/support/math_support.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/support/math_support.h
@@ -44,6 +44,7 @@
 #define IS_ODD(a) ((a) & 0x1)
 #define IS_EVEN(a) (!IS_ODD(a))
 #define IS_POWER2(a) (!((a)&((a)-1)))
+#define IS_MASK_BITS_SET(a, b)	((a & b) != 0)
 
 /*To Find next power of 2 number from x */
 #define bit2(x)            ((x)      | ((x) >> 1))
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/syscom/interface/ia_css_syscom_config.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/syscom/interface/ia_css_syscom_config.h
index 3a62c8f..8c827c2 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/syscom/interface/ia_css_syscom_config.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/syscom/interface/ia_css_syscom_config.h
@@ -91,6 +91,7 @@ struct ia_css_syscom_config {
 	 * if false, non-secure syscom
 	 */
 	bool secure;
+	unsigned int vtl0_addr_mask; /* only applicable in 'secure' case */
 };
 
 #endif /* __IA_CSS_SYSCOM_CONFIG_H */
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/syscom/src/ia_css_syscom.c b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/syscom/src/ia_css_syscom.c
index 13056e9..5dfa953 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/syscom/src/ia_css_syscom.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600/syscom/src/ia_css_syscom.c
@@ -367,6 +367,13 @@ ia_css_syscom_open(
 #if HAS_DUAL_CMD_CTX_SUPPORT
 	/* clear IRQ status */
 	regmem_store_32(ctx->cell_dmem_addr, SYSCOM_IRQ_REG, 0x0, cfg->ssid);
+
+	if (cfg->secure) {
+		/* store VTL0 address mask in 'secure' context */
+		IA_CSS_TRACE_3(SYSCOM, INFO, "ia_css_syscom_open store VTL0_ADDR_MASK (%#x) @ dmem_addr %#x ssid %d\n",
+			      cfg->vtl0_addr_mask, ctx->cell_dmem_addr, cfg->ssid);
+		regmem_store_32(ctx->cell_dmem_addr, SYSCOM_VTL0_ADDR_MASK, cfg->vtl0_addr_mask, cfg->ssid);
+	}
 #endif
 
 	/* Indicate if ctx is created for secure stream purpose */
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/Makefile b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/Makefile
index 9a1fc74..2321e29 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/Makefile
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/Makefile
@@ -20,7 +20,6 @@ include $(srcpath)/$(src)/../Makefile.ipu4psys_inc
 
 SSID        = 0
 MMID        = 0
-IPU_SYSVER  = bxtB0
 
 IPU_PSYSLIB_ROOT_REL = lib
 IPU_PSYSLIB_ROOT = $(srcpath)/$(src)/$(IPU_PSYSLIB_ROOT_REL)
@@ -43,9 +42,9 @@ HOST_DEFINES += -DFIRMWARE_RELEASE_VERSION
 HOST_DEFINES += -DPSYS_SERVER_ON_SPC
 HOST_DEFINES += -DAPI_SPLIT_START_STATE_UPDATE
 
-lib2600psys-mod-$(IPU_SYSVER)-objs := ../../../ipu-wrapper.o \
-	$(IPU_PSYSLIB_SRC)
+intel-ipu4-psys-csslib-objs := ../../../ipu-wrapper.o \
+			$(IPU_PSYSLIB_SRC)
 
-obj-$(CONFIG_VIDEO_INTEL_IPU)	+= lib2600psys-mod-$(IPU_SYSVER).o
+obj-$(CONFIG_VIDEO_INTEL_IPU)	+= intel-ipu4-psys-csslib.o
 ccflags-y += $(IPU_PSYSLIB_INC) $(HOST_DEFINES) -fno-common -v
 
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/DSS_V2_program_group/ia_css_fw_pkg_release.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/DSS_V2_program_group/ia_css_fw_pkg_release.h
index 4251d2f..795c783 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/DSS_V2_program_group/ia_css_fw_pkg_release.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/DSS_V2_program_group/ia_css_fw_pkg_release.h
@@ -11,4 +11,4 @@
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */
-#define IA_CSS_FW_PKG_RELEASE  0x20180412
+#define IA_CSS_FW_PKG_RELEASE  0x20180420
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/config/psys/subsystem_bxtB0.mk b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/config/psys/subsystem_bxtB0.mk
index 739c093..2f60853 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/config/psys/subsystem_bxtB0.mk
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/config/psys/subsystem_bxtB0.mk
@@ -48,14 +48,14 @@ HAS_ISP3			= 1
 
 # Specification for Psys server's fixed globals' locations
 REGMEM_OFFSET				= 0	# Starting from 0
-REGMEM_SIZE				= 17
+REGMEM_SIZE				= 18
 REGMEM_WORD_BYTES			= 4
-REGMEM_SIZE_BYTES			= 68
-GPC_ISP_PERF_DATA_OFFSET		= 68	# Taken from REGMEM_OFFSET + REGMEM_SIZE_BYTES
+REGMEM_SIZE_BYTES			= 72
+GPC_ISP_PERF_DATA_OFFSET		= 72	# Taken from REGMEM_OFFSET + REGMEM_SIZE_BYTES
 GPC_ISP_PERF_DATA_SIZE_BYTES		= 80
-FW_LOAD_NO_OF_REQUEST_OFFSET		= 148	# Taken from GPC_ISP_PERF_DATA_OFFSET + GPC_ISP_PERF_DATA_SIZE_BYTES
+FW_LOAD_NO_OF_REQUEST_OFFSET		= 152	# Taken from GPC_ISP_PERF_DATA_OFFSET + GPC_ISP_PERF_DATA_SIZE_BYTES
 FW_LOAD_NO_OF_REQUEST_SIZE_BYTES	= 4
-DISPATCHER_SCRATCH_SPACE_OFFSET		= 152	# Taken from FW_LOAD_NO_OF_REQUEST_OFFSET + FW_LOAD_NO_OF_REQUEST_SIZE_BYTES
+DISPATCHER_SCRATCH_SPACE_OFFSET		= 156	# Taken from FW_LOAD_NO_OF_REQUEST_OFFSET + FW_LOAD_NO_OF_REQUEST_SIZE_BYTES
 
 # TODO  use version naming scheme "v#" to decouple
 # IPU_SYSVER from version.
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/fw_abi_common_types/ia_css_terminal_defs.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/fw_abi_common_types/ia_css_terminal_defs.h
index f2cf330..dbf1cf9 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/fw_abi_common_types/ia_css_terminal_defs.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/fw_abi_common_types/ia_css_terminal_defs.h
@@ -71,9 +71,6 @@ typedef enum ia_css_terminal_type {
  * Dimensions of the data objects. Note that a C-style
  * data order is assumed. Data stored by row.
  */
-/* A strange problem with hivecc compiler forces this
- * enum to be explicitly initialized for the moment
- */
 typedef enum ia_css_dimension {
 	/**< The number of columns, i.e. the size of the row */
 	IA_CSS_COL_DIMENSION = 0,
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psys_server/src/bxt_spctrl_process_group_cmd_impl.c b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psys_server/src/bxt_spctrl_process_group_cmd_impl.c
index 693e192..6f8aea7 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psys_server/src/bxt_spctrl_process_group_cmd_impl.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psys_server/src/bxt_spctrl_process_group_cmd_impl.c
@@ -27,6 +27,64 @@
 #include "cpu_mem_support.h"
 #include "ia_css_bxt_spctrl_trace.h"
 
+#if HAS_DUAL_CMD_CTX_SUPPORT
+#define MAX_CLIENT_PGS 8 /* same as test_params.h */
+struct ia_css_process_group_context {
+	ia_css_process_group_t *pg;
+	bool secure;
+};
+struct ia_css_process_group_context pg_contexts[MAX_CLIENT_PGS];
+static unsigned int num_of_pgs;
+
+STORAGE_CLASS_INLINE
+struct ia_css_syscom_context *ia_css_process_group_get_context(ia_css_process_group_t *process_group)
+{
+	unsigned int i;
+	bool secure = false;
+
+	IA_CSS_TRACE_0(BXT_SPCTRL, INFO,
+		"ia_css_process_group_get_context(): enter:\n");
+
+	for (i = 0; i < num_of_pgs; i++) {
+		if (pg_contexts[i].pg == process_group) {
+			secure = pg_contexts[i].secure;
+			break;
+		}
+	}
+
+	IA_CSS_TRACE_1(BXT_SPCTRL, INFO,
+		"ia_css_process_group_get_context(): secure %d\n", secure);
+	return secure ? psys_syscom_secure : psys_syscom;
+}
+
+int ia_css_process_group_store(ia_css_process_group_t *process_group, bool secure)
+{
+	IA_CSS_TRACE_2(BXT_SPCTRL, INFO,
+		"ia_css_process_group_store(): pg instance %d secure %d\n", num_of_pgs, secure);
+
+	pg_contexts[num_of_pgs].pg     = process_group;
+	pg_contexts[num_of_pgs].secure = secure;
+	num_of_pgs++;
+	return 0;
+}
+#else /* HAS_DUAL_CMD_CTX_SUPPORT */
+STORAGE_CLASS_INLINE
+struct ia_css_syscom_context *ia_css_process_group_get_context(ia_css_process_group_t *process_group)
+{
+	NOT_USED(process_group);
+
+	return psys_syscom;
+}
+
+int ia_css_process_group_store(ia_css_process_group_t *process_group, bool secure)
+{
+	NOT_USED(process_group);
+	NOT_USED(secure);
+
+	return 0;
+}
+#endif /* HAS_DUAL_CMD_CTX_SUPPORT */
+
 int ia_css_process_group_on_create(
 	ia_css_process_group_t			*process_group,
 	const ia_css_program_group_manifest_t	*program_group_manifest,
@@ -102,7 +160,7 @@ int ia_css_process_group_exec_cmd(
 			"ia_css_process_group_exec_cmd(): IA_CSS_PROCESS_GROUP_CMD_DISOWN:\n");
 		verifexit(state == IA_CSS_PROCESS_GROUP_STARTED);
 
-		cmd_queue_full = ia_css_is_psys_cmd_queue_full(psys_syscom,
+		cmd_queue_full = ia_css_is_psys_cmd_queue_full(ia_css_process_group_get_context(process_group),
 					IA_CSS_PSYS_CMD_QUEUE_COMMAND_ID);
 		retval = EBUSY;
 		verifexit(cmd_queue_full == false);
@@ -113,7 +171,7 @@ int ia_css_process_group_exec_cmd(
 
 		verifexit(ia_css_process_group_print(process_group, NULL) == 0);
 
-		retval = ia_css_psys_cmd_queue_send(psys_syscom,
+		retval = ia_css_psys_cmd_queue_send(ia_css_process_group_get_context(process_group),
 				IA_CSS_PSYS_CMD_QUEUE_COMMAND_ID, &psys_cmd);
 		verifexit(retval > 0);
 		break;
@@ -122,7 +180,7 @@ int ia_css_process_group_exec_cmd(
 		IA_CSS_TRACE_0(BXT_SPCTRL, INFO,
 			"ia_css_process_group_exec_cmd(): IA_CSS_PROCESS_GROUP_CMD_STOP:\n");
 
-		cmd_queue_full = ia_css_is_psys_cmd_queue_full(psys_syscom,
+		cmd_queue_full = ia_css_is_psys_cmd_queue_full(ia_css_process_group_get_context(process_group),
 					IA_CSS_PSYS_CMD_QUEUE_COMMAND_ID);
 		retval = EBUSY;
 		verifexit(cmd_queue_full == false);
@@ -134,7 +192,7 @@ int ia_css_process_group_exec_cmd(
 		queue_id = ia_css_process_group_get_base_queue_id(process_group);
 		verifexit(queue_id < IA_CSS_N_PSYS_CMD_QUEUE_ID);
 
-		retval = ia_css_psys_cmd_queue_send(psys_syscom,
+		retval = ia_css_psys_cmd_queue_send(ia_css_process_group_get_context(process_group),
 				queue_id, &psys_cmd);
 		verifexit(retval > 0);
 		break;
@@ -148,7 +206,7 @@ int ia_css_process_group_exec_cmd(
 		 */
 		verifexit(state == IA_CSS_PROCESS_GROUP_BLOCKED);
 
-		cmd_queue_full = ia_css_is_psys_cmd_queue_full(psys_syscom,
+		cmd_queue_full = ia_css_is_psys_cmd_queue_full(ia_css_process_group_get_context(process_group),
 					IA_CSS_PSYS_CMD_QUEUE_COMMAND_ID);
 		retval = EBUSY;
 		verifexit(cmd_queue_full == false);
@@ -157,7 +215,7 @@ int ia_css_process_group_exec_cmd(
 		psys_cmd.msg = 0;
 		psys_cmd.context_handle = process_group->ipu_virtual_address;
 
-		retval = ia_css_psys_cmd_queue_send(psys_syscom,
+		retval = ia_css_psys_cmd_queue_send(ia_css_process_group_get_context(process_group),
 			IA_CSS_PSYS_CMD_QUEUE_DEVICE_ID, &psys_cmd);
 		verifexit(retval > 0);
 		break;
@@ -198,7 +256,7 @@ STORAGE_CLASS_INLINE int enqueue_buffer_set_cmd(
 		queue_offset;
 	verifexit(queue_id < IA_CSS_N_PSYS_CMD_QUEUE_ID);
 
-	cmd_queue_full = ia_css_is_psys_cmd_queue_full(psys_syscom, queue_id);
+	cmd_queue_full = ia_css_is_psys_cmd_queue_full(ia_css_process_group_get_context(process_group), queue_id);
 	retval = EBUSY;
 	verifexit(cmd_queue_full == false);
 
@@ -207,7 +265,7 @@ STORAGE_CLASS_INLINE int enqueue_buffer_set_cmd(
 	psys_cmd.context_handle =
 		ia_css_buffer_set_get_ipu_address(buffer_set);
 
-	retval = ia_css_psys_cmd_queue_send(psys_syscom, queue_id, &psys_cmd);
+	retval = ia_css_psys_cmd_queue_send(ia_css_process_group_get_context(process_group), queue_id, &psys_cmd);
 	verifexit(retval > 0);
 
 	retval = 0;
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/data/src/ia_css_program_group_data_impl.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/data/src/ia_css_program_group_data_impl.h
index d0f05f1..f08a057 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/data/src/ia_css_program_group_data_impl.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/data/src/ia_css_program_group_data_impl.h
@@ -336,7 +336,7 @@ int ia_css_frame_descriptor_print(
 	if (IA_CSS_N_DATA_DIMENSION > 2) {
 		for (i = 0; i < (int)IA_CSS_N_DATA_DIMENSION - 2; i++) {
 			IA_CSS_TRACE_1(PSYSAPI_DATA, INFO,
-			       "\t%4d,\n", frame_descriptor->stride[i]);
+				"\t%4d,\n", frame_descriptor->stride[i]);
 		}
 	}
 	IA_CSS_TRACE_1(PSYSAPI_DATA, INFO,
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/device/interface/ia_css_psys_device.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/device/interface/ia_css_psys_device.h
index cadee7d..abfdfb9 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/device/interface/ia_css_psys_device.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/device/interface/ia_css_psys_device.h
@@ -105,9 +105,10 @@ extern struct ia_css_syscom_config *ia_css_psys_specify(void);
 #if HAS_DUAL_CMD_CTX_SUPPORT
 /*! Create the syscom creation descriptor for secure stream
 
+ @param	vtl0_addr_mask[in]	VTL0 address mask that will be stored in 'secure' ctx
  @return NULL on error
  */
-extern struct ia_css_syscom_config *ia_css_psys_specify_secure(void);
+extern struct ia_css_syscom_config *ia_css_psys_specify_secure(unsigned int vtl0_addr_mask);
 #endif
 
 /*! Compute the size of storage required for allocating the Psys syscom object
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/device/src/ia_css_psys_device.c b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/device/src/ia_css_psys_device.c
index 58b1571..f7a84a8 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/device/src/ia_css_psys_device.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/device/src/ia_css_psys_device.c
@@ -16,6 +16,7 @@
 #include "ia_css_psys_device.h"
 #include "ia_css_psys_device_trace.h"
 #include "ia_css_psys_init.h"
+#include "regmem_access.h"
 
 #include <error_support.h>
 #include <print_support.h>
@@ -97,6 +98,7 @@ static void set_syscom_config(struct ia_css_syscom_config *config)
 	}
 	config->input = ia_css_psys_cmd_queue_cfg;
 	config->output = ia_css_psys_event_queue_cfg;
+	config->vtl0_addr_mask = 0;
 }
 
 struct ia_css_syscom_config *ia_css_psys_specify(void)
@@ -111,13 +113,14 @@ struct ia_css_syscom_config *ia_css_psys_specify(void)
 }
 
 #if HAS_DUAL_CMD_CTX_SUPPORT
-struct ia_css_syscom_config *ia_css_psys_specify_secure(void)
+struct ia_css_syscom_config *ia_css_psys_specify_secure(unsigned int vtl0_addr_mask)
 {
 	struct ia_css_syscom_config *config = &psys_syscom_config_secure;
 
-	IA_CSS_TRACE_0(PSYSAPI_DEVICE, INFO, "ia_css_psys_specify_secure(): enter:\n");
+	IA_CSS_TRACE_1(PSYSAPI_DEVICE, INFO, "ia_css_psys_specify_secure(mask %#x): enter:\n", vtl0_addr_mask);
 	set_syscom_config(config);
 	config->secure = true;
+	config->vtl0_addr_mask = vtl0_addr_mask;
 	return config;
 }
 #endif
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/dynamic/interface/ia_css_psys_process_group_cmd_impl.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/dynamic/interface/ia_css_psys_process_group_cmd_impl.h
index e1f2f54..f4b191e 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/dynamic/interface/ia_css_psys_process_group_cmd_impl.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/dynamic/interface/ia_css_psys_process_group_cmd_impl.h
@@ -161,4 +161,16 @@ extern int ia_css_enqueue_param_buffer_set(
 	ia_css_process_group_t				*process_group,
 	ia_css_buffer_set_t				*buffer_set);
 
+/*! Need to store the 'secure' mode for each PG for FW test app only
+ *
+ * @param	process_group[in]		process group object
+ * @param	secure[in]			parameter buffer set
+ *
+ * @return < 0 on error
+ */
+extern int ia_css_process_group_store(
+	ia_css_process_group_t				*process_group,
+	bool						secure);
+
+
 #endif /* __IA_CSS_PSYS_PROCESS_GROUP_CMD_IMPL_H */
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/dynamic/src/ia_css_psys_process.c b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/dynamic/src/ia_css_psys_process.c
index 7cfcd4f..f9e060f 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/dynamic/src/ia_css_psys_process.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/psysapi/dynamic/src/ia_css_psys_process.c
@@ -15,7 +15,7 @@
 #include "ia_css_psys_process.h"
 #include "ia_css_psys_dynamic_storage_class.h"
 #include "ia_css_psys_process_private_types.h"
-#include <misc_support.h>
+#include <misc_support.h>	/* for NOT_USED */
 
 /*
  * Functions to possibly inline
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/regmem/interface/regmem_access.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/regmem/interface/regmem_access.h
index 78b28ce..3fc8958 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/regmem/interface/regmem_access.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/regmem/interface/regmem_access.h
@@ -28,10 +28,20 @@ enum regmem_id {
 	SYSCOM_COMMAND_REG	= 3,
 	/* Store interrupt status - updated by SP */
 	SYSCOM_IRQ_REG		= 4,
+	/* Store VTL0_ADDR_MASK in trusted secure regision - provided by host.*/
+	SYSCOM_VTL0_ADDR_MASK	= 5,
 	/* first syscom queue pointer register */
-	SYSCOM_QPR_BASE_REG	= 5
+	SYSCOM_QPR_BASE_REG	= 6
 };
 
+#if HAS_DUAL_CMD_CTX_SUPPORT
+/* Bit 0: for untrusted non-secure DRV driver on VTL0
+ * Bit 1: for trusted secure TEE driver on VTL1
+ */
+#define SYSCOM_IRQ_VTL0_MASK 0x1
+#define SYSCOM_IRQ_VTL1_MASK 0x2
+#endif
+
 STORAGE_CLASS_INLINE unsigned int
 regmem_load_32(unsigned int mem_address, unsigned int reg, unsigned int ssid);
 
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/support/math_support.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/support/math_support.h
index 337fbd8..633f86f 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/support/math_support.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/support/math_support.h
@@ -44,6 +44,7 @@
 #define IS_ODD(a) ((a) & 0x1)
 #define IS_EVEN(a) (!IS_ODD(a))
 #define IS_POWER2(a) (!((a)&((a)-1)))
+#define IS_MASK_BITS_SET(a, b)	((a & b) != 0)
 
 /*To Find next power of 2 number from x */
 #define bit2(x)            ((x)      | ((x) >> 1))
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/syscom/interface/ia_css_syscom_config.h b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/syscom/interface/ia_css_syscom_config.h
index 3a62c8f..8c827c2 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/syscom/interface/ia_css_syscom_config.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/syscom/interface/ia_css_syscom_config.h
@@ -91,6 +91,7 @@ struct ia_css_syscom_config {
 	 * if false, non-secure syscom
 	 */
 	bool secure;
+	unsigned int vtl0_addr_mask; /* only applicable in 'secure' case */
 };
 
 #endif /* __IA_CSS_SYSCOM_CONFIG_H */
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/syscom/src/ia_css_syscom.c b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/syscom/src/ia_css_syscom.c
index 13056e9..5dfa953 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/syscom/src/ia_css_syscom.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/lib/syscom/src/ia_css_syscom.c
@@ -367,6 +367,13 @@ ia_css_syscom_open(
 #if HAS_DUAL_CMD_CTX_SUPPORT
 	/* clear IRQ status */
 	regmem_store_32(ctx->cell_dmem_addr, SYSCOM_IRQ_REG, 0x0, cfg->ssid);
+
+	if (cfg->secure) {
+		/* store VTL0 address mask in 'secure' context */
+		IA_CSS_TRACE_3(SYSCOM, INFO, "ia_css_syscom_open store VTL0_ADDR_MASK (%#x) @ dmem_addr %#x ssid %d\n",
+			      cfg->vtl0_addr_mask, ctx->cell_dmem_addr, cfg->ssid);
+		regmem_store_32(ctx->cell_dmem_addr, SYSCOM_VTL0_ADDR_MASK, cfg->vtl0_addr_mask, cfg->ssid);
+	}
 #endif
 
 	/* Indicate if ctx is created for secure stream purpose */
diff --git a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/libcsspsys2600.c b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/libcsspsys2600.c
index 4778a98..92ac830 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/libcsspsys2600.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-css/lib2600psys/libcsspsys2600.c
@@ -23,7 +23,6 @@
 #include "ipu.h"
 #include "ipu-fw-psys.h"
 #include "ipu-psys.h"
-#include "ipu-fw-resources.h"
 #include "ipu-wrapper.h"
 #include "ipu-mmu.h"
 
@@ -478,7 +477,7 @@ ipu_fw_psys_ppg_enqueue_bufs(struct ipu_psys_kcmd *kcmd,
 }
 EXPORT_SYMBOL_GPL(ipu_fw_psys_ppg_enqueue_bufs);
 
-static const struct ipu_resource_definitions default_defs = {
+static const struct ipu_fw_resource_definitions default_defs = {
 	.cells = vied_nci_cell_type,
 	.num_cells = VIED_NCI_N_CELL_ID,
 	.num_cells_type = VIED_NCI_N_CELL_TYPE_ID,
@@ -500,7 +499,7 @@ static const struct ipu_resource_definitions default_defs = {
 	.process.cell_id = offsetof(struct ia_css_process_s, cell_id),
 };
 
-const struct ipu_resource_definitions *res_defs = &default_defs;
+const struct ipu_fw_resource_definitions *res_defs = &default_defs;
 EXPORT_SYMBOL_GPL(res_defs);
 
 /*
diff --git a/drivers/media/pci/intel/ipu4/ipu4-fw-resources.c b/drivers/media/pci/intel/ipu4/ipu4-fw-resources.c
index 067c633..2229f03 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-fw-resources.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-fw-resources.c
@@ -1,14 +1,14 @@
 // SPDX-License_Identifier: GPL-2.0
 // Copyright (C) 2015 - 2018 Intel Corporation
 
-#include "ipu-fw-resources.h"
+#include "ipu-fw-psys.h"
 
-static const struct ipu_resource_definitions default_defs = {
+static const struct ipu_fw_resource_definitions default_defs = {
 	.cells = ipu_fw_psys_cell_types,
 	.num_cells = IPU_FW_PSYS_N_CELL_ID,
 	.num_cells_type = IPU_FW_PSYS_N_CELL_TYPE_ID,
 
-	.dev_channels = ipu_num_dev_channels,
+	.dev_channels = ipu_fw_num_dev_channels,
 	.num_dev_channels = IPU_FW_PSYS_N_DEV_CHN_ID,
 
 	.num_ext_mem_types = IPU_FW_PSYS_N_DATA_MEM_TYPE_ID,
@@ -29,7 +29,7 @@ static const struct ipu_resource_definitions default_defs = {
 	.process.cell_id = offsetof(struct ipu_fw_psys_process, cell_id),
 };
 
-const struct ipu_resource_definitions *res_defs = &default_defs;
+const struct ipu_fw_resource_definitions *res_defs = &default_defs;
 
 /********** Generic resource handling **********/
 
diff --git a/drivers/media/pci/intel/ipu4/ipu4-isys-isa.h b/drivers/media/pci/intel/ipu4/ipu4-isys-isa.h
index 0f55a18..a32157f 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-isys-isa.h
+++ b/drivers/media/pci/intel/ipu4/ipu4-isys-isa.h
@@ -11,10 +11,6 @@
 #include "ipu-isys-subdev.h"
 #include "ipu-isys-video.h"
 
-struct ipu_isys;
-struct ipu_fw_isys_frame_buff_set_abi;
-struct ipu_fw_isys_stream_cfg_data;
-
 #define ISA_PAD_SINK			0
 #define ISA_PAD_SOURCE			1
 #define ISA_PAD_CONFIG			2
@@ -26,8 +22,8 @@ struct ipu_fw_isys_stream_cfg_data;
 #define NR_OF_ISA_SOURCE_PADS		3
 #define NR_OF_ISA_STREAMS		1
 
+struct ipu_isys;
 struct ia_css_process_group_light;
-struct ia_css_terminal;
 
 /*
  * struct ipu_isa_buffer
diff --git a/drivers/media/pci/intel/ipu4/ipu4-psys.c b/drivers/media/pci/intel/ipu4/ipu4-psys.c
index 9dc6dc1..82fa987 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-psys.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-psys.c
@@ -1,10 +1,35 @@
 // SPDX-License_Identifier: GPL-2.0
 // Copyright (C) 2018 Intel Corporation
 
+#include <linux/uaccess.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/highmem.h>
+#include <linux/mm.h>
+#include <linux/pm_runtime.h>
+#include <linux/kthread.h>
+#include <linux/init_task.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+#include <linux/sched.h>
+#else
+#include <uapi/linux/sched/types.h>
+#endif
+#include <linux/module.h>
+#include <linux/fs.h>
+
 #include "ipu.h"
 #include "ipu-psys.h"
 #include "ipu-platform-regs.h"
 #include "ipu-trace.h"
+#define CREATE_TRACE_POINTS
+#define IPU_PG_KCMD_TRACE
+#include "ipu-trace-event.h"
+
+static bool early_pg_transfer;
+module_param(early_pg_transfer, bool, 0664);
+MODULE_PARM_DESC(early_pg_transfer,
+		 "Copy PGs back to user after resource allocation");
 
 struct ipu_trace_block psys_trace_blocks[] = {
 	{
@@ -111,7 +136,7 @@ static void set_isp_info_bits(void *base)
 			   base + IPU_REG_PSYS_INFO_SEG_DATA_MASTER(i));
 }
 
-void psys_setup_hw(struct ipu_psys *psys)
+void ipu_psys_setup_hw(struct ipu_psys *psys)
 {
 	void __iomem *base = psys->pdata->base;
 	void __iomem *spc_regs_base =
@@ -152,3 +177,602 @@ void psys_setup_hw(struct ipu_psys *psys)
 	for (i = 0; i < psys->pdata->ipdata->hw_variant.cdc_fifos; i++)
 		writel(thd[i], base + IPU_REG_PSYS_CDC_THRESHOLD(i));
 }
+
+/*
+ * Called to free up all resources associated with a kcmd.
+ * After this the kcmd doesn't anymore exist in the driver.
+ */
+void ipu_psys_kcmd_free(struct ipu_psys_kcmd *kcmd)
+{
+	struct ipu_psys *psys;
+	unsigned long flags;
+
+	if (!kcmd)
+		return;
+
+	psys = kcmd->fh->psys;
+
+	if (!list_empty(&kcmd->list))
+		list_del(&kcmd->list);
+
+	spin_lock_irqsave(&psys->pgs_lock, flags);
+	if (kcmd->kpg)
+		kcmd->kpg->pg_size = 0;
+	spin_unlock_irqrestore(&psys->pgs_lock, flags);
+
+	mutex_lock(&kcmd->fh->bs_mutex);
+	if (kcmd->kbuf_set)
+		kcmd->kbuf_set->buf_set_size = 0;
+	mutex_unlock(&kcmd->fh->bs_mutex);
+
+	kfree(kcmd->pg_manifest);
+	kfree(kcmd->kbufs);
+	kfree(kcmd->buffers);
+	kfree(kcmd);
+}
+
+struct ipu_psys_kcmd *ipu_psys_copy_cmd(struct ipu_psys_command *cmd,
+					struct ipu_psys_fh *fh)
+{
+	struct ipu_psys *psys = fh->psys;
+	struct ipu_psys_kcmd *kcmd;
+	struct ipu_psys_kbuffer *kpgbuf;
+	unsigned int i;
+	int ret, prevfd = 0;
+
+	if (cmd->bufcount > IPU_MAX_PSYS_CMD_BUFFERS)
+		return NULL;
+
+	if (!cmd->pg_manifest_size ||
+	    cmd->pg_manifest_size > KMALLOC_MAX_CACHE_SIZE)
+		return NULL;
+
+	kcmd = kzalloc(sizeof(*kcmd), GFP_KERNEL);
+	if (!kcmd)
+		return NULL;
+
+	kcmd->state = KCMD_STATE_NEW;
+	kcmd->fh = fh;
+	INIT_LIST_HEAD(&kcmd->list);
+	INIT_LIST_HEAD(&kcmd->started_list);
+
+	mutex_lock(&fh->mutex);
+	kpgbuf = ipu_psys_lookup_kbuffer(fh, cmd->pg);
+	mutex_unlock(&fh->mutex);
+	if (!kpgbuf || !kpgbuf->sgt)
+		goto error;
+
+	kcmd->pg_user = kpgbuf->kaddr;
+	kcmd->kpg = __get_pg_buf(psys, kpgbuf->len);
+	if (!kcmd->kpg)
+		goto error;
+
+	memcpy(kcmd->kpg->pg, kcmd->pg_user, kcmd->kpg->pg_size);
+
+	kcmd->pg_manifest = kzalloc(cmd->pg_manifest_size, GFP_KERNEL);
+	if (!kcmd->pg_manifest)
+		goto error;
+
+	ret = copy_from_user(kcmd->pg_manifest, cmd->pg_manifest,
+			     cmd->pg_manifest_size);
+	if (ret)
+		goto error;
+
+	kcmd->pg_manifest_size = cmd->pg_manifest_size;
+
+	kcmd->user_token = cmd->user_token;
+	kcmd->issue_id = cmd->issue_id;
+	kcmd->priority = cmd->priority;
+	if (kcmd->priority >= IPU_PSYS_CMD_PRIORITY_NUM)
+		goto error;
+
+	kcmd->nbuffers = ipu_fw_psys_pg_get_terminal_count(kcmd);
+	kcmd->buffers = kcalloc(kcmd->nbuffers, sizeof(*kcmd->buffers),
+				GFP_KERNEL);
+	if (!kcmd->buffers)
+		goto error;
+
+	kcmd->kbufs = kcalloc(kcmd->nbuffers, sizeof(kcmd->kbufs[0]),
+			      GFP_KERNEL);
+	if (!kcmd->kbufs)
+		goto error;
+
+
+	if (!cmd->bufcount || kcmd->nbuffers > cmd->bufcount)
+		goto error;
+
+	ret = copy_from_user(kcmd->buffers, cmd->buffers,
+			     kcmd->nbuffers * sizeof(*kcmd->buffers));
+	if (ret)
+		goto error;
+
+	for (i = 0; i < kcmd->nbuffers; i++) {
+		struct ipu_fw_psys_terminal *terminal;
+
+		terminal = ipu_fw_psys_pg_get_terminal(kcmd, i);
+		if (!terminal)
+			continue;
+
+
+		mutex_lock(&fh->mutex);
+		kcmd->kbufs[i] = ipu_psys_lookup_kbuffer(fh,
+						 kcmd->buffers[i].base.fd);
+		mutex_unlock(&fh->mutex);
+		if (!kcmd->kbufs[i] || !kcmd->kbufs[i]->sgt ||
+		    kcmd->kbufs[i]->len < kcmd->buffers[i].bytes_used)
+			goto error;
+		if ((kcmd->kbufs[i]->flags &
+		     IPU_BUFFER_FLAG_NO_FLUSH) ||
+		    (kcmd->buffers[i].flags &
+		     IPU_BUFFER_FLAG_NO_FLUSH) ||
+		    prevfd == kcmd->buffers[i].base.fd)
+			continue;
+
+		prevfd = kcmd->buffers[i].base.fd;
+		dma_sync_sg_for_device(&psys->adev->dev,
+				       kcmd->kbufs[i]->sgt->sgl,
+				       kcmd->kbufs[i]->sgt->orig_nents,
+				       DMA_BIDIRECTIONAL);
+	}
+
+
+	return kcmd;
+error:
+	ipu_psys_kcmd_free(kcmd);
+
+	dev_dbg(&psys->adev->dev, "failed to copy cmd\n");
+
+	return NULL;
+}
+
+static void ipu_psys_kcmd_run(struct ipu_psys *psys)
+{
+	struct ipu_psys_kcmd *kcmd = list_first_entry(&psys->started_kcmds_list,
+						      struct ipu_psys_kcmd,
+						      started_list);
+	int ret;
+
+	ret = ipu_psys_move_resources(&psys->adev->dev,
+				      &kcmd->resource_alloc,
+				      &psys->resource_pool_started,
+				      &psys->resource_pool_running);
+	if (!ret) {
+		psys->started_kcmds--;
+		psys->active_kcmds++;
+		kcmd->state = KCMD_STATE_RUNNING;
+		list_del(&kcmd->started_list);
+		kcmd->watchdog.expires = jiffies +
+		    msecs_to_jiffies(psys->timeout);
+		add_timer(&kcmd->watchdog);
+		return;
+	}
+
+	if (ret != -ENOSPC || !psys->active_kcmds) {
+		dev_err(&psys->adev->dev,
+			"kcmd %p failed to alloc resources (running (%d, psys->active_kcmds = %d))\n",
+			kcmd, ret, psys->active_kcmds);
+		ipu_psys_kcmd_abort(psys, kcmd, ret);
+		return;
+	}
+}
+
+/*
+ * Move kcmd into completed state (due to running finished or failure).
+ * Fill up the event struct and notify waiters.
+ */
+void ipu_psys_kcmd_complete(struct ipu_psys *psys,
+				   struct ipu_psys_kcmd *kcmd, int error)
+{
+	struct ipu_psys_fh *fh = kcmd->fh;
+
+	trace_ipu_pg_kcmd(__func__, kcmd->user_token, kcmd->issue_id,
+			  kcmd->priority,
+			  ipu_fw_psys_pg_get_id(kcmd),
+			  ipu_fw_psys_pg_load_cycles(kcmd),
+			  ipu_fw_psys_pg_init_cycles(kcmd),
+			  ipu_fw_psys_pg_processing_cycles(kcmd));
+
+	switch (kcmd->state) {
+	case KCMD_STATE_RUNNING:
+		if (try_to_del_timer_sync(&kcmd->watchdog) < 0) {
+			dev_err(&psys->adev->dev,
+				"could not cancel kcmd timer\n");
+			return;
+		}
+		/* Fall through on purpose */
+	case KCMD_STATE_RUN_PREPARED:
+		ipu_psys_free_resources(&kcmd->resource_alloc,
+					&psys->resource_pool_running);
+		if (psys->started_kcmds)
+			ipu_psys_kcmd_run(psys);
+		if (kcmd->state == KCMD_STATE_RUNNING)
+			psys->active_kcmds--;
+		break;
+	case KCMD_STATE_STARTED:
+		psys->started_kcmds--;
+		list_del(&kcmd->started_list);
+		/* Fall through on purpose */
+	case KCMD_STATE_START_PREPARED:
+		ipu_psys_free_resources(&kcmd->resource_alloc,
+					&psys->resource_pool_started);
+		break;
+	default:
+		break;
+	}
+
+	kcmd->ev.type = IPU_PSYS_EVENT_TYPE_CMD_COMPLETE;
+	kcmd->ev.user_token = kcmd->user_token;
+	kcmd->ev.issue_id = kcmd->issue_id;
+	kcmd->ev.error = error;
+
+	if (kcmd->constraint.min_freq)
+		ipu_buttress_remove_psys_constraint(psys->adev->isp,
+						    &kcmd->constraint);
+
+	if (!early_pg_transfer && kcmd->pg_user && kcmd->kpg->pg) {
+		struct ipu_psys_kbuffer *kbuf;
+
+		kbuf = ipu_psys_lookup_kbuffer_by_kaddr(kcmd->fh,
+							kcmd->pg_user);
+
+		if (kbuf && kbuf->valid)
+			memcpy(kcmd->pg_user,
+			       kcmd->kpg->pg, kcmd->kpg->pg_size);
+		else
+			dev_dbg(&psys->adev->dev,
+				"Skipping already unmapped buffer\n");
+	}
+
+	if (kcmd->state == KCMD_STATE_RUNNING ||
+	    kcmd->state == KCMD_STATE_STARTED) {
+		pm_runtime_mark_last_busy(&psys->adev->dev);
+		pm_runtime_put_autosuspend(&psys->adev->dev);
+	}
+
+	kcmd->state = KCMD_STATE_COMPLETE;
+
+	wake_up_interruptible(&fh->wait);
+}
+
+/*
+ * Move kcmd into completed state. If kcmd is currently running,
+ * abort it.
+ */
+int ipu_psys_kcmd_abort(struct ipu_psys *psys,
+			struct ipu_psys_kcmd *kcmd, int error)
+{
+	int ret = 0;
+
+	if (kcmd->state == KCMD_STATE_COMPLETE)
+		return 0;
+
+	if ((kcmd->state == KCMD_STATE_RUNNING ||
+	     kcmd->state == KCMD_STATE_STARTED)) {
+		ret = ipu_fw_psys_pg_abort(kcmd);
+		if (ret) {
+			dev_err(&psys->adev->dev, "failed to abort kcmd!\n");
+			goto out;
+		}
+	}
+
+out:
+	ipu_psys_kcmd_complete(psys, kcmd, ret);
+
+	return ret;
+}
+
+/*
+ * Submit kcmd into psys queue. If running fails, complete the kcmd
+ * with an error.
+ */
+static int ipu_psys_kcmd_start(struct ipu_psys *psys,
+			       struct ipu_psys_kcmd *kcmd)
+{
+	/*
+	 * Found a runnable PG. Move queue to the list tail for round-robin
+	 * scheduling and run the PG. Start the watchdog timer if the PG was
+	 * started successfully. Enable PSYS power if requested.
+	 */
+	int ret;
+
+	if (psys->adev->isp->flr_done) {
+		ipu_psys_kcmd_complete(psys, kcmd, -EIO);
+		return -EIO;
+	}
+
+	ret = pm_runtime_get_sync(&psys->adev->dev);
+	if (ret < 0) {
+		dev_err(&psys->adev->dev, "failed to power on PSYS\n");
+		ipu_psys_kcmd_complete(psys, kcmd, -EIO);
+		pm_runtime_put_noidle(&psys->adev->dev);
+		return ret;
+	}
+
+	if (early_pg_transfer && kcmd->pg_user && kcmd->kpg->pg)
+		memcpy(kcmd->pg_user, kcmd->kpg->pg, kcmd->kpg->pg_size);
+
+	ret = ipu_fw_psys_pg_start(kcmd);
+	if (ret) {
+		dev_err(&psys->adev->dev, "failed to start kcmd!\n");
+		goto error;
+	}
+
+	ipu_fw_psys_pg_dump(psys, kcmd, "run");
+
+	/*
+	 * Starting from scci_master_20151228_1800, pg start api is split into
+	 * two different calls, making driver responsible to flush pg between
+	 * start and disown library calls.
+	 */
+	clflush_cache_range(kcmd->kpg->pg, kcmd->kpg->pg_size);
+	ret = ipu_fw_psys_pg_disown(kcmd);
+	if (ret) {
+		dev_err(&psys->adev->dev, "failed to start kcmd!\n");
+		goto error;
+	}
+
+	trace_ipu_pg_kcmd(__func__, kcmd->user_token, kcmd->issue_id,
+			  kcmd->priority,
+			  ipu_fw_psys_pg_get_id(kcmd),
+			  ipu_fw_psys_pg_load_cycles(kcmd),
+			  ipu_fw_psys_pg_init_cycles(kcmd),
+			  ipu_fw_psys_pg_processing_cycles(kcmd));
+
+	switch (kcmd->state) {
+	case KCMD_STATE_RUN_PREPARED:
+		kcmd->state = KCMD_STATE_RUNNING;
+		psys->active_kcmds++;
+		kcmd->watchdog.expires = jiffies +
+		    msecs_to_jiffies(psys->timeout);
+		add_timer(&kcmd->watchdog);
+		break;
+	case KCMD_STATE_START_PREPARED:
+		kcmd->state = KCMD_STATE_STARTED;
+		psys->started_kcmds++;
+		list_add_tail(&kcmd->started_list, &psys->started_kcmds_list);
+		break;
+	default:
+		WARN_ON(1);
+		ret = -EINVAL;
+		goto error;
+	}
+	return 0;
+
+error:
+	dev_err(&psys->adev->dev, "failed to start process group\n");
+	ipu_psys_kcmd_complete(psys, kcmd, -EIO);
+	return ret;
+}
+
+static void ipu_psys_watchdog(unsigned long data)
+{
+	struct ipu_psys_kcmd *kcmd = (struct ipu_psys_kcmd *)data;
+	struct ipu_psys *psys = kcmd->fh->psys;
+
+	queue_work(IPU_PSYS_WORK_QUEUE, &psys->watchdog_work);
+}
+
+static int ipu_psys_config_legacy_pg(struct ipu_psys_kcmd *kcmd)
+{
+	struct ipu_psys *psys = kcmd->fh->psys;
+	unsigned int i;
+	int ret;
+
+	ret = ipu_fw_psys_pg_set_ipu_vaddress(kcmd, kcmd->kpg->pg_dma_addr);
+	if (ret) {
+		ret = -EIO;
+		goto error;
+	}
+
+	for (i = 0; i < kcmd->nbuffers; i++) {
+		struct ipu_fw_psys_terminal *terminal;
+		u32 buffer;
+
+		terminal = ipu_fw_psys_pg_get_terminal(kcmd, i);
+		if (!terminal)
+			continue;
+
+		buffer = (u32) kcmd->kbufs[i]->dma_addr +
+		    kcmd->buffers[i].data_offset;
+
+		ret = ipu_fw_psys_terminal_set(terminal, i, kcmd,
+					       buffer, kcmd->kbufs[i]->len);
+		if (ret == -EAGAIN)
+			continue;
+
+		if (ret) {
+			dev_err(&psys->adev->dev, "Unable to set terminal\n");
+			goto error;
+		}
+	}
+
+	ipu_fw_psys_pg_set_token(kcmd, (u64) kcmd);
+
+	ret = ipu_fw_psys_pg_submit(kcmd);
+	if (ret) {
+		dev_err(&psys->adev->dev, "failed to submit kcmd!\n");
+		goto error;
+	}
+
+	return 0;
+
+error:
+	dev_err(&psys->adev->dev, "failed to config legacy pg\n");
+	return ret;
+}
+
+static bool ipu_psys_kcmd_is_valid(struct ipu_psys *psys,
+				   struct ipu_psys_kcmd *kcmd)
+{
+	struct ipu_psys_fh *fh;
+	struct ipu_psys_kcmd *kcmd0;
+	int p;
+
+	list_for_each_entry(fh, &psys->fhs, list) {
+		mutex_lock(&fh->mutex);
+		for (p = 0; p < IPU_PSYS_CMD_PRIORITY_NUM; p++) {
+			list_for_each_entry(kcmd0, &fh->kcmds[p], list) {
+				if (kcmd0 == kcmd) {
+					mutex_unlock(&fh->mutex);
+					return true;
+				}
+			}
+		}
+		mutex_unlock(&fh->mutex);
+	}
+
+	return false;
+}
+
+int ipu_psys_kcmd_queue(struct ipu_psys *psys, struct ipu_psys_kcmd *kcmd)
+{
+	int ret;
+
+	if (kcmd->state != KCMD_STATE_NEW) {
+		WARN_ON(1);
+		return -EINVAL;
+	}
+
+	if (!psys->started_kcmds) {
+		ret = ipu_psys_allocate_resources(&psys->adev->dev,
+						  kcmd->kpg->pg,
+						  kcmd->pg_manifest,
+						  &kcmd->resource_alloc,
+						  &psys->resource_pool_running);
+		if (!ret) {
+			if (kcmd->state == KCMD_STATE_NEW)
+				kcmd->state = KCMD_STATE_RUN_PREPARED;
+			return ipu_psys_kcmd_start(psys, kcmd);
+		}
+
+		if (ret != -ENOSPC || !psys->active_kcmds) {
+			dev_err(&psys->adev->dev,
+				"kcmd %p failed to alloc resources (running)\n",
+				kcmd);
+			ipu_psys_kcmd_complete(psys, kcmd, ret);
+			/* kcmd_complete doesn't handle PM for KCMD_STATE_NEW */
+			pm_runtime_put(&psys->adev->dev);
+			return -EINVAL;
+		}
+	}
+
+	ret = ipu_psys_allocate_resources(&psys->adev->dev,
+					  kcmd->kpg->pg,
+					  kcmd->pg_manifest,
+					  &kcmd->resource_alloc,
+					  &psys->resource_pool_started);
+	if (!ret) {
+		kcmd->state = KCMD_STATE_START_PREPARED;
+		return ipu_psys_kcmd_start(psys, kcmd);
+	}
+
+	if (ret != -ENOSPC || !psys->started_kcmds) {
+		dev_err(&psys->adev->dev,
+			"kcmd %p failed to alloc resources (started)\n", kcmd);
+		ipu_psys_kcmd_complete(psys, kcmd, ret);
+		/* kcmd_complete doesn't handle PM for KCMD_STATE_NEW */
+		pm_runtime_put(&psys->adev->dev);
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+int ipu_psys_kcmd_new(struct ipu_psys_command *cmd, struct ipu_psys_fh *fh)
+{
+	struct ipu_psys *psys = fh->psys;
+	struct ipu_psys_kcmd *kcmd;
+	size_t pg_size;
+	int ret;
+
+	if (psys->adev->isp->flr_done)
+		return -EIO;
+
+	kcmd = ipu_psys_copy_cmd(cmd, fh);
+	if (!kcmd)
+		return -EINVAL;
+
+	ipu_psys_resource_alloc_init(&kcmd->resource_alloc);
+
+	init_timer(&kcmd->watchdog);
+	kcmd->watchdog.data = (unsigned long)kcmd;
+	kcmd->watchdog.function = &ipu_psys_watchdog;
+
+	if (cmd->min_psys_freq) {
+		kcmd->constraint.min_freq = cmd->min_psys_freq;
+		ipu_buttress_add_psys_constraint(psys->adev->isp,
+						 &kcmd->constraint);
+	}
+
+	pg_size = ipu_fw_psys_pg_get_size(kcmd);
+	if (pg_size > kcmd->kpg->pg_size) {
+		dev_dbg(&psys->adev->dev, "pg size mismatch %lu %lu\n",
+			pg_size, kcmd->kpg->pg_size);
+		ret = -EINVAL;
+		goto error;
+	}
+
+	ret = ipu_psys_config_legacy_pg(kcmd);
+	if (ret)
+		goto error;
+
+	mutex_lock(&fh->mutex);
+	list_add_tail(&kcmd->list, &fh->kcmds[cmd->priority]);
+	if (!fh->new_kcmd_tail[cmd->priority] && kcmd->state == KCMD_STATE_NEW) {
+		fh->new_kcmd_tail[cmd->priority] = kcmd;
+		/* Kick command scheduler thread */
+		atomic_set(&psys->wakeup_sched_thread_count, 1);
+		wake_up_interruptible(&psys->sched_cmd_wq);
+	}
+	mutex_unlock(&fh->mutex);
+
+	dev_dbg(&psys->adev->dev,
+		"IOC_QCMD: user_token:%llx issue_id:0x%llx pri:%d\n",
+		cmd->user_token, cmd->issue_id, cmd->priority);
+
+	return 0;
+
+error:
+	ipu_psys_kcmd_free(kcmd);
+
+	return ret;
+}
+
+void ipu_psys_handle_events(struct ipu_psys *psys)
+{
+	struct ipu_psys_kcmd *kcmd = NULL;
+	struct ipu_fw_psys_event event;
+	bool error;
+
+	do {
+		memset(&event, 0, sizeof(event));
+		if (!ipu_fw_psys_rcv_event(psys, &event))
+			break;
+
+		error = false;
+		kcmd = (struct ipu_psys_kcmd *)event.token;
+		error = IS_ERR_OR_NULL(kcmd) ? true : false;
+
+		dev_dbg(&psys->adev->dev, "psys received event status:%d\n",
+			event.status);
+
+		if (error) {
+			dev_err(&psys->adev->dev,
+				"no token received, command unknown\n");
+			pm_runtime_put(&psys->adev->dev);
+			ipu_psys_reset(psys);
+			pm_runtime_get(&psys->adev->dev);
+			break;
+		}
+
+		if (ipu_psys_kcmd_is_valid(psys, kcmd))
+			ipu_psys_kcmd_complete(psys, kcmd,
+			       event.status ==
+			       IPU_PSYS_EVENT_CMD_COMPLETE ||
+			       event.status ==
+			       IPU_PSYS_EVENT_FRAGMENT_COMPLETE
+			       ? 0 : -EIO);
+		/* Kick command scheduler thread */
+		atomic_set(&psys->wakeup_sched_thread_count, 1);
+		wake_up_interruptible(&psys->sched_cmd_wq);
+	} while (1);
+}
diff --git a/drivers/media/pci/intel/ipu4/ipu4-resource-tables.c b/drivers/media/pci/intel/ipu4/ipu4-resource-tables.c
deleted file mode 100644
index 029bd74..0000000
--- a/drivers/media/pci/intel/ipu4/ipu4-resource-tables.c
+++ /dev/null
@@ -1,173 +0,0 @@
-// SPDX-License_Identifier: GPL-2.0
-// Copyright (C) 2015 - 2018 Intel Corporation
-
-#include <linux/kernel.h>
-#include "ipu-resources.h"
-
-/*
- * Cell types by cell IDs
- */
-
-const u32 ipu_fw_psys_cell_types[IPU_FW_PSYS_N_CELL_ID] = {
-	IPU_FW_PSYS_SP_CTRL_TYPE_ID,
-	IPU_FW_PSYS_SP_SERVER_TYPE_ID,
-	IPU_FW_PSYS_SP_SERVER_TYPE_ID,
-	IPU_FW_PSYS_VP_TYPE_ID,
-	IPU_FW_PSYS_VP_TYPE_ID,
-	IPU_FW_PSYS_VP_TYPE_ID,
-	IPU_FW_PSYS_VP_TYPE_ID,
-	IPU_FW_PSYS_ACC_ISA_TYPE_ID,
-	IPU_FW_PSYS_ACC_PSA_TYPE_ID,
-	IPU_FW_PSYS_ACC_PSA_TYPE_ID,
-	IPU_FW_PSYS_ACC_PSA_TYPE_ID,
-	IPU_FW_PSYS_ACC_PSA_TYPE_ID,
-	IPU_FW_PSYS_ACC_PSA_TYPE_ID,
-	IPU_FW_PSYS_ACC_PSA_TYPE_ID,
-	IPU_FW_PSYS_ACC_OSA_TYPE_ID,
-	IPU_FW_PSYS_GDC_TYPE_ID,
-	IPU_FW_PSYS_GDC_TYPE_ID
-};
-
-const u16 ipu_num_dev_channels[IPU_FW_PSYS_N_DEV_CHN_ID] = {
-	IPU_FW_PSYS_DEV_CHN_DMA_EXT0_MAX_SIZE,
-	IPU_FW_PSYS_DEV_CHN_GDC_MAX_SIZE,
-	IPU_FW_PSYS_DEV_CHN_DMA_EXT1_READ_MAX_SIZE,
-	IPU_FW_PSYS_DEV_CHN_DMA_EXT1_WRITE_MAX_SIZE,
-	IPU_FW_PSYS_DEV_CHN_DMA_INTERNAL_MAX_SIZE,
-	IPU_FW_PSYS_DEV_CHN_DMA_IPFD_MAX_SIZE,
-	IPU_FW_PSYS_DEV_CHN_DMA_ISA_MAX_SIZE,
-	IPU_FW_PSYS_DEV_CHN_DMA_FW_MAX_SIZE,
-#ifdef CONFIG_VIDEO_INTEL_IPU4P
-	IPU_FW_PSYS_DEV_CHN_DMA_CMPRS_MAX_SIZE
-#endif
-};
-
-const u16 ipu_fw_psys_mem_size[IPU_FW_PSYS_N_MEM_ID] = {
-	IPU_FW_PSYS_VMEM0_MAX_SIZE,
-	IPU_FW_PSYS_VMEM1_MAX_SIZE,
-	IPU_FW_PSYS_VMEM2_MAX_SIZE,
-	IPU_FW_PSYS_VMEM3_MAX_SIZE,
-	IPU_FW_PSYS_VMEM4_MAX_SIZE,
-	IPU_FW_PSYS_BAMEM0_MAX_SIZE,
-	IPU_FW_PSYS_BAMEM1_MAX_SIZE,
-	IPU_FW_PSYS_BAMEM2_MAX_SIZE,
-	IPU_FW_PSYS_BAMEM3_MAX_SIZE,
-	IPU_FW_PSYS_DMEM0_MAX_SIZE,
-	IPU_FW_PSYS_DMEM1_MAX_SIZE,
-	IPU_FW_PSYS_DMEM2_MAX_SIZE,
-	IPU_FW_PSYS_DMEM3_MAX_SIZE,
-	IPU_FW_PSYS_DMEM4_MAX_SIZE,
-	IPU_FW_PSYS_DMEM5_MAX_SIZE,
-	IPU_FW_PSYS_DMEM6_MAX_SIZE,
-	IPU_FW_PSYS_DMEM7_MAX_SIZE,
-	IPU_FW_PSYS_PMEM0_MAX_SIZE,
-	IPU_FW_PSYS_PMEM1_MAX_SIZE,
-	IPU_FW_PSYS_PMEM2_MAX_SIZE,
-	IPU_FW_PSYS_PMEM3_MAX_SIZE
-};
-
-const enum ipu_mem_id
-ipu_fw_psys_cell_mem[IPU_FW_PSYS_N_CELL_ID][IPU_FW_PSYS_N_DATA_MEM_TYPE_ID] = {
-	{
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_DMEM0_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID
-	},
-	{
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_DMEM1_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID
-	},
-	{
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_DMEM2_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID
-	},
-	{
-	 IPU_FW_PSYS_VMEM4_ID,
-	 IPU_FW_PSYS_DMEM4_ID,
-	 IPU_FW_PSYS_VMEM0_ID,
-	 IPU_FW_PSYS_BAMEM0_ID
-	},
-	{
-	 IPU_FW_PSYS_VMEM4_ID,
-	 IPU_FW_PSYS_DMEM5_ID,
-	 IPU_FW_PSYS_VMEM1_ID,
-	 IPU_FW_PSYS_BAMEM1_ID
-	},
-	{
-	 IPU_FW_PSYS_VMEM4_ID,
-	 IPU_FW_PSYS_DMEM6_ID,
-	 IPU_FW_PSYS_VMEM2_ID,
-	 IPU_FW_PSYS_BAMEM2_ID
-	},
-	{
-	 IPU_FW_PSYS_VMEM4_ID,
-	 IPU_FW_PSYS_DMEM7_ID,
-	 IPU_FW_PSYS_VMEM3_ID,
-	 IPU_FW_PSYS_BAMEM3_ID
-	},
-	{
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID
-	},
-	{
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID
-	},
-	{
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID
-	},
-	{
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID
-	},
-	{
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID
-	},
-	{
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID
-	},
-	{
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID
-	},
-	{
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID
-	},
-	{
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID
-	},
-	{
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID,
-	 IPU_FW_PSYS_N_MEM_ID
-	}
-};
diff --git a/drivers/media/pci/intel/ipu-resources.c b/drivers/media/pci/intel/ipu4/ipu4-resources.c
similarity index 68%
rename from drivers/media/pci/intel/ipu-resources.c
rename to drivers/media/pci/intel/ipu4/ipu4-resources.c
index 38a959e..0bed8da 100644
--- a/drivers/media/pci/intel/ipu-resources.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-resources.c
@@ -11,7 +11,174 @@
 
 #include "ipu-fw-psys.h"
 #include "ipu-psys.h"
-#include "ipu-fw-resources.h"
+
+/* resources table */
+/*
+ * Cell types by cell IDs
+ */
+const u32 ipu_fw_psys_cell_types[IPU_FW_PSYS_N_CELL_ID] = {
+	IPU_FW_PSYS_SP_CTRL_TYPE_ID,
+	IPU_FW_PSYS_SP_SERVER_TYPE_ID,
+	IPU_FW_PSYS_SP_SERVER_TYPE_ID,
+	IPU_FW_PSYS_VP_TYPE_ID,
+	IPU_FW_PSYS_VP_TYPE_ID,
+	IPU_FW_PSYS_VP_TYPE_ID,
+	IPU_FW_PSYS_VP_TYPE_ID,
+	IPU_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU_FW_PSYS_ACC_OSA_TYPE_ID,
+	IPU_FW_PSYS_GDC_TYPE_ID,
+	IPU_FW_PSYS_GDC_TYPE_ID
+};
+
+const u16 ipu_fw_num_dev_channels[IPU_FW_PSYS_N_DEV_CHN_ID] = {
+	IPU_FW_PSYS_DEV_CHN_DMA_EXT0_MAX_SIZE,
+	IPU_FW_PSYS_DEV_CHN_GDC_MAX_SIZE,
+	IPU_FW_PSYS_DEV_CHN_DMA_EXT1_READ_MAX_SIZE,
+	IPU_FW_PSYS_DEV_CHN_DMA_EXT1_WRITE_MAX_SIZE,
+	IPU_FW_PSYS_DEV_CHN_DMA_INTERNAL_MAX_SIZE,
+	IPU_FW_PSYS_DEV_CHN_DMA_IPFD_MAX_SIZE,
+	IPU_FW_PSYS_DEV_CHN_DMA_ISA_MAX_SIZE,
+	IPU_FW_PSYS_DEV_CHN_DMA_FW_MAX_SIZE,
+#ifdef CONFIG_VIDEO_INTEL_IPU4P
+	IPU_FW_PSYS_DEV_CHN_DMA_CMPRS_MAX_SIZE
+#endif
+};
+
+const u16 ipu_fw_psys_mem_size[IPU_FW_PSYS_N_MEM_ID] = {
+	IPU_FW_PSYS_VMEM0_MAX_SIZE,
+	IPU_FW_PSYS_VMEM1_MAX_SIZE,
+	IPU_FW_PSYS_VMEM2_MAX_SIZE,
+	IPU_FW_PSYS_VMEM3_MAX_SIZE,
+	IPU_FW_PSYS_VMEM4_MAX_SIZE,
+	IPU_FW_PSYS_BAMEM0_MAX_SIZE,
+	IPU_FW_PSYS_BAMEM1_MAX_SIZE,
+	IPU_FW_PSYS_BAMEM2_MAX_SIZE,
+	IPU_FW_PSYS_BAMEM3_MAX_SIZE,
+	IPU_FW_PSYS_DMEM0_MAX_SIZE,
+	IPU_FW_PSYS_DMEM1_MAX_SIZE,
+	IPU_FW_PSYS_DMEM2_MAX_SIZE,
+	IPU_FW_PSYS_DMEM3_MAX_SIZE,
+	IPU_FW_PSYS_DMEM4_MAX_SIZE,
+	IPU_FW_PSYS_DMEM5_MAX_SIZE,
+	IPU_FW_PSYS_DMEM6_MAX_SIZE,
+	IPU_FW_PSYS_DMEM7_MAX_SIZE,
+	IPU_FW_PSYS_PMEM0_MAX_SIZE,
+	IPU_FW_PSYS_PMEM1_MAX_SIZE,
+	IPU_FW_PSYS_PMEM2_MAX_SIZE,
+	IPU_FW_PSYS_PMEM3_MAX_SIZE
+};
+
+const enum ipu_mem_id
+ipu_fw_psys_cell_mem[IPU_FW_PSYS_N_CELL_ID][IPU_FW_PSYS_N_DATA_MEM_TYPE_ID] = {
+	{
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_DMEM0_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID
+	},
+	{
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_DMEM1_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID
+	},
+	{
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_DMEM2_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID
+	},
+	{
+	 IPU_FW_PSYS_VMEM4_ID,
+	 IPU_FW_PSYS_DMEM4_ID,
+	 IPU_FW_PSYS_VMEM0_ID,
+	 IPU_FW_PSYS_BAMEM0_ID
+	},
+	{
+	 IPU_FW_PSYS_VMEM4_ID,
+	 IPU_FW_PSYS_DMEM5_ID,
+	 IPU_FW_PSYS_VMEM1_ID,
+	 IPU_FW_PSYS_BAMEM1_ID
+	},
+	{
+	 IPU_FW_PSYS_VMEM4_ID,
+	 IPU_FW_PSYS_DMEM6_ID,
+	 IPU_FW_PSYS_VMEM2_ID,
+	 IPU_FW_PSYS_BAMEM2_ID
+	},
+	{
+	 IPU_FW_PSYS_VMEM4_ID,
+	 IPU_FW_PSYS_DMEM7_ID,
+	 IPU_FW_PSYS_VMEM3_ID,
+	 IPU_FW_PSYS_BAMEM3_ID
+	},
+	{
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID
+	},
+	{
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID
+	},
+	{
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID
+	},
+	{
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID
+	},
+	{
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID
+	},
+	{
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID
+	},
+	{
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID
+	},
+	{
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID
+	},
+	{
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID
+	},
+	{
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID,
+	 IPU_FW_PSYS_N_MEM_ID
+	}
+};
 
 static int ipu_resource_init(struct ipu_resource *res, u32 id, int elements)
 {
@@ -29,7 +196,6 @@ static int ipu_resource_init(struct ipu_resource *res, u32 id, int elements)
 	return 0;
 }
 
-
 static unsigned long
 ipu_resource_alloc(struct ipu_resource *res, int n,
 		   struct ipu_resource_alloc *alloc,
@@ -123,6 +289,7 @@ int ipu_psys_resource_pool_init(struct ipu_psys_resource_pool
 	return ret;
 }
 
+
 void ipu_psys_resource_pool_cleanup(struct ipu_psys_resource_pool
 				    *pool)
 {
@@ -171,12 +338,10 @@ static int ipu_psys_allocate_one_resource(const struct device *dev,
 		return (int)retl;
 	}
 	alloc->resources++;
-	ipu_fw_psys_set_process_dev_chn_offset(process, resource_id, retl);
 
 	return 0;
 }
 
-
 /*
  * ext_mem_type_id is a generic type id for memory (like DMEM, VMEM)
  * ext_mem_bank_id is detailed type id for  memory (like DMEM0, DMEM1 etc.)
@@ -211,10 +376,6 @@ static int ipu_psys_allocate_memory_resource(
 
 	alloc->resources++;
 
-	ipu_fw_psys_set_process_ext_mem_id(process, ext_mem_type_id,
-					   ext_mem_bank_id);
-	ipu_fw_psys_set_process_ext_mem_offset(process, ext_mem_type_id, retl);
-
 	return 0;
 }
 
@@ -250,14 +411,16 @@ int ipu_psys_allocate_resources(const struct device *dev,
 		    ((char *)pg + process_offset_table[i]);
 		struct ipu_fw_generic_program_manifest pm;
 
+		memset(&pm, 0, sizeof(pm));
 		if (!process) {
 			dev_err(dev, "can not get process\n");
 			ret = -ENOENT;
 			goto free_out;
 		}
 
-		ret = ipu_fw_psys_get_program_manifest_by_process
-		    (&pm, pg_manifest, process);
+		ret = ipu_fw_psys_get_program_manifest_by_process(&pm,
+								  pg_manifest,
+								  process);
 		if (ret < 0) {
 			dev_err(dev, "can not get manifest\n");
 			goto free_out;
@@ -293,32 +456,40 @@ int ipu_psys_allocate_resources(const struct device *dev,
 			ret = -ENOSPC;
 			goto free_out;
 		}
-		for (resid = 0; resid < res_defs->num_dev_channels; resid++) {
-			ret = ipu_psys_allocate_one_resource
-			    (dev, process,
-			     &pool->dev_channels[resid], &pm, resid, alloc);
-			if (ret)
-				goto free_out;
+		if (pm.dev_chn_size) {
+			for (resid = 0; resid < res_defs->num_dev_channels; resid++) {
+				ret = ipu_psys_allocate_one_resource
+				    (dev, process,
+				     &pool->dev_channels[resid], &pm, resid, alloc);
+				if (ret)
+					goto free_out;
+				ipu_fw_psys_set_process_dev_chn_offset(process, resid,
+					alloc->resource_alloc[alloc->resources - 1].pos);
+			}
 		}
 
-
-		for (mem_type_id = 0;
-		     mem_type_id < res_defs->num_ext_mem_types; mem_type_id++) {
-			u32 mem_bank_id = res_defs->num_ext_mem_ids;
-
-			if (cell != res_defs->num_cells)
-				mem_bank_id =
-				    res_defs->cell_mem[res_defs->cell_mem_row *
-						       cell + mem_type_id];
-			if (mem_bank_id == res_defs->num_ext_mem_ids)
-				continue;
-
-			ret = ipu_psys_allocate_memory_resource
-			    (dev, process,
-			     &pool->ext_memory[mem_bank_id],
-			     &pm, mem_type_id, mem_bank_id, alloc);
-			if (ret)
-				goto free_out;
+		if (pm.ext_mem_size) {
+			for (mem_type_id = 0;
+			     mem_type_id < res_defs->num_ext_mem_types; mem_type_id++) {
+				u32 mem_bank_id = res_defs->num_ext_mem_ids;
+
+				if (cell != res_defs->num_cells)
+					mem_bank_id =
+					    res_defs->cell_mem[res_defs->cell_mem_row *
+							       cell + mem_type_id];
+				if (mem_bank_id == res_defs->num_ext_mem_ids)
+					continue;
+
+				ret = ipu_psys_allocate_memory_resource
+				    (dev, process,
+				     &pool->ext_memory[mem_bank_id],
+				     &pm, mem_type_id, mem_bank_id, alloc);
+				if (ret)
+					goto free_out;
+				ipu_fw_psys_set_process_ext_mem_id(process, mem_type_id, mem_bank_id);
+				ipu_fw_psys_set_process_ext_mem_offset(process, mem_type_id,
+					alloc->resource_alloc[alloc->resources - 1].pos);
+			}
 		}
 	}
 	alloc->cells |= cells;
diff --git a/drivers/media/pci/intel/ipu4/ipu4.c b/drivers/media/pci/intel/ipu4/ipu4.c
index 4c0d758..74a85eb 100644
--- a/drivers/media/pci/intel/ipu4/ipu4.c
+++ b/drivers/media/pci/intel/ipu4/ipu4.c
@@ -1,7 +1,5 @@
-/* SPDX-License_Identifier: GPL-2.0
- * Copyright (C) 2018 Intel Corporation
- * FIXME: update checkpatch script
- */
+// SPDX-License_Identifier: GPL-2.0
+// Copyright (C) 2018 Intel Corporation
 
 #include <linux/device.h>
 #include <linux/delay.h>
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/Makefile.ipu4pisys_src b/drivers/media/pci/intel/ipu4/ipu4p-css/Makefile.ipu4pisys_src
index 6380816..c20760b 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/Makefile.ipu4pisys_src
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/Makefile.ipu4pisys_src
@@ -2,6 +2,8 @@ IPU_ISYSLIB_SRC = \
 	$(IPU_ISYSLIB_ROOT_REL)/isysapi/src/ia_css_isys_private.o \
 	$(IPU_ISYSLIB_ROOT_REL)/isysapi/src/ia_css_isys_public.o \
 	$(IPU_ISYSLIB_ROOT_REL)/isysapi/src/ia_css_isys_public_trace.o
+
+ifeq ($(CONFIG_VIDEO_INTEL_IPU), m)
 IPU_ISYSLIB_SRC += \
 	$(IPU_ISYSLIB_ROOT_REL)/buffer/src/cpu/buffer_access.o \
 	$(IPU_ISYSLIB_ROOT_REL)/buffer/src/cpu/ia_css_buffer.o \
@@ -13,4 +15,5 @@ IPU_ISYSLIB_SRC += \
 	$(IPU_ISYSLIB_ROOT_REL)/port/src/recv_port.o \
 	$(IPU_ISYSLIB_ROOT_REL)/port/src/send_port.o \
 	$(IPU_ISYSLIB_ROOT_REL)/reg_dump/src/reg_dump_generic_bridge.o \
-	$(IPU_ISYSLIB_ROOT_REL)/syscom/src/ia_css_syscom.o
\ No newline at end of file
+	$(IPU_ISYSLIB_ROOT_REL)/syscom/src/ia_css_syscom.o
+endif
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/Makefile.isyslib b/drivers/media/pci/intel/ipu4/ipu4p-css/Makefile.isyslib
index 209fa7c..0f066d9 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/Makefile.isyslib
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/Makefile.isyslib
@@ -15,36 +15,34 @@ include $(srcpath)/$(src)/ipu4p-css/Makefile.ipu4pisys_src
 #
 $(shell cp -f $(srcpath)/$(src)/../ipu-wrapper.c $(srcpath)/$(src)/ipu4p-css/ipu-wrapper.c)
 
-lib2600-mod-$(IPU_STEP)-objs := \
-	ipu4p-css/libintel-ipu4p.o \
-	../libintel-checker.o \
-	$(IPU_ISYSLIB_SRC)
+intel-ipu4p-isys-csslib-objs := \
+		ipu4p-css/libintel-ipu4p.o \
+		../libintel-checker.o \
+		$(IPU_ISYSLIB_SRC)
 
 ifeq ($(CONFIG_VIDEO_INTEL_IPU), m)
-lib2600-mod-$(IPU_STEP)-objs += ipu4p-css/ipu-wrapper.o
+intel-ipu4p-isys-csslib-objs += ipu4p-css/ipu-wrapper.o
 endif
+obj-$(CONFIG_VIDEO_INTEL_IPU)	+= intel-ipu4p-isys-csslib.o
 
-obj-$(CONFIG_VIDEO_INTEL_IPU)	+= lib2600-mod-$(IPU_STEP).o
-
-INCLUDES := \
-	-I$(srcpath)/$(src)/$(IPU_ISYSLIB_ROOT_REL) \
+INCLUDES := -I$(srcpath)/$(src)/$(IPU_ISYSLIB_ROOT_REL) \
 	-I$(srcpath)/$(src) \
 	$(IPU_ISYSLIB_INC)
 
 DEFINES:= -D__HOST__ -D__KERNEL__ -DISYS_FPGA -DPSYS_FPGA
 
- DEFINES += -DSSID=1
- DEFINES += -DMMID=1
- DEFINES += -DPROGNAME=isys_fw
- DEFINES += -DPROGMAP=\"isys_fw.map.h\"
- DEFINES += -DSUBSYSTEM_INCLUDE=\<isys.h\>
- DEFINES += -DCELL=input_system_unis_logic_sp_control_tile_sp
- DEFINES += -DSPMAIN=isys_fw
- DEFINES += -DRUN_INTEGRATION
- DEFINES += -DDEBUG_SP_NCI
- DEFINES += -DCFG_VIED_SUBSYSTEM_ACCESS_LIB_IMPL=1
- DEFINES += -DHRT_ON_VIED_SUBSYSTEM_ACCESS=0
- DEFINES += -DHRT_USE_VIR_ADDRS
- DEFINES += -DHRT_HW
+DEFINES += -DSSID=1
+DEFINES += -DMMID=1
+DEFINES += -DPROGNAME=isys_fw
+DEFINES += -DPROGMAP=\"isys_fw.map.h\"
+DEFINES += -DSUBSYSTEM_INCLUDE=\<isys.h\>
+DEFINES += -DCELL=input_system_unis_logic_sp_control_tile_sp
+DEFINES += -DSPMAIN=isys_fw
+DEFINES += -DRUN_INTEGRATION
+DEFINES += -DDEBUG_SP_NCI
+DEFINES += -DCFG_VIED_SUBSYSTEM_ACCESS_LIB_IMPL=1
+DEFINES += -DHRT_ON_VIED_SUBSYSTEM_ACCESS=0
+DEFINES += -DHRT_USE_VIR_ADDRS
+DEFINES += -DHRT_HW
 
 ccflags-y += $(INCLUDES) $(DEFINES) -fno-common
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/ia_css_fw_pkg_release.h b/drivers/media/pci/intel/ipu4/ipu4p-css/ia_css_fw_pkg_release.h
index 3435bd5..795c783 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/ia_css_fw_pkg_release.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/ia_css_fw_pkg_release.h
@@ -11,4 +11,4 @@
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */
-#define IA_CSS_FW_PKG_RELEASE  0x20180308
+#define IA_CSS_FW_PKG_RELEASE  0x20180420
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/config/isys/subsystem_cnlB0.mk b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/config/isys/subsystem_cnlB0.mk
new file mode 100644
index 0000000..e49be29
--- /dev/null
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/config/isys/subsystem_cnlB0.mk
@@ -0,0 +1,73 @@
+# # #
+# Support for Intel Camera Imaging ISP subsystem.
+# Copyright (c) 2010 - 2018, Intel Corporation.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details
+#
+
+############################################################################
+# This file is used to specify versions and properties of ISYS firmware
+# components. Please note that these are subsystem specific. System specific
+# properties should go to system_$IPU_SYSVER.mk. Also the device versions
+# should be defined under "devices" or should be taken from the SDK.
+############################################################################
+
+############################################################################
+# FIRMWARE RELATED VARIABLES
+############################################################################
+
+# Activate loading params and storing stats DDR<->REGs with DMA
+ISYS_USE_ISA_DMA                 = 1
+#DMA does not work with AF due to a known bug
+DISABLE_AF_STAT_DMA              = 1
+# Used in ISA module
+ISYS_ISL_DPC_DPC_V2              = 1
+
+# Specification for Isys server's fixed globals' locations
+REGMEM_OFFSET				= 0	# Starting from 0
+REGMEM_SECURE_OFFSET			= 4096
+REGMEM_SIZE				= 34
+REGMEM_WORD_BYTES			= 4
+FW_LOAD_NO_OF_REQUEST_OFFSET		= 136	# Taken from REGMEM_OFFSET + REGMEM_SIZE_BYTES
+FW_LOAD_NO_OF_REQUEST_SIZE_BYTES	= 4
+
+# Workarounds:
+
+# This WA is not to pipeline store frame commands for SID processors that control a Str2Vec (ISA output)
+WA_HSD1304553438                 = 1
+
+# FW workaround for HSD 1404347241. Disable clock gating for CSI2 DPHY Receiver ports
+DISABLE_CSI2_RX_DPHY_CLK_GATE    = 1
+
+# Larger than specified frames that complete mid-line
+WA_HSD1209062354                 = 0
+
+# WA to disable clock gating for the devices in the CSI receivers needed for using the mipi_pkt_gen device
+WA_HSD1805168877		 = 0
+
+# Support IBUF soft-reset at stream start
+SOFT_RESET_IBUF_STREAM_START_SUPPORT = 0
+
+############################################################################
+# TESTING RELATED VARIABLES
+############################################################################
+
+# Cannot remove this define
+# Used in mipi_capture, isys_utils.mk, and stream_controller.mk
+ISYS_DISABLE_VERIFY_RECEIVED_SOF_EOF     = 0
+
+ISYS_ACCESS_BLOCKER_VERSION      = v1
+
+HAS_SPC				= 1
+
+# Support dual command context for VTIO - concurrent secure and non-secure streams
+ISYS_HAS_DUAL_CMD_CTX_SUPPORT	= 1
+
+AB_CONFIG_ARRAY_SIZE = 50
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/cpd_binary/ia_css_fw_pkg_release.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/cpd_binary/ia_css_fw_pkg_release.h
index 3435bd5..795c783 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/cpd_binary/ia_css_fw_pkg_release.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/cpd_binary/ia_css_fw_pkg_release.h
@@ -11,4 +11,4 @@
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */
-#define IA_CSS_FW_PKG_RELEASE  0x20180308
+#define IA_CSS_FW_PKG_RELEASE  0x20180420
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/fw_abi_common_types/ia_css_terminal_defs.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/fw_abi_common_types/ia_css_terminal_defs.h
index f2cf330..dbf1cf9 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/fw_abi_common_types/ia_css_terminal_defs.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/fw_abi_common_types/ia_css_terminal_defs.h
@@ -71,9 +71,6 @@ typedef enum ia_css_terminal_type {
  * Dimensions of the data objects. Note that a C-style
  * data order is assumed. Data stored by row.
  */
-/* A strange problem with hivecc compiler forces this
- * enum to be explicitly initialized for the moment
- */
 typedef enum ia_css_dimension {
 	/**< The number of columns, i.e. the size of the row */
 	IA_CSS_COL_DIMENSION = 0,
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/interface/ia_css_isysapi_types.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/interface/ia_css_isysapi_types.h
index 2cdc28d..cc00cb6 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/interface/ia_css_isysapi_types.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/interface/ia_css_isysapi_types.h
@@ -71,6 +71,7 @@ struct ia_css_isys_device_cfg_data {
 	struct ia_css_isys_buffer_partition buffer_partition;
 	struct ia_css_driver_proxy_config driver_proxy;
 	bool secure;
+	unsigned vtl0_addr_mask; /* only applicable in 'secure' case */
 };
 
 /**
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/isysapi.mk b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/isysapi.mk
index 50da4e4..0d06298 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/isysapi.mk
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/isysapi.mk
@@ -14,6 +14,8 @@
 #
 # MODULE is ISYSAPI
 
+include $(MODULES_DIR)/config/isys/subsystem_$(IPU_SYSVER).mk
+
 ISYSAPI_DIR=$${MODULES_DIR}/isysapi
 
 ISYSAPI_INTERFACE=$(ISYSAPI_DIR)/interface
@@ -61,6 +63,8 @@ ISYSAPI_FW_CPPFLAGS += -I$(HIVESDK)/include/ipu
 
 ISYSAPI_FW_CPPFLAGS += -DWA_HSD1805168877=$(WA_HSD1805168877)
 
+ISYSAPI_HOST_CPPFLAGS += -DREGMEM_OFFSET=$(REGMEM_OFFSET)
+
 ifeq ($(ISYS_HAS_DUAL_CMD_CTX_SUPPORT), 1)
 ISYSAPI_HOST_CPPFLAGS += -DHAS_DUAL_CMD_CTX_SUPPORT=$(ISYS_HAS_DUAL_CMD_CTX_SUPPORT)
 ISYSAPI_FW_CPPFLAGS += -DHAS_DUAL_CMD_CTX_SUPPORT=$(ISYS_HAS_DUAL_CMD_CTX_SUPPORT)
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/src/ia_css_isys_public.c b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/src/ia_css_isys_public.c
index 6983f98..1c56da1 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/src/ia_css_isys_public.c
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/isysapi/src/ia_css_isys_public.c
@@ -218,6 +218,9 @@ static int isys_context_create(
 	/* parameters size */
 	sys.specific_size = sizeof(isys_fw_cfg);
 	sys.secure = config->secure;
+	if (config->secure) {
+		sys.vtl0_addr_mask = config->vtl0_addr_mask;
+	}
 
 	IA_CSS_TRACE_0(ISYSAPI, VERBOSE,
 		"isys_context_create || call ia_css_syscom_open()\n");
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/regmem/interface/regmem_access.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/regmem/interface/regmem_access.h
index 78b28ce..3fc8958 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/regmem/interface/regmem_access.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/regmem/interface/regmem_access.h
@@ -28,10 +28,20 @@ enum regmem_id {
 	SYSCOM_COMMAND_REG	= 3,
 	/* Store interrupt status - updated by SP */
 	SYSCOM_IRQ_REG		= 4,
+	/* Store VTL0_ADDR_MASK in trusted secure regision - provided by host.*/
+	SYSCOM_VTL0_ADDR_MASK	= 5,
 	/* first syscom queue pointer register */
-	SYSCOM_QPR_BASE_REG	= 5
+	SYSCOM_QPR_BASE_REG	= 6
 };
 
+#if HAS_DUAL_CMD_CTX_SUPPORT
+/* Bit 0: for untrusted non-secure DRV driver on VTL0
+ * Bit 1: for trusted secure TEE driver on VTL1
+ */
+#define SYSCOM_IRQ_VTL0_MASK 0x1
+#define SYSCOM_IRQ_VTL1_MASK 0x2
+#endif
+
 STORAGE_CLASS_INLINE unsigned int
 regmem_load_32(unsigned int mem_address, unsigned int reg, unsigned int ssid);
 
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/support/math_support.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/support/math_support.h
index 337fbd8..633f86f 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/support/math_support.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/support/math_support.h
@@ -44,6 +44,7 @@
 #define IS_ODD(a) ((a) & 0x1)
 #define IS_EVEN(a) (!IS_ODD(a))
 #define IS_POWER2(a) (!((a)&((a)-1)))
+#define IS_MASK_BITS_SET(a, b)	((a & b) != 0)
 
 /*To Find next power of 2 number from x */
 #define bit2(x)            ((x)      | ((x) >> 1))
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/syscom/interface/ia_css_syscom_config.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/syscom/interface/ia_css_syscom_config.h
index 3a62c8f..8c827c2 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/syscom/interface/ia_css_syscom_config.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/syscom/interface/ia_css_syscom_config.h
@@ -91,6 +91,7 @@ struct ia_css_syscom_config {
 	 * if false, non-secure syscom
 	 */
 	bool secure;
+	unsigned int vtl0_addr_mask; /* only applicable in 'secure' case */
 };
 
 #endif /* __IA_CSS_SYSCOM_CONFIG_H */
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/syscom/src/ia_css_syscom.c b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/syscom/src/ia_css_syscom.c
index 13056e9..5dfa953 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/syscom/src/ia_css_syscom.c
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600/syscom/src/ia_css_syscom.c
@@ -367,6 +367,13 @@ ia_css_syscom_open(
 #if HAS_DUAL_CMD_CTX_SUPPORT
 	/* clear IRQ status */
 	regmem_store_32(ctx->cell_dmem_addr, SYSCOM_IRQ_REG, 0x0, cfg->ssid);
+
+	if (cfg->secure) {
+		/* store VTL0 address mask in 'secure' context */
+		IA_CSS_TRACE_3(SYSCOM, INFO, "ia_css_syscom_open store VTL0_ADDR_MASK (%#x) @ dmem_addr %#x ssid %d\n",
+			      cfg->vtl0_addr_mask, ctx->cell_dmem_addr, cfg->ssid);
+		regmem_store_32(ctx->cell_dmem_addr, SYSCOM_VTL0_ADDR_MASK, cfg->vtl0_addr_mask, cfg->ssid);
+	}
 #endif
 
 	/* Indicate if ctx is created for secure stream purpose */
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/Makefile b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/Makefile
index e68937d..629899d 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/Makefile
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/Makefile
@@ -27,7 +27,7 @@ IPU_PSYSLIB_ROOT = $(srcpath)/$(src)/$(IPU_PSYSLIB_ROOT_REL)
 
 ccflags-y += -I$(srcpath)/$(src)/../../../
 ccflags-y += -I$(srcpath)/$(src)/../../
-ccflags-y += -DHAS_DUAL_CMD_CTX_SUPPORT=0 -DHAS_LATE_BINDING_SUPPORT=0
+ccflags-y += -DHAS_DUAL_CMD_CTX_SUPPORT=0 -DHAS_LATE_BINDING_SUPPORT=0 -DIPU_PSYS_LEGACY
 
 IPU_PSYSLIB_SRC += libcsspsys2600.o
 
@@ -45,9 +45,9 @@ HOST_DEFINES += -DAPI_SPLIT_START_STATE_UPDATE
 HOST_DEFINES += -DHAS_DUAL_CMD_CTX_SUPPORT=0
 HOST_DEFINES += -DHAS_LATE_BINDING_SUPPORT=0
 
-lib2600psys-mod-$(IPU_SYSVER)-objs := ../../../ipu-wrapper.o \
-	$(IPU_PSYSLIB_SRC)
-obj-$(CONFIG_VIDEO_INTEL_IPU)	+= lib2600psys-mod-$(IPU_SYSVER).o
+intel-ipu4p-psys-csslib-objs := ../../../ipu-wrapper.o \
+		$(IPU_PSYSLIB_SRC)
+obj-$(CONFIG_VIDEO_INTEL_IPU)	+= intel-ipu4p-psys-csslib.o
 
 ccflags-y += $(IPU_PSYSLIB_INC) $(HOST_DEFINES) -fno-common -v
 
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/CNL_program_group/ia_css_fw_pkg_release.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/CNL_program_group/ia_css_fw_pkg_release.h
index 3435bd5..795c783 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/CNL_program_group/ia_css_fw_pkg_release.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/CNL_program_group/ia_css_fw_pkg_release.h
@@ -11,4 +11,4 @@
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */
-#define IA_CSS_FW_PKG_RELEASE  0x20180308
+#define IA_CSS_FW_PKG_RELEASE  0x20180420
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/ICL_program_group/ia_css_fw_pkg_release.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/ICL_program_group/ia_css_fw_pkg_release.h
index 3435bd5..795c783 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/ICL_program_group/ia_css_fw_pkg_release.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/ICL_program_group/ia_css_fw_pkg_release.h
@@ -11,4 +11,4 @@
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */
-#define IA_CSS_FW_PKG_RELEASE  0x20180308
+#define IA_CSS_FW_PKG_RELEASE  0x20180420
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/config/psys/subsystem_cnlB0.mk b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/config/psys/subsystem_cnlB0.mk
index 2695e7a..b4c24fd 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/config/psys/subsystem_cnlB0.mk
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/config/psys/subsystem_cnlB0.mk
@@ -59,14 +59,14 @@ ENABLE_MMU_STREAM_ID_LUT = 1
 # Specification for Psys server's fixed globals' locations
 REGMEM_OFFSET				= 0
 REGMEM_SECURE_OFFSET			= 4096
-REGMEM_SIZE				= 17
+REGMEM_SIZE				= 18
 REGMEM_WORD_BYTES			= 4
-REGMEM_SIZE_BYTES			= 68
-GPC_ISP_PERF_DATA_OFFSET		= 68	# Taken from REGMEM_SECURE_OFFSET + REGMEM_SIZE_BYTES
+REGMEM_SIZE_BYTES			= 72
+GPC_ISP_PERF_DATA_OFFSET		= 72	# Taken from REGMEM_OFFSET + REGMEM_SIZE_BYTES
 GPC_ISP_PERF_DATA_SIZE_BYTES		= 80
-FW_LOAD_NO_OF_REQUEST_OFFSET		= 148	# Taken from GPC_ISP_PERF_DATA_OFFSET + GPC_ISP_PERF_DATA_SIZE_BYTES
+FW_LOAD_NO_OF_REQUEST_OFFSET		= 152	# Taken from GPC_ISP_PERF_DATA_OFFSET + GPC_ISP_PERF_DATA_SIZE_BYTES
 FW_LOAD_NO_OF_REQUEST_SIZE_BYTES	= 4
-DISPATCHER_SCRATCH_SPACE_OFFSET 	= 4164	# Taken from REGMEM_SECURE_OFFSET + REGMEM_SIZE_BYTES
+DISPATCHER_SCRATCH_SPACE_OFFSET 	= 4168	# Taken from REGMEM_SECURE_OFFSET + REGMEM_SIZE_BYTES
 
 # use DMA NCI for OFS Service to reduce load in tproxy
 DMA_NCI_IN_OFS_SERVICE = 1
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psys_server/src/bxt_spctrl_process_group_cmd_impl.c b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psys_server/src/bxt_spctrl_process_group_cmd_impl.c
index d5d97fc..6f8aea7 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psys_server/src/bxt_spctrl_process_group_cmd_impl.c
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psys_server/src/bxt_spctrl_process_group_cmd_impl.c
@@ -27,8 +27,6 @@
 #include "cpu_mem_support.h"
 #include "ia_css_bxt_spctrl_trace.h"
 
-#if !defined(__KERNEL__) && !defined(_MSC_VER)
-/* This section is for FW testing app only */
 #if HAS_DUAL_CMD_CTX_SUPPORT
 #define MAX_CLIENT_PGS 8 /* same as test_params.h */
 struct ia_css_process_group_context {
@@ -36,7 +34,7 @@ struct ia_css_process_group_context {
 	bool secure;
 };
 struct ia_css_process_group_context pg_contexts[MAX_CLIENT_PGS];
-int num_of_pgs;
+static unsigned int num_of_pgs;
 
 STORAGE_CLASS_INLINE
 struct ia_css_syscom_context *ia_css_process_group_get_context(ia_css_process_group_t *process_group)
@@ -47,7 +45,7 @@ struct ia_css_syscom_context *ia_css_process_group_get_context(ia_css_process_gr
 	IA_CSS_TRACE_0(BXT_SPCTRL, INFO,
 		"ia_css_process_group_get_context(): enter:\n");
 
-	for (i = 0; i < MAX_CLIENT_PGS; i++) {
+	for (i = 0; i < num_of_pgs; i++) {
 		if (pg_contexts[i].pg == process_group) {
 			secure = pg_contexts[i].secure;
 			break;
@@ -87,17 +85,6 @@ int ia_css_process_group_store(ia_css_process_group_t *process_group, bool secur
 }
 #endif /* HAS_DUAL_CMD_CTX_SUPPORT */
 
-#else /* !defined(__KERNEL__) && !defined(_MSC_VER) */
-/* This section is for driver environment. */
-STORAGE_CLASS_INLINE
-struct ia_css_syscom_context *ia_css_process_group_get_context(ia_css_process_group_t *process_group)
-{
-	NOT_USED(process_group);
-
-	return psys_syscom;
-}
-#endif /* !defined(__KERNEL__) && !defined(_MSC_VER) */
-
 int ia_css_process_group_on_create(
 	ia_css_process_group_t			*process_group,
 	const ia_css_program_group_manifest_t	*program_group_manifest,
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/data/src/ia_css_program_group_data_impl.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/data/src/ia_css_program_group_data_impl.h
index c44e0ac..f08a057 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/data/src/ia_css_program_group_data_impl.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/data/src/ia_css_program_group_data_impl.h
@@ -17,6 +17,7 @@
 
 #include "ia_css_program_group_data.h"
 #include "ia_css_psys_data_trace.h"
+#include "ia_css_terminal_defs.h"
 #include <error_support.h>	/* for verifexit */
 #include <assert_support.h>	/* for COMPILATION_ERROR_IF */
 #include <misc_support.h>	/* for NOT_USED */
@@ -332,12 +333,12 @@ int ia_css_frame_descriptor_print(
 	IA_CSS_TRACE_1(PSYSAPI_DATA, INFO,
 		"\tstride[%d] = {\n", IA_CSS_N_DATA_DIMENSION - 1);
 	i = 0;
-#if IA_CSS_N_DATA_DIMENSION > 2
-	for (i = 0; i < (int)IA_CSS_N_DATA_DIMENSION - 2; i++) {
-		IA_CSS_TRACE_1(PSYSAPI_DATA, INFO,
-			"\t%4d,\n", frame_descriptor->stride[i]);
+	if (IA_CSS_N_DATA_DIMENSION > 2) {
+		for (i = 0; i < (int)IA_CSS_N_DATA_DIMENSION - 2; i++) {
+			IA_CSS_TRACE_1(PSYSAPI_DATA, INFO,
+				"\t%4d,\n", frame_descriptor->stride[i]);
+		}
 	}
-#endif
 	IA_CSS_TRACE_1(PSYSAPI_DATA, INFO,
 		"\t%4d }\n", frame_descriptor->stride[i]);
 
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/device/interface/ia_css_psys_device.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/device/interface/ia_css_psys_device.h
index cadee7d..abfdfb9 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/device/interface/ia_css_psys_device.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/device/interface/ia_css_psys_device.h
@@ -105,9 +105,10 @@ extern struct ia_css_syscom_config *ia_css_psys_specify(void);
 #if HAS_DUAL_CMD_CTX_SUPPORT
 /*! Create the syscom creation descriptor for secure stream
 
+ @param	vtl0_addr_mask[in]	VTL0 address mask that will be stored in 'secure' ctx
  @return NULL on error
  */
-extern struct ia_css_syscom_config *ia_css_psys_specify_secure(void);
+extern struct ia_css_syscom_config *ia_css_psys_specify_secure(unsigned int vtl0_addr_mask);
 #endif
 
 /*! Compute the size of storage required for allocating the Psys syscom object
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/device/src/ia_css_psys_device.c b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/device/src/ia_css_psys_device.c
index 58b1571..f7a84a8 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/device/src/ia_css_psys_device.c
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/device/src/ia_css_psys_device.c
@@ -16,6 +16,7 @@
 #include "ia_css_psys_device.h"
 #include "ia_css_psys_device_trace.h"
 #include "ia_css_psys_init.h"
+#include "regmem_access.h"
 
 #include <error_support.h>
 #include <print_support.h>
@@ -97,6 +98,7 @@ static void set_syscom_config(struct ia_css_syscom_config *config)
 	}
 	config->input = ia_css_psys_cmd_queue_cfg;
 	config->output = ia_css_psys_event_queue_cfg;
+	config->vtl0_addr_mask = 0;
 }
 
 struct ia_css_syscom_config *ia_css_psys_specify(void)
@@ -111,13 +113,14 @@ struct ia_css_syscom_config *ia_css_psys_specify(void)
 }
 
 #if HAS_DUAL_CMD_CTX_SUPPORT
-struct ia_css_syscom_config *ia_css_psys_specify_secure(void)
+struct ia_css_syscom_config *ia_css_psys_specify_secure(unsigned int vtl0_addr_mask)
 {
 	struct ia_css_syscom_config *config = &psys_syscom_config_secure;
 
-	IA_CSS_TRACE_0(PSYSAPI_DEVICE, INFO, "ia_css_psys_specify_secure(): enter:\n");
+	IA_CSS_TRACE_1(PSYSAPI_DEVICE, INFO, "ia_css_psys_specify_secure(mask %#x): enter:\n", vtl0_addr_mask);
 	set_syscom_config(config);
 	config->secure = true;
+	config->vtl0_addr_mask = vtl0_addr_mask;
 	return config;
 }
 #endif
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/dynamic/interface/ia_css_psys_process_group_cmd_impl.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/dynamic/interface/ia_css_psys_process_group_cmd_impl.h
index 1677bbf..f4b191e 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/dynamic/interface/ia_css_psys_process_group_cmd_impl.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/dynamic/interface/ia_css_psys_process_group_cmd_impl.h
@@ -161,7 +161,6 @@ extern int ia_css_enqueue_param_buffer_set(
 	ia_css_process_group_t				*process_group,
 	ia_css_buffer_set_t				*buffer_set);
 
-#if !defined(__KERNEL__) && !defined(_MSC_VER)
 /*! Need to store the 'secure' mode for each PG for FW test app only
  *
  * @param	process_group[in]		process group object
@@ -172,6 +171,6 @@ extern int ia_css_enqueue_param_buffer_set(
 extern int ia_css_process_group_store(
 	ia_css_process_group_t				*process_group,
 	bool						secure);
-#endif
+
 
 #endif /* __IA_CSS_PSYS_PROCESS_GROUP_CMD_IMPL_H */
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/dynamic/src/ia_css_psys_process.c b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/dynamic/src/ia_css_psys_process.c
index 3617070..f9e060f 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/dynamic/src/ia_css_psys_process.c
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/dynamic/src/ia_css_psys_process.c
@@ -15,6 +15,7 @@
 #include "ia_css_psys_process.h"
 #include "ia_css_psys_dynamic_storage_class.h"
 #include "ia_css_psys_process_private_types.h"
+#include <misc_support.h>	/* for NOT_USED */
 
 /*
  * Functions to possibly inline
@@ -917,6 +918,7 @@ int ia_css_process_print(const ia_css_process_t *process, void *fid)
 			(int)vied_nci_cell_get_mem_type(cell_id, mem_index),
 			(int)mem_id,
 			process->ext_mem_offset[mem_index]);
+		NOT_USED(mem_id);
 	}
 	for (dev_chn_index = 0; dev_chn_index < (int)VIED_NCI_N_DEV_CHN_ID;
 		dev_chn_index++) {
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/static/src/ia_css_psys_terminal_manifest.c b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/static/src/ia_css_psys_terminal_manifest.c
index 9c6eccc..80ff0d5 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/static/src/ia_css_psys_terminal_manifest.c
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/psysapi/static/src/ia_css_psys_terminal_manifest.c
@@ -1007,6 +1007,9 @@ int ia_css_terminal_manifest_print(
 		PRINT_DIMENSION("max_frame_grid_dimension",
 			framed->max_frame_grid_dimension);
 
+		NOT_USED(framed);
+		NOT_USED(fragd);
+
 		for (sec_index = 0; sec_index < sec_count; sec_index++) {
 			sec = ia_css_spatial_param_terminal_manifest_get_frm_grid_prm_sct_desc(
 				stm, sec_index);
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/regmem/interface/regmem_access.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/regmem/interface/regmem_access.h
index 78b28ce..3fc8958 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/regmem/interface/regmem_access.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/regmem/interface/regmem_access.h
@@ -28,10 +28,20 @@ enum regmem_id {
 	SYSCOM_COMMAND_REG	= 3,
 	/* Store interrupt status - updated by SP */
 	SYSCOM_IRQ_REG		= 4,
+	/* Store VTL0_ADDR_MASK in trusted secure regision - provided by host.*/
+	SYSCOM_VTL0_ADDR_MASK	= 5,
 	/* first syscom queue pointer register */
-	SYSCOM_QPR_BASE_REG	= 5
+	SYSCOM_QPR_BASE_REG	= 6
 };
 
+#if HAS_DUAL_CMD_CTX_SUPPORT
+/* Bit 0: for untrusted non-secure DRV driver on VTL0
+ * Bit 1: for trusted secure TEE driver on VTL1
+ */
+#define SYSCOM_IRQ_VTL0_MASK 0x1
+#define SYSCOM_IRQ_VTL1_MASK 0x2
+#endif
+
 STORAGE_CLASS_INLINE unsigned int
 regmem_load_32(unsigned int mem_address, unsigned int reg, unsigned int ssid);
 
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/support/math_support.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/support/math_support.h
index 337fbd8..633f86f 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/support/math_support.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/support/math_support.h
@@ -44,6 +44,7 @@
 #define IS_ODD(a) ((a) & 0x1)
 #define IS_EVEN(a) (!IS_ODD(a))
 #define IS_POWER2(a) (!((a)&((a)-1)))
+#define IS_MASK_BITS_SET(a, b)	((a & b) != 0)
 
 /*To Find next power of 2 number from x */
 #define bit2(x)            ((x)      | ((x) >> 1))
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/syscom/interface/ia_css_syscom_config.h b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/syscom/interface/ia_css_syscom_config.h
index 3a62c8f..8c827c2 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/syscom/interface/ia_css_syscom_config.h
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/syscom/interface/ia_css_syscom_config.h
@@ -91,6 +91,7 @@ struct ia_css_syscom_config {
 	 * if false, non-secure syscom
 	 */
 	bool secure;
+	unsigned int vtl0_addr_mask; /* only applicable in 'secure' case */
 };
 
 #endif /* __IA_CSS_SYSCOM_CONFIG_H */
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/syscom/src/ia_css_syscom.c b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/syscom/src/ia_css_syscom.c
index 13056e9..5dfa953 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/syscom/src/ia_css_syscom.c
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/lib/syscom/src/ia_css_syscom.c
@@ -367,6 +367,13 @@ ia_css_syscom_open(
 #if HAS_DUAL_CMD_CTX_SUPPORT
 	/* clear IRQ status */
 	regmem_store_32(ctx->cell_dmem_addr, SYSCOM_IRQ_REG, 0x0, cfg->ssid);
+
+	if (cfg->secure) {
+		/* store VTL0 address mask in 'secure' context */
+		IA_CSS_TRACE_3(SYSCOM, INFO, "ia_css_syscom_open store VTL0_ADDR_MASK (%#x) @ dmem_addr %#x ssid %d\n",
+			      cfg->vtl0_addr_mask, ctx->cell_dmem_addr, cfg->ssid);
+		regmem_store_32(ctx->cell_dmem_addr, SYSCOM_VTL0_ADDR_MASK, cfg->vtl0_addr_mask, cfg->ssid);
+	}
 #endif
 
 	/* Indicate if ctx is created for secure stream purpose */
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/libcsspsys2600.c b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/libcsspsys2600.c
index 8069e5d..6572b62 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/libcsspsys2600.c
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/lib2600psys/libcsspsys2600.c
@@ -23,7 +23,6 @@
 #include "ipu.h"
 #include "ipu-fw-psys.h"
 #include "ipu-psys.h"
-#include "ipu-fw-resources.h"
 #include "ipu-wrapper.h"
 #include "ipu-mmu.h"
 
@@ -263,7 +262,7 @@ void ipu_fw_psys_pg_dump(struct ipu_psys *psys,
 		ia_css_process_group_get_program_group_ID(pg);
 	uint8_t processes = ia_css_process_group_get_process_count(
 		(ia_css_process_group_t *)kcmd->kpg->pg);
-	unsigned int p, chn, dfm, mem;
+	unsigned int p, chn, mem;
 
 	dev_dbg(&psys->adev->dev, "%s %s pgid %i has %i processes\n",
 		__func__, note, pgid, processes);
@@ -281,12 +280,6 @@ void ipu_fw_psys_pg_dump(struct ipu_psys *psys,
 			"%s pgid %i process %i kernel bitmap 0x%llx \n",
 			__func__, pgid, p,
 			ia_css_process_get_kernel_bitmap(process));
-		for (dfm = 0; dfm < VIED_NCI_N_DEV_DFM_ID; dfm++ ) {
-			dev_dbg(&psys->adev->dev,
-				"%s pgid %i process %i dfm port bitmap 0x%x \n",
-				__func__, pgid, p,
-				ia_css_process_get_dfm_port_bitmap(process, dfm));
-		}
 		for (mem = 0; mem < VIED_NCI_N_DATA_MEM_TYPE_ID; mem++ ) {
 			unsigned int mem_id = process->ext_mem_id[mem];
 			dev_dbg(&psys->adev->dev,
@@ -492,15 +485,7 @@ ipu_fw_psys_ppg_enqueue_bufs(struct ipu_psys_kcmd *kcmd,
 }
 EXPORT_SYMBOL_GPL(ipu_fw_psys_ppg_enqueue_bufs);
 
-void ipu_fw_psys_register_ctx_addr(void *ctx_cpu_addr, u32 ctx_vied_addr)
-{}
-EXPORT_SYMBOL_GPL(ipu_fw_psys_register_ctx_addr);
-
-void ipu_fw_psys_unregister_ctx_addr(void *ctx_cpu_addr, u32 ctx_vied_addr)
-{}
-EXPORT_SYMBOL_GPL(ipu_fw_psys_unregister_ctx_addr);
-
-static const struct ipu_resource_definitions default_defs = {
+static const struct ipu_fw_resource_definitions default_defs = {
 	.cells = vied_nci_cell_type,
 	.num_cells = VIED_NCI_N_CELL_ID,
 	.num_cells_type = VIED_NCI_N_CELL_TYPE_ID,
@@ -522,7 +507,7 @@ static const struct ipu_resource_definitions default_defs = {
 	.process.cell_id = offsetof(struct ia_css_process_s, cell_id),
 };
 
-const struct ipu_resource_definitions *res_defs = &default_defs;
+const struct ipu_fw_resource_definitions *res_defs = &default_defs;
 EXPORT_SYMBOL_GPL(res_defs);
 
 /*
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-css/libintel-ipu4p.c b/drivers/media/pci/intel/ipu4/ipu4p-css/libintel-ipu4p.c
index 5e71204..c2f8113 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-css/libintel-ipu4p.c
+++ b/drivers/media/pci/intel/ipu4/ipu4p-css/libintel-ipu4p.c
@@ -1,4 +1,4 @@
-// SPDX-LIcense_Identifier: GPL-2.0
+// SPDX-License_Identifier: GPL-2.0
 // Copyright (C) 2014 - 2018 Intel Corporation
 
 #include <linux/module.h>
diff --git a/drivers/media/platform/intel/Kconfig b/drivers/media/platform/intel/Kconfig
index 7495161..d1dc1e7 100755
--- a/drivers/media/platform/intel/Kconfig
+++ b/drivers/media/platform/intel/Kconfig
@@ -1,5 +1,6 @@
 config INTEL_IPU4_BXT_P_PDATA
 	bool "Enable built in platform data for Broxton-P"
+	depends on VIDEO_INTEL_IPU4
 	---help---
 	Pre-ACPI system platform data is compiled inside kernel
 
@@ -10,6 +11,7 @@ config INTEL_IPU4_ICI_BXT_P_PDATA
 
 config INTEL_IPU4P_CNL_RVP_PDATA
 	bool "Enable built in platform data for ipu4p"
+	depends on VIDEO_INTEL_IPU4P
 	---help---
 	Pre-ACPI system platform data is compiled inside kernel
 
diff --git a/drivers/media/platform/intel/Makefile b/drivers/media/platform/intel/Makefile
index 8baafb4..91e5798 100644
--- a/drivers/media/platform/intel/Makefile
+++ b/drivers/media/platform/intel/Makefile
@@ -1,20 +1,18 @@
-#
-#  Copyright (c) 2010 - 2018 Intel Corporation.
-#
-#  This program is free software; you can redistribute it and/or modify it
-#  under the terms and conditions of the GNU General Public License,
-#  version 2, as published by the Free Software Foundation.
-#
-#  This program is distributed in the hope it will be useful, but WITHOUT
-#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-#  more details.
-#
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (c) 2010 - 2018, Intel Corporation.
 
 ifneq ($(EXTERNAL_BUILD), 1)
 srcpath := $(srctree)
 endif
 
+# force check the compile warning to make sure zero warnings
+# note we may have build issue when gcc upgraded.
+ccflags-y := -Wall -Wextra
+ccflags-y += $(call cc-disable-warning, unused-parameter)
+ccflags-y += $(call cc-disable-warning, implicit-fallthrough)
+ccflags-y += $(call cc-disable-warning, missing-field-initializers)
+ccflags-$(CONFIG_VIDEO_INTEL_IPU_WERROR) += -Werror
+
 ccflags-y += -I$(srcpath)/$(src)/../../../../include/
 ccflags-y += -I$(srcpath)/$(src)/../../pci/intel/
 
diff --git a/drivers/media/platform/intel/ipu4-bxt-p-pdata.c b/drivers/media/platform/intel/ipu4-bxt-p-pdata.c
index 3818ea0..cd09177 100755
--- a/drivers/media/platform/intel/ipu4-bxt-p-pdata.c
+++ b/drivers/media/platform/intel/ipu4-bxt-p-pdata.c
@@ -1,18 +1,6 @@
-/*
- * Copyright (c) 2015--2018 Intel Corporation.
- *
- * Author: Jianxu Zheng <jian.xu.zheng@intel.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
+// SPDX-License_Identifier: GPL-2.0
+// Copyright (C) 2015 - 2018 Intel Corporation
+
 #include <linux/clk.h>
 #include <linux/clkdev.h>
 #include <linux/gpio.h>
diff --git a/drivers/media/platform/intel/ipu4p-cnl-rvp-pdata.c b/drivers/media/platform/intel/ipu4p-cnl-rvp-pdata.c
index a56d52d..633d7ad 100644
--- a/drivers/media/platform/intel/ipu4p-cnl-rvp-pdata.c
+++ b/drivers/media/platform/intel/ipu4p-cnl-rvp-pdata.c
@@ -1,16 +1,6 @@
-/*
- * Copyright (c) 2018 Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
+// SPDX-License_Identifier: GPL-2.0
+// Copyright (C) 2018 Intel Corporation
+
 #include <linux/clk.h>
 #include <linux/clkdev.h>
 #include <linux/kernel.h>
diff --git a/drivers/media/platform/video-sensor-stub-pdata.c b/drivers/media/platform/video-sensor-stub-pdata.c
index 6f7697d..86fa86e 100644
--- a/drivers/media/platform/video-sensor-stub-pdata.c
+++ b/drivers/media/platform/video-sensor-stub-pdata.c
@@ -23,9 +23,6 @@ static struct ipu_isys_csi2_config stub_csi2_cfg[] = {
 		.port = 0,
 	},
 	{
-		/*
-		 * For BXT B0 FPGA board, port 1 only support 1 lane
-		 */
 		.nlanes = 1,
 		.port = 1,
 	},
@@ -66,12 +63,4 @@ static void ipu_quirk(struct pci_dev *pci_dev)
 	pci_dev->dev.platform_data = &pdata;
 }
 
-/* BXT ISYS FPGA */
-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x9488, ipu_quirk);
-/* BXT A0 */
-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x4008, ipu_quirk);
-/* BXTP A0 Iunit=BXT B0 Iunit */
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x5a88, ipu_quirk);
-/* BXT FPGA. ISYS & PSYS */
-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x0a88, ipu_quirk);
-
diff --git a/drivers/media/platform/video-sensor-stub.c b/drivers/media/platform/video-sensor-stub.c
index 4d7bf33..08195e7 100644
--- a/drivers/media/platform/video-sensor-stub.c
+++ b/drivers/media/platform/video-sensor-stub.c
@@ -79,6 +79,10 @@ static const uint32_t sensor_supported_codes_pad[] = {
 };
 
 
+static const uint32_t * const sensor_supported_codes[] = {
+	sensor_supported_codes_pad,
+};
+
 static u32 sensor_pixel_order(struct stub_sensor *sensor)
 {
 	return sensor->default_pixel_order;
-- 
2.7.4

