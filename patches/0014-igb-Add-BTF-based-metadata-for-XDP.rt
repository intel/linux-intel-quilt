From 9ec197e6dbf9b58dbf7d91a20670a1662c943c59 Mon Sep 17 00:00:00 2001
From: florent pirou <florent.pirou@intel.com>
Date: Mon, 25 Mar 2024 03:52:36 -0700
Subject: [PATCH 14/20] igb: Add BTF based metadata for XDP

This commit adds support for BTF based metadata for XDP. Currently, the
support has only been tested on receive side. Following is the struct
describing the metadata:

struct xdp_md_desc {
       u64 timestamp;
       };

Note that only a single member is added to the struct. More members will
be added in the future.

Link: https://github.com/intel/linux-intel-lts/commit/421b0336d53a8c7617042804e8cb537b189d2ed7
Signed-off-by: florent pirou <florent.pirou@intel.com>
---
 drivers/net/ethernet/intel/igb/igb.h      |  12 +++
 drivers/net/ethernet/intel/igb/igb_main.c |  11 ++
 drivers/net/ethernet/intel/igb/igb_xsk.c  | 119 ++++++++++++++++++++++
 3 files changed, 142 insertions(+)

diff --git a/drivers/net/ethernet/intel/igb/igb.h b/drivers/net/ethernet/intel/igb/igb.h
index 9ee18ac1ba47..269b68d7acd4 100644
--- a/drivers/net/ethernet/intel/igb/igb.h
+++ b/drivers/net/ethernet/intel/igb/igb.h
@@ -21,6 +21,7 @@
 
 #include <net/xdp.h>
 #include <net/xdp_sock_drv.h>
+#include <asm-generic/int-ll64.h>
 
 struct igb_adapter;
 
@@ -544,6 +545,8 @@ struct igb_adapter {
 
 	struct net_device *netdev;
 	struct bpf_prog *xdp_prog;
+	struct btf *btf;
+	u8 btf_enabled;
 
 	unsigned long state;
 	unsigned int flags;
@@ -720,6 +723,10 @@ enum igb_boards {
 	board_82575,
 };
 
+struct igb_md_desc {
+	u64 timestamp;
+};
+
 extern char igb_driver_name[];
 
 int igb_xmit_xdp_ring(struct igb_adapter *adapter,
@@ -840,4 +847,9 @@ int igb_clean_rx_irq_zc(struct igb_q_vector *q_vector, const int budget);
 bool igb_xmit_zc(struct igb_ring *tx_ring);
 int igb_xsk_wakeup(struct net_device *dev, u32 qid, u32 flags);
 
+int igb_xdp_register_rxq_info(struct igb_ring *ring);
+void igb_xdp_unregister_rxq_info(struct igb_ring *ring);
+int igb_xdp_query_btf(struct net_device *dev, u8 *enabled);
+int igb_xdp_set_btf_md(struct net_device *dev, u8 enable);
+
 #endif /* _IGB_H_ */
diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
index af57738e64e8..66a447d2d2b4 100644
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -30,6 +30,7 @@
 #include <linux/if_ether.h>
 #include <linux/prefetch.h>
 #include <linux/bpf.h>
+#include <linux/btf.h>
 #include <linux/bpf_trace.h>
 #include <linux/pm_runtime.h>
 #include <linux/etherdevice.h>
@@ -2925,6 +2926,11 @@ static int igb_xdp(struct net_device *dev, struct netdev_bpf *xdp)
 	case XDP_SETUP_XSK_POOL:
 		return igb_xsk_pool_setup(adapter, xdp->xsk.pool,
 					  xdp->xsk.queue_id);
+	case XDP_SETUP_MD_BTF:
+		return igb_xdp_set_btf_md(dev, xdp->btf_enable);
+	case XDP_QUERY_MD_BTF:
+		xdp->btf_id = igb_xdp_query_btf(dev, &xdp->btf_enable);
+		return 0;
 	default:
 		return -EINVAL;
 	}
@@ -3885,6 +3891,11 @@ static void igb_remove(struct pci_dev *pdev)
 	cancel_work_sync(&adapter->reset_task);
 	cancel_work_sync(&adapter->watchdog_task);
 
+	if (adapter->btf) {
+		adapter->btf_enabled = 0;
+		btf_unregister(adapter->btf);
+	}
+
 #ifdef CONFIG_IGB_DCA
 	if (adapter->flags & IGB_FLAG_DCA_ENABLED) {
 		dev_info(&pdev->dev, "DCA disabled\n");
diff --git a/drivers/net/ethernet/intel/igb/igb_xsk.c b/drivers/net/ethernet/intel/igb/igb_xsk.c
index bfabc71e8c85..1b69af4f81f8 100644
--- a/drivers/net/ethernet/intel/igb/igb_xsk.c
+++ b/drivers/net/ethernet/intel/igb/igb_xsk.c
@@ -4,10 +4,120 @@
 #include <linux/bpf_trace.h>
 #include <net/xdp_sock_drv.h>
 #include <net/xdp.h>
+#include <linux/btf.h>
 
 #include "e1000_hw.h"
 #include "igb.h"
 
+#define BTF_INFO_ENC(kind, kind_flag, vlen)			\
+	((!!(kind_flag) << 31) | ((kind) << 24) | ((vlen) & BTF_MAX_VLEN))
+
+#define BTF_TYPE_ENC(name, info, size_or_type)	\
+	(name), (info), (size_or_type)
+
+#define BTF_INT_ENC(encoding, bits_offset, nr_bits)	\
+	((encoding) << 24 | (bits_offset) << 16 | (nr_bits))
+
+#define BTF_TYPE_INT_ENC(name, encoding, bits_offset, bits, sz)	\
+	BTF_TYPE_ENC(name, BTF_INFO_ENC(BTF_KIND_INT, 0, 0), sz),	\
+	BTF_INT_ENC(encoding, bits_offset, bits)
+
+#define BTF_STRUCT_ENC(name, nr_elems, sz)	\
+	BTF_TYPE_ENC(name, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, nr_elems), sz)
+
+#define BTF_MEMBER_ENC(name, type, bits_offset)	\
+	(name), (type), (bits_offset)
+
+#define IGB_MD_NUM_MMBRS 1
+static const char names_str[] = "\0xdp_md_desc\0timestamp\0";
+
+/* Must match struct xdp_md_desc */
+static const u32 igb_md_raw_types[] = {
+	/* #define u64 */
+	BTF_TYPE_INT_ENC(0, 0, 0, 64, 8),         /* type [1] */
+	/* struct xdp_md_desc { */
+	BTF_STRUCT_ENC(1, IGB_MD_NUM_MMBRS, 8),
+		BTF_MEMBER_ENC(13, 1, 0),    /* u64 timestamp;    */
+	/* } */
+};
+
+static int igb_xdp_register_btf(struct igb_adapter *priv)
+{
+	unsigned int type_sec_sz, str_sec_sz;
+	char *types_sec, *str_sec;
+	struct btf_header *hdr;
+	unsigned int btf_size;
+	void *raw_btf = NULL;
+	int err = 0;
+
+	type_sec_sz = sizeof(igb_md_raw_types);
+	str_sec_sz  = sizeof(names_str);
+
+	btf_size = sizeof(*hdr) + type_sec_sz + str_sec_sz;
+	raw_btf = kzalloc(btf_size, GFP_KERNEL);
+	if (!raw_btf)
+		return -ENOMEM;
+
+	hdr = raw_btf;
+	hdr->magic    = BTF_MAGIC;
+	hdr->version  = BTF_VERSION;
+	hdr->hdr_len  = sizeof(*hdr);
+	hdr->type_off = 0;
+	hdr->type_len = type_sec_sz;
+	hdr->str_off  = type_sec_sz;
+	hdr->str_len  = str_sec_sz;
+
+	types_sec = raw_btf   + sizeof(*hdr);
+	str_sec   = types_sec + type_sec_sz;
+	memcpy(types_sec, igb_md_raw_types, type_sec_sz);
+	memcpy(str_sec, names_str, str_sec_sz);
+
+	priv->btf = btf_register(priv->netdev->name, raw_btf, btf_size);
+	if (IS_ERR(priv->btf)) {
+		err = PTR_ERR(priv->btf);
+		priv->btf = NULL;
+		netdev_err(priv->netdev, "failed to register BTF MD, err (%d)\n", err);
+	}
+
+	kfree(raw_btf);
+	return err;
+}
+
+int igb_xdp_query_btf(struct net_device *dev, u8 *enabled)
+{
+	struct igb_adapter *priv = netdev_priv(dev);
+	u32 md_btf_id = 0;
+
+	if (!IS_ENABLED(CONFIG_BPF_SYSCALL))
+		return md_btf_id;
+
+	if (!priv->btf)
+		igb_xdp_register_btf(priv);
+
+	*enabled = !!priv->btf_enabled;
+	md_btf_id = priv->btf ? btf_obj_id(priv->btf) : 0;
+
+	return md_btf_id;
+}
+
+int igb_xdp_set_btf_md(struct net_device *dev, u8 enable)
+{
+	struct igb_adapter *priv = netdev_priv(dev);
+	int err = 0;
+
+	if (enable && !priv->btf) {
+		igb_xdp_register_btf(priv);
+		if (!priv->btf) {
+			err = -EINVAL;
+			goto unlock;
+		}
+	}
+
+	priv->btf_enabled = enable;
+unlock:
+	return err;
+}
+
 static int igb_realloc_rx_buffer_info(struct igb_ring *ring, bool pool_present)
 {
 	int size = pool_present ?
@@ -312,6 +422,7 @@ int igb_clean_rx_irq_zc(struct igb_q_vector *q_vector, const int budget)
 	int cpu = smp_processor_id();
 	unsigned int xdp_xmit = 0;
 	struct netdev_queue *nq;
+	struct igb_md_desc *md;
 	bool failure = false;
 	u16 entries_to_alloc;
 	struct sk_buff *skb;
@@ -350,6 +461,14 @@ int igb_clean_rx_irq_zc(struct igb_q_vector *q_vector, const int budget)
 			size -= ts_hdr_len;
 		}
 
+		if (adapter->btf_enabled) {
+			md = xdp->data - sizeof(*md);
+			md->timestamp = timestamp;
+			xdp->data_meta = md;
+		} else {
+			xdp_set_data_meta_invalid(xdp);
+		}
+
 		skb = igb_run_xdp(adapter, rx_ring, xdp);
 
 		if (IS_ERR(skb)) {
-- 
2.34.1

