From aad15e590cf7bc267c463109aa747dcb53c612d7 Mon Sep 17 00:00:00 2001
From: Ong Boon Leong <boon.leong.ong@intel.com>
Date: Sat, 14 Jul 2018 07:47:40 +0800
Subject: [PATCH 42/58] REVERTME: net: stmmac: add IEEE802.1 Qbu FPE-related
 ethtool_ops implementations

This patch is kept here for IP validation purpose. It will be dropped
once Linux mainline traffic-control TSN framework has matured.

This patch binds FPE implementation into stmmac ethtool interfaces, i.e.,
{get, set}_fpe_info.

It also adds the support for handling FPE-related GCL entry setting:
ETH_GATEOP_SET_N_HOLD_MAC & ETH_GATEOP_SET_N_RELS_MAC.

It also extends the hardware tunable to cover FPE-related tunable params,
e.g. AFSZ, HADV and RADV.

Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
---
 .../net/ethernet/stmicro/stmmac/stmmac_ethtool.c   | 167 ++++++++++++++++++++-
 1 file changed, 166 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
index 67f8653..1e6d649 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
@@ -1169,6 +1169,18 @@ static int stmmac_get_tunable(struct net_device *dev,
 		ret = stmmac_get_tsn_hwtunable(priv, TSN_HWTUNA_TX_EST_CTOV,
 					       data);
 		break;
+	case ETHTOOL_TX_FPE_AFSZ:
+		ret = stmmac_get_tsn_hwtunable(priv, TSN_HWTUNA_TX_FPE_AFSZ,
+					       data);
+		break;
+	case ETHTOOL_TX_FPE_HADV:
+		ret = stmmac_get_tsn_hwtunable(priv, TSN_HWTUNA_TX_FPE_HADV,
+					       data);
+		break;
+	case ETHTOOL_TX_FPE_RADV:
+		ret = stmmac_get_tsn_hwtunable(priv, TSN_HWTUNA_TX_FPE_RADV,
+					       data);
+		break;
 	default:
 		ret = -EINVAL;
 		break;
@@ -1203,6 +1215,21 @@ static int stmmac_set_tunable(struct net_device *dev,
 					       TSN_HWTUNA_TX_EST_CTOV,
 					       data);
 		break;
+	case ETHTOOL_TX_FPE_AFSZ:
+		ret = stmmac_set_tsn_hwtunable(priv, priv->ioaddr,
+					       TSN_HWTUNA_TX_FPE_AFSZ,
+					       data);
+		break;
+	case ETHTOOL_TX_FPE_HADV:
+		ret = stmmac_set_tsn_hwtunable(priv, priv->ioaddr,
+					       TSN_HWTUNA_TX_FPE_HADV,
+					       data);
+		break;
+	case ETHTOOL_TX_FPE_RADV:
+		ret = stmmac_set_tsn_hwtunable(priv, priv->ioaddr,
+					       TSN_HWTUNA_TX_FPE_RADV,
+					       data);
+		break;
 	default:
 		ret = -EINVAL;
 		break;
@@ -1248,6 +1275,7 @@ static int stmmac_ethtool_get_est_gcl(struct net_device *dev,
 				      void *gclbuf)
 {
 	struct est_gc_config *gcc;
+	struct fpe_config *fpecfg;
 	struct ethtool_gc_entry *egce;
 	struct est_gc_entry *sgce;
 	int i, bank, ret;
@@ -1272,6 +1300,13 @@ static int stmmac_ethtool_get_est_gcl(struct net_device *dev,
 		return -EINVAL;
 	}
 
+	ret = stmmac_get_fpe_config(priv, priv->ioaddr, &fpecfg, 0);
+	if (ret) {
+		dev_err(priv->device, "fail to get FPE config.\n");
+
+		return ret;
+	}
+
 	egce = (struct ethtool_gc_entry *)gclbuf;
 	sgce = gcc->gcb[bank].gcl;
 	for (i = 0; i < gcl->len; i++) {
@@ -1279,6 +1314,13 @@ static int stmmac_ethtool_get_est_gcl(struct net_device *dev,
 		egce->ti_ns = sgce->ti_nsec;
 		egce->opid = ETH_GATEOP_SET_GATE_STATES;
 
+		if (!fpecfg->enable)
+			egce->opid = ETH_GATEOP_SET_GATE_STATES;
+		else if (sgce->gates & FPE_PMAC_BIT)
+			egce->opid = ETH_GATEOP_SET_N_HOLD_MAC;
+		else
+			egce->opid = ETH_GATEOP_SET_N_RELS_MAC;
+
 		egce++;
 		sgce++;
 	}
@@ -1291,8 +1333,10 @@ static int stmmac_ethtool_set_est_gcl(struct net_device *dev,
 				      void *gclbuf)
 {
 	struct ethtool_gc_entry *egce;
+	struct fpe_config *fpecfg;
 	int i, bank;
 	struct stmmac_priv *priv = netdev_priv(dev);
+	u32 fpe_in_gcl = 0;
 	int ret = -1;
 
 	if (gcl->cmd != ETHTOOL_SGCL ||
@@ -1301,12 +1345,46 @@ static int stmmac_ethtool_set_est_gcl(struct net_device *dev,
 
 	bank = stmmac_get_est_bank(priv, priv->ioaddr, gcl->own);
 
+	/* Parse GCL for Hold/Release MAC cmd */
+	egce = (struct ethtool_gc_entry *)gclbuf;
+	for (i = 0; i < gcl->len; i++) {
+		if (egce->opid != ETH_GATEOP_SET_GATE_STATES) {
+			fpe_in_gcl = 1;
+		break;
+		}
+		egce++;
+	}
+	ret = stmmac_get_fpe_config(priv, priv->ioaddr, &fpecfg, 0);
+	if (ret) {
+		dev_err(priv->device, "fail to get FPE config.\n");
+
+		return ret;
+	}
+
+	/* Ensure that FPE is enabled for GC entry contains
+	 * ETH_GATEOP_SET_N_{HOLD,RELS}_MAC opid.
+	 */
+	if (!fpecfg->enable && fpe_in_gcl) {
+		dev_err(priv->device,
+			"FPE is not enabled for hold/release GCE cmd\n");
+
+		return -EINVAL;
+	}
+
+	/* Finally, handle the translation for FPE-related cmd:
+	 * ETH_GATEOP_SET_N_{HOLD,RELS}_MAC by setting/clearing
+	 * least significant bit of GC entry.
+	 */
 	egce = (struct ethtool_gc_entry *)gclbuf;
 	for (i = 0; i < gcl->len; i++) {
 		struct est_gc_entry sgce;
 
 		sgce.gates = egce->gates;
 		sgce.ti_nsec = egce->ti_ns;
+		if (egce->opid == ETH_GATEOP_SET_N_HOLD_MAC)
+			sgce.gates |= FPE_PMAC_BIT;
+		else if (egce->opid == ETH_GATEOP_SET_N_RELS_MAC)
+			sgce.gates &= ~FPE_PMAC_BIT;
 
 		ret = stmmac_set_est_gce(priv, priv->ioaddr, &sgce,
 					 i, bank, 1);
@@ -1327,6 +1405,7 @@ static int stmmac_ethtool_get_est_gce(struct net_device *dev,
 				      struct ethtool_gce *gce)
 {
 	struct est_gc_config *gcc;
+	struct fpe_config *fpecfg;
 	struct est_gc_entry *sgce;
 	int bank, ret;
 	struct stmmac_priv *priv = netdev_priv(dev);
@@ -1349,10 +1428,22 @@ static int stmmac_ethtool_get_est_gce(struct net_device *dev,
 		return -EINVAL;
 	}
 
+	ret = stmmac_get_fpe_config(priv, priv->ioaddr, &fpecfg, 0);
+	if (ret) {
+		dev_err(priv->device, "fail to get FPE config.\n");
+
+		return ret;
+	}
+
 	sgce = gcc->gcb[bank].gcl + gce->row;
 	gce->gce.gates = sgce->gates;
 	gce->gce.ti_ns = sgce->ti_nsec;
-	gce->gce.opid = ETH_GATEOP_SET_GATE_STATES;
+	if (!fpecfg->enable)
+		gce->gce.opid = ETH_GATEOP_SET_GATE_STATES;
+	else if (sgce->gates & FPE_PMAC_BIT)
+		gce->gce.opid = ETH_GATEOP_SET_N_HOLD_MAC;
+	else
+		gce->gce.opid = ETH_GATEOP_SET_N_RELS_MAC;
 
 	return 0;
 }
@@ -1361,6 +1452,7 @@ static int stmmac_ethtool_set_est_gce(struct net_device *dev,
 				      struct ethtool_gce *gce)
 {
 	struct est_gc_entry sgce;
+	struct fpe_config *fpecfg;
 	int bank, gcl_length, ret;
 	struct stmmac_priv *priv = netdev_priv(dev);
 
@@ -1392,8 +1484,33 @@ static int stmmac_ethtool_set_est_gce(struct net_device *dev,
 		return -EINVAL;
 	}
 
+	ret = stmmac_get_fpe_config(priv, priv->ioaddr, &fpecfg, 0);
+	if (ret) {
+		dev_err(priv->device, "fail to get FPE config.\n");
+
+		return ret;
+	}
+
+	/* Ensure that FPE is enabled for GC entry contains
+	 * ETH_GATEOP_SET_N_{HOLD,RELS}_MAC opid.
+	 */
+	if (!fpecfg->enable && gce->gce.opid != ETH_GATEOP_SET_GATE_STATES) {
+		dev_err(priv->device,
+			"FPE is not enabled for hold/release GCE cmd\n");
+
+		return -EINVAL;
+	}
+
+	/* Finally, handle the translation for FPE-related cmd:
+	 * ETH_GATEOP_SET_N_{HOLD,RELS}_MAC by setting/clearing
+	 * least significant bit of GC entry.
+	 */
 	sgce.gates = gce->gce.gates;
 	sgce.ti_nsec = gce->gce.ti_ns;
+	if (gce->gce.opid == ETH_GATEOP_SET_N_HOLD_MAC)
+		sgce.gates |= FPE_PMAC_BIT;
+	else if (gce->gce.opid == ETH_GATEOP_SET_N_RELS_MAC)
+		sgce.gates &= ~FPE_PMAC_BIT;
 
 	ret = stmmac_set_est_gce(priv, priv->ioaddr, &sgce, gce->row,
 				 bank, 1);
@@ -1480,6 +1597,52 @@ static int stmmac_ethtool_set_est_info(struct net_device *dev,
 	return stmmac_set_est_gcrr_times(priv, priv->ioaddr, &egcrr, bank, 1);
 }
 
+static int stmmac_ethtool_get_fpe_info(struct net_device *dev,
+				       struct ethtool_fpe_info *fpei)
+{
+	struct fpe_config *fpecfg;
+	u32 hrs;
+	struct stmmac_priv *priv = netdev_priv(dev);
+	int ret;
+
+	if (fpei->cmd != ETHTOOL_GFPEINFO)
+		return -EINVAL;
+
+	ret = stmmac_get_fpe_config(priv, priv->ioaddr, &fpecfg, 0);
+	if (ret) {
+		dev_err(priv->device, "fail to get FPE config.\n");
+
+		return ret;
+	}
+
+	ret = stmmac_get_fpe_pmac_sts(priv, priv->ioaddr, &hrs);
+	if (ret) {
+		dev_err(priv->device, "fail to get pMAC status.\n");
+
+		return ret;
+	}
+
+	fpei->sts_map = fpecfg->txqpec;
+	fpei->hold_req = hrs;
+	fpei->lp_fpe = fpecfg->lp_fpe_support;
+
+	return 0;
+}
+
+static int stmmac_ethtool_set_fpe_info(struct net_device *dev,
+				       struct ethtool_fpe_info *fpei)
+{
+	struct fpe_config fpecfg;
+	struct stmmac_priv *priv = netdev_priv(dev);
+
+	if (fpei->cmd != ETHTOOL_SFPEINFO)
+		return -EINVAL;
+
+	fpecfg.txqpec = fpei->sts_map;
+
+	return stmmac_set_fpe_config(priv, priv->ioaddr, &fpecfg);
+}
+
 static const struct ethtool_ops stmmac_ethtool_ops = {
 	.begin = stmmac_check_if_running,
 	.get_drvinfo = stmmac_ethtool_getdrvinfo,
@@ -1514,6 +1677,8 @@ static const struct ethtool_ops stmmac_ethtool_ops = {
 	.set_est_gce = stmmac_ethtool_set_est_gce,
 	.get_est_info = stmmac_ethtool_get_est_info,
 	.set_est_info = stmmac_ethtool_set_est_info,
+	.get_fpe_info = stmmac_ethtool_get_fpe_info,
+	.set_fpe_info = stmmac_ethtool_set_fpe_info,
 };
 
 void stmmac_set_ethtool_ops(struct net_device *netdev)
-- 
2.7.4

