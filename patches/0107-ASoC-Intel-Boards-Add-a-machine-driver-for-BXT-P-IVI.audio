From 5ffa95c148375a0c2ccae8d215755b1e2716b201 Mon Sep 17 00:00:00 2001
From: Pardha Saradhi K <pardha.saradhi.kesapragada@intel.com>
Date: Wed, 3 Jan 2018 19:52:29 +0530
Subject: [PATCH 107/163] ASoC: Intel: Boards: Add a machine driver for BXT-P
 IVI M3

This patch adds support for a machine driver for Validation
purposes only for M3 topology in IVI, that supports -
1. 2 bluetooth streams for playback and capture
2. 2 streams out of a Master SSP with 8 channels (PB & CP)
3. 2 more streams out of a Slave SSP with 8 channels (PB & CP)
   whose clock and frame are tied to above Master SSP for synchronous
   playback of 16 channel data.

Dummy Codec driver is used for reference.
Related Changes for Makefile and Kconfig have been added.

Change-Id: Ibd8562678890accd21adfd89f521502fc7e88bf9
Signed-off-by: Pardha Saradhi K <pardha.saradhi.kesapragada@intel.com>
Reviewed-on:
Reviewed-by: Singh, Guneshwor O <guneshwor.o.singh@intel.com>
Reviewed-by: Prabhu, PuneethX <puneethx.prabhu@intel.com>
Reviewed-by: Kale, Sanyog R <sanyog.r.kale@intel.com>
Tested-by: Madiwalar, MadiwalappaX <madiwalappax.madiwalar@intel.com>
Signed-off-by: Cezary Rojewski <cezary.rojewski@intel.com>
---
 sound/soc/intel/boards/Kconfig       |  12 ++
 sound/soc/intel/boards/Makefile      |   2 +
 sound/soc/intel/boards/bxtp_ivi_m3.c | 286 +++++++++++++++++++++++++++
 3 files changed, 300 insertions(+)
 create mode 100644 sound/soc/intel/boards/bxtp_ivi_m3.c

diff --git a/sound/soc/intel/boards/Kconfig b/sound/soc/intel/boards/Kconfig
index a73529fb96ba..701aaeed7b66 100644
--- a/sound/soc/intel/boards/Kconfig
+++ b/sound/soc/intel/boards/Kconfig
@@ -286,6 +286,9 @@ config SND_SOC_INTEL_BXTP_IVI_RSE_MACH
 config SND_SOC_INTEL_BXTP_IVI_HU_MACH
 	tristate
 
+config SND_SOC_INTEL_BXTP_IVI_M3_MACH
+	tristate
+
 choice SND_SOC_INTEL_BXT_RT298_I2S
 	tristate "Broxton with RT298 in I2S mode drivers"
 	depends on I2C && ACPI
@@ -319,6 +322,15 @@ config SND_SOC_INTEL_BXTP_IVI_DUMMY_HU
 	  Say Y or m if you have such a device. This is a recommended option.
 	  If unsure select "N".
 
+config SND_SOC_INTEL_BXTP_IVI_DUMMY_M3
+	prompt "BXTP with Dummy codec for M3"
+	select SND_SOC_INTEL_BXTP_IVI_M3_MACH
+	help
+	  This adds support for ASoC machine driver for Broxton-P platforms
+	  with Dummy I2S audio codec for IVI M3 topology.
+	  Say Y or m if you have such a device. This is a recommended option.
+	  If unsure select "N".
+
 endchoice ## SND_SOC_INTEL_BXT_RT298_I2S
 
 config SND_SOC_INTEL_BXT_TDF8532_MACH
diff --git a/sound/soc/intel/boards/Makefile b/sound/soc/intel/boards/Makefile
index a37c36406b5a..86fb5e8dee52 100644
--- a/sound/soc/intel/boards/Makefile
+++ b/sound/soc/intel/boards/Makefile
@@ -8,6 +8,7 @@ snd-soc-sst-bxt-da7219_max98357a-objs := bxt_da7219_max98357a.o
 snd-soc-sst-bxt-rt298-objs := bxt_rt298.o
 snd-soc-bxtp_ivi_rse_rt298-objs := bxtp_ivi_rse_rt298.o
 snd-soc-bxtp_ivi_hu_rt298-objs := bxtp_ivi_hu_rt298.o
+snd-soc-bxtp_ivi_m3-objs := bxtp_ivi_m3.o
 snd-soc-sst_bxt_tdf8532-objs := bxt_tdf8532.o
 snd-soc-bxt_ivi_ull-objs := bxt_ivi_ull.o
 snd-soc-sst-glk-rt5682_max98357a-objs := glk_rt5682_max98357a.o
@@ -42,6 +43,7 @@ obj-$(CONFIG_SND_SOC_INTEL_BXT_DA7219_MAX98357A_MACH) += snd-soc-sst-bxt-da7219_
 obj-$(CONFIG_SND_SOC_INTEL_BXT_RT298_MACH) += snd-soc-sst-bxt-rt298.o
 obj-$(CONFIG_SND_SOC_INTEL_BXTP_IVI_RSE_MACH) += snd-soc-bxtp_ivi_rse_rt298.o
 obj-$(CONFIG_SND_SOC_INTEL_BXTP_IVI_HU_MACH) += snd-soc-bxtp_ivi_hu_rt298.o
+obj-$(CONFIG_SND_SOC_INTEL_BXTP_IVI_M3_MACH) += snd-soc-bxtp_ivi_m3.o
 obj-$(CONFIG_SND_SOC_INTEL_BXT_TDF8532_MACH) += snd-soc-sst_bxt_tdf8532.o
 obj-$(CONFIG_SND_SOC_INTEL_BXT_ULL_MACH) += snd-soc-bxt_ivi_ull.o
 obj-$(CONFIG_SND_SOC_INTEL_GLK_RT5682_MAX98357A_MACH) += snd-soc-sst-glk-rt5682_max98357a.o
diff --git a/sound/soc/intel/boards/bxtp_ivi_m3.c b/sound/soc/intel/boards/bxtp_ivi_m3.c
new file mode 100644
index 000000000000..b11c4284600c
--- /dev/null
+++ b/sound/soc/intel/boards/bxtp_ivi_m3.c
@@ -0,0 +1,286 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// bxtp_ivi_m3.c  --  Intel BXTP-IVI M3 I2S Machine Driver
+//
+// Copyright(c) 2018 Intel Corporation
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+
+#define SSP0_GPIO_BASE 0xd0c40610
+#define SSP0_GPIO_VALUE1 0x40900500
+#define SSP0_GPIO_VALUE2 0x44000600
+#define SSP1_GPIO_BASE 0xd0c40660
+#define SSP1_GPIO_VALUE1 0x44000400
+#define SSP4_GPIO_BASE 0xd0c705A0
+#define SSP4_GPIO_VALUE1 0x44000A00
+#define SSP4_GPIO_VALUE2 0x44000800
+#define SSP5_GPIO_BASE 0xd0c70580
+#define SSP5_GPIO_VALUE 0x44000800
+
+#define DEF_BT_RATE_INBDEX 0x0
+
+struct bxtp_ivi_gen_prv {
+	int srate;
+};
+
+static unsigned int ivi_gen_bt_rates[] = {
+	8000,
+	16000,
+};
+
+/* sound card controls */
+static const char * const bt_rate[] = {"8K", "16K"};
+
+static const struct soc_enum btrate_enum =
+	SOC_ENUM_SINGLE_EXT(2, bt_rate);
+
+static int bt_sample_rate_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct bxtp_ivi_gen_prv *drv = snd_soc_card_get_drvdata(card);
+
+	ucontrol->value.integer.value[0] = drv->srate;
+	return 0;
+}
+
+static int bt_sample_rate_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct bxtp_ivi_gen_prv *drv = snd_soc_card_get_drvdata(card);
+
+	if (ucontrol->value.integer.value[0] == drv->srate)
+		return 0;
+
+	drv->srate = ucontrol->value.integer.value[0];
+	return 0;
+
+}
+static const struct snd_kcontrol_new gen_snd_controls[] = {
+
+	SOC_ENUM_EXT("BT Rate", btrate_enum,
+			bt_sample_rate_get, bt_sample_rate_put),
+};
+
+static const struct snd_soc_dapm_widget broxton_widgets[] = {
+	SND_SOC_DAPM_SPK("Speaker", NULL),
+	SND_SOC_DAPM_MIC("DMIC2", NULL),
+};
+
+static const struct snd_soc_dapm_route broxton_rt298_map[] = {
+	{"Speaker", NULL, "Dummy Playback"},
+	{"Dummy Capture", NULL, "DMIC2"},
+	/* BE connections */
+	{ "Dummy Playback", NULL, "ssp4 Tx"},
+	{ "ssp4 Tx", NULL, "codec0_out"},
+	{ "codec0_in", NULL, "ssp4 Rx" },
+	{ "ssp4 Rx", NULL, "Dummy Capture"},
+
+	{ "Dummy Playback", NULL, "ssp2 Tx"},
+	{ "ssp2 Tx", NULL, "codec1_out"},
+	{ "codec1_in", NULL, "ssp2 Rx"},
+	{ "ssp2 Rx", NULL, "Dummy Capture"},
+
+	{ "hdmi_ssp0_in", NULL, "ssp0 Rx"},
+	{ "ssp0 Rx", NULL, "Dummy Capture"},
+	{ "Dummy Playback", NULL, "ssp0 Tx"},
+	{ "ssp0 Tx", NULL, "codec4_out"},
+};
+
+static int bxtp_ssp0_gpio_init(struct snd_soc_pcm_runtime *rtd)
+{
+	char *gpio_addr;
+	u32 gpio_value1 = SSP0_GPIO_VALUE1;
+	u32 gpio_value2 = SSP0_GPIO_VALUE2;
+
+	gpio_addr = (void *)ioremap_nocache(SSP0_GPIO_BASE, 0x30);
+	if (gpio_addr == NULL)
+		return(-EIO);
+
+	memcpy_toio(gpio_addr + 0x8, &gpio_value1, sizeof(gpio_value1));
+	memcpy_toio(gpio_addr + 0x10, &gpio_value2, sizeof(gpio_value2));
+	memcpy_toio(gpio_addr + 0x18, &gpio_value2, sizeof(gpio_value2));
+	memcpy_toio(gpio_addr + 0x20, &gpio_value2, sizeof(gpio_value2));
+
+	iounmap(gpio_addr);
+	return 0;
+}
+
+static int bxtp_ssp4_gpio_init(struct snd_soc_pcm_runtime *rtd)
+{
+
+	char *gpio_addr;
+	u32 gpio_value1 = SSP4_GPIO_VALUE1;
+	u32 gpio_value2 = SSP4_GPIO_VALUE2;
+
+	gpio_addr = (void *)ioremap_nocache(SSP4_GPIO_BASE, 0x30);
+	if (gpio_addr == NULL)
+		return(-EIO);
+
+	memcpy_toio(gpio_addr, &gpio_value1, sizeof(gpio_value1));
+	memcpy_toio(gpio_addr + 0x8, &gpio_value1, sizeof(gpio_value1));
+	memcpy_toio(gpio_addr + 0x10, &gpio_value1, sizeof(gpio_value1));
+	memcpy_toio(gpio_addr + 0x18, &gpio_value2, sizeof(gpio_value2));
+
+	iounmap(gpio_addr);
+	return 0;
+
+}
+
+static int broxton_ssp2_fixup(struct snd_soc_pcm_runtime *rtd,
+			struct snd_pcm_hw_params *params)
+{
+	struct snd_interval *rate = hw_param_interval(params,
+				SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval *channels = hw_param_interval(params,
+				SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_soc_card *card =  rtd->card;
+	struct bxtp_ivi_gen_prv *drv = snd_soc_card_get_drvdata(card);
+
+
+	/* The ADSP will covert the FE rate to 8k,16k mono */
+	rate->min = rate->max = ivi_gen_bt_rates[drv->srate];
+	channels->min = channels->max = 2;
+	return 0;
+
+}
+
+SND_SOC_DAILINK_DEF(dummy,
+	DAILINK_COMP_ARRAY(COMP_DUMMY()));
+
+SND_SOC_DAILINK_DEF(ssp0_pin,
+	DAILINK_COMP_ARRAY(COMP_CPU("SSP0 Pin")));
+SND_SOC_DAILINK_DEF(ssp2_pin,
+	DAILINK_COMP_ARRAY(COMP_CPU("SSP2 Pin")));
+SND_SOC_DAILINK_DEF(ssp4_pin,
+	DAILINK_COMP_ARRAY(COMP_CPU("SSP4 Pin")));
+
+SND_SOC_DAILINK_DEF(platform,
+	DAILINK_COMP_ARRAY(COMP_PLATFORM("0000:00:0e.0")));
+
+/* broxton digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link broxton_rt298_dais[] = {
+	/* Back End DAI links */
+	{
+		/* SSP0 - Codec */
+		.name = "SSP0-Codec",
+		.id = 0,
+		.no_pcm = 1,
+		.init = bxtp_ssp0_gpio_init,
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		.ignore_suspend = 1,
+		.ignore_pmdown_time = 1,
+		.dpcm_capture = 1,
+		.dpcm_playback = 1,
+		SND_SOC_DAILINK_REG(ssp0_pin, dummy, platform),
+	},
+	{
+		/* SSP2 - Codec */
+		.name = "SSP2-Codec",
+		.id = 2,
+		.no_pcm = 1,
+		.init = NULL,
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		.ignore_suspend = 1,
+		.ignore_pmdown_time = 1,
+		.be_hw_params_fixup = broxton_ssp2_fixup,
+		.dpcm_playback = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(ssp2_pin, dummy, platform),
+	},
+	{
+		/* SSP4 - Codec */
+		.name = "SSP4-Codec",
+		.id = 4,
+		.no_pcm = 1,
+		.init =  bxtp_ssp4_gpio_init,
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		.ignore_suspend = 1,
+		.ignore_pmdown_time = 1,
+		.dpcm_playback = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(ssp4_pin, dummy, platform),
+	},
+};
+
+static int
+bxt_add_dai_link(struct snd_soc_card *card, struct snd_soc_dai_link *link)
+{
+	link->platforms->name = "0000:00:0e.0";
+	link->nonatomic = 1;
+
+	return 0;
+}
+
+/* broxton audio machine driver for SPT + RT298S */
+static struct snd_soc_card broxton_rt298 = {
+	.name = "broxton-ivi-m3",
+	.dai_link = broxton_rt298_dais,
+	.num_links = ARRAY_SIZE(broxton_rt298_dais),
+	.controls = gen_snd_controls,
+	.num_controls = ARRAY_SIZE(gen_snd_controls),
+	.dapm_widgets = broxton_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(broxton_widgets),
+	.dapm_routes = broxton_rt298_map,
+	.num_dapm_routes = ARRAY_SIZE(broxton_rt298_map),
+	.fully_routed = true,
+	.add_dai_link = bxt_add_dai_link,
+};
+
+static int broxton_audio_probe(struct platform_device *pdev)
+{
+	int ret_val;
+	struct bxtp_ivi_gen_prv *drv;
+
+	broxton_rt298.dev = &pdev->dev;
+
+	drv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_KERNEL);
+	if (!drv)
+		return -ENOMEM;
+
+	drv->srate = DEF_BT_RATE_INBDEX;
+	snd_soc_card_set_drvdata(&broxton_rt298, drv);
+	ret_val = snd_soc_register_card(&broxton_rt298);
+
+	if (ret_val) {
+		dev_dbg(&pdev->dev, "snd_soc_register_card failed %d\n",
+								 ret_val);
+		return ret_val;
+	}
+
+	platform_set_drvdata(pdev, &broxton_rt298);
+
+	return ret_val;
+}
+
+static int broxton_audio_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_card(&broxton_rt298);
+	return 0;
+}
+
+static struct platform_driver broxton_audio = {
+	.probe = broxton_audio_probe,
+	.remove = broxton_audio_remove,
+	.driver = {
+		.name = "bxt_alc298s_i2s",
+	},
+};
+
+module_platform_driver(broxton_audio);
+
+/* Module information */
+MODULE_AUTHOR("Pardha Saradhi K <pardha.saradhi.kesapragada@intel.com>");
+MODULE_AUTHOR("Mousumi Jana <mousumix.jana@intel.com>");
+MODULE_DESCRIPTION("Intel SST Audio for Broxton");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:bxt_alc298s_i2s");
-- 
2.17.1

