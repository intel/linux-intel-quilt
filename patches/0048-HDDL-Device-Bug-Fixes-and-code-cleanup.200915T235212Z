From 42dba42159880c53788259e1278ad6672f72f2d2 Mon Sep 17 00:00:00 2001
From: "C, Udhayakumar" <udhayakumar.c@intel.com>
Date: Wed, 26 Aug 2020 19:14:52 +0530
Subject: [PATCH 48/48] HDDL Device Bug Fixes and code cleanup.

Enabled static loading for hddl device module from arm host.
Onchip temperature sensors configurations are moved to DTS.
External sensors and its configurations are passed to remote host
via xlink message.
i2c_del_adapter stuck indefinitely, while unloading xlink-smbus,
this was due to the module reference count was not 0, so delete
adapter was blocked on wait event. This is resolved after invoking
i2c_put_adapter in hddl device module.
Introduced generic framework for registering onchip temperature
sensors to support scalability across platforms.

Signed-off-by: C, Udhayakumar <udhayakumar.c@intel.com>
---
 .../bindings/misc/intel,hddl-client.txt       |  29 +
 .../bindings/misc/intel,intel-tsens.txt       |  51 ++
 drivers/misc/Kconfig                          |   4 +-
 drivers/misc/Makefile                         |   6 +-
 drivers/misc/hddl_device/Kconfig              |   5 +-
 drivers/misc/hddl_device/Makefile             |   4 +-
 drivers/misc/hddl_device/hddl_device.c        | 712 -----------------
 drivers/misc/hddl_device/hddl_device_client.c | 620 +++++++++++++++
 drivers/misc/hddl_device/hddl_device_helper.h | 498 ++++++++++++
 drivers/misc/hddl_device/hddl_device_server.c | 698 +++++++++++++++++
 drivers/misc/host_kmb_tj/Kconfig              |   9 -
 drivers/misc/host_kmb_tj/Makefile             |   5 -
 drivers/misc/host_kmb_tj/keembay_tsens_host.h |  60 --
 drivers/misc/intel_tsens/Kconfig              |  31 +
 drivers/misc/intel_tsens/Makefile             |   8 +
 drivers/misc/intel_tsens/intel_tsens_host.c   | 280 +++++++
 drivers/misc/intel_tsens/intel_tsens_host.h   |  29 +
 .../misc/intel_tsens/intel_tsens_thermal.c    | 729 ++++++++++++++++++
 .../misc/intel_tsens/intel_tsens_thermal.h    |  47 ++
 drivers/misc/intel_tsens/keembay_cooling.c    | 109 +++
 .../keembay_cooling_host.c                    |  23 +-
 drivers/misc/intel_tsens/keembay_thermal.c    | 173 +++++
 drivers/misc/intel_tsens/keembay_tsens.h      | 354 +++++++++
 drivers/misc/slave_kmb_tj/Kconfig             |   6 -
 drivers/misc/slave_kmb_tj/Makefile            |  21 -
 drivers/misc/xlink-smbus/xlink-smbus.c        |  83 +-
 include/linux/hddl_device.h                   | 151 +++-
 include/linux/intel_tsens_host.h              |  33 +
 28 files changed, 3872 insertions(+), 906 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/misc/intel,hddl-client.txt
 create mode 100644 Documentation/devicetree/bindings/misc/intel,intel-tsens.txt
 delete mode 100644 drivers/misc/hddl_device/hddl_device.c
 create mode 100644 drivers/misc/hddl_device/hddl_device_client.c
 create mode 100644 drivers/misc/hddl_device/hddl_device_helper.h
 create mode 100644 drivers/misc/hddl_device/hddl_device_server.c
 delete mode 100644 drivers/misc/host_kmb_tj/Kconfig
 delete mode 100644 drivers/misc/host_kmb_tj/Makefile
 delete mode 100644 drivers/misc/host_kmb_tj/keembay_tsens_host.h
 create mode 100644 drivers/misc/intel_tsens/Kconfig
 create mode 100644 drivers/misc/intel_tsens/Makefile
 create mode 100644 drivers/misc/intel_tsens/intel_tsens_host.c
 create mode 100644 drivers/misc/intel_tsens/intel_tsens_host.h
 create mode 100644 drivers/misc/intel_tsens/intel_tsens_thermal.c
 create mode 100644 drivers/misc/intel_tsens/intel_tsens_thermal.h
 create mode 100644 drivers/misc/intel_tsens/keembay_cooling.c
 rename drivers/misc/{host_kmb_tj => intel_tsens}/keembay_cooling_host.c (82%)
 create mode 100644 drivers/misc/intel_tsens/keembay_thermal.c
 create mode 100644 drivers/misc/intel_tsens/keembay_tsens.h
 delete mode 100644 drivers/misc/slave_kmb_tj/Kconfig
 delete mode 100644 drivers/misc/slave_kmb_tj/Makefile
 create mode 100644 include/linux/intel_tsens_host.h

diff --git a/Documentation/devicetree/bindings/misc/intel,hddl-client.txt b/Documentation/devicetree/bindings/misc/intel,hddl-client.txt
new file mode 100644
index 000000000000..978b300a9847
--- /dev/null
+++ b/Documentation/devicetree/bindings/misc/intel,hddl-client.txt
@@ -0,0 +1,29 @@
+Intel HDDL client
+---------------------
+
+The hddl client driver enables reading of onchip sensors present
+in the Intel Bay SoC.
+
+Required properties:
+- compatible : "intel,hddl-client"
+
+- reg: list of register areas, as specified in reg-names
+- interrupts: not used
+- clocks: clock needed for thermal to operate
+
+Example:
+	hddl_dev: hddl_device {
+		compatible = "intel,hddl-client";
+		status = "disabled";
+		reg = <0x0 0x20320000 0x0 0x800>;
+		xlink_chan = <1080>;
+		i2c_xlink_chan = <1081>;
+		kmb_xlink_tj@5a {
+			status = "okay";
+			compatible = "intel_tsens";
+			reg = <0x4000005a>;
+			local-host = <0x3>;
+			remote-host = <0x3>;
+			bus = <0x1>;
+		};
+	};
diff --git a/Documentation/devicetree/bindings/misc/intel,intel-tsens.txt b/Documentation/devicetree/bindings/misc/intel,intel-tsens.txt
new file mode 100644
index 000000000000..861e514fa527
--- /dev/null
+++ b/Documentation/devicetree/bindings/misc/intel,intel-tsens.txt
@@ -0,0 +1,51 @@
+Intel Temperature sensors in Bay series
+---------------------
+
+The tsens driver enables reading of onchip sensors present
+in the Intel Bay SoC.
+
+Required properties:
+- compatible : "intel,intel-tsens"
+
+- reg: list of register areas, as specified in reg-names
+- interrupts: not used
+- clocks: clock needed for thermal to operate
+
+Example:
+		tsens: tsens@20260000 {
+			compatible = "intel,intel-tsens";
+			status = "disabled";
+			plat_name = "intel,keembay_thermal";
+			reg = <0x0 0x20260000 0x0 0x100>;
+			interrupts = <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk MOVISOC_KMB_A53_AUX_TSENS>;
+			clk-rate = <1250000>;
+
+			mss {
+				passive_delay = <1000>;
+				polling_delay = <2000>;
+				trip_temp = <40000 80000 1000000>;
+				trip_type = "passive", "passive", "critical";
+			};
+
+			css {
+				passive_delay = <1000>;
+				polling_delay = <2000>;
+				trip_temp = <40000 80000 1000000>;
+				trip_type = "passive", "passive", "critical";
+			};
+
+			nce {
+				passive_delay = <1000>;
+				polling_delay = <2000>;
+				trip_temp = <40000 80000 1000000>;
+				trip_type = "passive", "passive", "critical";
+			};
+
+			soc {
+				passive_delay = <1000>;
+				polling_delay = <2000>;
+				trip_temp = <40000 80000 1000000>;
+				trip_type = "passive", "passive", "critical";
+			};
+		};
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 0f22462db33d..1571874ecd08 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -486,9 +486,7 @@ source "drivers/misc/xlink-pcie/Kconfig"
 source "drivers/misc/xlink-usb/Kconfig"
 source "drivers/misc/vpusmm/Kconfig"
 source "drivers/misc/hddl_device/Kconfig"
-source "drivers/misc/keembay-thermal/Kconfig"
-source "drivers/misc/slave_kmb_tj/Kconfig"
-source "drivers/misc/host_kmb_tj/Kconfig"
+source "drivers/misc/intel_tsens/Kconfig"
 source "drivers/misc/xlink-smbus/Kconfig"
 source "drivers/misc/emc2103/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index f794bafb71de..c6e1114fdf74 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -61,9 +61,7 @@ obj-$(CONFIG_INTEL_GNA)		+= gna/
 obj-y				+= xlink-usb/
 obj-y				+= xlink-pcie/
 obj-$(CONFIG_VPUSMM)		+= vpusmm/
-obj-$(CONFIG_HDDL_DEVICE)	+= hddl_device/
-obj-y				+= keembay-thermal/
-obj-$(CONFIG_SLAVE_KMB_TJ)	+= slave_kmb_tj/
-obj-$(CONFIG_HOST_KMB_TJ)	+= host_kmb_tj/
+obj-y				+= hddl_device/
+obj-y				+= intel_tsens/
 obj-$(CONFIG_XLINK_SMBUS)	+= xlink-smbus/
 obj-$(CONFIG_XLINK_SMBUS)	+= emc2103/
diff --git a/drivers/misc/hddl_device/Kconfig b/drivers/misc/hddl_device/Kconfig
index 0b0ca337125d..353bd8a623ac 100644
--- a/drivers/misc/hddl_device/Kconfig
+++ b/drivers/misc/hddl_device/Kconfig
@@ -1,15 +1,14 @@
 # Copyright (C) 2019 Intel Corporation
 # SPDX-License-Identifier: GPL-2.0-only
 
-config HDDL_DEVICE
+config HDDL_DEVICE_SERVER
 	tristate "Support for hddl device"
 	default m
 	depends on XLINK_CORE
 	help
 	  hddl device management
 
-
-config HDDL_LOCAL_HOST
+config HDDL_DEVICE_CLIENT
 	tristate "Support for hddl device local host"
 	depends on XLINK_CORE
 	default y
diff --git a/drivers/misc/hddl_device/Makefile b/drivers/misc/hddl_device/Makefile
index b6fae62b8450..a025781428ec 100644
--- a/drivers/misc/hddl_device/Makefile
+++ b/drivers/misc/hddl_device/Makefile
@@ -2,5 +2,5 @@
 # SPDX-License-Identifier: GPL-2.0-only
 #     Makefile for KeemBay VPUSMM
 #
-#obj-$(CONFIG_HDDL_DEVICE) += hddl_device.o
-obj-m += hddl_device.o
+obj-$(CONFIG_HDDL_DEVICE_CLIENT) += hddl_device_client.o
+obj-$(CONFIG_HDDL_DEVICE_SERVER) += hddl_device_server.o
diff --git a/drivers/misc/hddl_device/hddl_device.c b/drivers/misc/hddl_device/hddl_device.c
deleted file mode 100644
index b6459d64cdfc..000000000000
--- a/drivers/misc/hddl_device/hddl_device.c
+++ /dev/null
@@ -1,712 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * HDDL Device Kernel module.
- *
- * Copyright (C) 2019-2020 Intel Corporation
- */
-
-#include <asm/page.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/printk.h>
-#include <uapi/linux/stat.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/of_device.h>
-#include <linux/of_reserved_mem.h>
-#include <linux/of_address.h>
-#include <linux/platform_device.h>
-#include <linux/xlink.h>
-#include <linux/time.h>
-#include <linux/kmod.h>
-#include <linux/i2c.h>
-#include <linux/sched.h>
-#include <linux/sched/mm.h>
-#include <linux/sched/task.h>
-#include <linux/hddl_device.h>
-#include <linux/ioctl.h>
-#include <linux/uaccess.h>
-#include <linux/cdev.h>
-#include <linux/fs.h>
-#include <linux/mutex.h>
-#include <linux/delay.h>
-#include <linux/xlink_drv_inf.h>
-#define DRIVER_NAME "hddl_device"
-
-#define HOST_KMB_TJ_DEVICE "host_kmb_tj"
-#define SLAVE_KMB_TJ_DRIVER "slave_kmb_tj"
-
-#define XLINK_MAX_DEVICE_NAME_SIZE 128
-#define XLINK_MAX_DEVICE_LIST_SIZE 8
-
-#ifndef CONFIG_HDDL_LOCAL_HOST
-
-struct mutex my_mutex; /* shared between the threads */
-
-static struct i2c_board_info soc_i2c_ext_devices[] = {
-	{
-		I2C_BOARD_INFO("tmp112", 0x48),
-	},
-	{
-		I2C_BOARD_INFO("tmp112", 0x49),
-	},
-	{
-		I2C_BOARD_INFO("ina3221", 0x40),
-	},
-	{
-		I2C_BOARD_INFO("emc2103", 0x2e),
-	},
-};
-static struct i2c_board_info host_xlinki2c_devices[] = {
-	{
-		I2C_BOARD_INFO("host_kmb_tj", 0x5a),
-	},
-};
-#else
-static struct i2c_board_info kmb_i2c_devices[] = {
-	{
-		I2C_BOARD_INFO("slave-kmb-tj", (unsigned short)0x4000005b),
-	},
-};
-#endif
-
-#define HDDL_DEVICE_DEBUG 0
-
-struct hddl_device_kmb kmb_hddls[HDDL_MAX_DEVICE] = {0};
-#define HDDL_NODE_XLINK_CHANNEL 1080
-#define HDDL_I2C_XLINK_CHANNEL 1081
-
-struct device_driver hddl_dbg_name = {
-	.name = "hddldev"
-};
-
-struct device hddl_dbg_subname = {
-	.init_name = "",	/* set to "" */
-	.driver = &hddl_dbg_name
-};
-
-static struct device *hddl_dbg = &hddl_dbg_subname;
-
-
-#ifdef CONFIG_HDDL_LOCAL_HOST
-
-uint32_t hddl_board_id;
-uint32_t hddl_kmb_id;
-
-
-int hddl_get_board_id(void)
-{
-	return hddl_board_id;
-}
-EXPORT_SYMBOL(hddl_get_board_id);
-
-int hddl_get_kmb_id(void)
-{
-	return hddl_kmb_id;
-}
-EXPORT_SYMBOL(hddl_get_kmb_id);
-
-int hddl_get_i2c_slave_address(void)
-{
-	return ((hddl_board_id << 3) | hddl_kmb_id);
-}
-EXPORT_SYMBOL(hddl_get_i2c_slave_address);
-
-static int hddl_device_thread_create(void);
-
-static int __init hddl_device_init(void)
-{
-	char *gpio_base_address; // = NULL;
-	uint32_t board_id;
-	uint32_t kmb_id;
-
-	//int gpio_base_address1;
-	gpio_base_address = ioremap(0x20320000, 2048);
-
-	/* Configure the GPIOs */
-
-	writel(0x1C0F, gpio_base_address + 0x2CC);
-	writel(0x1C0F, gpio_base_address + 0x2D0);
-	writel(0x1C0F, gpio_base_address + 0x2D4);
-
-#if HDDL_DEVICE_DEBUG
-	dev_info(hddl_dbg, "0x2CC = %x\n", readl(gpio_base_address + 0x2CC));
-	dev_info(hddl_dbg, "0x2D0 = %x\n", readl(gpio_base_address + 0x2D0));
-	dev_info(hddl_dbg, "0x2D4 = %x\n", readl(gpio_base_address + 0x2D4));
-#endif
-
-	writel(0x1C0F, gpio_base_address + 0x328);
-	writel(0x1C0F, gpio_base_address + 0x32C);
-	writel(0x1C0F, gpio_base_address + 0x330);
-
-
-#if HDDL_DEVICE_DEBUG
-	dev_info(hddl_dbg, "0x328 = %x\n", readl(gpio_base_address + 0x328));
-	dev_info(hddl_dbg, "0x32C = %x\n", readl(gpio_base_address + 0x32C));
-	dev_info(hddl_dbg, "0x330 = %x\n", readl(gpio_base_address + 0x330));
-#endif
-
-	board_id = readl(gpio_base_address + 0x24);
-	board_id = (board_id >> 19) & 0x7;
-	kmb_id = readl(gpio_base_address + 0x28);
-	kmb_id = (kmb_id >> 10) & 0x7;
-	if (kmb_id > 2) {
-		kmb_id = 0;
-		dev_info(hddl_dbg, "HDDL: GPIO KEEMBAY ID > 2, ");
-		dev_info(hddl_dbg, "Hence setting KEEMBAY ID = 0\n");
-	}
-
-	kmb_hddls[board_id].board_id = board_id;
-	kmb_hddls[board_id].soc[kmb_id].id = (board_id << 4) | kmb_id;
-	hddl_board_id = board_id;
-	hddl_kmb_id = kmb_id;
-
-#if HDDL_DEVICE_DEBUG
-	dev_info(hddl_dbg, "HDDL:Board Id = %x\n", hddl_board_id);
-	dev_info(hddl_dbg, "HDDL:Kmb Id = %x\n", hddl_kmb_id);
-#endif
-
-	hddl_device_thread_create();
-	return 0;
-}
-
-static void hddl_device_exit(void)
-{
-	dev_info(hddl_dbg, "%s done\n", __func__);
-}
-
-#endif
-
-/*ioctl*/
-dev_t dev;
-int sw_id_value;
-static struct class *dev_class;
-static struct cdev hddl_cdev;
-
-static long hddl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-
-	int i, j, rc = 0;
-	struct sw_id_hddl_data data = {0};
-	struct sw_id_soft_reset reset = {0};
-	struct xlink_handle *devH;
-
-	switch (cmd) {
-	case HDDL_SOFT_RESET:
-		if (copy_from_user(&reset,
-			(int32_t *)arg, sizeof(struct sw_id_soft_reset)))
-			return -EFAULT;
-		for (i = 0; i < HDDL_MAX_DEVICE; i++) {
-			for (j = 0; j < HDDL_MAX_BAY_DEVICE; j++) {
-				if (kmb_hddls[i].soc[j].devH.sw_device_id
-					== reset.sw_id) {
-					break;
-				}
-			}
-			if (j < HDDL_MAX_BAY_DEVICE)
-				break;
-		}
-		if (i == HDDL_MAX_DEVICE) {
-			dev_warn(hddl_dbg, "SoftReset: [%x]device not found:\n",
-				 reset.sw_id);
-			return -EFAULT;
-		}
-
-		/* xlink-reset */
-		devH = &kmb_hddls[i].soc[j].devH;
-		rc =  xlink_reset_device(devH);
-
-		if (rc > 0)
-			dev_info(hddl_dbg, "xlink_reset_device failed");
-		else
-			reset.return_id = 1;
-
-		if (copy_to_user((struct sw_id_soft_reset *) arg,
-			&reset, sizeof(struct sw_id_soft_reset)))
-			return -EFAULT;
-		/* xlink-rest */
-		break;
-	case HDDL_READ_SW_ID_DATA:
-		if (copy_from_user(&data, (int32_t *)arg,
-				sizeof(struct sw_id_hddl_data)))
-			return -EFAULT;
-		for (i = 0; i < HDDL_MAX_DEVICE; i++) {
-			for (j = 0; j < HDDL_MAX_BAY_DEVICE; j++) {
-				if (kmb_hddls[i].soc[j].devH.sw_device_id
-					== data.sw_id) {
-					break;
-				}
-			}
-			if (j < HDDL_MAX_BAY_DEVICE)
-				break;
-		}
-		if (i == HDDL_MAX_DEVICE) {
-			dev_warn(hddl_dbg, "HDDL Data: [%x]device not found:\n",
-				 data.sw_id);
-			return -EFAULT;
-		}
-
-		data.board_id = kmb_hddls[i].board_id;
-		data.soc_id = kmb_hddls[i].soc[j].id;
-		data.soc_adaptor_no[0] = kmb_hddls[i].soc[j].adap[0].nr;
-		data.soc_adaptor_no[1] = kmb_hddls[i].soc[j].adap[1].nr;
-		data.return_id = 1;
-		if (copy_to_user((struct sw_id_hddl_data *) arg,
-				&data,
-				sizeof(struct sw_id_hddl_data)))
-			return -EFAULT;
-		break;
-	}
-	return 0;
-}
-
-static const struct file_operations fops = {
-	.owner	= THIS_MODULE,
-	.unlocked_ioctl = hddl_ioctl,
-};
-
-int hddl_per_device_connect_thread(void *thread_param);
-		/*ioctl-end*/
-void hddl_device_probe(uint32_t swdev)
-{
-	int i, j;
-	struct task_struct *task_recv;
-
-	for (i = 0; i < HDDL_MAX_DEVICE; i++) {
-		for (j = 0; j < HDDL_MAX_BAY_DEVICE; j++) {
-			if (kmb_hddls[i].soc[j].devH.sw_device_id == swdev)
-				break;
-		}
-		if (j < HDDL_MAX_BAY_DEVICE)
-			break;
-	}
-	if (i == HDDL_MAX_DEVICE) {
-		dev_warn(hddl_dbg, "Probe: [%x]device not found:\n", swdev);
-		return;
-	}
-
-	task_recv = kthread_run(hddl_per_device_connect_thread,
-			(void *)&kmb_hddls[i].soc[j].devH,
-			"hddl_per_device_thread");
-	if (task_recv == NULL)
-		dev_info(hddl_dbg,
-		    "hddl_device_init Thread creation failed");
-}
-
-void hddl_device_remove(uint32_t swdev)
-{
-	int i, j, k, rc = 0;
-	uint32_t chan_num;
-	struct kmb *soc;
-
-	for (i = 0; i < HDDL_MAX_DEVICE; i++) {
-		for (j = 0; j < HDDL_MAX_BAY_DEVICE; j++) {
-			if (kmb_hddls[i].soc[j].devH.sw_device_id == swdev)
-				break;
-		}
-		if (j < HDDL_MAX_BAY_DEVICE)
-			break;
-	}
-	if (i == HDDL_MAX_DEVICE) {
-		dev_warn(hddl_dbg, "Remove:[%x]device not found:\n", swdev);
-		return;
-	}
-
-	soc = &kmb_hddls[i].soc[j];
-	for (k = 0; k < soc->i2c_slaves_cnt; k++)
-		i2c_unregister_device(soc->i2c_slaves_ext[k]);
-
-	for (k = 0; k < soc->soc_xlinki2c_cnt; k++) {
-		if (soc->soc_smbus[k])
-			i2c_unregister_device(soc->soc_smbus[k]);
-	}
-	for (k = 0; k < soc->soc_xlinki2c_cnt; k++) {
-		if (soc->soc_xlinki2c[k])
-			i2c_unregister_device(soc->soc_xlinki2c[k]);
-	}
-
-	chan_num = HDDL_NODE_XLINK_CHANNEL;
-
-	for (k = 0; k < ARRAY_SIZE(soc->xlink_i2c_plt_dev); k++)
-		platform_device_unregister(soc->xlink_i2c_plt_dev[k]);
-
-	rc = xlink_close_channel(&soc->devH, chan_num);
-
-	rc = xlink_disconnect(&soc->devH);
-
-	dev_info(hddl_dbg, "[%x]kmb device down\n", swdev);
-}
-
-uint32_t xlink_device_events[] = {
-	_NOTIFY_INCOMING_DISCONNECTION,
-	_NOTIFY_DEVICE_DISCONNECTED,
-	_NOTIFY_DEVICE_CONNECTED,
-	_ERROR_UNEXPECTED_DISCONNECTION,
-	_NUM_EVENT_TYPE
-};
-
-
-int hddl_event_notify(uint32_t swdevid, enum _xlink_device_event_type event)
-{
-	dev_info(hddl_dbg, "xlink pcie notify[%x]: [%d]\n", swdevid, event);
-	switch (event) {
-	/*case _NOTIFY_INCOMING_DISCONNECTION:*/
-	case _NOTIFY_DEVICE_DISCONNECTED:
-	case _ERROR_UNEXPECTED_DISCONNECTION:
-		hddl_device_remove(swdevid);
-		break;
-
-	case _NOTIFY_DEVICE_CONNECTED:
-		hddl_device_probe(swdevid);
-		break;
-
-	default:
-		dev_info(hddl_dbg, "HDDL:pcie notify-Error[%x]:[%d]\n",
-			swdevid,
-			event);
-		break;
-	}
-	return 0;
-}
-
-int hddl_per_device_connect_thread(void *thread_param)
-{
-	struct kmb *soc;
-	char device_name[XLINK_MAX_DEVICE_NAME_SIZE];
-	uint32_t stat = 0xFF;
-	uint32_t board_info;
-	uint32_t board_id_rcvd;
-	uint32_t size = 0;
-	uint32_t rc = X_LINK_ERROR;
-	uint32_t board_id = 0;
-	uint32_t kmb_id = 0;
-	struct timespec64 ts;
-	uint32_t chan_num;
-	uint32_t j = 0, i = 0;
-#ifndef CONFIG_HDDL_LOCAL_HOST
-	struct i2c_adapter *temp;
-	struct i2c_board_info temp_host_i2c_device;
-#endif
-	struct xlink_handle *devH = thread_param;
-	struct platform_device_info xlink_i2c_info = {0};
-
-	rc = xlink_get_device_name(devH,
-		device_name, XLINK_MAX_DEVICE_NAME_SIZE);
-	if (rc > 0) {
-		dev_info(hddl_dbg,
-			"HDDL:Failed to get device name of id [EC%d] %x\n",
-			rc, devH->sw_device_id);
-		return rc;
-	}
-	rc = X_LINK_ERROR;
-	while (rc != X_LINK_SUCCESS) {
-		rc = xlink_boot_device(devH, device_name);
-		msleep_interruptible(1000);
-	}
-
-	rc = X_LINK_ERROR;
-	while (rc != X_LINK_SUCCESS)
-		rc = xlink_get_device_status(devH, &stat);
-
-	rc = X_LINK_ERROR;
-	while (rc  != X_LINK_SUCCESS)
-		rc = xlink_connect(devH);
-
-	chan_num = HDDL_NODE_XLINK_CHANNEL;
-
-	xlink_pcie_register_device_event(devH->sw_device_id,
-				xlink_device_events,
-				_NUM_EVENT_TYPE,
-				hddl_event_notify,
-				0);
-
-	while ((rc = xlink_open_channel(devH,
-			chan_num,
-			RXB_TXB, /* mode */
-			64 * 1024,
-			0 /* timeout */)) != 0) {
-	}
-	dev_info(hddl_dbg, "Booting Device..%x", devH->sw_device_id);
-
-#ifdef CONFIG_HDDL_LOCAL_HOST
-	size = sizeof(ts);
-	rc = xlink_read_data_to_buffer(devH, chan_num, (uint8_t *)&ts, &size);
-	xlink_release_data(devH, chan_num, NULL);
-
-	do_settimeofday64(&ts);
-
-	board_id = hddl_get_board_id();
-	kmb_id = hddl_get_kmb_id();
-	board_info = (board_id << 4) | kmb_id;
-	rc = xlink_write_volatile(devH, chan_num,
-		(uint8_t *)&board_info, sizeof(board_info));
-
-	size = sizeof(board_id_rcvd);
-	rc = xlink_read_data_to_buffer(devH, chan_num,
-		(uint8_t *) &board_id_rcvd, &size);
-	xlink_release_data(devH, chan_num, NULL);
-
-	if (board_info == ~(board_id_rcvd)) {
-		memcpy(&kmb_hddls[board_id].soc[kmb_id].devH, devH,
-		sizeof(struct xlink_handle));
-	}
-#else
-
-	ktime_get_real_ts64(&ts);
-	rc = xlink_write_volatile(
-		devH,
-		chan_num,
-		(uint8_t *) &ts,
-		sizeof(struct timespec64));
-	size = sizeof(board_id_rcvd);
-	rc = xlink_read_data_to_buffer(devH, chan_num,
-		(uint8_t *)&board_id_rcvd, &size);
-	xlink_release_data(devH, chan_num, NULL);
-
-	board_info = ~(board_id_rcvd);
-	rc = xlink_write_volatile(devH, chan_num, (uint8_t *)&board_info,
-			sizeof(board_info));
-	board_id = (board_id_rcvd >> 4) & 0xF;
-	kmb_id = (board_id_rcvd & 0xF);
-	kmb_hddls[board_id].board_id = board_id;
-	kmb_hddls[board_id].soc[kmb_id].id = board_id_rcvd;
-	memcpy(&kmb_hddls[board_id].soc[kmb_id].devH, devH,
-			sizeof(struct xlink_handle));
-#endif
-	soc = &kmb_hddls[board_id].soc[kmb_id];
-	for (j = 0; j < 2; ++j) {
-		xlink_i2c_info.name = "i2c_xlink";
-		xlink_i2c_info.id = board_id << 4 | kmb_id << 2 | j;
-		kmb_hddls[board_id].soc[kmb_id].xlink_i2c_ch[j] =
-					HDDL_I2C_XLINK_CHANNEL + j;
-		xlink_i2c_info.data = &kmb_hddls[board_id].soc[kmb_id];
-		xlink_i2c_info.size_data =
-				sizeof(kmb_hddls[board_id].soc[kmb_id]);
-		soc->xlink_i2c_plt_dev[j] =
-		platform_device_register_full(&xlink_i2c_info);
-		soc->adap[j] =
-			*((struct i2c_adapter *)platform_get_drvdata(
-						soc->xlink_i2c_plt_dev[j]));
-	}
-
-	dev_info(hddl_dbg, "Handshake Complete = %x\n", devH->sw_device_id);
-	dev_info(hddl_dbg,
-		"Board[%x] Soc[%x] Adapter[%d]\n",
-		kmb_hddls[board_id].board_id,
-		kmb_hddls[board_id].soc[kmb_id].id,
-		soc->adap[0].nr);
-
-#ifndef CONFIG_HDDL_LOCAL_HOST
-	soc->soc_xlinki2c_cnt
-		= sizeof(host_xlinki2c_devices)/sizeof(struct i2c_board_info);
-
-	soc->soc_smbus
-		= kzalloc(
-			sizeof(struct i2c_client *) * (soc->soc_xlinki2c_cnt),
-			GFP_KERNEL);
-
-	soc->soc_xlinki2c
-		= kzalloc(
-			sizeof(struct i2c_client *) * (soc->soc_xlinki2c_cnt),
-			GFP_KERNEL);
-
-	for (i = 0; i < soc->soc_xlinki2c_cnt; i++) {
-		temp_host_i2c_device = host_xlinki2c_devices[i];
-
-		if (board_id <= 4) {
-			/* slave address range 0x10 -- 0x1F */
-			temp_host_i2c_device.addr =
-						kmb_id + 0x10 + (board_id * 3);
-		} else {
-			/* Slave address range 0x60 -- 0x6F */
-			temp_host_i2c_device.addr =
-				kmb_id + 0x60 + ((board_id - 5) * 3);
-		}
-		temp_host_i2c_device.platform_data = &(soc->devH.sw_device_id);
-
-		j = 0;
-		while ((temp = i2c_get_adapter(j)) != NULL) {
-			if (strstr(temp->name, "SMBus I801") != NULL) {
-				soc->soc_smbus[i]
-				  = i2c_new_device(temp, &temp_host_i2c_device);
-				break;
-			}
-			j++;
-		}
-		soc->soc_xlinki2c[i] = i2c_new_device(i2c_get_adapter(
-				soc->adap[1].nr),
-				&temp_host_i2c_device);
-	}
-
-	soc->i2c_slaves_cnt
-		= sizeof(soc_i2c_ext_devices)/sizeof(struct i2c_board_info);
-
-	soc->i2c_slaves_ext
-		= kzalloc(
-			sizeof(struct i2c_client *) * (soc->i2c_slaves_cnt),
-			GFP_KERNEL);
-
-	mutex_lock(&my_mutex);
-
-	for (i = 0; i < soc->i2c_slaves_cnt; i++) {
-		soc->i2c_slaves_ext[i] = i2c_new_device(
-			i2c_get_adapter(soc->adap[0].nr),
-			&soc_i2c_ext_devices[i]);
-
-		ssleep(1);
-	}
-	mutex_unlock(&my_mutex);
-
-#else
-	soc->soc_xlinki2c_cnt
-		= sizeof(kmb_i2c_devices)/sizeof(struct i2c_board_info);
-	soc->soc_xlinki2c
-		= kzalloc(
-			sizeof(struct i2c_client *) * (soc->soc_xlinki2c_cnt),
-		GFP_KERNEL);
-	for (i = 0; i < soc->soc_xlinki2c_cnt; i++) {
-		soc->soc_xlinki2c[i] = i2c_new_device(
-			i2c_get_adapter(soc->adap[1].nr),
-			&kmb_i2c_devices[i]);
-	}
-#endif
-	dev_info(hddl_dbg, "[%x]kmb device up\n", devH->sw_device_id);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(hddl_per_device_connect_thread);
-
-
-
-
-#define SW_DEVICE_ID_INTERFACE_SHIFT 24U
-#define SW_DEVICE_ID_INTERFACE_MASK  0x7
-#define GET_INTERFACE_FROM_SW_DEVICE_ID(id) \
-	((id >> SW_DEVICE_ID_INTERFACE_SHIFT) & SW_DEVICE_ID_INTERFACE_MASK)
-#define SW_DEVICE_ID_IPC_INTERFACE  0x0
-#define SW_DEVICE_ID_PCIE_INTERFACE 0x1
-
-#define XLINK_CONNECT_THREAD_BASED
-static struct xlink_handle xdevH[HDDL_MAX_DEVICE*HDDL_MAX_BAY_DEVICE];
-static int hddl_device_thermal_init(void *thread_param)
-{
-	uint32_t num_devices = 0;
-	uint32_t sw_device_id_list[XLINK_MAX_DEVICE_LIST_SIZE];
-	char device_name[XLINK_MAX_DEVICE_NAME_SIZE];
-	uint32_t i = 0;
-
-	dev_info(hddl_dbg, "HDDL:Getting device list...\n");
-#ifndef CONFIG_HDDL_LOCAL_HOST
-	mutex_init(&my_mutex);
-#endif
-
-	xlink_get_device_list(sw_device_id_list, &num_devices);
-	if (num_devices == 0) {
-		dev_info(hddl_dbg, "HDDL:No devices found\n");
-		return 0;
-	} else if (num_devices > (HDDL_MAX_DEVICE*HDDL_MAX_BAY_DEVICE)) {
-		dev_info(hddl_dbg, "HDDL:Increase xdevH array size\n");
-		return -1;
-	}
-	dev_info(hddl_dbg, "%u devices found...\n", num_devices);
-	for (i = 0; i < num_devices; i++) {
-		memset(&xdevH[i], 0, sizeof(struct xlink_handle));
-
-		xdevH[i].dev_type = HOST_DEVICE;
-		xdevH[i].sw_device_id = sw_device_id_list[i];
-		xlink_get_device_name(&(xdevH[i]),
-		device_name, XLINK_MAX_DEVICE_NAME_SIZE);
-		dev_info(hddl_dbg, "HDDL:Device name: %x %s\n",
-		xdevH[i].sw_device_id, device_name);
-	}
-
-	for (i = 0; i < num_devices; i++) {
-		struct task_struct *task_recv;
-
-		if (GET_INTERFACE_FROM_SW_DEVICE_ID(xdevH[i].sw_device_id)
-				== SW_DEVICE_ID_PCIE_INTERFACE) {
-			task_recv = kthread_run(hddl_per_device_connect_thread,
-					(void *)&xdevH[i],
-					"hddl_per_device_thread");
-			if (task_recv == NULL)
-				dev_info(hddl_dbg, "Thread creation failed");
-		}
-
-	}
-	return 0;
-}
-
-#ifndef CONFIG_HDDL_LOCAL_HOST
-static void hddl_device_thermal_exit(void)
-{
-	/*ioctl*/
-	device_destroy(dev_class, dev);
-	class_destroy(dev_class);
-	cdev_del(&hddl_cdev);
-	unregister_chrdev_region(dev, 1);
-	dev_info(hddl_dbg, "Device Driver Remove...Done!!!\n");
-
-	/*ioctl-end*/
-	return;
-};
-#endif
-
-static int hddl_device_thread_create(void)
-{
-	struct task_struct *task_recv;
-
-	/* create receiver thread */
-	task_recv = kthread_run(hddl_device_thermal_init, NULL,
-		"hddl_device receiver_thread");
-	if (task_recv == NULL)
-		dev_info(hddl_dbg, "hddl_device_init Thread creation failed");
-		/*ioctl*/
-
-  /*Allocating Major number*/
-	if ((alloc_chrdev_region(&dev, 0, 1, "Hddl_Dev")) < 0) {
-		dev_info(hddl_dbg, "Cannot allocate major number\n");
-		return -1;
-	}
-	dev_info(hddl_dbg, "Major = %d Minor = %d\n", MAJOR(dev), MINOR(dev));
-	/*Creating cdev structure*/
-	cdev_init(&hddl_cdev, &fops);
-	/*Adding character device to the system*/
-	if ((cdev_add(&hddl_cdev, dev, 1)) < 0) {
-		dev_info(hddl_dbg, "Cannot add the device to the system\n");
-		goto r_class;
-	}
-	/*Creating struct class*/
-	dev_class = class_create(THIS_MODULE, "hddl_class");
-	if (dev_class == NULL) {
-		dev_info(hddl_dbg, "Cannot create the struct class\n");
-		goto r_class;
-	}
-	/*Creating device*/
-	if ((device_create(dev_class, NULL, dev, NULL, "hddl_dev"))
-		== NULL) {
-		dev_info(hddl_dbg, "Cannot create the Device 1\n");
-		goto r_device;
-	}
-	return 0;
-r_device:
-	class_destroy(dev_class);
-r_class:
-	unregister_chrdev_region(dev, 1);
-
-/*ioctl-end*/
-	return 0;
-}
-
-#ifdef CONFIG_HDDL_LOCAL_HOST
-module_init(hddl_device_init);
-module_exit(hddl_device_exit);
-#else
-module_init(hddl_device_thread_create);
-module_exit(hddl_device_thermal_exit);
-#endif
-
-MODULE_DESCRIPTION("KeemBay HDDL Device driver");
-MODULE_AUTHOR("Raja Subramanian, Lakshmi Bai <lakshmi.bai.raja.subramanian@intel.com>");
-MODULE_AUTHOR("Sandeep Singh <sandeep1.singh@intel.com>");
-MODULE_AUTHOR("Vaidya, Mahesh R <mahesh.r.vaidya@intel.com>");
-MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/hddl_device/hddl_device_client.c b/drivers/misc/hddl_device/hddl_device_client.c
new file mode 100644
index 000000000000..0deb72bcce68
--- /dev/null
+++ b/drivers/misc/hddl_device/hddl_device_client.c
@@ -0,0 +1,620 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * HDDL Device Kernel module.
+ *
+ * Copyright (C) 2019-2020 Intel Corporation
+ */
+
+#include <asm/page.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/printk.h>
+#include <uapi/linux/stat.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of_device.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/xlink.h>
+#include <linux/time.h>
+#include <linux/kmod.h>
+#include <linux/i2c.h>
+#include <linux/sched.h>
+#include <linux/sched/mm.h>
+#include <linux/sched/task.h>
+#include <linux/hddl_device.h>
+#include <linux/ioctl.h>
+#include <linux/uaccess.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/gpio/consumer.h>
+#include <linux/workqueue.h>
+#include <linux/hddl_device.h>
+#include "hddl_device_helper.h"
+
+#define DRIVER_NAME "hddl_device_client"
+
+struct intel_hddl_client_priv {
+	void __iomem *base_addr;
+	int board_id;
+	int soc_id;
+	uint32_t xlink_chan;
+	uint32_t i2c_xlink_chan;
+	struct platform_device *pdev;
+	struct intel_hddl_clients **hddl_client;
+	uint32_t n_hddl_devs;
+	struct task_struct *hddl_dev_init_task;
+	struct intel_hddl_i2c_devs **i2c_devs;
+	int n_slaves;
+	struct intel_hddl_board_info board_info;
+};
+
+static struct intel_hddl_client_priv *g_priv;
+
+static struct intel_hddl_clients **intel_hddl_get_device(int *n_devs)
+{
+	if (!g_priv || !n_devs)
+		return NULL;
+	*n_devs = g_priv->n_hddl_devs;
+	return g_priv->hddl_client;
+}
+
+static int intel_hddl_unregister_pdev(struct intel_hddl_clients *c)
+{
+	struct intel_hddl_client_priv *priv = c->pdata;
+
+	intel_hddl_xlink_remove_i2c_adap(&priv->pdev->dev, c);
+	return 0;
+}
+
+static uint8_t *intel_tsens_thermal_msg(struct intel_hddl_clients *c,
+		struct intel_hddl_tsens_msg *msg, uint32_t *size)
+{
+	struct intel_tsens **tsens = (struct intel_tsens **)c->tsens;
+
+	switch (msg->msg_type) {
+	case HDDL_GET_NSENS:
+	{
+		uint32_t *data;
+		*size = sizeof(int);
+		data = kzalloc(*size, GFP_KERNEL);
+		if (!data)
+			return NULL;
+		*data = c->nsens;
+		return (uint8_t *)data;
+	}
+		break;
+	case HDDL_GET_SENS_DETAILS:
+	{
+		struct intel_tsens_data *data;
+		uint32_t index = msg->index;
+
+		*size = sizeof(struct intel_tsens_data);
+		data = kzalloc(*size, GFP_KERNEL);
+		if (!data)
+			return NULL;
+		strcpy(data->name, tsens[index]->name);
+		data->n_trips = tsens[index]->n_trips;
+		data->passive_delay = tsens[index]->passive_delay;
+		data->polling_delay = tsens[index]->polling_delay;
+		data->sensor_type = tsens[index]->sensor_type;
+		return (uint8_t *)data;
+	}
+		break;
+	case HDDL_GET_SENS_TRIP_INFO:
+	{
+		struct intel_tsens_trip_info *data;
+		uint32_t index = msg->index;
+		uint32_t index2 = msg->index2;
+
+		*size = sizeof(struct intel_tsens_trip_info);
+		data = kzalloc(*size, GFP_KERNEL);
+		if (!data)
+			return NULL;
+		memcpy(data, tsens[index]->trip_info[index2],
+				sizeof(struct intel_tsens_trip_info));
+		return (uint8_t *)data;
+	}
+		break;
+
+	default:
+		break;
+	}
+	return NULL;
+}
+
+static int intel_hddl_i2c_clients(struct device *dev,
+				struct intel_hddl_clients *c)
+{
+	int rc, i;
+	struct intel_hddl_tsens_msg msg;
+	int size;
+	struct xlink_handle *xlink = &c->xlink_dev;
+	struct intel_hddl_client_priv *priv = c->pdata;
+
+	/* Get msg type */
+	rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+	(uint8_t *) &msg, &size);
+	xlink_release_data(xlink, c->chan_num, NULL);
+
+	while (msg.msg_type != HDDL_GET_SENS_COMPLETE) {
+		uint32_t *data;
+
+		switch (msg.msg_type) {
+		case HDDL_GET_N_I2C_DEVS:
+		{
+			size = sizeof(int);
+			data = kzalloc(size, GFP_KERNEL);
+			if (!data) {
+				dev_err(&priv->pdev->dev, "HDDL: failed to get details\n");
+				return -EINVAL;
+			}
+			*data = priv->n_slaves;
+		}
+			break;
+		case HDDL_GET_I2C_DEVS:
+		{
+			struct intel_hddl_i2c_devs_data *t;
+			int index = msg.index;
+
+			size = sizeof(struct intel_hddl_i2c_devs_data);
+			t = kzalloc(size, GFP_KERNEL);
+			if (!t) {
+				dev_err(&priv->pdev->dev, "HDDL: failed to get details\n");
+				return -EINVAL;
+			}
+			strcpy(t->name, priv->i2c_devs[index]->name);
+			t->addr = priv->i2c_devs[index]->addr;
+			t->bus = priv->i2c_devs[index]->bus;
+			t->enabled = priv->i2c_devs[index]->enabled;
+			t->local_host = priv->i2c_devs[index]->local_host;
+			t->remote_host = priv->i2c_devs[index]->remote_host;
+			data = (uint32_t *)t;
+
+		}
+			break;
+		default:
+			break;
+		}
+		rc = xlink_write_volatile(xlink, c->chan_num,
+			(uint8_t *)data, size);
+		dev_dbg(&priv->pdev->dev,
+			"HDDL: xlink_write_data complete [%d].\n",
+			rc);
+		kfree(data);
+		rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+		(uint8_t *) &msg, &size);
+		xlink_release_data(xlink, c->chan_num, NULL);
+	}
+
+	for (i = 0; i < priv->n_slaves; i++) {
+		msg.msg_type = HDDL_GET_I2C_DEV_ADDR;
+		msg.index = i;
+		rc = xlink_write_volatile(xlink, c->chan_num,
+				(uint8_t *)&msg, sizeof(msg));
+		rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+				(uint8_t *) &priv->i2c_devs[i]->addr, &size);
+		dev_info(&priv->pdev->dev, "HDDL: Slave addr for %s is %d\n",
+					priv->i2c_devs[i]->name,
+					priv->i2c_devs[i]->addr);
+		priv->i2c_devs[i]->board_info.addr = priv->i2c_devs[i]->addr;
+		xlink_release_data(xlink, c->chan_num, NULL);
+	}
+	/* Send Complete */
+	msg.msg_type = HDDL_GET_SENS_COMPLETE;
+	rc = xlink_write_volatile(xlink, c->chan_num,
+				(uint8_t *)&msg, sizeof(msg));
+
+	rc = intel_hddl_xlink_i2c_clients(&priv->pdev->dev, c, priv->i2c_devs,
+			priv->n_slaves, 0);
+	if (rc) {
+		dev_err(&priv->pdev->dev, "HDDL: register i2c slaves failed\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static int intel_hddl_tsens_data(struct intel_hddl_clients *c)
+{
+	int rc;
+	struct intel_hddl_client_priv *priv = c->pdata;
+	struct xlink_handle *xlink = &c->xlink_dev;
+	uint32_t size;
+	uint8_t *data;
+	struct intel_hddl_tsens_msg msg;
+
+	/* Get msg type */
+	rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+	(uint8_t *) &msg, &size);
+	xlink_release_data(xlink, c->chan_num, NULL);
+
+	while (msg.msg_type != HDDL_GET_SENS_COMPLETE) {
+		data = intel_tsens_thermal_msg(c, &msg, &size);
+		if (!data) {
+			dev_err(&priv->pdev->dev, "HDDL: failed to get details\n");
+			return -EINVAL;
+		}
+		rc = xlink_write_volatile(xlink, c->chan_num,
+			(uint8_t *)data, size);
+		dev_dbg(&priv->pdev->dev, "HDDL: %s write complete\n",
+					__func__);
+		kfree(data);
+		rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+		(uint8_t *) &msg, &size);
+		xlink_release_data(xlink, c->chan_num, NULL);
+	}
+	dev_dbg(&priv->pdev->dev, "HDDL: %s xfer complete\n",
+					__func__);
+
+	return 0;
+}
+
+static int intel_hddl_device_connect_task(void *data)
+{
+	struct intel_hddl_clients *c = (struct intel_hddl_clients *)data;
+	struct intel_hddl_client_priv *priv = c->pdata;
+	struct timespec64 ts;
+	uint32_t size, rc;
+	struct xlink_handle *xlink = &c->xlink_dev;
+	struct intel_hddl_board_info board_info_rcvd;
+
+	memcpy(&c->board_info, &priv->board_info,
+			sizeof(struct intel_hddl_board_info));
+	c->tsens = (void **)intel_tsens_hddl_register(&c->nsens);
+	c->chan_num = priv->xlink_chan;
+	c->i2c_chan_num = priv->i2c_xlink_chan;
+	c->i2c_devs = priv->i2c_devs;
+	c->n_slaves = priv->n_slaves;
+	if (intel_hddl_open_xlink_device(&priv->pdev->dev, c)) {
+		dev_err(&priv->pdev->dev, "HDDL open xlink dev failed\n");
+		return -EINVAL;
+	}
+	size = sizeof(ts);
+	rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+			(uint8_t *)&ts, &size);
+	xlink_release_data(xlink, c->chan_num, NULL);
+
+	dev_dbg(&priv->pdev->dev, "HDDL: Received %d Bytes [%d]\n", size, rc);
+	dev_info(&priv->pdev->dev, "S[%llx] NS[%lx]\n", ts.tv_sec, ts.tv_nsec);
+	do_settimeofday64(&ts);
+
+	dev_dbg(&priv->pdev->dev, "HDDL: xlink_write_data to start...\n");
+	rc = xlink_write_volatile(xlink, c->chan_num,
+	(uint8_t *)&c->board_info, sizeof(struct intel_hddl_board_info));
+	dev_dbg(&priv->pdev->dev, "HDDL: xlink_write_data complete[%d].\n",
+						rc);
+	dev_dbg(&priv->pdev->dev, "HDDL: xlink_read_data to start...\n");
+	size = sizeof(board_info_rcvd);
+	rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+	(uint8_t *) &board_info_rcvd, &size);
+	xlink_release_data(xlink, c->chan_num, NULL);
+	dev_dbg(&priv->pdev->dev,
+		"HDDL: [%d]xlink_read_data completed Rcvd Size[%d]\n",
+		rc, size);
+	dev_info(&priv->pdev->dev, "HDDL: Board Info[%x %x]\n",
+				c->board_info.board_id,
+				board_info_rcvd.board_id);
+
+	if (c->board_info.board_id ==
+			~(board_info_rcvd.board_id)) {
+		dev_info(&priv->pdev->dev, "HDDL: Handshake Complete = %x\n",
+		c->board_info.board_id);
+		dev_info(&priv->pdev->dev,
+		"HDDL: Board[%x] Soc[%x] DevType[%x]\n",
+			c->board_info.board_id,
+			c->board_info.soc_id,
+			xlink->dev_type
+		);
+	}
+	rc = intel_hddl_tsens_data(c);
+	if (rc) {
+		dev_err(&priv->pdev->dev, "HDDL: tsens data not sent\n");
+		return -EINVAL;
+	}
+	rc = intel_hddl_xlink_i2c_adap(&priv->pdev->dev, c);
+	if (rc) {
+		dev_err(&priv->pdev->dev,
+			"HDDL: register xlink i2c adapter failed\n");
+		return -EINVAL;
+	}
+	rc = intel_hddl_i2c_clients(&priv->pdev->dev, c);
+	if (rc) {
+		dev_err(&priv->pdev->dev,
+			"HDDL: register i2c slaves failed\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int intel_hddl_check_for_new_device(
+		struct intel_hddl_client_priv *priv)
+{
+	priv->hddl_client = intel_hddl_setup_device(&priv->pdev->dev,
+				intel_hddl_device_connect_task,
+				&priv->n_hddl_devs, priv->hddl_client, priv);
+
+	if (priv->hddl_client == NULL)
+		dev_err(&priv->pdev->dev, "intel_hddl_setup_device returned NULL\n");
+
+	return (priv->hddl_client != NULL)?1:0;
+}
+
+static int intel_hddl_device_init_task(void *data)
+{
+	struct intel_hddl_client_priv *priv =
+		(struct intel_hddl_client_priv *)data;
+
+	while (true) {
+		if (!intel_hddl_check_for_new_device(priv)) {
+			dev_err(&priv->pdev->dev, "intel_hddl_setup_device returned NULL\n");
+			break;
+		}
+		msleep_interruptible(5000);
+	}
+	dev_err(&priv->pdev->dev, "Setup HDDL client devices failed\n");
+
+	return -EINVAL;
+}
+
+static int intel_hddl_device_init(struct intel_hddl_client_priv *priv)
+{
+	priv->hddl_dev_init_task = kthread_run(
+					intel_hddl_device_init_task,
+					(void *)priv,
+					"hddl_device_init");
+	if (!priv->hddl_dev_init_task) {
+		dev_err(&priv->pdev->dev, "failed to create thread\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int intel_hddl_config_dt(struct intel_hddl_client_priv *priv)
+{
+	struct platform_device *pdev = priv->pdev;
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *s_node;
+	struct resource *res;
+	struct gpio_descs *board_id_gpios;
+	struct gpio_descs *soc_id_gpios;
+	int gpio_cfg_count, board_cfg_count, soc_cfg_count, i;
+	int ret;
+	unsigned long values;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res) {
+		priv->base_addr = ioremap(res->start,
+				(res->end - res->start));
+	}
+	priv->board_info.soc_id = 0;
+	priv->board_info.board_id = 0;
+	of_property_read_u32(np, "xlink_chan",
+				&priv->xlink_chan);
+	of_property_read_u32(np, "i2c_xlink_chan",
+				&priv->i2c_xlink_chan);
+	board_id_gpios =
+		gpiod_get_array_optional(&pdev->dev, "board-id",
+				GPIOD_IN);
+	if (board_id_gpios) {
+		ret = gpiod_get_array_value(board_id_gpios->ndescs,
+			board_id_gpios->desc,
+			NULL, &values);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"failed to get boardid values %d",
+				ret);
+			return ret;
+		}
+		priv->board_info.board_id = values;
+		priv->board_id = priv->board_info.board_id;
+	} else {
+		dev_info(&pdev->dev, "board-id cfg is not enabled in dts\n");
+	}
+	soc_id_gpios =
+		gpiod_get_array_optional(&pdev->dev, "soc-id",
+				GPIOD_IN);
+	if (soc_id_gpios) {
+		ret = gpiod_get_array_value(soc_id_gpios->ndescs,
+			soc_id_gpios->desc,
+			NULL, &values);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"failed to get soc-id values %d",
+				ret);
+			return ret;
+		}
+		priv->board_info.soc_id = values;
+		priv->soc_id = priv->board_info.soc_id;
+	} else {
+		dev_info(&pdev->dev, "soc-id cfg is not enabled in dts\n");
+	}
+
+	gpio_cfg_count = of_property_count_u32_elems(np, "gpio-cfg-table");
+	if (gpio_cfg_count > 0) {
+		u32 offset, setting;
+
+		for (i = 0; i < (gpio_cfg_count/2); i++) {
+			u32 index = (i*2);
+
+			of_property_read_u32_index(np,
+					"gpio-cfg-table", index,
+					&offset);
+			of_property_read_u32_index(np,
+					"gpio-cfg-table", index+1,
+					&setting);
+			iowrite32(setting, (priv->base_addr + offset));
+		}
+	}
+	board_cfg_count = of_property_count_u32_elems(np, "board-cfg-table");
+	if (board_cfg_count > 0) {
+		u32 offset, bit_pos, bit_mask, val;
+
+		of_property_read_u32_index(np, "board-cfg-table", 0,
+						&offset);
+		of_property_read_u32_index(np, "board-cfg-table", 1,
+						&bit_pos);
+		of_property_read_u32_index(np, "board-cfg-table", 2,
+						&bit_mask);
+		val = ioread32((priv->base_addr + offset));
+		priv->board_info.board_id = (val >> bit_pos) & bit_mask;
+		priv->board_id = priv->board_info.board_id;
+	}
+	soc_cfg_count = of_property_count_u32_elems(np, "soc-cfg-table");
+	if (soc_cfg_count > 0) {
+		u32 offset, bit_pos, bit_mask, val;
+
+		of_property_read_u32_index(np, "soc-cfg-table", 0,
+						&offset);
+		of_property_read_u32_index(np, "soc-cfg-table", 1,
+						&bit_pos);
+		of_property_read_u32_index(np, "soc-cfg-table", 2,
+						&bit_mask);
+		val = ioread32((priv->base_addr + offset));
+		priv->board_info.soc_id = (val >> bit_pos) & bit_mask;
+		priv->soc_id = priv->board_info.soc_id;
+	}
+	dev_info(&pdev->dev, "Board ID %d, Soc ID %d\n",
+				priv->board_id,
+				priv->soc_id);
+
+	priv->n_slaves = of_get_child_count(np);
+	priv->i2c_devs = devm_kzalloc(&pdev->dev,
+				(sizeof(struct intel_hddl_i2c_devs *) *
+				 priv->n_slaves),
+				GFP_KERNEL);
+	if (!priv->i2c_devs)
+		return -ENOMEM;
+
+	i = 0;
+	for_each_child_of_node(np, s_node) {
+		const char *status;
+
+		priv->i2c_devs[i] = devm_kzalloc(&pdev->dev,
+					sizeof(struct intel_hddl_i2c_devs),
+					GFP_KERNEL);
+		if (priv->i2c_devs[i] == NULL) {
+			dev_err(&pdev->dev, "Memory alloc failed for %s\n",
+				s_node->name);
+			ret = -ENOMEM;
+			goto f_i2c_dev;
+		}
+		of_property_read_string_index(s_node, "status", 0,
+				&status);
+		if (!strcmp(status, "okay")) {
+			uint32_t addr;
+			const char *name = NULL;
+
+			priv->i2c_devs[i]->enabled = 1;
+			of_property_read_string_index(s_node, "compatible", 0,
+					&name);
+			if (name) {
+				strcpy(priv->i2c_devs[i]->name, name);
+				strcpy(priv->i2c_devs[i]->board_info.type,
+					priv->i2c_devs[i]->name);
+			}
+			of_property_read_u32(s_node, "reg", &addr);
+			priv->i2c_devs[i]->board_info.addr = addr;
+			priv->i2c_devs[i]->addr = addr;
+			of_property_read_u32(s_node, "bus",
+					&priv->i2c_devs[i]->bus);
+			of_property_read_u32(s_node, "remote-host",
+					&priv->i2c_devs[i]->remote_host);
+			of_property_read_u32(s_node, "local-host",
+					&priv->i2c_devs[i]->local_host);
+		}
+		i++;
+	}
+	return 0;
+f_i2c_dev:
+	return ret;
+}
+
+static int intel_hddl_client_probe(struct platform_device *pdev)
+{
+	struct intel_hddl_client_priv *priv;
+	int ret;
+
+	dev_info(&pdev->dev,
+		"%s Entry\n", __func__);
+	priv = devm_kzalloc(&pdev->dev,
+				sizeof(struct intel_hddl_client_priv),
+				GFP_KERNEL);
+	if (priv == NULL) {
+		dev_err(&pdev->dev, "No memory");
+		return -ENOMEM;
+	}
+	priv->pdev = pdev;
+	g_priv = priv;
+	if (pdev->dev.of_node) {
+		ret = intel_hddl_config_dt(priv);
+		if (ret) {
+			dev_err(&pdev->dev, "dt configuration failed\n");
+			devm_kfree(&pdev->dev, priv);
+			return ret;
+		}
+	} else {
+		dev_err(&pdev->dev, "Non Device Tree build is not supported\n");
+		devm_kfree(&pdev->dev, priv);
+		return -EINVAL;
+	}
+	ret = intel_hddl_device_init(priv);
+	if (ret) {
+		dev_err(&pdev->dev, "HDDL device init failed\n");
+		devm_kfree(&pdev->dev, priv);
+		return -EINVAL;
+	}
+	platform_set_drvdata(pdev, priv);
+	return 0;
+}
+
+/* Device Exit */
+static int intel_hddl_client_exit(struct platform_device *pdev)
+{
+	int k;
+	struct intel_hddl_client_priv *priv = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev,
+		"%s Entry\n", __func__);
+	if (!priv)
+		return -EINVAL;
+	for (k = 0; k < priv->n_hddl_devs; k++) {
+		struct intel_hddl_clients *d = priv->hddl_client[k];
+
+		intel_hddl_device_remove(d);
+	}
+	dev_info(&pdev->dev,
+		"%s Exit\n", __func__);
+
+	return 0;
+}
+
+static const struct of_device_id intel_hddl_client_id_table[] = {
+	{ .compatible = "intel,hddl-client" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, intel_hddl_client_id_table);
+
+static struct platform_driver intel_hddl_client_driver = {
+	.probe = intel_hddl_client_probe,
+	.remove = intel_hddl_client_exit,
+	.driver = {
+		.name = "intel_hddl_client",
+		.of_match_table = intel_hddl_client_id_table,
+	},
+};
+
+module_platform_driver(intel_hddl_client_driver);
+
+MODULE_DESCRIPTION("KeemBay HDDL Device driver");
+MODULE_AUTHOR("Raja Subramanian, Lakshmi Bai"
+	      "<lakshmi.bai.raja.subramanian@intel.com>");
+MODULE_AUTHOR("Sandeep Singh <sandeep1.singh@intel.com>");
+MODULE_AUTHOR("Vaidya, Mahesh R <mahesh.r.vaidya@intel.com>");
+MODULE_AUTHOR("Udhayakumar C <udhayakumar.c@intel.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/hddl_device/hddl_device_helper.h b/drivers/misc/hddl_device/hddl_device_helper.h
new file mode 100644
index 000000000000..ba7b4e0cd01f
--- /dev/null
+++ b/drivers/misc/hddl_device/hddl_device_helper.h
@@ -0,0 +1,498 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * HDDL Device HELPER module.
+ *
+ * Copyright (C) 2019-2020 Intel Corporation
+ */
+
+#ifndef _LINUX_HDDL_DEVICE_HELPER_H
+#define _LINUX_HDDL_DEVICE_HELPER_H
+
+#include <linux/xlink_drv_inf.h>
+#include "../xlink-core/xlink-defs.h"
+
+static uint32_t hddl_xlink_device_events[] = {
+	_NOTIFY_INCOMING_DISCONNECTION,
+	_NOTIFY_DEVICE_DISCONNECTED,
+	_NOTIFY_DEVICE_CONNECTED,
+	_ERROR_UNEXPECTED_DISCONNECTION,
+	_NUM_EVENT_TYPE
+};
+
+typedef int (*intel_hddl_connect_task)(void *);
+
+
+static inline struct intel_hddl_clients **intel_hddl_new_device(
+			struct device *dev,
+			struct intel_hddl_clients **hddl_clients,
+			uint32_t *sw_device_id_list,
+			uint32_t num_devices,
+			uint32_t *n_devs)
+{
+	int i, j;
+	bool new_dev = true;
+	struct intel_hddl_clients **cls;
+
+	for (i = 0; i < num_devices; i++) {
+		for (j = 0; j < (*n_devs); j++) {
+			if (sw_device_id_list[i] ==
+				hddl_clients[j]->xlink_dev.sw_device_id) {
+				new_dev = false;
+				break;
+			}
+		}
+	}
+	if (!new_dev)
+		return hddl_clients;
+	dev_info(dev, "new device found\n");
+	cls = devm_kzalloc(dev,
+		(sizeof(struct intel_hddl_clients *) * num_devices),
+		GFP_KERNEL);
+	if (cls == NULL) {
+		dev_err(dev, "HDDL:No Memory\n");
+		return NULL;
+	}
+	*n_devs = num_devices;
+	for (i = 0; i < num_devices; i++) {
+		for (j = 0; j < *n_devs; j++) {
+			if (sw_device_id_list[i] ==
+				hddl_clients[j]->xlink_dev.sw_device_id) {
+				cls[i] = hddl_clients[j];
+				break;
+			}
+		}
+	}
+	devm_kfree(dev, hddl_clients);
+	return cls;
+}
+
+static inline struct intel_hddl_clients **intel_hddl_setup_device(
+		struct device *dev,
+		intel_hddl_connect_task task, uint32_t *n_devs,
+		struct intel_hddl_clients **hddl_clients,
+		void *pdata)
+{
+	uint32_t num_devices = 0;
+	uint32_t sw_device_id_list[XLINK_MAX_DEVICE_LIST_SIZE];
+	char device_name[XLINK_MAX_DEVICE_NAME_SIZE];
+	uint32_t i = 0;
+
+	xlink_get_device_list(sw_device_id_list, &num_devices);
+	if (num_devices == 0) {
+		dev_err(dev, "HDDL:No devices found\n");
+		return NULL;
+	}
+	dev_dbg(dev, "HDDL:%u devices found...\n", num_devices);
+
+	if (hddl_clients != NULL) {
+		hddl_clients = intel_hddl_new_device(dev,
+				hddl_clients, sw_device_id_list,
+				num_devices, n_devs);
+		if (!hddl_clients)
+			return NULL;
+	} else {
+		hddl_clients = devm_kzalloc(dev,
+				(sizeof(struct intel_hddl_clients *)
+				 * num_devices),
+				GFP_KERNEL);
+		if (hddl_clients == NULL) {
+			dev_err(dev, "HDDL:No Memory\n");
+			return NULL;
+		}
+		*n_devs = num_devices;
+	}
+
+	for (i = 0; i < num_devices; i++) {
+		struct intel_hddl_clients *c = hddl_clients[i];
+
+		if (c != NULL)
+			continue;
+		c = devm_kzalloc(dev,
+				(sizeof(struct intel_hddl_clients)),
+				GFP_KERNEL);
+		if (c == NULL) {
+			dev_err(dev, "Memory alloc failed\n");
+			goto f_clients;
+		}
+
+		c->pdata = pdata;
+		c->xlink_dev.dev_type = HOST_DEVICE;
+		c->xlink_dev.sw_device_id = sw_device_id_list[i];
+		xlink_get_device_name((&c->xlink_dev),
+		device_name, XLINK_MAX_DEVICE_NAME_SIZE);
+		dev_info(dev, "HDDL:Device name: %x %s\n",
+			c->xlink_dev.sw_device_id, device_name);
+		if (GET_INTERFACE_FROM_SW_DEVICE_ID(
+				c->xlink_dev.sw_device_id) ==
+				SW_DEVICE_ID_PCIE_INTERFACE) {
+			c->hddl_dev_connect_task = kthread_run(task,
+								(void *)c,
+								device_name);
+			if (!c->hddl_dev_connect_task) {
+				dev_err(dev, "failed to create thread\n");
+				goto f_wq;
+			}
+			c->task = (void *)task;
+		}
+		hddl_clients[i] = c;
+	}
+
+	return hddl_clients;
+	/*TODO: free memory */
+f_wq:
+f_clients:
+	return NULL;
+}
+
+static inline int intel_hddl_xlink_remove_i2c_adap(struct device *dev,
+			struct intel_hddl_clients *c)
+{
+	int k;
+
+	for (k = 0; k < 2; k++) {
+		if (c->xlink_i2c_plt_dev[k] != NULL) {
+			dev_info(dev,
+			"HDDL : platform_device_unregister = %d\n",
+			k);
+			platform_device_unregister(c->xlink_i2c_plt_dev[k]);
+			c->xlink_i2c_plt_dev[k] = NULL;
+		}
+	}
+	return 0;
+}
+
+static int intel_hddl_remote_xlink_slave(struct device *dev,
+				struct intel_hddl_clients *c,
+				struct intel_hddl_i2c_devs *i2c_devs)
+{
+	if (!i2c_devs->enabled)
+		return 0;
+	if (i2c_devs->remote_host &
+		HDDL_XLINK_SLAVE) {
+		if (!c->xlink_i2c_plt_dev[1])
+			return 0;
+		c->adap[1] = (struct i2c_adapter *)platform_get_drvdata(
+						c->xlink_i2c_plt_dev[1]);
+		dev_info(dev,
+		"HDDL : registering xlink smbus slave %s addr %d\n",
+		i2c_devs->board_info.type,
+		i2c_devs->board_info.addr);
+		if (!c->adap[1]) {
+			dev_info(dev,
+			"HDDL : xlink smbus adapter not loaded\n");
+			return 0;
+		}
+		i2c_devs->board_info.platform_data = c;
+		i2c_devs->xlk_client = i2c_new_device(
+					c->adap[1],
+					&i2c_devs->board_info);
+		ssleep(1);
+	}
+	if (i2c_devs->remote_host &
+		HDDL_I2C_SLAVE) {
+		int j = 0;
+		struct i2c_adapter *temp;
+
+		while ((temp = i2c_get_adapter(j)) != NULL) {
+			if (strstr(temp->name, "SMBus I801") != NULL) {
+				i2c_devs->board_info.platform_data = c;
+				i2c_devs->i2c_client =
+						i2c_new_device(temp,
+						&i2c_devs->board_info);
+				dev_info(dev, "soc_smbus adapter %d",
+				i2c_devs->i2c_client->adapter->nr);
+				ssleep(1);
+				break;
+			}
+			i2c_put_adapter(temp);
+			j++;
+		}
+	}
+	if (i2c_devs->remote_host &
+		HDDL_XLINK_SMBUS_SLAVE) {
+		if (!c->xlink_i2c_plt_dev[0])
+			return 0;
+		c->adap[0] = (struct i2c_adapter *)platform_get_drvdata(
+						c->xlink_i2c_plt_dev[0]);
+		dev_info(dev,
+			"HDDL : registering xlink smbus slave %s addr %d\n",
+					i2c_devs->board_info.type,
+					i2c_devs->board_info.addr);
+		if (!c->adap[0]) {
+			dev_info(dev,
+				"HDDL : xlink smbus adapter not loaded\n");
+			return 0;
+		}
+		i2c_devs->smbus_client = i2c_new_device(
+						c->adap[0],
+						&i2c_devs->board_info);
+		ssleep(1);
+	}
+
+	return 0;
+}
+
+static int intel_hddl_xlink_slave(struct device *dev,
+				struct intel_hddl_clients *c,
+				struct intel_hddl_i2c_devs *i2c_devs)
+{
+	if (!i2c_devs->enabled)
+		return 0;
+	if (i2c_devs->local_host &
+		HDDL_XLINK_SLAVE) {
+		if (!c->xlink_i2c_plt_dev[1])
+			return 0;
+		c->adap[1] = (struct i2c_adapter *)platform_get_drvdata(
+						c->xlink_i2c_plt_dev[1]);
+		dev_info(dev, "HDDL : registering xlink slave %s addr %d\n",
+					i2c_devs->board_info.type,
+					i2c_devs->board_info.addr);
+		if (!c->adap[1]) {
+			dev_info(dev, "HDDL : Slave adapter not loaded\n");
+			return 0;
+		}
+		i2c_devs->xlk_client = i2c_new_device(
+						c->adap[1],
+					&i2c_devs->board_info);
+		ssleep(1);
+	}
+	if (i2c_devs->local_host &
+			HDDL_I2C_SLAVE) {
+		dev_info(dev, "HDDL : registering i2c slave %s addr %d\n",
+					i2c_devs->board_info.type,
+					i2c_devs->board_info.addr);
+		i2c_devs->i2c_client = i2c_new_device(
+					i2c_get_adapter(i2c_devs->bus),
+						&i2c_devs->board_info);
+		ssleep(1);
+	}
+	return 0;
+}
+
+static int intel_hddl_xlink_i2c_clients(struct device *dev,
+				struct intel_hddl_clients *c,
+				struct intel_hddl_i2c_devs **i2c_devs,
+				int n_slaves, int remote)
+{
+	int i, ret;
+
+	for (i = 0; i < n_slaves; i++) {
+		if (remote) {
+			ret = intel_hddl_remote_xlink_slave(dev,
+					c, i2c_devs[i]);
+		} else {
+			ret = intel_hddl_xlink_slave(dev,
+					c, i2c_devs[i]);
+		}
+	}
+
+	return ret;
+}
+
+static int intel_hddl_xlink_i2c_adap(struct device *dev,
+		struct intel_hddl_clients *c)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		struct platform_device_info xlink_i2c_info;
+		int soc_id = c->board_info.soc_id;
+
+		memset(&xlink_i2c_info, 0, sizeof(xlink_i2c_info));
+		xlink_i2c_info.name = "i2c_xlink";
+		xlink_i2c_info.id = c->board_info.board_id << 4 |
+					soc_id << 2 | i;
+		c->xlink_i2c_ch[i] =
+			c->i2c_chan_num + (soc_id * 2) + i;
+		xlink_i2c_info.data = c;
+		xlink_i2c_info.size_data =
+			sizeof(struct intel_hddl_clients);
+		c->xlink_i2c_plt_dev[i] =
+			platform_device_register_full(&xlink_i2c_info);
+		if (!c->xlink_i2c_plt_dev[i]) {
+			dev_err(dev, "platform device register failed\n");
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+static struct intel_hddl_clients **intel_hddl_get_device(int *ndevs);
+
+static void intel_hddl_device_probe(struct intel_hddl_clients *d)
+{
+	char device_name[XLINK_MAX_DEVICE_NAME_SIZE];
+
+	if (d->status == HDDL_DEV_STATUS_CONNECTED)
+		return;
+	xlink_get_device_name((&d->xlink_dev),
+		device_name, XLINK_MAX_DEVICE_NAME_SIZE);
+	d->hddl_dev_connect_task = kthread_run(
+			(intel_hddl_connect_task)d->task,
+			(void *)d,
+			device_name);
+	if (!d->hddl_dev_connect_task) {
+		pr_err("failed to create thread\n");
+		return;
+	}
+	d->status = HDDL_DEV_STATUS_CONNECTED;
+}
+
+static int intel_hddl_unregister_pdev(struct intel_hddl_clients *c);
+
+static void intel_hddl_device_remove(struct intel_hddl_clients *d)
+{
+	int k, rc;
+
+	mutex_lock(&d->lock);
+	if (d->status == HDDL_DEV_STATUS_DISCONNECTED) {
+		mutex_unlock(&d->lock);
+		return;
+	}
+
+	for (k = 0; k < d->n_slaves; k++) {
+		struct intel_hddl_i2c_devs *i2c_dev =
+			d->i2c_devs[k];
+
+		if (i2c_dev->xlk_client) {
+			pr_info("HDDL: unregistering %s\n",
+					i2c_dev->xlk_client->name);
+			i2c_unregister_device(i2c_dev->xlk_client);
+			pr_info("HDDL: unregistered\n");
+		}
+		if (i2c_dev->i2c_client) {
+			pr_info("HDDL: unregistering %s\n",
+					i2c_dev->i2c_client->name);
+			i2c_unregister_device(i2c_dev->i2c_client);
+			pr_info("HDDL: unregistered\n");
+		}
+		if (i2c_dev->smbus_client) {
+			pr_info("HDDL: unregistering %s\n",
+					i2c_dev->smbus_client->name);
+			i2c_unregister_device(i2c_dev->smbus_client);
+			pr_info("HDDL: unregistered\n");
+		}
+		i2c_dev->xlk_client = NULL;
+		i2c_dev->i2c_client = NULL;
+		i2c_dev->smbus_client = NULL;
+	}
+	pr_info("HDDL:i2c slaves unregisterd\n");
+
+	intel_hddl_unregister_pdev(d);
+
+	pr_info("HDDL: platform device unregistered\n");
+	rc = xlink_close_channel(&d->xlink_dev, d->chan_num);
+
+	rc = xlink_disconnect(&d->xlink_dev);
+	kthread_stop(d->hddl_dev_connect_task);
+	d->status = HDDL_DEV_STATUS_DISCONNECTED;
+	pr_info("HDDL: device status %d\n",
+			d->status);
+	mutex_unlock(&d->lock);
+}
+
+static int intel_hddl_device_pcie_event_notify(uint32_t sw_device_id,
+				enum _xlink_device_event_type event_type)
+{
+	/*TODO: XLINK should pass private ptr*/
+	int ndevs = 0;
+	struct intel_hddl_clients **c = intel_hddl_get_device(&ndevs);
+	struct intel_hddl_clients *d = NULL;
+	int i;
+
+	pr_info("HDDL:xlink pcie notify[%x]: [%d]\n",
+			sw_device_id, event_type);
+	if (!c)
+		return 0;
+	for (i = 0; i < ndevs; i++) {
+		if (c[i]->xlink_dev.sw_device_id == sw_device_id) {
+			d = c[i];
+			break;
+		}
+	}
+	if (!d)
+		return 0;
+	switch (event_type) {
+	case _NOTIFY_INCOMING_DISCONNECTION:
+	case _NOTIFY_DEVICE_DISCONNECTED:
+	case _ERROR_UNEXPECTED_DISCONNECTION:
+		intel_hddl_device_remove(d);
+		break;
+
+	case _NOTIFY_DEVICE_CONNECTED:
+		intel_hddl_device_probe(d);
+		break;
+
+	default:
+		pr_info("HDDL:xlink pcie notify - Error[%x]: [%d]\n",
+				sw_device_id, event_type);
+		break;
+	}
+	return 0;
+}
+
+static inline int intel_hddl_open_xlink_device(struct device *dev,
+		struct intel_hddl_clients *d)
+{
+	char device_name[XLINK_MAX_DEVICE_NAME_SIZE];
+	uint32_t device_status = 0xFF;
+	int rc;
+
+	dev_info(dev, "intel_hddl_device_connect_task\n");
+	mutex_init(&d->lock);
+	rc = xlink_get_device_name(&d->xlink_dev,
+		device_name, XLINK_MAX_DEVICE_NAME_SIZE);
+	if (rc > 0) {
+		dev_err(dev,
+		"HDDL:Failed to get device name of id [EC%d] %x\n",
+		rc, d->xlink_dev.sw_device_id);
+		return -ENODEV;
+	}
+	dev_info(dev, "HDDL:Device name: %x %s\n",
+		d->xlink_dev.sw_device_id, device_name);
+	while (xlink_boot_device(&d->xlink_dev, device_name) !=
+				X_LINK_SUCCESS) {
+		msleep_interruptible(1000);
+		if (kthread_should_stop())
+			return -ENODEV;
+	}
+	while (xlink_get_device_status(&d->xlink_dev, &device_status) !=
+				X_LINK_SUCCESS) {
+		msleep_interruptible(1000);
+		if (kthread_should_stop())
+			return -ENODEV;
+	}
+	dev_info(dev, "HDDL:Device status %u\n", device_status);
+	while (xlink_connect(&d->xlink_dev) != X_LINK_SUCCESS) {
+		msleep_interruptible(1000);
+		if (kthread_should_stop())
+			return -ENODEV;
+	}
+	dev_info(dev, "HDDL:Channel Number[%x]: %u\n",
+			d->xlink_dev.sw_device_id,
+				d->chan_num);
+
+	xlink_pcie_register_device_event(d->xlink_dev.sw_device_id,
+					hddl_xlink_device_events,
+					_NUM_EVENT_TYPE,
+					intel_hddl_device_pcie_event_notify,
+					0);
+
+	d->status = HDDL_DEV_STATUS_CONNECTED;
+	while (xlink_open_channel(&d->xlink_dev,
+				d->chan_num, RXB_TXB,
+				64 * 1024, 0 /* timeout */) !=
+				X_LINK_SUCCESS) {
+		msleep_interruptible(1000);
+		if (kthread_should_stop()) {
+			xlink_disconnect(&d->xlink_dev);
+			return -ENODEV;
+		}
+	}
+	dev_info(dev, "HDDL: xlink_open_channel completed\n");
+
+	return 0;
+}
+
+
+#endif /* _LINUX_HDDL_DEVICE_HELPER_H */
diff --git a/drivers/misc/hddl_device/hddl_device_server.c b/drivers/misc/hddl_device/hddl_device_server.c
new file mode 100644
index 000000000000..a4019303e5b7
--- /dev/null
+++ b/drivers/misc/hddl_device/hddl_device_server.c
@@ -0,0 +1,698 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * HDDL Device Kernel module.
+ *
+ * Copyright (C) 2019-2020 Intel Corporation
+ */
+
+#include <asm/page.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/printk.h>
+#include <uapi/linux/stat.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of_device.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/xlink.h>
+#include <linux/time.h>
+#include <linux/kmod.h>
+#include <linux/i2c.h>
+#include <linux/sched.h>
+#include <linux/sched/mm.h>
+#include <linux/sched/task.h>
+#include <linux/hddl_device.h>
+#include <linux/ioctl.h>
+#include <linux/uaccess.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include <linux/thermal.h>
+#include <linux/hddl_device.h>
+#include <linux/intel_tsens_host.h>
+#include "hddl_device_helper.h"
+
+#define DRIVER_NAME "hddl_device_server"
+
+#define HDDL_NODE_XLINK_CHANNEL 1080
+#define HDDL_I2C_XLINK_CHANNEL 1081
+
+struct intel_hddl_server_plat_data {
+	uint32_t xlink_chan;
+	uint32_t i2c_xlink_chan;
+};
+
+struct intel_hddl_device_priv {
+	uint32_t xlink_chan;
+	uint32_t i2c_xlink_chan;
+	struct mutex lock;
+	struct platform_device *pdev;
+	uint32_t n_hddl_devs;
+	struct intel_hddl_clients **hddl_client;
+	struct task_struct *hddl_dev_init_task;
+	struct intel_hddl_server_plat_data *plat_data;
+	dev_t cdev;
+	struct class *dev_class;
+	struct cdev hddl_cdev;
+};
+
+static struct intel_hddl_device_priv *g_priv;
+
+static struct intel_hddl_clients **intel_hddl_get_device(int *n_devs)
+{
+	if (!g_priv)
+		return NULL;
+	*n_devs = g_priv->n_hddl_devs;
+	return g_priv->hddl_client;
+}
+
+static long hddl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct intel_hddl_device_priv *priv = file->private_data;
+	struct intel_hddl_clients **c = NULL;
+	struct intel_hddl_clients *d = NULL;
+	int i, rc = 0;
+	T_SW_ID_HDDL_DATA swid_data = {0};
+	T_SW_ID_SOFT_RESET soft_reset = {0};
+
+	if ((int32_t *)arg == NULL) {
+		pr_err("HDDL: Null pointer from user\n");
+		return -EINVAL;
+	}
+	if (!priv) {
+		pr_err("HDDL: Device ioctl failed\n");
+		return -ENODEV;
+	}
+	c = priv->hddl_client;
+	if (!c) {
+		pr_err("HDDL: Device ioctl failed\n");
+		return -ENODEV;
+	}
+	switch (cmd) {
+	case HDDL_SOFT_RESET:
+		if (copy_from_user(&soft_reset,
+				(int32_t *)arg, sizeof(T_SW_ID_SOFT_RESET)))
+			return -EFAULT;
+		for (i = 0; i < priv->n_hddl_devs; i++) {
+			if (c[i]->xlink_dev.sw_device_id ==
+					soft_reset.sw_id) {
+				d = c[i];
+				break;
+			}
+		}
+
+		if (!d) {
+			pr_err("HDDL: Device ioctl failed\n");
+			return -ENODEV;
+		}
+		/* xlink-reset */
+		rc =  xlink_reset_device(&d->xlink_dev);
+		if (rc > 0)
+			pr_err("HDDL : xlink_reset_device failed");
+		else
+			soft_reset.return_id = 1;
+		if (copy_to_user((T_SW_ID_SOFT_RESET *) arg,
+				&soft_reset, sizeof(T_SW_ID_SOFT_RESET)))
+			return -EFAULT;
+		/* xlink-rest */
+		break;
+	case HDDL_READ_SW_ID_DATA:
+		if (copy_from_user(&swid_data, (int32_t *)arg,
+			sizeof(T_SW_ID_HDDL_DATA)))
+			return -EFAULT;
+		for (i = 0; i < priv->n_hddl_devs; i++) {
+			if (c[i]->xlink_dev.sw_device_id ==
+					swid_data.sw_id) {
+				d = c[i];
+				break;
+			}
+		}
+
+		swid_data.board_id = d->board_info.board_id;
+		swid_data.soc_id = d->board_info.soc_id;
+		if (d->adap[0])
+			swid_data.soc_adaptor_no[0] = d->adap[0]->nr;
+		if (d->adap[1])
+			swid_data.soc_adaptor_no[1] = d->adap[1]->nr;
+		swid_data.return_id = 1;
+		if (copy_to_user((T_SW_ID_HDDL_DATA *) arg,
+				&swid_data, sizeof(T_SW_ID_HDDL_DATA)))
+			return -EFAULT;
+		break;
+	}
+	return 0;
+}
+
+int hddl_open(struct inode *inode, struct file *filp)
+{
+	struct intel_hddl_device_priv *priv;
+
+	priv = container_of(inode->i_cdev,
+			struct intel_hddl_device_priv, hddl_cdev);
+	if (!priv) {
+		pr_err("HDDL: Device open failed\n");
+		return -ENODEV;
+	}
+	filp->private_data = priv;
+	return 0;
+}
+
+static const struct file_operations hddl_fops = {
+	.owner	= THIS_MODULE,
+	.open = hddl_open,
+	.unlocked_ioctl = hddl_ioctl,
+};
+
+
+static int intel_hddl_cdev_init(struct intel_hddl_device_priv *priv)
+{
+	/*Allocating Major number*/
+	if ((alloc_chrdev_region(&priv->cdev, 0, 1, "Hddl_Dev")) < 0) {
+		pr_err("Cannot allocate major number\n");
+		return -EINVAL;
+	}
+	pr_info("Major = %d Minor = %d\n", MAJOR(priv->cdev),
+			MINOR(priv->cdev));
+	/*Creating cdev structure*/
+	cdev_init(&priv->hddl_cdev, &hddl_fops);
+	/*Adding character device to the system*/
+	if ((cdev_add(&priv->hddl_cdev, priv->cdev, 1)) < 0) {
+		pr_err("Cannot add the device to the system\n");
+		goto r_class;
+	}
+	/*Creating struct class*/
+	priv->dev_class = class_create(THIS_MODULE, "hddl_class");
+	if (priv->dev_class == NULL) {
+		pr_err("Cannot create the struct class\n");
+		goto r_class;
+	}
+	/*Creating device*/
+	if ((device_create(priv->dev_class, NULL, priv->cdev, NULL,
+					"hddl_device")) == NULL) {
+		pr_err("Cannot create the Device 1\n");
+		goto r_device;
+	}
+	return 0;
+r_device:
+	class_destroy(priv->dev_class);
+r_class:
+	unregister_chrdev_region(priv->cdev, 1);
+	return -EINVAL;
+}
+
+static void intel_hddl_cdev_remove(struct intel_hddl_device_priv *priv)
+{
+	device_destroy(priv->dev_class, priv->cdev);
+	class_destroy(priv->dev_class);
+	unregister_chrdev_region(priv->cdev, 1);
+}
+
+static int intel_hddl_unregister_pdev(struct intel_hddl_clients *c)
+{
+	struct intel_hddl_device_priv *priv = c->pdata;
+
+	intel_hddl_xlink_remove_i2c_adap(&priv->pdev->dev, c);
+	return 0;
+
+}
+
+static int host_reserved_addr[] = {
+	0x42,
+	0x52,
+	0x54,
+	0x60
+};
+
+static int hddl_get_free_slave(struct intel_hddl_i2c_devs **i2c_devs,
+				int count)
+{
+	static int current_addr = 0x10;
+	int i;
+	/*Reserved: 0x00 - 0x0f
+	 *           0xf0 - 0xff
+	 */
+	for (i = 0;
+	i < ARRAY_SIZE(host_reserved_addr); i++) {
+		if (current_addr == host_reserved_addr[i])
+			current_addr++;
+		else
+			break;
+	}
+	for (i = 0; i < count; i++) {
+		if ((i2c_devs[i]->addr & (1 << 30)) ||
+			(i2c_devs[i]->addr == 0)) {
+			continue;
+		} else if (i2c_devs[i]->addr == current_addr) {
+			current_addr++;
+			continue;
+		}
+	}
+	return current_addr++;
+}
+
+static int intel_hddl_i2c_clients(struct device *dev,
+				struct intel_hddl_clients *c)
+{
+	int rc;
+	struct intel_hddl_tsens_msg msg;
+	int ndevs, size, i;
+	struct intel_hddl_device_priv *priv = c->pdata;
+	struct xlink_handle *xlink = &c->xlink_dev;
+	struct intel_hddl_i2c_devs **i2c_devs;
+
+	/* Get N I2C devices */
+	msg.msg_type = HDDL_GET_N_I2C_DEVS;
+	rc = xlink_write_volatile(xlink, c->chan_num,
+					(uint8_t *)&msg, sizeof(msg));
+	rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+	(uint8_t *) &ndevs, &size);
+	dev_info(dev, "Number of i2c devices %d\n", ndevs);
+	xlink_release_data(xlink, c->chan_num, NULL);
+	c->n_slaves = ndevs;
+	i2c_devs = devm_kzalloc(dev,
+			(sizeof(struct intel_hddl_i2c_devs *) * ndevs),
+			GFP_KERNEL);
+	if (!i2c_devs) {
+		dev_err(dev, "Memory alloc failed\n");
+		return -ENOMEM;
+	}
+	c->i2c_devs = i2c_devs;
+	for (i = 0; i < ndevs; i++) {
+		struct intel_hddl_i2c_devs *i2c;
+		struct intel_hddl_i2c_devs_data i2c_data;
+
+		i2c = devm_kzalloc(dev,
+				sizeof(struct intel_hddl_i2c_devs),
+				GFP_KERNEL);
+		if (!i2c) {
+			dev_err(dev, "Memory alloc failed\n");
+			return -ENOMEM;
+		}
+		i2c_devs[i] = i2c;
+
+		/* Get Details*/
+		msg.msg_type = HDDL_GET_I2C_DEVS;
+		msg.index = i;
+		rc = xlink_write_volatile(xlink, c->chan_num,
+					(uint8_t *)&msg, sizeof(msg));
+		rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+		(uint8_t *)&i2c_data, &size);
+		strcpy(i2c->name, i2c_data.name);
+		i2c->addr = i2c_data.addr;
+		i2c->bus = i2c_data.bus;
+		i2c->enabled = i2c_data.enabled;
+		i2c->local_host = i2c_data.local_host;
+		i2c->remote_host = i2c_data.remote_host;
+		dev_info(dev, "i2c slave: [%d] [%s]\n", i, i2c->name);
+		xlink_release_data(xlink, c->chan_num, NULL);
+	}
+
+	mutex_lock(&priv->lock);
+	for (i = 0; i < ndevs; i++) {
+		if (i2c_devs[i]->addr & (1<<30)) {
+			i2c_devs[i]->addr = hddl_get_free_slave(i2c_devs,
+					ndevs);
+			dev_info(dev, "Slave addr for [%s] [%d]",
+					i2c_devs[i]->name,
+					i2c_devs[i]->addr);
+		}
+		strcpy(i2c_devs[i]->board_info.type,
+				i2c_devs[i]->name);
+		i2c_devs[i]->board_info.addr = i2c_devs[i]->addr;
+	}
+	mutex_unlock(&priv->lock);
+	/* Send Complete */
+	msg.msg_type = HDDL_GET_SENS_COMPLETE;
+	rc = xlink_write_volatile(xlink, c->chan_num,
+				(uint8_t *)&msg, sizeof(msg));
+	mutex_lock(&priv->lock);
+
+	/* Get msg type */
+	rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+	(uint8_t *) &msg, &size);
+	xlink_release_data(xlink, c->chan_num, NULL);
+	while (msg.msg_type != HDDL_GET_SENS_COMPLETE) {
+		switch (msg.msg_type) {
+		case HDDL_GET_I2C_DEV_ADDR:
+		{
+			i = msg.index;
+			rc = xlink_write_volatile(xlink, c->chan_num,
+			(uint8_t *)&i2c_devs[i]->addr,
+			sizeof(i2c_devs[i]->addr));
+		}
+		break;
+		default:
+			break;
+		}
+		rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+					(uint8_t *) &msg, &size);
+		xlink_release_data(xlink, c->chan_num, NULL);
+	}
+	rc = intel_hddl_xlink_i2c_clients(dev, c, c->i2c_devs,
+			c->n_slaves, 1);
+	if (rc) {
+		dev_err(dev, "HDDL: register i2c slaves failed\n");
+		return -EINVAL;
+	}
+	mutex_unlock(&priv->lock);
+	return 0;
+}
+
+static int intel_hddl_tsens_data(struct intel_hddl_clients *c)
+{
+	int rc;
+	struct intel_hddl_device_priv *priv = c->pdata;
+	struct xlink_handle *xlink = &c->xlink_dev;
+	uint32_t size, i, j;
+	uint32_t nsens;
+	struct intel_hddl_tsens_msg msg;
+	struct intel_tsens_host **p_tsens;
+
+	/* Get Nsens */
+	msg.msg_type = HDDL_GET_NSENS;
+	rc = xlink_write_volatile(xlink, c->chan_num,
+					(uint8_t *)&msg, sizeof(msg));
+	rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+	(uint8_t *) &nsens, &size);
+	dev_info(&priv->pdev->dev, "Number of sensors %d\n", nsens);
+	xlink_release_data(xlink, c->chan_num, NULL);
+	c->nsens = nsens;
+	p_tsens = devm_kzalloc(&priv->pdev->dev,
+			(sizeof(struct intel_tsens_host *) * nsens),
+			GFP_KERNEL);
+	if (!p_tsens) {
+		dev_err(&priv->pdev->dev, "Memory alloc failed\n");
+		return -ENOMEM;
+	}
+	c->tsens = (void **)p_tsens;
+	for (i = 0; i < nsens; i++) {
+		struct intel_tsens_host *tsens;
+		struct intel_tsens_data *tsens_data;
+
+		tsens = devm_kzalloc(&priv->pdev->dev,
+				sizeof(struct intel_tsens_host),
+				GFP_KERNEL);
+		if (!tsens) {
+			dev_err(&priv->pdev->dev, "Memory alloc failed\n");
+			return -ENOMEM;
+		}
+		tsens_data = devm_kzalloc(&priv->pdev->dev,
+				sizeof(struct intel_tsens_data),
+				GFP_KERNEL);
+		if (!tsens_data) {
+			dev_err(&priv->pdev->dev, "Memory alloc failed\n");
+			return -ENOMEM;
+		}
+		tsens->t_data = tsens_data;
+
+		/* Get Details*/
+		msg.msg_type = HDDL_GET_SENS_DETAILS;
+		msg.index = i;
+		rc = xlink_write_volatile(xlink, c->chan_num,
+					(uint8_t *)&msg, sizeof(msg));
+		rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+		(uint8_t *) tsens_data, &size);
+		dev_info(&priv->pdev->dev, "sensor[%d]: %s\n", i,
+				tsens_data->name);
+		xlink_release_data(xlink, c->chan_num, NULL);
+
+		/* Get trip info*/
+		tsens->trip_info =
+			devm_kzalloc(
+				&priv->pdev->dev,
+				(sizeof(struct intel_tsens_host_trip_info *) *
+				tsens_data->n_trips),
+				GFP_KERNEL);
+		if (!tsens->trip_info) {
+			dev_err(&priv->pdev->dev, "Memory alloc failed\n");
+			return -ENOMEM;
+		}
+		for (j = 0; j < tsens_data->n_trips; j++) {
+			struct intel_tsens_host_trip_info *t_info;
+
+			t_info = devm_kzalloc(&priv->pdev->dev,
+				sizeof(struct intel_tsens_host_trip_info),
+				GFP_KERNEL);
+			if (!t_info) {
+				dev_err(&priv->pdev->dev, "Memory alloc failed\n");
+				return -ENOMEM;
+			}
+			tsens->trip_info[j] = t_info;
+			msg.msg_type = HDDL_GET_SENS_TRIP_INFO;
+			msg.index = i;
+			msg.index2 = j;
+			rc = xlink_write_volatile(xlink, c->chan_num,
+					(uint8_t *)&msg, sizeof(msg));
+			rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+				(uint8_t *) t_info, &size);
+			dev_info(&priv->pdev->dev, "trip[%d]: type %d temp %d\n",
+					j, t_info->trip_type, t_info->temp);
+			xlink_release_data(xlink, c->chan_num, NULL);
+		}
+		p_tsens[i] = tsens;
+	}
+	/* Send Complete */
+	msg.msg_type = HDDL_GET_SENS_COMPLETE;
+	rc = xlink_write_volatile(xlink, c->chan_num,
+				(uint8_t *)&msg, sizeof(msg));
+
+	return 0;
+}
+
+static int intel_hddl_device_connect_task(void *data)
+{
+	struct intel_hddl_clients *c = (struct intel_hddl_clients *)data;
+	struct intel_hddl_device_priv *priv = c->pdata;
+	struct timespec64 ts;
+	uint32_t size, rc;
+	struct xlink_handle *xlink = &c->xlink_dev;
+	struct intel_hddl_board_info board_info_rcvd;
+
+	c->chan_num = priv->xlink_chan;
+	c->i2c_chan_num = priv->i2c_xlink_chan;
+	if (intel_hddl_open_xlink_device(&priv->pdev->dev, c)) {
+		dev_err(&priv->pdev->dev, "HDDL open xlink dev failed\n");
+		return -ENODEV;
+	}
+	ktime_get_real_ts64(&ts);
+	dev_info(&priv->pdev->dev, "S[%llx] NS[%lx]\n", ts.tv_sec, ts.tv_nsec);
+	rc = xlink_write_volatile(xlink, c->chan_num, (uint8_t *) &ts,
+			sizeof(struct timespec64));
+	dev_dbg(&priv->pdev->dev, "HDDL: Size Transferred[%d] = %ld\n",
+			rc, sizeof(struct timespec64));
+
+	dev_dbg(&priv->pdev->dev, "HDDL: xlink_read_data to start...\n");
+	size = sizeof(c->board_info);
+	rc = xlink_read_data_to_buffer(xlink, c->chan_num,
+	(uint8_t *)&c->board_info, &size);
+	xlink_release_data(xlink, c->chan_num, NULL);
+	dev_dbg(&priv->pdev->dev, "HDDL: xlink_read_data completed Rcvd Size[%d][%d]\n",
+	rc, size);
+
+	board_info_rcvd.board_id = ~(c->board_info.board_id);
+	dev_info(&priv->pdev->dev, "HDDL: xlink_write_data to start...\n");
+	rc = xlink_write_volatile(xlink, c->chan_num,
+			(uint8_t *)&board_info_rcvd,
+			sizeof(board_info_rcvd));
+	dev_dbg(&priv->pdev->dev, "HDDL: xlink_write_data complete.[%d]\n",
+			rc);
+	dev_dbg(&priv->pdev->dev, "HDDL: Board Info[%x %x]",
+					c->board_info.board_id,
+					board_info_rcvd.board_id);
+	dev_info(&priv->pdev->dev, "HDDL: Board[%x] Soc[%x] DevType[%x]\n",
+		c->board_info.board_id,
+		c->board_info.soc_id,
+		xlink->dev_type
+	);
+	rc = intel_hddl_tsens_data(c);
+	if (rc) {
+		dev_err(&priv->pdev->dev, "HDDL: tsens data not rcvd\n");
+		return -EINVAL;
+	}
+	rc = intel_hddl_xlink_i2c_adap(&priv->pdev->dev, c);
+	if (rc) {
+		dev_err(&priv->pdev->dev,
+				"HDDL: register xlink i2c adapter failed\n");
+		return -EINVAL;
+	}
+	rc = intel_hddl_i2c_clients(&priv->pdev->dev, c);
+	if (rc) {
+		dev_err(&priv->pdev->dev,
+				"HDDL: register i2c slaves failed\n");
+		return -EINVAL;
+	}
+	while (!kthread_should_stop())
+		msleep_interruptible(2000);
+
+	return 0;
+}
+
+static int intel_hddl_check_for_new_device(struct intel_hddl_device_priv *priv)
+{
+	priv->hddl_client = intel_hddl_setup_device(&priv->pdev->dev,
+				intel_hddl_device_connect_task,
+				&priv->n_hddl_devs, priv->hddl_client, priv);
+
+	if (priv->hddl_client == NULL) {
+		dev_err(&priv->pdev->dev,
+				"intel_hddl_setup_device returned NULL\n");
+		return 0;
+	}
+
+	return (priv->hddl_client != NULL)?1:0;
+}
+
+static int intel_hddl_device_init_task(void *data)
+{
+	struct intel_hddl_device_priv *priv =
+		(struct intel_hddl_device_priv *)data;
+
+	while (!kthread_should_stop()) {
+		if (!intel_hddl_check_for_new_device(priv)) {
+			dev_err(&priv->pdev->dev, "intel_hddl_setup_device returned NULL\n");
+			break;
+		}
+		msleep_interruptible(2000);
+	}
+	dev_err(&priv->pdev->dev, "Setup HDDL client devices failed\n");
+
+	return 0;
+}
+
+static int intel_hddl_device_init(struct intel_hddl_device_priv *priv)
+{
+	priv->hddl_dev_init_task = kthread_run(intel_hddl_device_init_task,
+						(void *)priv,
+						"hddl_device_init");
+	if (!priv->hddl_dev_init_task) {
+		dev_err(&priv->pdev->dev, "failed to create thread\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int intel_hddl_server_probe(struct platform_device *pdev)
+{
+	struct intel_hddl_device_priv *priv;
+	struct intel_hddl_server_plat_data *plat_data;
+	int ret;
+
+	plat_data = pdev->dev.platform_data;
+	if (!plat_data) {
+		dev_err(&pdev->dev, "Platform data not found\n");
+		return -EINVAL;
+	}
+
+	priv = devm_kzalloc(&pdev->dev,
+				sizeof(struct intel_hddl_device_priv),
+				GFP_KERNEL);
+	if (priv == NULL) {
+		dev_err(&pdev->dev, "No memory");
+		return -ENOMEM;
+	}
+	priv->pdev = pdev;
+	priv->plat_data = plat_data;
+	priv->xlink_chan = plat_data->xlink_chan;
+	priv->i2c_xlink_chan = plat_data->i2c_xlink_chan;
+	mutex_init(&priv->lock);
+	g_priv = priv;
+	platform_set_drvdata(pdev, priv);
+	ret = intel_hddl_device_init(priv);
+	if (ret) {
+		dev_err(&pdev->dev, "HDDL device init failed\n");
+		devm_kfree(&pdev->dev, priv);
+		return -EINVAL;
+	}
+	ret = intel_hddl_cdev_init(priv);
+	if (ret) {
+		dev_err(&pdev->dev, "HDDL char device init failed\n");
+		devm_kfree(&pdev->dev, priv);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* Device Exit */
+static int intel_hddl_server_remove(struct platform_device *pdev)
+{
+	int k;
+	struct intel_hddl_device_priv *priv = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev,
+		"%s Entry\n", __func__);
+	if (!priv)
+		return -EINVAL;
+	intel_hddl_cdev_remove(priv);
+	for (k = 0; k < priv->n_hddl_devs; k++) {
+		struct intel_hddl_clients *d = priv->hddl_client[k];
+
+		intel_hddl_device_remove(d);
+	}
+	kthread_stop(priv->hddl_dev_init_task);
+	dev_info(&pdev->dev,
+		"%s Exit\n", __func__);
+
+	return 0;
+}
+
+static struct platform_driver intel_hddl_server_driver = {
+	.probe = intel_hddl_server_probe,
+	.remove = intel_hddl_server_remove,
+	.driver = {
+		.name = "intel_hddl_server",
+	},
+};
+
+static struct platform_device *intel_hddl_server_pdev;
+
+static void intel_hddl_server_exit(void)
+{
+	pr_info("HDDL:hddl_device_exit\n");
+	platform_driver_unregister(&intel_hddl_server_driver);
+	platform_device_unregister(intel_hddl_server_pdev);
+}
+
+static int __init intel_hddl_server_init(void)
+{
+	int ret;
+	struct platform_device_info pdevinfo;
+	struct platform_device *dd;
+	struct intel_hddl_server_plat_data plat;
+
+	ret = platform_driver_register(&intel_hddl_server_driver);
+	if (ret) {
+		pr_err("HDDL: platform driver register failed\n");
+		return -EINVAL;
+	}
+	memset(&pdevinfo, 0, sizeof(pdevinfo));
+	pdevinfo.name = "intel_hddl_server";
+	pdevinfo.data = &plat;
+	plat.xlink_chan = HDDL_NODE_XLINK_CHANNEL;
+	plat.i2c_xlink_chan = HDDL_I2C_XLINK_CHANNEL;
+	pdevinfo.size_data = sizeof(struct  intel_hddl_server_plat_data);
+	dd = platform_device_register_full(&pdevinfo);
+	if (IS_ERR(dd)) {
+		pr_err("HDDL: platform device register failed\n");
+		return -EINVAL;
+	}
+	intel_hddl_server_pdev = dd;
+	return 0;
+}
+
+module_init(intel_hddl_server_init);
+module_exit(intel_hddl_server_exit);
+
+MODULE_DESCRIPTION("KeemBay HDDL Device driver");
+MODULE_AUTHOR("Raja Subramanian, Lakshmi Bai"
+	      "<lakshmi.bai.raja.subramanian@intel.com>");
+MODULE_AUTHOR("Sandeep Singh <sandeep1.singh@intel.com>");
+MODULE_AUTHOR("Vaidya, Mahesh R <mahesh.r.vaidya@intel.com>");
+MODULE_AUTHOR("Udhayakumar C <udhayakumar.c@intel.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/host_kmb_tj/Kconfig b/drivers/misc/host_kmb_tj/Kconfig
deleted file mode 100644
index 7e2b18d33ba5..000000000000
--- a/drivers/misc/host_kmb_tj/Kconfig
+++ /dev/null
@@ -1,9 +0,0 @@
-#
-# kConfig for KeemBay Thermal Linux driver
-#
-
-config HOST_KMB_TJ
-	tristate "IA Host Keembay Tj Driver"
-	default m
-	help
-	  Enable this option to get the KMB Tj in the IA host
diff --git a/drivers/misc/host_kmb_tj/Makefile b/drivers/misc/host_kmb_tj/Makefile
deleted file mode 100644
index 3cd38e36e17e..000000000000
--- a/drivers/misc/host_kmb_tj/Makefile
+++ /dev/null
@@ -1,5 +0,0 @@
-#
-# Makefile for KeemBay Thermal Linux driver
-#
-
-obj-$(CONFIG_HOST_KMB_TJ)	+= host_kmb_tj.o
diff --git a/drivers/misc/host_kmb_tj/keembay_tsens_host.h b/drivers/misc/host_kmb_tj/keembay_tsens_host.h
deleted file mode 100644
index 530a64410205..000000000000
--- a/drivers/misc/host_kmb_tj/keembay_tsens_host.h
+++ /dev/null
@@ -1,60 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Keembay Temperature sensor module.
- *
- * Copyright (C) 2019-2020 Intel Corporation.
- */
-
-#ifndef _LINUX_KEEMBAY_TSENS_HOST_H
-#define _LINUX_KEEMBAY_TSENS_HOST_H
-
-#include <linux/thermal.h>
-
-
-enum keembay_thermal_trip {
-	KEEMBAY_TRIP_ACTIVE,
-	KEEMBAY_TRIP_PASSIVE,
-	KEEMBAY_TRIP_CRITICAL,
-	KEEMBAY_TRIP_NUM,
-};
-
-enum keembay_thermal_sensor_en {
-	KEEMBAY_SENSOR_MSS,
-	KEEMBAY_SENSOR_CSS,
-	KEEMBAY_SENSOR_NCE,
-	KEEMBAY_SENSOR_SOC,
-	KEEMBAY_SENSOR_MSS_HOST,
-	KEEMBAY_SENSOR_CSS_HOST,
-	KEEMBAY_SENSOR_NCE_HOST,
-	KEEMBAY_SENSOR_SOC_HOST
-};
-
-struct kmb_trip_info_st {
-	enum thermal_trip_type trip_type;
-	int temperature;
-};
-
-
-struct keembay_therm_info {
-	struct i2c_client *i2c_c;
-	struct i2c_adapter *host_kmb_tj_adap;
-	spinlock_t lock;
-	struct device *dev;
-	int temperature;
-};
-
-
-#define HOST_KEEMBAY_MAX_TRIP_INFO 10
-struct kmb_trip_point_info {
-	enum keembay_thermal_sensor_en sensor_type;
-	const char *sensor_name;
-	int n_trips;
-	int passive_delay;
-	int polling_delay;
-	struct kmb_trip_info_st trip_info[HOST_KEEMBAY_MAX_TRIP_INFO];
-	struct keembay_therm_info *thermal_info;
-	struct thermal_zone_device *tz;
-	int kmb_address;
-};
-
-#endif /* _LINUX_KEEMBAY_TSENS_HOST_H */
diff --git a/drivers/misc/intel_tsens/Kconfig b/drivers/misc/intel_tsens/Kconfig
new file mode 100644
index 000000000000..d1a8df742931
--- /dev/null
+++ b/drivers/misc/intel_tsens/Kconfig
@@ -0,0 +1,31 @@
+config INTEL_TSENS
+	tristate "Temperature sensor driver for intel tsens"
+	default y
+	depends on XLINK_CORE
+	help
+	  Enable this option if you want to have support for thermal management
+	  controller
+
+config INTEL_TSENS_HOST
+	tristate "Temperature sensor driver for intel tsens remote host"
+	default y
+	depends on XLINK_CORE
+	help
+	  Enable this option if you want to have support for thermal management
+	  controller
+
+config KEEMBAY_THERMAL
+	tristate "Temperature sensor driver for intel keembay"
+	default y
+	depends on XLINK_CORE
+	help
+	  Enable this option if you want to have support for thermal management
+	  controller present in Keembay
+
+config KEEMBAY_COOLING
+	tristate "dummy cooling driver for intel keembay"
+	default y
+	depends on XLINK_CORE
+	help
+	  Enable this option if you want to have support for thermal management
+	  controller present in Keembay
diff --git a/drivers/misc/intel_tsens/Makefile b/drivers/misc/intel_tsens/Makefile
new file mode 100644
index 000000000000..6fadcc47b287
--- /dev/null
+++ b/drivers/misc/intel_tsens/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for KeemBay Thermal Linux driver
+#
+
+obj-$(CONFIG_INTEL_TSENS)       += intel_tsens_thermal.o
+obj-$(CONFIG_INTEL_TSENS_HOST) 	+= intel_tsens_host.o
+obj-$(CONFIG_KEEMBAY_THERMAL)	+= keembay_thermal.o
+obj-$(CONFIG_KEEMBAY_THERMAL)	+= keembay_cooling.o
diff --git a/drivers/misc/intel_tsens/intel_tsens_host.c b/drivers/misc/intel_tsens/intel_tsens_host.c
new file mode 100644
index 000000000000..ac2803fef650
--- /dev/null
+++ b/drivers/misc/intel_tsens/intel_tsens_host.c
@@ -0,0 +1,280 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * HDDL Device Kernel module.
+ *
+ * Copyright (C) 2019-2020 Intel Corporation
+ */
+
+#include <asm/page.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/printk.h>
+#include <uapi/linux/stat.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of_device.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/xlink.h>
+#include <linux/time.h>
+#include <linux/kmod.h>
+#include <linux/i2c.h>
+#include <linux/sched.h>
+#include <linux/sched/mm.h>
+#include <linux/sched/task.h>
+#include <linux/hddl_device.h>
+#include <linux/ioctl.h>
+#include <linux/uaccess.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include <linux/thermal.h>
+#include <linux/hddl_device.h>
+#include <linux/intel_tsens_host.h>
+
+static int intel_tsens_get_temp(struct thermal_zone_device *zone,
+							int *temp)
+{
+	struct intel_tsens_host *tsens =
+		(struct intel_tsens_host *)zone->devdata;
+	struct i2c_client *i2c_c;
+
+	if (strstr(zone->type, "smb") != NULL)
+		i2c_c = tsens->i2c_smbus;
+	else
+		i2c_c = tsens->i2c_xlk;
+
+	*temp = i2c_smbus_read_word_data(i2c_c,
+				tsens->t_data->sensor_type);
+	return 0;
+}
+
+static int intel_tsens_thermal_get_trip_type(struct thermal_zone_device *zone,
+			int trip, enum thermal_trip_type *type)
+{
+	struct intel_tsens_host *tsens =
+		(struct intel_tsens_host *)zone->devdata;
+
+	*type = tsens->trip_info[trip]->trip_type;
+	return 0;
+}
+
+static int intel_tsens_thermal_get_trip_temp(struct thermal_zone_device *zone,
+				int trip, int *temp)
+{
+	struct intel_tsens_host *tsens =
+		(struct intel_tsens_host *)zone->devdata;
+
+	*temp = tsens->trip_info[trip]->temp;
+	return 0;
+}
+
+static int intel_tsens_thermal_notify(struct thermal_zone_device *zone,
+			       int trip, enum thermal_trip_type type)
+{
+
+	switch (type) {
+	case THERMAL_TRIP_ACTIVE:
+		pr_warn("Thermal reached to active temperature\n");
+		break;
+	case THERMAL_TRIP_CRITICAL:
+		pr_warn("Thermal reached to critical temperature\n");
+		break;
+	default:
+		pr_warn("Thermal not reached to active temperature\n");
+		break;
+	}
+	thermal_generate_netlink_event(zone, type);
+	return 0;
+}
+
+static int intel_tsens_bind(struct thermal_zone_device *tz,
+		    struct thermal_cooling_device *cdev)
+{
+	int ret;
+
+	/*Check here thermal device zone name and*/
+	/*cdev name to match, then call the bind device */
+	if (strncmp("intel_tsens_thermal", cdev->type,
+				THERMAL_NAME_LENGTH) == 0) {
+		ret = thermal_zone_bind_cooling_device
+				(tz,
+				THERMAL_TRIP_ACTIVE,
+				cdev,
+				THERMAL_NO_LIMIT,
+				THERMAL_NO_LIMIT,
+				THERMAL_WEIGHT_DEFAULT);
+		if (ret) {
+			dev_err(&tz->device,
+				"binding zone %s with cdev %s failed:%d\n",
+				tz->type, cdev->type, ret);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static int intel_tsens_unbind(struct thermal_zone_device *tz,
+		      struct thermal_cooling_device *cdev)
+{
+	int ret;
+
+	if (strncmp("intel_tsens_thermal", cdev->type,
+				THERMAL_NAME_LENGTH) == 0) {
+		ret = thermal_zone_unbind_cooling_device(tz, 0, cdev);
+		if (ret) {
+			dev_err(&tz->device,
+				"unbinding zone %s with cdev %s failed:%d\n",
+				tz->type, cdev->type, ret);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+
+static struct thermal_zone_device_ops tsens_thermal_ops = {
+	.bind = intel_tsens_bind,
+	.unbind = intel_tsens_unbind,
+	.get_temp = intel_tsens_get_temp,
+	.get_trip_type	= intel_tsens_thermal_get_trip_type,
+	.get_trip_temp	= intel_tsens_thermal_get_trip_temp,
+	.notify		= intel_tsens_thermal_notify,
+};
+
+static int intel_tsens_add_thermal_zone(struct intel_tsens_host *tsens,
+					struct thermal_zone_device **tz,
+					const char *name,
+					struct device *dev,
+					int i)
+{
+	int ret;
+
+	*tz =  thermal_zone_device_register(
+			name,
+			tsens->t_data->n_trips,
+			0,
+			tsens,
+			&tsens_thermal_ops,
+			NULL,
+			tsens->t_data->passive_delay,
+			tsens->t_data->polling_delay
+			);
+	if (IS_ERR(*tz)) {
+		ret = PTR_ERR(*tz);
+		dev_err(dev,
+			"failed to register thermal zone device %s\n",
+			tsens->t_data->name);
+		goto remove_thermal_zone;
+	}
+	return 0;
+
+remove_thermal_zone:
+	/*TODO: unregister thermal zone */
+	return ret;
+}
+
+static int intel_tsens_tj_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct intel_hddl_clients *d = client->dev.platform_data;
+	uint32_t *device_id = &d->xlink_dev.sw_device_id;
+	char *i2c_str;
+	int ret, i;
+
+	if (strstr(client->adapter->name, "SMBus I801") != NULL) {
+		i2c_str = "smb";
+		for (i = 0; i < d->nsens; i++) {
+			struct intel_tsens_host *tsens = d->tsens[i];
+
+			tsens->sensor_name_smbus = kasprintf(GFP_KERNEL,
+				"%s_%s-%x", tsens->t_data->name,
+				i2c_str, *device_id);
+			tsens->i2c_smbus = client;
+			ret = intel_tsens_add_thermal_zone(tsens,
+					&tsens->tz_smbus,
+					tsens->sensor_name_smbus,
+					&client->dev,
+					i);
+			if (ret) {
+				dev_err(&client->dev, "thermal zone configuration failed\n");
+				return ret;
+			}
+		}
+	} else {
+		i2c_str = "xlk";
+		for (i = 0; i < d->nsens; i++) {
+			struct intel_tsens_host *tsens = d->tsens[i];
+
+			tsens->sensor_name_xlk = kasprintf(GFP_KERNEL,
+				"%s_%s-%x", tsens->t_data->name,
+				i2c_str, *device_id);
+			tsens->i2c_xlk = client;
+			ret = intel_tsens_add_thermal_zone(tsens,
+					&tsens->tz_xlk,
+					tsens->sensor_name_xlk,
+					&client->dev,
+					i);
+			if (ret) {
+				dev_err(&client->dev, "thermal zone configuration failed\n");
+				return ret;
+			}
+		}
+	}
+
+	i2c_set_clientdata(client, d);
+
+	return 0;
+}
+
+static int intel_tsens_tj_exit(struct i2c_client *client)
+{
+	struct intel_hddl_clients *d = client->dev.platform_data;
+	int i;
+
+	if (strstr(client->adapter->name, "SMBus I801") != NULL) {
+		for (i = 0; i < d->nsens; i++) {
+			struct intel_tsens_host *tsens = d->tsens[i];
+
+			thermal_zone_device_unregister(
+				tsens->tz_smbus);
+		}
+	} else {
+		for (i = 0; i < d->nsens; i++) {
+			struct intel_tsens_host *tsens = d->tsens[i];
+
+			thermal_zone_device_unregister(
+				tsens->tz_xlk);
+		}
+	}
+	return 0;
+}
+
+static const struct i2c_device_id i2c_intel_tsens_id[] = {
+	{ "intel_tsens", (kernel_ulong_t)NULL },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, i2c_intel_tsens_id);
+
+static struct i2c_driver i2c_intel_tsens_driver = {
+	.driver = {
+		.name = "intel_tsens",
+	},
+	.probe = intel_tsens_tj_probe,
+	.remove = intel_tsens_tj_exit,
+	.id_table = i2c_intel_tsens_id,
+};
+module_i2c_driver(i2c_intel_tsens_driver);
+
+MODULE_DESCRIPTION("KeemBay HDDL Device driver");
+MODULE_AUTHOR("Raja Subramanian, Lakshmi Bai"
+	      "<lakshmi.bai.raja.subramanian@intel.com>");
+MODULE_AUTHOR("Sandeep Singh <sandeep1.singh@intel.com>");
+MODULE_AUTHOR("Vaidya, Mahesh R <mahesh.r.vaidya@intel.com>");
+MODULE_AUTHOR("Udhayakumar C <udhayakumar.c@intel.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/intel_tsens/intel_tsens_host.h b/drivers/misc/intel_tsens/intel_tsens_host.h
new file mode 100644
index 000000000000..e0cdb9418b78
--- /dev/null
+++ b/drivers/misc/intel_tsens/intel_tsens_host.h
@@ -0,0 +1,29 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * HDDL Device HELPER module.
+ *
+ * Copyright (C) 2019-2020 Intel Corporation
+ */
+
+#ifndef _LINUX_INTEL_TSENS_HOST_DEVICE_H
+#define _LINUX_INTEL_TSENS_HOST_DEVICE_H
+
+#include "../hddl_device/hddl_device.h"
+
+__packed __aligned(size) struct intel_tsens_trip_info {
+	enum thermal_trip_type trip_type;
+	int temp;
+};
+
+struct intel_tsens {
+	struct intel_tsens_data *t_data;
+	struct intel_tsens_trip_info **trip_info;
+	struct thermal_zone_device *tz;
+};
+
+struct intel_tsens_plat_data {
+	int nsens;
+	struct intel_tsens **tsens;
+};
+
+#endif /*_LINUX_INTEL_TSENS_HOST_DEVICE_H*/
diff --git a/drivers/misc/intel_tsens/intel_tsens_thermal.c b/drivers/misc/intel_tsens/intel_tsens_thermal.c
new file mode 100644
index 000000000000..9d9e0b6e440e
--- /dev/null
+++ b/drivers/misc/intel_tsens/intel_tsens_thermal.c
@@ -0,0 +1,729 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * intel-tsens-thermal.c - Tsens Thermal Driver.
+ *
+ * Copyright (C) 2019-2020 Intel Corporation
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/thermal.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/thermal.h>
+#include <linux/hddl_device.h>
+
+struct intel_tsens_i2c {
+	u16 buffer_idx;
+	u8 idx_write_cnt;
+	bool read_only;
+	int sensor_type;
+};
+
+struct intel_tsens_priv {
+	int n_sens;
+	spinlock_t lock;
+	bool global_clk_available;
+	void __iomem *base_addr;
+	struct clk *tsens_clk;
+	u32 tsens_clk_rate;
+	struct intel_tsens **intel_tsens;
+	struct device *dev;
+	struct platform_device *pdev;
+	struct intel_tsens_plat_info plat_info;
+	struct intel_tsens_i2c tsens_i2c;
+};
+
+static int g_nsens;
+static struct intel_tsens **g_intel_tsens;
+
+static int intel_i2c_tsens_slave_cb(struct i2c_client *client,
+				enum i2c_slave_event event, u8 *val)
+{
+	struct intel_tsens_priv *priv = i2c_get_clientdata(client);
+	struct intel_tsens_i2c *tsens_i2c = &priv->tsens_i2c;
+
+	switch (event) {
+	case I2C_SLAVE_WRITE_RECEIVED:
+	{
+		tsens_i2c->sensor_type = *val;
+		break;
+	}
+
+	case I2C_SLAVE_READ_PROCESSED:
+	{
+		/* The previous byte made it to the bus, get next one */
+	}
+		/* fallthrough */
+	case I2C_SLAVE_READ_REQUESTED:
+	{
+		*val = (priv->intel_tsens[tsens_i2c->sensor_type]->curr_temp >>
+			(tsens_i2c->buffer_idx * 8));
+		tsens_i2c->buffer_idx++;
+		/*
+		 * Do not increment buffer_idx here, because we don't know if
+		 * this byte will be actually used. Read Linux I2C slave docs
+		 * for details.
+		 */
+		break;
+	}
+
+	case I2C_SLAVE_STOP:
+	{
+		tsens_i2c->idx_write_cnt = 0;
+		tsens_i2c->buffer_idx = 0;
+		break;
+	}
+	case I2C_SLAVE_WRITE_REQUESTED:
+	{
+		tsens_i2c->idx_write_cnt = 0;
+		tsens_i2c->buffer_idx = 0;
+		break;
+	}
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int intel_i2c_tsens_slave_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	int ret;
+	struct intel_tsens_priv *priv =
+		(struct intel_tsens_priv *)id->driver_data;
+
+	dev_info(&priv->pdev->dev, "Slave address %s is %d",
+					client->name, client->addr);
+	i2c_set_clientdata(client, priv);
+	ret = i2c_slave_register(client, intel_i2c_tsens_slave_cb);
+	if (ret) {
+		dev_err(&priv->pdev->dev, "i2c slave register failed\n");
+		return ret;
+	}
+
+	return 0;
+};
+
+static int intel_i2c_tsens_slave_remove(struct i2c_client *client)
+{
+	i2c_slave_unregister(client);
+	return 0;
+}
+
+static struct i2c_device_id intel_i2c_tsens_slave_id[] = {
+	{ "intel_tsens", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, intel_i2c_tsens_slave_id);
+
+static struct i2c_driver intel_i2c_tsens_slave_driver = {
+	.driver = {
+		.name = "intel_tsens",
+	},
+	.probe = intel_i2c_tsens_slave_probe,
+	.remove = intel_i2c_tsens_slave_remove,
+	.id_table = intel_i2c_tsens_slave_id,
+};
+
+
+struct intel_tsens **intel_tsens_hddl_register(int *nsens)
+{
+	*nsens = g_nsens;
+	return g_intel_tsens;
+}
+EXPORT_SYMBOL(intel_tsens_hddl_register);
+
+static int intel_tsens_register_pdev(struct intel_tsens_plat_info *plat_info)
+{
+	struct platform_device_info pdevinfo;
+	struct platform_device *dd;
+	struct intel_tsens_plat_data plat_data, *pdata = NULL;
+	static int id;
+
+	memset(&pdevinfo, 0, sizeof(pdevinfo));
+	pdevinfo.name = plat_info->plat_name;
+	pdevinfo.id = id++;
+	plat_data.base_addr = plat_info->base_addr;
+	plat_data.name = plat_info->plat_name;
+	plat_data.get_temp = NULL;
+	pdevinfo.data = &plat_data;
+	pdevinfo.size_data = sizeof(plat_data);
+	dd = platform_device_register_full(&pdevinfo);
+	if (IS_ERR(dd))
+		return -EINVAL;
+
+	pdata = dd->dev.platform_data;
+	plat_info->pdev = dd;
+
+	return 0;
+}
+
+static int intel_tsens_add_pdev(struct intel_tsens_priv *priv)
+{
+	int i, ret;
+
+	if (priv->plat_info.plat_name != NULL) {
+		priv->plat_info.base_addr = priv->base_addr;
+		ret = intel_tsens_register_pdev(&priv->plat_info);
+		if (ret)
+			return ret;
+	}
+	for (i = 0; i < priv->n_sens; i++) {
+		struct intel_tsens *tsens = priv->intel_tsens[i];
+
+		if (tsens->plat_info.plat_name == NULL)
+			continue;
+		tsens->plat_info.base_addr = tsens->base_addr;
+		ret = intel_tsens_register_pdev(&tsens->plat_info);
+		if (ret)
+			goto f_tsens_pdev;
+	}
+	return 0;
+f_tsens_pdev:
+	/*TODO: free pdev*/
+	return ret;
+}
+
+static int intel_tsens_thermal_get_temp(struct thermal_zone_device *tz,
+							int *temp)
+{
+	struct intel_tsens *tsens = (struct intel_tsens *)tz->devdata;
+	struct intel_tsens_priv *priv = (struct intel_tsens_priv *)tsens->pdata;
+	struct platform_device *pdev;
+	struct intel_tsens_plat_data *plat_data;
+	int type = tsens->sensor_type;
+
+	if (tsens->plat_info.plat_name != NULL) {
+		pdev = tsens->plat_info.pdev;
+		plat_data = pdev->dev.platform_data;
+
+		if (!plat_data) {
+			dev_err(&pdev->dev, "Platform data not found for %s\n",
+					tsens->name);
+			return -EINVAL;
+		}
+		if (!plat_data->get_temp) {
+			dev_dbg(&pdev->dev,
+				"Platform driver not available for %s\n",
+				tsens->name);
+			*temp = 0;
+			return 0;
+		}
+		if (plat_data->get_temp(pdev, type, temp))
+			return -EINVAL;
+		tsens->curr_temp = *temp;
+		return 0;
+	}
+	if (priv->plat_info.plat_name != NULL) {
+		pdev = priv->plat_info.pdev;
+		plat_data = pdev->dev.platform_data;
+
+		if (!plat_data) {
+			dev_err(&pdev->dev, "Platform data not found for %s\n",
+					tsens->name);
+			return -EINVAL;
+		}
+		if (!plat_data->get_temp) {
+			dev_dbg(&pdev->dev,
+				"Platform driver not available for %s\n",
+				tsens->name);
+			*temp = 0;
+			return 0;
+		}
+
+		if (plat_data->get_temp(pdev, type, temp))
+			return -EINVAL;
+		tsens->curr_temp = *temp;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int intel_tsens_thermal_get_trip_type(struct thermal_zone_device *tz,
+			int trip, enum thermal_trip_type *type)
+{
+	struct intel_tsens *tsens = (struct intel_tsens *)tz->devdata;
+
+	*type = tsens->trip_info[trip]->trip_type;
+	return 0;
+}
+
+
+static int intel_tsens_thermal_get_trip_temp(struct thermal_zone_device *tz,
+				int trip, int *temp)
+{
+
+	struct intel_tsens *tsens = (struct intel_tsens *)tz->devdata;
+
+	*temp = tsens->trip_info[trip]->temp;
+	return 0;
+}
+
+/* Refer https://lwn.net/Articles/242046/
+ * how to receive this event in userspace
+ */
+static int intel_tsens_notify_user_space(struct thermal_zone_device *tz,
+		int trip)
+{
+	char *thermal_prop[5];
+	int i;
+
+	mutex_lock(&tz->lock);
+	thermal_prop[0] = kasprintf(GFP_KERNEL, "NAME=%s", tz->type);
+	thermal_prop[1] = kasprintf(GFP_KERNEL, "TEMP=%d",
+						tz->emul_temperature);
+	thermal_prop[2] = kasprintf(GFP_KERNEL, "TRIP=%d", trip);
+	thermal_prop[3] = kasprintf(GFP_KERNEL, "EVENT=%d", tz->notify_event);
+	thermal_prop[4] = NULL;
+	kobject_uevent_env(&tz->device.kobj, KOBJ_CHANGE, thermal_prop);
+	for (i = 0; i < 4; ++i)
+		kfree(thermal_prop[i]);
+	mutex_unlock(&tz->lock);
+	return 0;
+}
+
+
+static int intel_tsens_thermal_notify(struct thermal_zone_device *tz,
+			       int trip, enum thermal_trip_type type)
+{
+	struct intel_tsens *tsens = (struct intel_tsens *)tz->devdata;
+	struct intel_tsens_priv *priv = (struct intel_tsens_priv *)tsens->pdata;
+
+	intel_tsens_notify_user_space(tz, trip);
+	switch (type) {
+	case THERMAL_TRIP_PASSIVE:
+		dev_warn(&priv->pdev->dev, "Thermal reached to passive temperature\n");
+		break;
+	case THERMAL_TRIP_CRITICAL:
+		dev_warn(&priv->pdev->dev, "Thermal reached to critical temperature\n");
+		break;
+	default:
+		dev_warn(&priv->pdev->dev, "Thermal not reached to passive temperature\n");
+		break;
+	}
+	return 0;
+}
+
+static int intel_tsens_thermal_bind(struct thermal_zone_device *tz,
+		    struct thermal_cooling_device *cdev)
+{
+	int ret;
+	struct intel_tsens *tsens = (struct intel_tsens *)tz->devdata;
+	struct intel_tsens_priv *priv = (struct intel_tsens_priv *)tsens->pdata;
+
+	/*Check here thermal device zone name and*/
+	/*cdev name to match, then call the bind device */
+	if (strncmp(tz->type, cdev->type, THERMAL_NAME_LENGTH) == 0) {
+		ret = thermal_zone_bind_cooling_device
+				(tz,
+				THERMAL_TRIP_PASSIVE,
+				cdev,
+				THERMAL_NO_LIMIT,
+				THERMAL_NO_LIMIT,
+				THERMAL_WEIGHT_DEFAULT);
+		if (ret) {
+			dev_err(&priv->pdev->dev,
+				"binding zone %s with cdev %s failed:%d\n",
+				tz->type, cdev->type, ret);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static int intel_tsens_thermal_unbind(struct thermal_zone_device *tz,
+		      struct thermal_cooling_device *cdev)
+{
+	int ret;
+
+	ret = thermal_zone_unbind_cooling_device(tz, 0, cdev);
+	if (ret) {
+		dev_err(&tz->device,
+			"unbinding zone %s with cdev %s failed:%d\n",
+			tz->type, cdev->type, ret);
+		return ret;
+	}
+	return 0;
+}
+
+static struct thermal_zone_device_ops tsens_thermal_ops = {
+	.bind = intel_tsens_thermal_bind,
+	.unbind = intel_tsens_thermal_unbind,
+	.get_temp = intel_tsens_thermal_get_temp,
+	.get_trip_type	= intel_tsens_thermal_get_trip_type,
+	.get_trip_temp	= intel_tsens_thermal_get_trip_temp,
+	.notify		= intel_tsens_thermal_notify,
+/*	.set_emul_temp = tsens_thermal_emulation */
+
+};
+
+static int intel_tsens_add_thermal_zone(struct intel_tsens_priv *priv)
+{
+	int ret, i;
+
+	for (i = 0; i < priv->n_sens; i++) {
+		priv->intel_tsens[i]->tz =  thermal_zone_device_register(
+			priv->intel_tsens[i]->name,
+			priv->intel_tsens[i]->n_trips,
+			0,
+			priv->intel_tsens[i],
+			&tsens_thermal_ops,
+			NULL,
+			priv->intel_tsens[i]->passive_delay,
+			priv->intel_tsens[i]->polling_delay
+			);
+		if (IS_ERR(priv->intel_tsens[i]->tz)) {
+			ret = PTR_ERR(priv->intel_tsens[i]->tz);
+			dev_err(&priv->pdev->dev,
+				"failed to register thermal zone device %s\n",
+				priv->intel_tsens[i]->name);
+			goto remove_thermal_zone;
+		}
+	}
+	return 0;
+
+remove_thermal_zone:
+	/*TODO: unregister thermal zone */
+	return ret;
+}
+
+static void intel_tsens_remove_clk_config(struct intel_tsens_priv *priv)
+{
+}
+
+static int intel_tsens_clk_config(struct intel_tsens_priv *priv)
+{
+	struct platform_device *pdev = priv->pdev;
+	int ret;
+
+
+	if (priv->global_clk_available) {
+		priv->tsens_clk = devm_clk_get(&pdev->dev, NULL);
+		if (IS_ERR(priv->tsens_clk)) {
+			ret = PTR_ERR(priv->tsens_clk);
+			if (ret != -EPROBE_DEFER) {
+				dev_err(&pdev->dev,
+					"failed to get thermal clk: %d\n", ret);
+			}
+			return PTR_ERR(priv->tsens_clk);
+		}
+
+		ret = clk_prepare_enable(priv->tsens_clk);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"failed to enable thermal clk: %d\n",
+				ret);
+			return ret;
+		}
+		ret = clk_set_rate(priv->tsens_clk, priv->tsens_clk_rate);
+		ret = clk_prepare_enable(priv->tsens_clk);
+		ret = clk_enable(priv->tsens_clk);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"failed to enable thermal clk: %d\n",
+				ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int intel_tsens_config_sensors(struct device_node *s_node,
+			struct intel_tsens *tsens, int sensor_type)
+{
+	struct intel_tsens_priv *priv = (struct intel_tsens_priv *)tsens->pdata;
+	struct platform_device *pdev = priv->pdev;
+	s32 trip_temp_count, trip_temp_type_c, i, ret;
+
+	of_property_read_string_index(s_node, "plat_name", 0,
+				&tsens->plat_info.plat_name);
+	tsens->sensor_type = sensor_type;
+	if (of_property_read_u32(s_node, "passive_delay",
+				&tsens->passive_delay)) {
+		dev_err(&pdev->dev,
+			"passive_delay missing in dt for %s\n",
+			tsens->name);
+		return -EINVAL;
+	}
+	if (of_property_read_u32(s_node, "polling_delay",
+				&tsens->polling_delay)) {
+		dev_err(&pdev->dev,
+			"polling_delay missing in dt for %s\n",
+			tsens->name);
+		return -EINVAL;
+	}
+	trip_temp_count = of_property_count_u32_elems(s_node, "trip_temp");
+	trip_temp_type_c = of_property_count_strings(s_node, "trip_type");
+	if ((trip_temp_count != trip_temp_type_c) ||
+		(trip_temp_count <= 0) || (trip_temp_type_c <= 0)) {
+		dev_err(&pdev->dev,
+			"trip temp config is missing in dt for %s\n",
+			tsens->name);
+		return -EINVAL;
+	}
+
+	tsens->trip_info =
+		devm_kzalloc(&pdev->dev,
+			(sizeof(struct intel_tsens_trip_info *) *
+			 trip_temp_count),
+			GFP_KERNEL);
+	if (tsens->trip_info == NULL) {
+		dev_err(&pdev->dev,
+				"Temperature Memory alloc failed for %s\n",
+				s_node->name);
+		return -ENOMEM;
+	}
+	tsens->n_trips = trip_temp_count;
+	for (i = 0; i < trip_temp_count; i++) {
+		const char *trip_name;
+
+		tsens->trip_info[i] = devm_kzalloc(&pdev->dev,
+					(sizeof(struct intel_tsens_trip_info)),
+					GFP_KERNEL);
+		if (tsens->trip_info[i] == NULL) {
+			dev_err(&pdev->dev, "Temperature Memory alloc failed for %s\n",
+				s_node->name);
+			ret = -ENOMEM;
+			goto f_tsens_trip;
+		}
+
+		of_property_read_u32_index(s_node, "trip_temp", i,
+				&tsens->trip_info[i]->temp);
+		of_property_read_string_index(s_node, "trip_type", i,
+				&trip_name);
+		if (!strcmp(trip_name, "passive"))
+			tsens->trip_info[i]->trip_type = THERMAL_TRIP_PASSIVE;
+		else if (!strcmp(trip_name, "critical"))
+			tsens->trip_info[i]->trip_type = THERMAL_TRIP_CRITICAL;
+		else if (!strcmp(trip_name, "hot"))
+			tsens->trip_info[i]->trip_type = THERMAL_TRIP_HOT;
+		else
+			tsens->trip_info[i]->trip_type = THERMAL_TRIP_ACTIVE;
+	}
+	return 0;
+f_tsens_trip:
+	while (i >= 0) {
+		if (tsens->trip_info[i] != NULL)
+			devm_kfree(&pdev->dev, tsens->trip_info[i]);
+		i--;
+	}
+	devm_kfree(&pdev->dev, tsens->trip_info);
+	return ret;
+}
+
+static int intel_tsens_config_dt(struct intel_tsens_priv *priv)
+{
+	struct platform_device *pdev = priv->pdev;
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *s_node;
+	struct resource *res;
+	int i = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->base_addr = devm_ioremap_resource(&pdev->dev, res);
+	priv->n_sens = of_get_child_count(np);
+	priv->global_clk_available = of_property_read_bool(np, "clocks");
+	of_property_read_u32(np, "clk-rate", &priv->tsens_clk_rate);
+	of_property_read_string_index(np, "plat_name", 0,
+				&priv->plat_info.plat_name);
+	if (priv->n_sens == 0) {
+		dev_err(&pdev->dev, "No sensors configured in dt\n");
+		return -EINVAL;
+	}
+	priv->intel_tsens =
+		devm_kzalloc(&pdev->dev,
+			(sizeof(struct intel_tsens *) * priv->n_sens),
+			GFP_KERNEL);
+	g_intel_tsens = priv->intel_tsens;
+	g_nsens = priv->n_sens;
+	for_each_child_of_node(np, s_node) {
+		int reg_count, size_count;
+
+		priv->intel_tsens[i] = devm_kzalloc(&pdev->dev,
+					sizeof(struct intel_tsens),
+					GFP_KERNEL);
+		if (priv->intel_tsens[i] == NULL) {
+			dev_err(&pdev->dev, "Memory alloc failed for %s\n",
+					s_node->name);
+			i--;
+			goto free_tsens_sensors;
+		}
+		strcpy(priv->intel_tsens[i]->name, s_node->name);
+		if (!of_property_read_u32(s_node, "address-cells", &reg_count)
+			&& !of_property_read_u32(s_node, "size-cells",
+				&size_count)) {
+			if (reg_count > 1) {
+				of_property_read_u64_index(s_node, "reg", 0,
+					  &priv->intel_tsens[i]->addr);
+			} else {
+				of_property_read_u32_index(s_node, "reg", 0,
+					  (u32 *)&priv->intel_tsens[i]->addr);
+			}
+			if (size_count > 1) {
+				int index =
+					(reg_count > 1)?(reg_count/2) :
+					reg_count;
+
+				of_property_read_u64_index(s_node, "reg", index,
+					  &priv->intel_tsens[i]->size);
+			} else {
+				of_property_read_u32_index(s_node, "reg",
+					reg_count,
+					(u32 *)&priv->intel_tsens[i]->size);
+
+			}
+			dev_info(&pdev->dev, "address %llx\n",
+					priv->intel_tsens[i]->addr);
+			dev_info(&pdev->dev, "size %llx\n",
+					priv->intel_tsens[i]->size);
+			priv->intel_tsens[i]->base_addr =
+				devm_ioremap(&pdev->dev,
+					priv->intel_tsens[i]->addr,
+					priv->intel_tsens[i]->size);
+		} else
+			priv->intel_tsens[i]->base_addr = priv->base_addr;
+		if (priv->intel_tsens[i]->base_addr == NULL) {
+			dev_err(&pdev->dev, "ioremap failed for %s\n",
+					priv->intel_tsens[i]->name);
+			goto unmap;
+		}
+		priv->intel_tsens[i]->pdata = priv;
+		if (intel_tsens_config_sensors(
+					s_node, priv->intel_tsens[i], i)) {
+			dev_err(&pdev->dev,
+					"Missing sensor info in dts for %s\n",
+					priv->intel_tsens[i]->name);
+			goto unmap;
+		}
+		dev_info(&pdev->dev, "Parsing cfg for %s from dt is success\n",
+				priv->intel_tsens[i]->name);
+		i++;
+	}
+
+	return 0;
+unmap:
+free_tsens_sensors:
+	while (i >= 0)
+		devm_kfree(&pdev->dev, priv->intel_tsens[i--]);
+	devm_kfree(&pdev->dev, priv->intel_tsens);
+	return -EINVAL;
+}
+
+static void intel_tsens_remove_dt(struct intel_tsens_priv *priv)
+{
+	int i;
+	struct platform_device *pdev = priv->pdev;
+
+	for (i = 0; i < priv->n_sens; i++)
+		devm_kfree(&pdev->dev, priv->intel_tsens[i]);
+	devm_kfree(&pdev->dev, priv->intel_tsens);
+}
+
+static int intel_tsens_thermal_probe(struct platform_device *pdev)
+{
+	struct intel_tsens_priv *intel_tsens_priv;
+	int ret;
+
+	dev_info(&pdev->dev,
+		"%s Entry\n", __func__);
+
+	intel_tsens_priv = devm_kzalloc(&pdev->dev,
+					sizeof(struct intel_tsens_priv),
+					GFP_KERNEL);
+	if (intel_tsens_priv == NULL) {
+		dev_err(&pdev->dev, "No memory");
+		return -ENOMEM;
+	}
+	intel_tsens_priv->pdev = pdev;
+	spin_lock_init(&intel_tsens_priv->lock);
+	if (pdev->dev.of_node) {
+		ret = intel_tsens_config_dt(intel_tsens_priv);
+		if (ret) {
+			dev_err(&pdev->dev, "dt configuration failed\n");
+			devm_kfree(&pdev->dev, intel_tsens_priv);
+			return ret;
+		}
+	} else {
+		dev_err(&pdev->dev, "Non Device Tree build is not supported\n");
+		devm_kfree(&pdev->dev, intel_tsens_priv);
+		return -EINVAL;
+	}
+	ret = intel_tsens_clk_config(intel_tsens_priv);
+	if (ret) {
+		intel_tsens_remove_dt(intel_tsens_priv);
+		devm_kfree(&pdev->dev, intel_tsens_priv);
+		return ret;
+	}
+	ret = intel_tsens_add_pdev(intel_tsens_priv);
+	if (ret) {
+		dev_err(&pdev->dev, "platform device registration failed\n");
+		intel_tsens_remove_dt(intel_tsens_priv);
+		intel_tsens_remove_clk_config(intel_tsens_priv);
+		devm_kfree(&pdev->dev, intel_tsens_priv);
+		return ret;
+
+	}
+	ret = intel_tsens_add_thermal_zone(intel_tsens_priv);
+	if (ret) {
+		dev_err(&pdev->dev, "thermal zone configuration failed\n");
+		/*TODO: remove platform device */
+		intel_tsens_remove_dt(intel_tsens_priv);
+		intel_tsens_remove_clk_config(intel_tsens_priv);
+		devm_kfree(&pdev->dev, intel_tsens_priv);
+		return ret;
+	}
+	intel_i2c_tsens_slave_id[0].driver_data =
+				(kernel_ulong_t)intel_tsens_priv;
+	if (i2c_add_driver(&intel_i2c_tsens_slave_driver)) {
+		dev_err(&pdev->dev, "I2C register driver failed\n");
+		return -EINVAL;
+	}
+
+	dev_info(&pdev->dev,
+		"%d sensors registered\n", intel_tsens_priv->n_sens);
+	dev_info(&pdev->dev,
+		"%s Exit\n", __func__);
+	return 0;
+}
+
+/* Device Exit */
+static int intel_tsens_thermal_exit(struct platform_device *pdev)
+{
+	i2c_del_driver(&intel_i2c_tsens_slave_driver);
+
+	return 0;
+}
+
+static const struct of_device_id intel_tsens_thermal_id_table[] = {
+	{ .compatible = "intel,intel-tsens" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, intel_tsens_thermal_id_table);
+
+static struct platform_driver intel_tsens_thermal_driver = {
+	.probe = intel_tsens_thermal_probe,
+	.remove = intel_tsens_thermal_exit,
+	.driver = {
+		.name = "intel_tsens_thermal",
+		.of_match_table = intel_tsens_thermal_id_table,
+	},
+};
+
+module_platform_driver(intel_tsens_thermal_driver);
+
+MODULE_DESCRIPTION("TSENS Thermal Driver");
+MODULE_AUTHOR("Sandeep Singh <sandeep1.singh@intel.com>");
+MODULE_AUTHOR("Raja Subramanian, Lakshmi Bai <lakshmi.bai.raja.subramanian@intel.com>");
+MODULE_AUTHOR("Udhayakumar C <udhayakumar.c@intel.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/intel_tsens/intel_tsens_thermal.h b/drivers/misc/intel_tsens/intel_tsens_thermal.h
new file mode 100644
index 000000000000..18328b91c170
--- /dev/null
+++ b/drivers/misc/intel_tsens/intel_tsens_thermal.h
@@ -0,0 +1,47 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Keembay Temperature sensor local-host module.
+ *
+ * Copyright (C) 2019-2020 Intel Corporation.
+ */
+
+#ifndef _LINUX_INTEL_TSENS_H
+#define _LINUX_INTEL_TSENS_H
+
+
+#include <linux/thermal.h>
+
+struct intel_tsens_plat_data {
+	const char *name;
+	void __iomem *base_addr;
+	int (*get_temp)(struct platform_device *pdev, int type, int *temp);
+	void *pdata;
+};
+
+__packed __aligned(4)) struct intel_tsens_trip_info {
+	enum thermal_trip_type trip_type;
+	int temp;
+};
+
+struct intel_tsens_plat_info {
+	const char *plat_name;
+	struct platform_device *pdev;
+	void __iomem *base_addr;
+};
+
+struct intel_tsens {
+	char name[10];
+	u32 n_trips;
+	u32 passive_delay;
+	u32 polling_delay;
+	u32 sensor_type;
+	u64 addr;
+	u64 size;
+	void __iomem *base_addr;
+	struct intel_tsens_trip_info **trip_info;
+	struct thermal_zone_device *tz;
+	void *pdata;
+	struct intel_tsens_plat_info plat_info;
+};
+struct intel_tsens **intel_tsens_hddl_register(int *nsens);
+#endif /* _LINUX_INTEL_TSENS_H */
diff --git a/drivers/misc/intel_tsens/keembay_cooling.c b/drivers/misc/intel_tsens/keembay_cooling.c
new file mode 100644
index 000000000000..fcd059675d85
--- /dev/null
+++ b/drivers/misc/intel_tsens/keembay_cooling.c
@@ -0,0 +1,109 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Keembay cooling Device Kernel module.
+ *
+ * Copyright (C) 2019-2020 Intel Corporation
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/acpi.h>
+#include <linux/thermal.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+
+
+
+struct keembay_cooling_data {
+	struct thermal_cooling_device *cooling_dev;
+};
+
+static int
+keembay_cooling_get_max_state(struct thermal_cooling_device *cooling_dev,
+			      unsigned long *state)
+{
+	*state = 4;
+	return 0;
+}
+
+static int
+keembay_cooling_set_cur_state(struct thermal_cooling_device *cooling_dev,
+			      unsigned long state)
+{
+	state = 0;
+	pr_warn("keembay_cooling_set_cur_state\n");
+	return 0;
+}
+
+static int
+keembay_cooling_get_cur_state(struct thermal_cooling_device *cooling_dev,
+			      unsigned long *state)
+{
+	*state = 0;
+	return 0;
+}
+
+static const struct thermal_cooling_device_ops keembay_cooling_ops = {
+	.get_max_state = keembay_cooling_get_max_state,
+	.get_cur_state = keembay_cooling_get_cur_state,
+	.set_cur_state = keembay_cooling_set_cur_state,
+
+};
+
+static int keembay_cooling_probe(struct platform_device *pdev)
+{
+	struct keembay_cooling_data *d;
+	int ret;
+
+	pr_warn("keembay_thermal_cooling_probe_start\n");
+	d = devm_kzalloc(&pdev->dev, sizeof(*d), GFP_KERNEL);
+	if (!d) {
+		pr_warn("keembay_thermal_cooling_dev_kzalloc_failed\n");
+		return -ENOMEM;
+	}
+	pr_warn("keembay_thermal_cooling_kzalloc\n");
+	d->cooling_dev = thermal_cooling_device_register(
+			"keembay_thermal", d, &keembay_cooling_ops);
+	if (IS_ERR(d->cooling_dev)) {
+		ret = PTR_ERR(d->cooling_dev);
+		dev_err(&pdev->dev,
+		"failed to register thermal zone device %d\n", ret);
+		pr_warn("keembay_thermal_cooling_register_failed\n");
+	}
+	pr_warn("keembay_thermal_cooling_register\n");
+
+	return 0;
+}
+
+static int keembay_cooling_remove(struct platform_device *pdev)
+{
+	struct keembay_cooling_data *d = platform_get_drvdata(pdev);
+
+	thermal_cooling_device_unregister(d->cooling_dev);
+	return 0;
+}
+
+static const struct of_device_id keembay_cooling_id_table[] = {
+	{ .compatible = "intel,keembay-dummy" },
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, keembay_cooling_id_table);
+
+static struct platform_driver keembay_cooling_driver = {
+	.probe = keembay_cooling_probe,
+	.remove = keembay_cooling_remove,
+	.driver = {
+		.name = "keembay_cooling",
+		.of_match_table = keembay_cooling_id_table,
+	},
+};
+
+module_platform_driver(keembay_cooling_driver);
+
+MODULE_AUTHOR("Sandeep Singh <sandeep1.singh@intel.com>");
+MODULE_DESCRIPTION("keembay thermal driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/host_kmb_tj/keembay_cooling_host.c b/drivers/misc/intel_tsens/keembay_cooling_host.c
similarity index 82%
rename from drivers/misc/host_kmb_tj/keembay_cooling_host.c
rename to drivers/misc/intel_tsens/keembay_cooling_host.c
index 3db96f5a7c0d..e4a73d3ffe01 100644
--- a/drivers/misc/host_kmb_tj/keembay_cooling_host.c
+++ b/drivers/misc/intel_tsens/keembay_cooling_host.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * keembay_cooling_host.c - Host KeemBay cooling driver(used for testing).
+ * intel-tsens-thermal.c - Tsens Thermal Driver.
  *
  * Copyright (C) 2019-2020 Intel Corporation
  */
@@ -36,7 +36,7 @@ keembay_cooling_set_cur_state(struct thermal_cooling_device *cooling_dev,
 			      unsigned long state)
 {
 	state = 0;
-	dev_info(&cooling_dev->dev, "%s\n", __func__);
+	pr_warn("keembay_cooling_set_cur_state\n");
 	return 0;
 }
 
@@ -44,7 +44,6 @@ static int
 keembay_cooling_get_cur_state(struct thermal_cooling_device *cooling_dev,
 			      unsigned long *state)
 {
-	//printk(KERN_WARNING "keembay_cooling_get_cur_state\n");
 	*state = 0;
 	return 0;
 }
@@ -60,18 +59,22 @@ static int keembay_cooling_probe(struct platform_device *pdev)
 {
 	struct keembay_cooling_data *d;
 	int ret;
-
-	d = devm_kzalloc(&pdev->dev, sizeof(*d), GFP_KERNEL);
-	if (d == NULL)
+		pr_warn("keembay_thermal_cooling_probe_start\n");
+		d = devm_kzalloc(&pdev->dev, sizeof(*d), GFP_KERNEL);
+	if (!d) {
+		pr_warn("keembay_thermal_cooling_dev_kzalloc_failed\n");
 		return -ENOMEM;
+	}
+	pr_warn("keembay_thermal_cooling_kzalloc\n");
 	d->cooling_dev = thermal_cooling_device_register("keembay_thermal",
-					 d, &keembay_cooling_ops);
+						 d, &keembay_cooling_ops);
 	if (IS_ERR(d->cooling_dev)) {
 		ret = PTR_ERR(d->cooling_dev);
 		dev_err(&pdev->dev,
 			"failed to register thermal zone device %d\n", ret);
-	}
-	dev_info(&pdev-dev, "keembay_thermal_cooling_register..Done\n");
+			pr_warn("keembay_thermal_cooling_register_failed\n");
+		}
+		pr_warn("keembay_thermal_cooling_register\n");
 
 	return 0;
 }
@@ -105,5 +108,3 @@ module_platform_driver(keembay_cooling_driver);
 MODULE_AUTHOR("Sandeep Singh <sandeep1.singh@intel.com>");
 MODULE_DESCRIPTION("keembay thermal driver");
 MODULE_LICENSE("GPL");
-
-
diff --git a/drivers/misc/intel_tsens/keembay_thermal.c b/drivers/misc/intel_tsens/keembay_thermal.c
new file mode 100644
index 000000000000..a1d03751e5de
--- /dev/null
+++ b/drivers/misc/intel_tsens/keembay_thermal.c
@@ -0,0 +1,173 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * keembay-thermal.c - KeemBay Thermal Driver.
+ *
+ * Copyright (C) 2019-2020 Intel Corporation
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/thermal.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/hddl_device.h>
+#include "keembay_tsens.h"
+
+struct keembay_thermal_priv {
+	const char *name;
+	void __iomem *base_addr;
+	spinlock_t lock;
+	u32 current_temp[KEEMBAY_SENSOR_MAX];
+	struct intel_tsens_plat_data *plat_data;
+};
+
+static int kmb_sensor_read_temp(void __iomem *regs_val,
+						int offset,
+						int sample_valid_mask,
+						int sample_value,
+						int bit_shift,
+						int *temp)
+{
+	int reg_val, kmb_raw_index;
+	/* clear the bit of TSENS_EN and re-enable again */
+	iowrite32(0x00, regs_val+AON_TSENS_CFG);
+	iowrite32(CFG_MASK_MANUAL, regs_val+AON_TSENS_CFG);
+	reg_val = ioread32(regs_val+offset);
+	if (reg_val & sample_valid_mask) {
+		reg_val = (reg_val >> bit_shift & sample_value);
+		kmb_raw_index = reg_val - KEEMBAY_SENSOR_BASE_TEMP;
+		if (kmb_raw_index < 0)
+			reg_val = raw_kmb[0];
+		else if (kmb_raw_index > (raw_kmb_size-1))
+			reg_val = raw_kmb[raw_kmb_size - 1];
+		else
+			reg_val = raw_kmb[kmb_raw_index];
+		*temp = reg_val;
+	} else
+		*temp = 0;
+	return 0;
+}
+
+
+static int keembay_get_temp(struct platform_device *pdev, int type, int *temp)
+{
+	struct keembay_thermal_priv *priv = platform_get_drvdata(pdev);
+
+	spin_lock(&priv->lock);
+	switch (type) {
+	case KEEMBAY_SENSOR_MSS:
+			kmb_sensor_read_temp(priv->base_addr,
+					AON_TSENS_DATA0,
+					MSS_T_SAMPLE_VALID,
+					MSS_T_SAMPLE,
+					MSS_BIT_SHIFT,
+					temp);
+			priv->current_temp[KEEMBAY_SENSOR_MSS] = *temp;
+			break;
+	case KEEMBAY_SENSOR_CSS:
+			kmb_sensor_read_temp(priv->base_addr,
+					AON_TSENS_DATA0,
+					CSS_T_SAMPLE_VALID,
+					CSS_T_SAMPLE,
+					CSS_BIT_SHIFT,
+					temp);
+			priv->current_temp[KEEMBAY_SENSOR_CSS] = *temp;
+			break;
+	case KEEMBAY_SENSOR_NCE:
+		{
+			int nce0, nce1;
+
+			kmb_sensor_read_temp(priv->base_addr,
+					AON_TSENS_DATA1,
+					NCE0_T_SAMPLE_VALID,
+					NCE0_T_SAMPLE,
+					NCE0_BIT_SHIFT,
+					&nce0);
+			kmb_sensor_read_temp(priv->base_addr,
+					AON_TSENS_DATA1,
+					NCE1_T_SAMPLE_VALID,
+					NCE1_T_SAMPLE,
+					NCE1_BIT_SHIFT,
+					&nce1);
+			*temp = nce1;
+			if (nce0 > nce1)
+				*temp = nce0;
+			priv->current_temp[KEEMBAY_SENSOR_NCE] = *temp;
+		}
+		break;
+	case KEEMBAY_SENSOR_SOC:
+		{
+			int i;
+
+			*temp = 0;
+			for (i = 0; i < KEEMBAY_SENSOR_MAX; i++) {
+				if (*temp < priv->current_temp[i])
+					*temp = priv->current_temp[i];
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	spin_unlock(&priv->lock);
+
+	return 0;
+}
+
+static int keembay_thermal_probe(struct platform_device *pdev)
+{
+	struct intel_tsens_plat_data *plat_data = NULL;
+	struct keembay_thermal_priv *priv;
+
+	plat_data = pdev->dev.platform_data;
+	if (!plat_data) {
+		dev_err(&pdev->dev, "Platform data not found\n");
+		return -EINVAL;
+	}
+	if (plat_data->base_addr == NULL)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev,
+			sizeof(struct keembay_thermal_priv),
+			GFP_KERNEL);
+	if (priv == NULL) {
+		dev_err(&pdev->dev, "No memory");
+		return -ENOMEM;
+	}
+	priv->name = plat_data->name;
+	priv->base_addr = plat_data->base_addr;
+	priv->plat_data = plat_data;
+	plat_data->get_temp = keembay_get_temp;
+	spin_lock_init(&priv->lock);
+	platform_set_drvdata(pdev, priv);
+	dev_info(&pdev->dev, "Thermal driver loaded for %s\n",
+			plat_data->name);
+	return 0;
+}
+
+static int keembay_thermal_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver keembay_thermal_driver = {
+	.probe = keembay_thermal_probe,
+	.remove = keembay_thermal_remove,
+	.driver = {
+		.name = "intel,keembay_thermal",
+	},
+};
+
+module_platform_driver(keembay_thermal_driver);
+
+MODULE_DESCRIPTION("KeemBay Thermal Driver");
+MODULE_AUTHOR("Sandeep Singh <sandeep1.singh@intel.com>");
+MODULE_AUTHOR("Raja Subramanian, Lakshmi Bai <lakshmi.bai.raja.subramanian@intel.com>");
+MODULE_AUTHOR("Udhayakumar C <udhayakumar.c@intel.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/intel_tsens/keembay_tsens.h b/drivers/misc/intel_tsens/keembay_tsens.h
new file mode 100644
index 000000000000..96dc4ab0dabd
--- /dev/null
+++ b/drivers/misc/intel_tsens/keembay_tsens.h
@@ -0,0 +1,354 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Keembay Temperature sensor local-host module.
+ *
+ * Copyright (C) 2019-2020 Intel Corporation.
+ */
+
+#ifndef _LINUX_KEEMBAY_TSENS_H
+#define _LINUX_KEEMBAY_TSENS_H
+
+
+#include <linux/thermal.h>
+
+/* Register values for keembay temperature (PVT Sensor) */
+#define AON_TSENS_TRIM0_CFG 0x0030
+#define AON_TSENS_TRIM1_CFG 0x0034
+#define AON_TSENS_CFG 0x0038
+#define AON_TSENS_INT0 0x203c
+#define AON_TSENS_INT1 0x2040
+#define AON_TSENS_IRQ_CLEAR 0x0044
+#define AON_TSENS_DATA0 0x0048
+#define MSS_T_SAMPLE_VALID 0x80000000
+#define MSS_T_SAMPLE 0x3ff
+#define CSS_T_SAMPLE_VALID 0x8000
+#define CSS_T_SAMPLE 0x3ff
+#define NCE1_T_SAMPLE_VALID 0x80000000
+#define NCE1_T_SAMPLE 0x3ff
+#define NCE0_T_SAMPLE_VALID 0x8000
+#define NCE0_T_SAMPLE 0x3ff
+#define AON_TSENS_DATA1 0x004c
+#define AON_INTERFACE 0x20260000
+/* Bit shift for registers*/
+#define MSS_BIT_SHIFT 16
+#define CSS_BIT_SHIFT 0
+#define NCE0_BIT_SHIFT 0
+#define NCE1_BIT_SHIFT 16
+/* mask values for config register */
+#define CFG_MASK_AUTO 0x80ff //(auto configuration)
+#define CFG_IRQ_MASK 0x8fff
+#define CFG_MASK_MANUAL  0x000f // TSENS_EN (manual configuration)
+
+enum keembay_thermal_sensor_en {
+	KEEMBAY_SENSOR_MSS,
+	KEEMBAY_SENSOR_CSS,
+	KEEMBAY_SENSOR_NCE,
+	KEEMBAY_SENSOR_SOC,
+	KEEMBAY_SENSOR_MAX
+};
+
+#define KEEMBAY_SENSOR_BASE_TEMP 27
+
+static int raw_kmb[] = {
+39956,  -39637, -39319, -39001, -38684,
+
+38367,  -38050, -37734, -37418, -37103,
+
+36787,  -36472, -36158, -35844, -35530,
+
+35216,  -34903, -34590, -34278, -33966,
+
+33654,  -33343, -33032, -32721, -32411,
+
+32101,  -31791, -31482, -31173, -30864,
+
+30556,  -30248, -29940, -29633, -29326,
+
+29020,  -28713, -28407, -28102, -27797,
+
+27492,  -27187, -26883, -26579, -26276,
+
+25973,  -25670, -25367, -25065, -24763,
+
+24462,  -24160, -23860, -23559, -23259,
+
+22959,  -22660, -22360, -22062, -21763,
+
+21465,  -21167, -20869, -20572, -20275,
+
+19979,  -19683, -19387, -19091, -18796,
+
+18501,  -18206, -17912, -17618, -17325,
+
+-17031, -16738,  -16446, -16153, -15861,
+
+-15570, -15278,  -14987, -14697, -14406,
+
+-14116, -13826,  -13537, -13248, -12959,
+
+-12670, -12382,  -12094, -11807, -11520,
+
+-11233, -10946,  -10660, -10374, -10088,
+
+-9803, -9518, -9233, -8949, -8665,
+
+-8381, -8097, -7814, -7531, -7249,
+
+-6967, -6685, -6403, -6122, -5841,
+
+-5560, -5279, -4999, -4720, -4440,
+
+-4161, -3882, -3603, -3325, -3047,
+
+-2770, -2492, -2215, -1938, -1662,
+
+-1386, -1110, -834, -559, -284,
+
+-9, 265, 539, 813, 1086,
+
+1360, 1633, 1905, 2177, 2449,
+
+2721, 2993, 3264, 3535, 3805,
+
+4075, 4345, 4615, 4884, 5153,
+
+5422, 5691, 5959, 6227, 6495,
+
+6762, 7029, 7296, 7562, 7829,
+
+8095, 8360, 8626, 8891, 9155,
+
+9420, 9684, 9948, 10212, 10475,
+
+10738, 11001, 11264, 11526, 11788,
+
+12049, 12311, 12572, 12833, 13093,
+
+13354, 13614, 13874, 14133, 14392,
+
+14651, 14910, 15168, 15426, 15684,
+
+15942, 16199, 16456, 16713, 16969,
+
+17225, 17481, 17737, 17992, 18247,
+
+18502, 18757, 19011, 19265, 19519,
+
+19772, 20025, 20278, 20531, 20784,
+
+21036, 21288, 21539, 21791, 22042,
+
+22292, 22543, 22793, 23043, 23293,
+
+23543, 23792, 24041, 24290, 24538,
+
+24786, 25034, 25282, 25529, 25776,
+
+26023, 26270, 26516, 26763, 27008,
+
+27254, 27499, 27745, 27989, 28234,
+
+28478, 28722, 28966, 29210, 29453,
+
+29696, 29939, 30182, 30424, 30666,
+
+30908, 31149, 31391, 31632, 31873,
+
+32113, 32353, 32593, 32833, 33073,
+
+33312, 33551, 33790, 34029, 34267,
+
+34505, 34743, 34980, 35218, 35455,
+
+35692, 35928, 36165, 36401, 36637,
+
+36872, 37108, 37343, 37578, 37813,
+
+38047, 38281, 38515, 38749, 38982,
+
+39216, 39448, 39681, 39914, 40146,
+
+40378, 40610, 40841, 41073, 41304,
+
+41535, 41765, 41996, 42226, 42456,
+
+42686, 42915, 43144, 43373, 43602,
+
+43830, 44059, 44287, 44515, 44742,
+
+44970, 45197, 45424, 45650, 45877,
+
+46103, 46329, 46555, 46780, 47006,
+
+47231, 47456, 47680, 47905, 48129,
+
+48353, 48576, 48800,  49023, 49246,
+
+49469, 49692, 49914,  50136, 50358,
+
+50580, 50801, 51023,  51244, 51464,
+
+51685, 51905, 52126,  52346, 52565,
+
+52785, 53004, 53223,  53442, 53661,
+
+53879, 54097, 54315,  54533, 54750,
+
+54968, 55185, 55402,  55618, 55835,
+
+56051, 56267, 56483,  56699, 56914,
+
+57129, 57344, 57559,  57773, 57988,
+
+58202, 58416, 58630,  58843, 59056,
+
+59269, 59482, 59695,  59907, 60120,
+
+60332, 60543, 60755,  60966, 61178,
+
+61389, 61599, 61810,  62020, 62231,
+
+62440, 62650, 62860,  63069, 63278,
+
+63487, 63696, 63904,  64113, 64321,
+
+64529, 64737, 64944,  65151, 65358,
+
+65565, 65772, 65979,  66185, 66391,
+
+66597, 66803, 67008, 67213, 67419,
+
+67624, 67828, 68033, 68237, 68441,
+
+68645, 68849, 69052, 69256, 69459,
+
+69662, 69865, 70067, 70270, 70472,
+
+70674, 70876, 71077, 71279, 71480,
+
+71681, 71882, 72082, 72283, 72483,
+
+72683, 72883, 73083, 73282, 73481,
+
+73680, 73879, 74078, 74277, 74475,
+
+74673, 74871, 75069, 75266, 75464,
+
+75661, 75858, 76055, 76252, 76448,
+
+76644, 76841, 77037, 77232, 77428,
+
+77623, 77818, 78013, 78208, 78403,
+
+78597, 78792, 78986, 79180, 79373,
+
+79567, 79760, 79953, 80146, 80339,
+
+80532, 80724, 80917, 81109, 81301,
+
+81492, 81684, 81875, 82066, 82258,
+
+82448, 82639, 82830, 83020, 83210,
+
+83400, 83590, 83779, 83969, 84158,
+
+84347, 84536, 84725, 84913, 85102,
+
+85290, 85478, 85666, 85854, 86041,
+
+86228, 86416, 86603, 86789, 86976,
+
+87163, 87349, 87535, 87721, 87907,
+
+88092, 88278, 88463, 88648, 88833,
+
+89018, 89203, 89387, 89571, 89755,
+
+89939, 90123, 90307, 90490, 90674,
+
+90857, 91040, 91222, 91405, 91587,
+
+91770, 91952, 92134, 92315, 92497,
+
+92679, 92860, 93041, 93222, 93403,
+
+93583, 93764, 93944, 94124, 94304,
+
+94484, 94664, 94843, 95023, 95202,
+
+95381, 95560, 95738, 95917, 96095,
+
+96273, 96451, 96629, 96807, 96985,
+
+97162, 97339, 97516, 97693, 97870,
+
+98047, 98223, 98399, 98576, 98752,
+
+98927, 99103, 99279, 99454, 99629,
+
+99804, 99979, 100154, 100328, 100503,
+
+100677, 100851, 101025, 101199, 101373,
+
+101546, 101720, 101893, 102066, 102239,
+
+102411, 102584, 102756, 102929, 103101,
+
+103273, 103445, 103616, 103788, 103959,
+
+104130, 104302, 104472, 104643, 104814,
+
+104984, 105155, 105325, 105495, 105665,
+
+105835, 106004, 106174, 106343, 106512,
+
+106681, 106850, 107019, 107187, 107355,
+
+107524, 107692, 107860, 108028, 108195,
+
+108363, 108530, 108697, 108865, 109031,
+
+109198, 109365, 109531, 109698, 109864,
+
+110030, 110196, 110362, 110528, 110693,
+
+110858, 111024, 111189, 111354, 111518,
+
+111683, 111848, 112012, 112176, 112340,
+
+112504, 112668, 112832, 112995, 113159,
+
+113322, 113485, 113648, 113811, 113973,
+
+114136, 114298, 114461, 114623, 114785,
+
+114947, 115108, 115270, 115431, 115593,
+
+115754, 115915, 116076, 116236, 116397,
+
+116558, 116718, 116878, 117038, 117198,
+
+117358, 117518, 117677, 117836, 117996,
+
+118155, 118314, 118473, 118631, 118790,
+
+118948, 119107, 119265, 119423, 119581,
+
+119739, 119896, 120054, 120211, 120368,
+
+120525, 120682, 120839, 120996, 121153,
+
+121309, 121465, 121622, 121778, 121934,
+
+122089, 122245, 122400, 122556, 122711,
+
+122866, 123021, 123176, 123331, 123486,
+
+123640, 123794, 123949, 124103, 124257,
+
+124411, 124564, 124718, 124871, 125025,
+};
+
+static int raw_kmb_size = sizeof(raw_kmb)/sizeof(int);
+
+#endif /* _LINUX_KEEMBAY_TSENS_H */
diff --git a/drivers/misc/slave_kmb_tj/Kconfig b/drivers/misc/slave_kmb_tj/Kconfig
deleted file mode 100644
index 60391947ef22..000000000000
--- a/drivers/misc/slave_kmb_tj/Kconfig
+++ /dev/null
@@ -1,6 +0,0 @@
-config SLAVE_KMB_TJ
-	tristate "KMB Tj in slave mode"
-	default y
-	help
-	  Enable this option if you want to have support for thermal management
-	  controller present in Keembay
diff --git a/drivers/misc/slave_kmb_tj/Makefile b/drivers/misc/slave_kmb_tj/Makefile
deleted file mode 100644
index 7229f7a3cff9..000000000000
--- a/drivers/misc/slave_kmb_tj/Makefile
+++ /dev/null
@@ -1,21 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the i2c core.
-#
-
-#obj-$(CONFIG_I2C_BOARDINFO)	+= i2c-boardinfo.o
-#obj-$(CONFIG_I2C)		+= i2c-core.o
-#i2c-core-objs 			:= i2c-core-base.o i2c-core-smbus.o
-#i2c-core-$(CONFIG_ACPI)		+= i2c-core-acpi.o
-#i2c-core-$(CONFIG_I2C_SLAVE) 	+= i2c-core-slave.o
-#i2c-core-$(CONFIG_OF) 		+= i2c-core-of.o
-#
-#obj-$(CONFIG_I2C_SMBUS)		+= i2c-smbus.o
-#obj-$(CONFIG_I2C_CHARDEV)	+= i2c-dev.o
-#obj-$(CONFIG_I2C_MUX)		+= i2c-mux.o
-#obj-y				+= algos/ busses/ muxes/
-#obj-$(CONFIG_I2C_STUB)		+= i2c-stub.o
-#obj-$(CONFIG_I2C_SLAVE_EEPROM)	+= i2c-slave-eeprom.o
-obj-$(CONFIG_SLAVE_KMB_TJ)	+= slave_kmb_tj.o
-
-#ccflags-$(CONFIG_I2C_DEBUG_CORE) := -DDEBUG
diff --git a/drivers/misc/xlink-smbus/xlink-smbus.c b/drivers/misc/xlink-smbus/xlink-smbus.c
index f97f94aa2d50..db4f63a1bb33 100644
--- a/drivers/misc/xlink-smbus/xlink-smbus.c
+++ b/drivers/misc/xlink-smbus/xlink-smbus.c
@@ -19,11 +19,8 @@
 #include <linux/hddl_device.h>
 #include <linux/slab.h>
 
-//#undef CONFIG_I2C_SLAVE
 /* Define the xlink debug device structures to be used with dev_dbg() et al */
 
-#define XLINK_SMBUS_DEBUG 0
-
 static struct device_driver dbg_name = {
 	.name = "xlink_i2c_dbg"
 };
@@ -170,18 +167,15 @@ static s32 xlink_smbus_xfer(struct i2c_adapter *adap, u16 addr,
 #endif
 	struct xlink_adapter_data *adapt_data = i2c_get_adapdata(adap);
 
-#if XLINK_SMBUS_DEBUG
-	dev_info(dbgxi2c, "%s was called with the following parameters:\n",
+	dev_dbg(dbgxi2c, "%s was called with the following parameters:\n",
 		__func__);
-	dev_info(dbgxi2c, "addr = %.4x\n", addr);
-	dev_info(dbgxi2c, "flags = %.4x\n", flags);
-	dev_info(dbgxi2c, "read_write = %s\n",
+	dev_dbg(dbgxi2c, "addr = %.4x\n", addr);
+	dev_dbg(dbgxi2c, "flags = %.4x\n", flags);
+	dev_dbg(dbgxi2c, "read_write = %s\n",
 			read_write == I2C_SMBUS_WRITE ? "write" : "read");
-	dev_info(dbgxi2c, "command = %d\n", command);
-	dev_info(dbgxi2c, "protocol = %d\n", protocol);
-	dev_info(dbgxi2c, "data = %p\n", data);
-#endif
-
+	dev_dbg(dbgxi2c, "command = %d\n", command);
+	dev_dbg(dbgxi2c, "protocol = %d\n", protocol);
+	dev_dbg(dbgxi2c, "data = %p\n", data);
 	msg = kzalloc(sizeof(struct xlink_msg), GFP_KERNEL);
 	if (!msg)
 		return X_LINK_ERROR;
@@ -198,9 +192,9 @@ static s32 xlink_smbus_xfer(struct i2c_adapter *adap, u16 addr,
 	xerr = xlink_write_data(adapt_data->xhandle, adapt_data->channel,
 				(u8 *)msg,
 				sizeof(struct xlink_msg));
-	kfree(msg);
+	//kfree(msg);
 	if (xerr != X_LINK_SUCCESS) {
-		dev_info(dbgxi2c,
+		dev_err(dbgxi2c,
 			"xlink_write_data failed (%d) dropping packet.\n",
 			xerr);
 		return -ENODEV;
@@ -217,7 +211,7 @@ static s32 xlink_smbus_xfer(struct i2c_adapter *adap, u16 addr,
 		if (data)
 			*data = msg->data;
 		rc = msg->status;
-		kfree(msg);
+		//kfree(msg);
 	} else {
 		rc = -ETIMEDOUT;
 	}
@@ -236,12 +230,12 @@ static int xlinki2c_receive_thread(void *param)
 	struct xlink_msg *msg;
 	struct device *dev = &adapt_data->adap->dev;
 
-	//dev_info(dbgxi2c, "xlinknet receive thread started [%p].\n",
-	//adapt_data);
-	//dev_info(dbgxi2c, "xlinknet adapt_data channel [%d].\n",
-	//adapt_data->channel);
-	//dev_info(dbgxi2c, "xlinknet adapt_data xhandle[%p].\n",
-	//adapt_data->xhandle);
+	dev_dbg(dbgxi2c, "xlinknet receive thread started [%p].\n",
+			adapt_data);
+	dev_dbg(dbgxi2c, "xlinknet adapt_data channel [%d].\n",
+			adapt_data->channel);
+	dev_dbg(dbgxi2c, "xlinknet adapt_data xhandle[%p].\n",
+			adapt_data->xhandle);
 	while (!kthread_should_stop()) {
 		msg = kzalloc(sizeof(struct xlink_msg), GFP_KERNEL);
 		if (!msg)
@@ -284,16 +278,14 @@ static int xlinki2c_receive_thread(void *param)
 			xlink_write_data(adapt_data->xhandle,
 			adapt_data->channel, (u8 *)msg,
 			sizeof(struct xlink_msg));
-			kfree(msg);
+			//kfree(msg);
 		} else {
 			/* this is an adapter on its own. */
 			list_add_tail(&msg->node, &adapt_data->head);
 			complete(&adapt_data->work);
 		}
 	}
-#if XLINK_SMBUS_DEBUG
-	dev_info(dev, "[%d] %s stopped\n", adapt_data->adap->nr, __func__);
-#endif
+	dev_dbg(dev, "[%d] %s stopped\n", adapt_data->adap->nr, __func__);
 
 	return 0;
 }
@@ -345,15 +337,15 @@ static int xlink_i2c_probe(struct platform_device *pdev)
 {
 	struct xlink_adapter_data *adapt_data;
 	uint32_t rc = 0;
-	struct kmb *hddl_device = pdev->dev.platform_data;
-	struct xlink_handle *devH = &hddl_device->devH;
-	struct i2c_adapter *adap = &hddl_device->adap[pdev->id & 0x3];
+	struct intel_hddl_clients *c = pdev->dev.platform_data;
+	struct xlink_handle *devH = &c->xlink_dev;
+	struct i2c_adapter *adap;
 	struct device *dev = &pdev->dev;
 
-#if XLINK_SMBUS_DEBUG
-	dev_info(dev, "Registering xlink I2C adapter...\n");
-#endif
+	dev_dbg(dev, "Registering xlink I2C adapter...\n");
 
+	adap = kzalloc(sizeof(struct i2c_adapter), GFP_KERNEL);
+	c->adap[pdev->id & 0x3] = adap;
 	memset(adap, 0, sizeof(struct i2c_adapter));
 	adap->class = 0; //I2C_CLASS_HWMON;
 	adap->owner  = THIS_MODULE;
@@ -367,7 +359,7 @@ static int xlink_i2c_probe(struct platform_device *pdev)
 
 	INIT_LIST_HEAD(&adapt_data->head);
 	/* TODO: connect and assign channel number */
-	adapt_data->channel = hddl_device->xlink_i2c_ch[pdev->id & 0x3];
+	adapt_data->channel = c->xlink_i2c_ch[pdev->id & 0x3];
 	adapt_data->slave = NULL;
 	adapt_data->xhandle = devH;
 	adapt_data->adap = adap;
@@ -376,12 +368,17 @@ static int xlink_i2c_probe(struct platform_device *pdev)
 			adapt_data->channel,
 			RXB_TXB,  /* mode */
 			64*1024,
-			2000   /* timeout */);
-#if XLINK_SMBUS_DEBUG
-	dev_info(dev, "xlink_open_channel completed[%d][%d][%p]\n", rc,
+			100   /* timeout */);
+	if (rc != X_LINK_SUCCESS) {
+		dev_err(dev, "xlink_open_channel failed[%d][%d][%p]\n", rc,
+		  adapt_data->channel,
+		  adapt_data->xhandle);
+		kfree(adap);
+		return -EINVAL;
+	}
+	dev_dbg(dev, "xlink_open_channel completed[%d][%d][%p]\n", rc,
 			adapt_data->channel,
 			adapt_data->xhandle);
-#endif
 
 	i2c_set_adapdata(adap, adapt_data);
 
@@ -395,7 +392,7 @@ static int xlink_i2c_probe(struct platform_device *pdev)
 					adapt_data,
 					"xlinki2c_receive_thread");
 	if (adapt_data->task_recv == NULL)
-		dev_info(dev, "%s Thread creation failed", __func__);
+		dev_err(dev, "%s Thread creation failed", __func__);
 	return rc;
 }
 
@@ -409,7 +406,7 @@ static int xlink_i2c_remove(struct platform_device *pdev)
 	/* close the channel and disconnect */
 	xlink_close_channel(adapt_data->xhandle, adapt_data->channel);
 	/* This will block the dynamic registration */
-	//i2c_del_adapter(adapt_data->adap);
+	i2c_del_adapter(adapt_data->adap);
 	kfree(adapt_data);
 	dev_info(&adap->dev, "delete the adapter[%d]\n", adap->nr);
 
@@ -426,17 +423,13 @@ static struct platform_driver xlink_i2c_driver = {
 
 static void __exit xlink_adapter_exit(void)
 {
-#if XLINK_SMBUS_DEBUG
-	dev_info(dbgxi2c, "Unloading XLink I2C module...\n");
-#endif
+	dev_dbg(dbgxi2c, "Unloading XLink I2C module...\n");
 	platform_driver_unregister(&xlink_i2c_driver);
 }
 
 static int __init xlink_adapter_init(void)
 {
-#if XLINK_SMBUS_DEBUG
-	dev_info(dbgxi2c, "Loading XLink I2C module...\n");
-#endif
+	dev_dbg(dbgxi2c, "Loading XLink I2C module...\n");
 	platform_driver_register(&xlink_i2c_driver);
 	return 0;
 
diff --git a/include/linux/hddl_device.h b/include/linux/hddl_device.h
index d4c63c2e7bfc..8cce6b85f57c 100644
--- a/include/linux/hddl_device.h
+++ b/include/linux/hddl_device.h
@@ -1,4 +1,4 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Keembay HDDL module.
  *
@@ -11,35 +11,15 @@
 #include <linux/types.h>
 #include <linux/platform_device.h>
 #include <linux/i2c.h>
+#include <linux/thermal.h>
 #include <linux/xlink.h>
+#include <linux/xlink_drv_inf.h>
 
 #define HDDL_MAGIC 'x'
 #define HDDL_READ_SW_ID_DATA    _IOW(HDDL_MAGIC, 'a', void*)
 #define HDDL_SOFT_RESET		_IOW(HDDL_MAGIC, 'b', void*)
 
-
-#define HDDL_MAX_DEVICE 8
-#define HDDL_MAX_BAY_DEVICE 3
-
-struct hddl_device_kmb {
-	uint32_t board_id;
-	struct kmb {
-		uint32_t  id;
-		struct xlink_handle devH;
-		struct platform_device_info host_kmb_tj_info;
-		struct platform_device *host_kmb_tj_plt_dev;
-		uint32_t xlink_i2c_ch[2];
-		struct i2c_adapter adap[2];
-		struct i2c_client **i2c_slaves_ext;
-		struct i2c_client **soc_smbus;
-		struct i2c_client **soc_xlinki2c;
-		struct platform_device *xlink_i2c_plt_dev[2];
-		uint32_t i2c_slaves_cnt;
-		uint32_t soc_xlinki2c_cnt;
-	} soc[HDDL_MAX_BAY_DEVICE];
-} T_HDDL_DEVICE_KMB_NODE;
-
-struct sw_id_hddl_data {
+typedef struct sw_id_hddl_data {
 	uint32_t board_id;
 	uint32_t soc_id;
 	uint32_t soc_adaptor_no[2];
@@ -47,10 +27,131 @@ struct sw_id_hddl_data {
 	uint32_t return_id;
 } T_SW_ID_HDDL_DATA;
 
-struct sw_id_soft_reset {
+typedef struct sw_id_soft_reset {
 	uint32_t sw_id;
 	uint32_t return_id;
 } T_SW_ID_SOFT_RESET;
 
+enum hddl_device {
+	HDDL_I2C_SLAVE = (1<<0),
+	HDDL_XLINK_SLAVE = (1<<1),
+	HDDL_XLINK_SMBUS_SLAVE = (1<<2),
+};
+
+enum hddl_device_status {
+	HDDL_DEV_STATUS_START,
+	HDDL_DEV_STATUS_CONNECTED,
+	HDDL_DEV_STATUS_DISCONNECTED,
+	HDDL_DEV_STATUS_END,
+};
+
+enum hddl_msg_type {
+	HDDL_GET_NSENS = 0x10,
+	HDDL_GET_SENS_NAME = 0x11,
+	HDDL_GET_SENS_DETAILS = 0x12,
+	HDDL_GET_SENS_TRIP_INFO = 0x13,
+	HDDL_GET_N_I2C_DEVS = 0x14,
+	HDDL_GET_I2C_DEVS = 0x15,
+	HDDL_GET_I2C_DEV_ADDR = 0x16,
+	HDDL_GET_SENS_COMPLETE = 0x20,
+};
+
+__packed __aligned(4) struct intel_hddl_tsens_msg {
+	int msg_type;
+	uint32_t index;
+	uint32_t index2;
+};
+
+__packed __aligned(4) struct intel_hddl_board_info {
+	int board_id;
+	int soc_id;
+};
+
+__packed __aligned(4) struct intel_tsens_data {
+	char name[20];
+	u32 n_trips;
+	u32 passive_delay;
+	u32 polling_delay;
+	u32 sensor_type;
+};
+
+__packed __aligned(4) struct intel_hddl_i2c_devs_data {
+	char name[20];
+	uint32_t addr;
+	uint32_t bus;
+	int enabled;
+	int local_host;
+	int remote_host;
+};
+
+struct intel_hddl_i2c_devs {
+	char name[20];
+	uint32_t addr;
+	uint32_t bus;
+	int enabled;
+	int local_host;
+	int remote_host;
+	struct i2c_board_info board_info;
+	struct i2c_client *xlk_client;
+	struct i2c_client *i2c_client;
+	struct i2c_client *smbus_client;
+};
+
+struct intel_hddl_clients {
+	struct xlink_handle xlink_dev;
+	struct task_struct *hddl_dev_connect_task;
+	void *task;
+	uint32_t chan_num;
+	void *pdata;
+	struct intel_hddl_board_info board_info;
+	void **tsens;
+	int nsens;
+	uint32_t xlink_i2c_ch[2];
+	uint32_t i2c_chan_num;
+	struct platform_device *xlink_i2c_plt_dev[2];
+	struct platform_device *pdev;
+	struct i2c_adapter *adap[2];
+	struct intel_hddl_i2c_devs **i2c_devs;
+	int n_slaves;
+	enum hddl_device_status status;
+	struct mutex lock;
+};
+
+struct intel_tsens_plat_data {
+	const char *name;
+	void __iomem *base_addr;
+	int (*get_temp)(struct platform_device *pdev, int type, int *temp);
+	void *pdata;
+};
+
+__packed __aligned(4) struct intel_tsens_trip_info {
+	enum thermal_trip_type trip_type;
+	int temp;
+};
+
+struct intel_tsens_plat_info {
+	const char *plat_name;
+	struct platform_device *pdev;
+	void __iomem *base_addr;
+};
+
+struct intel_tsens {
+	char name[20];
+	u32 n_trips;
+	u32 passive_delay;
+	u32 polling_delay;
+	u32 sensor_type;
+	u64 addr;
+	u64 size;
+	u32 curr_temp;
+	void __iomem *base_addr;
+	struct intel_tsens_trip_info **trip_info;
+	struct thermal_zone_device *tz;
+	void *pdata;
+	struct intel_tsens_plat_info plat_info;
+};
+
+struct intel_tsens **intel_tsens_hddl_register(int *nsens);
+
 #endif /* __HDDL_DEVICE_H */
 
diff --git a/include/linux/intel_tsens_host.h b/include/linux/intel_tsens_host.h
new file mode 100644
index 000000000000..b604bd08534b
--- /dev/null
+++ b/include/linux/intel_tsens_host.h
@@ -0,0 +1,33 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * HDDL Device HELPER module.
+ *
+ * Copyright (C) 2019-2020 Intel Corporation
+ */
+
+#ifndef _LINUX_INTEL_TSENS_HOST_DEVICE_H
+#define _LINUX_INTEL_TSENS_HOST_DEVICE_H
+
+__packed __aligned(4) struct intel_tsens_host_trip_info {
+	enum thermal_trip_type trip_type;
+	int temp;
+};
+
+struct intel_tsens_host {
+	const char *sensor_name_smbus;
+	const char *sensor_name_xlk;
+	struct intel_tsens_data *t_data;
+	struct intel_tsens_host_trip_info **trip_info;
+	uint32_t device_id;
+	struct i2c_client *i2c_xlk;
+	struct i2c_client *i2c_smbus;
+	struct thermal_zone_device *tz_xlk;
+	struct thermal_zone_device *tz_smbus;
+};
+
+struct intel_tsens_host_plat_data {
+	int nsens;
+	struct intel_tsens_host **tsens;
+};
+
+#endif /*_LINUX_INTEL_TSENS_HOST_DEVICE_H*/
-- 
2.17.1

