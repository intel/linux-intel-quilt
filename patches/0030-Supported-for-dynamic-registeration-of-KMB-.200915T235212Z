From 0cc5ef0456621e45e8644badd8abb5091e727db2 Mon Sep 17 00:00:00 2001
From: "Raja Subramanian, Lakshmi Bai" <lakshmi.bai.raja.subramanian@intel.com>
Date: Mon, 15 Jun 2020 21:38:29 +0530
Subject: [PATCH 30/48] Supported for dynamic registeration of KMB devices from
 hddl_device

Signed-off-by: Raja Subramanian, Lakshmi Bai <lakshmi.bai.raja.subramanian@intel.com>
---
 drivers/misc/hddl_device/hddl_device.c | 303 ++++++++++++++++---------
 drivers/misc/host_kmb_tj/host_kmb_tj.c |  99 ++++----
 drivers/misc/xlink-smbus/xlink-smbus.c |  52 +++--
 include/linux/hddl_device.h            |   5 +
 4 files changed, 295 insertions(+), 164 deletions(-)

diff --git a/drivers/misc/hddl_device/hddl_device.c b/drivers/misc/hddl_device/hddl_device.c
index 85830b88e9a4..ae0756782742 100644
--- a/drivers/misc/hddl_device/hddl_device.c
+++ b/drivers/misc/hddl_device/hddl_device.c
@@ -31,7 +31,7 @@
 #include <linux/fs.h>
 #include <linux/mutex.h>
 #include <linux/delay.h>
-
+#include <linux/xlink_drv_inf.h>
 #define DRIVER_NAME "hddl_device"
 
 #define HOST_KMB_TJ_DEVICE "host_kmb_tj"
@@ -44,29 +44,31 @@
 
 struct mutex my_mutex; /* shared between the threads */
 
-static struct i2c_board_info host_i2c_devices[] = {
+static struct i2c_board_info soc_i2c_ext_devices[] = {
 	{
 		I2C_BOARD_INFO("tmp112", 0x48),
 	},
 	{
 		I2C_BOARD_INFO("tmp112", 0x49),
 	},
+	{
+		I2C_BOARD_INFO("ina3221", 0x40),
+	},
 	{
 		I2C_BOARD_INFO("emc2103", 0x2e),
 	},
+};
+static struct i2c_board_info host_xlinki2c_devices[] = {
 	{
 		I2C_BOARD_INFO("host_kmb_tj", 0x5a),
 	},
+};
+#else
+static struct i2c_board_info kmb_i2c_devices[] = {
 	{
-		I2C_BOARD_INFO("ina3221", 0x40),
+		I2C_BOARD_INFO("slave-kmb-tj", (unsigned short)0x4000005b),
 	},
 };
-#else
-	static struct i2c_board_info kmb_i2c_devices[] = {
-		{
-			I2C_BOARD_INFO("slave-kmb-tj", (unsigned short)0x4000005b),
-		},
-	};
 #endif
 
 #define MAX_HDDL_DEVICES 8
@@ -185,8 +187,8 @@ static long hddl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 					} else {
 						soft_reset.return_id = 1;
 					}
-				    if (copy_to_user((T_SW_ID_SOFT_RESET *) arg, &soft_reset, sizeof(T_SW_ID_SOFT_RESET)))
-					return -EFAULT;
+					if (copy_to_user((T_SW_ID_SOFT_RESET *) arg, &soft_reset, sizeof(T_SW_ID_SOFT_RESET)))
+						return -EFAULT;
 					/* xlink-rest */
 				}
 			}
@@ -219,12 +221,89 @@ static struct file_operations fops = {
 };
 
 		/*ioctl-end*/
+int hddl_per_device_connect_thread(void *thread_param);
 
+void hddl_device_probe(uint32_t sw_device_id)
+{
+	int i, j;
+	struct task_struct *task_recv;
+	printk(KERN_INFO "hddl_device_probe = %x\n", sw_device_id);
+
+	for (i = 0; i < 8; i++) {
+	for (j = 0; j < 3; j++) {
+		if (kmb_hddls[i].soc[j].devH.sw_device_id == sw_device_id) {
+
+			printk("inside probe if-condition sw_device_id %x\n", kmb_hddls[i].soc[j].devH.sw_device_id);
 
+			printk("HDDL: Booting kmb device after reset\n");
+			task_recv = kthread_run(hddl_per_device_connect_thread,
+					(void *)&kmb_hddls[i].soc[j].devH,
+					"hddl_per_device_thread");
+			if (task_recv == NULL)
+				printk(KERN_WARNING "hddl_device_init Thread creation failed");
+			}
+		}
+	}
+}
+
+void hddl_device_remove(uint32_t sw_device_id)
+{
+	int i, j, k, rc;
+	uint32_t chan_num;
+	struct kmb *soc;
+
+	printk(KERN_INFO "hddl_device_remove = %x\n", sw_device_id);
+
+	for (i = 0; i < 8; i++) {
+	for (j = 0; j < 3; j++) {
+		if (kmb_hddls[i].soc[j].devH.sw_device_id == sw_device_id) {
+
+			soc = &kmb_hddls[i].soc[j];
+			for (k = 0; k < soc->i2c_slaves_cnt; k++) {
+				printk("i2c_slaves_ext adapter %d", soc->i2c_slaves_ext[k]->adapter->nr);
+				i2c_unregister_device(soc->i2c_slaves_ext[k]);
+			}
+			for (k = 0; k < soc->soc_xlinki2c_cnt; k++) {
+				if (soc->soc_smbus[k]) {
+					printk("soc_smbus adapter %d", soc->soc_smbus[k]->adapter->nr);
+					i2c_unregister_device(soc->soc_smbus[k]);
+				}
+			}
+			for (k = 0; k < soc->soc_xlinki2c_cnt; k++) {
+				if (soc->soc_xlinki2c[k]) {
+					printk("soc_xlinki2c adapter %d", soc->soc_xlinki2c[k]->adapter->nr);
+					i2c_unregister_device(soc->soc_xlinki2c[k]);
+				}
+			}
+
+			chan_num = HDDL_NODE_XLINK_CHANNEL + soc->devH.node;
+			printk("chan_num form remove function = %d\n", chan_num);
+
+			for (k = 0; k < 2; k++) {
+
+				printk("HDDL : platform_device_unregister = %d\n", k);
+				platform_device_unregister(soc->xlink_i2c_plt_dev[k]);
+			}
+
+			rc = xlink_close_channel(&soc->devH, chan_num);
+			printk(KERN_INFO "HDDL:Close Channel Number[%x]: [%u] EC[%d]\n", sw_device_id, chan_num, rc);
+
+			rc = xlink_disconnect(&soc->devH);
+			printk(KERN_INFO "HDDL:Disconnect[%x]: EC[%d]\n", sw_device_id, rc);
+			printk("value of rc from remove = %d", rc);
+			}
+		}
+	}
+}
 
+const struct xlink_drv_event_ops ops = {
+	.probe = hddl_device_probe,
+	.remove = hddl_device_remove,
+};
 
-static int hddl_per_device_connect_thread(void *thread_param)
+int hddl_per_device_connect_thread(void *thread_param)
 {
+	struct kmb *soc;
 	char device_name[XLINK_MAX_DEVICE_NAME_SIZE];
 	uint32_t device_status = 0xFF;
 	uint32_t board_info;
@@ -235,7 +314,7 @@ static int hddl_per_device_connect_thread(void *thread_param)
 	uint32_t kmb_id = 0;
 	struct timespec64 ts;
 	uint32_t chan_num;
-	uint32_t j = 0;
+	uint32_t j = 0, i = 0;
 	#ifndef CONFIG_HDDL_LOCAL_HOST
 	struct i2c_adapter *temp;
 	struct i2c_board_info temp_host_i2c_device;
@@ -244,43 +323,49 @@ static int hddl_per_device_connect_thread(void *thread_param)
 
 	struct platform_device_info xlink_i2c_info = {0};
 
+	while ((rc = xlink_boot_device(devH, DEFAULT_NOMINAL_MAX)) != X_LINK_SUCCESS) {
+		msleep_interruptible(1000);
+	}
+
 	rc = xlink_get_device_name(devH->sw_device_id,
-	device_name, XLINK_MAX_DEVICE_NAME_SIZE);
+		device_name, XLINK_MAX_DEVICE_NAME_SIZE);
 	if (rc > 0) {
 		printk(KERN_INFO
-		"HDDL:Failed to get device name of id [EC%d] %u\n",
+		"HDDL:Failed to get device name of id [EC%d] %x\n",
 		rc, devH->sw_device_id);
 		return rc;
 	}
-	printk(KERN_INFO "HDDL:Device name: %d %s\n",
-	devH->sw_device_id, device_name);
-	while ((rc = xlink_get_device_status(devH->sw_device_id,
-	&device_status)) != X_LINK_SUCCESS) {
+	printk(KERN_INFO "HDDL:Device name: %x %s\n",
+		devH->sw_device_id, device_name);
+	while ((rc = xlink_get_device_status(devH->sw_device_id, &device_status)) != X_LINK_SUCCESS) {
+
 	}
 	printk(KERN_INFO "HDDL:Device status[%d]: %u\n", rc, device_status);
 	while ((rc = xlink_connect(devH)) != 0) {
 	}
+
 	#ifdef CONFIG_HDDL_LOCAL_HOST
-		switch (hddl_get_kmb_id()) {
-		default:
-		case 0:
-			chan_num = HDDL_NODE_XLINK_CHANNEL + 0;
-			break;
-
-		case 1:
-			chan_num = HDDL_NODE_XLINK_CHANNEL + 2;
-			break;
-
-		case 2:
-			chan_num = HDDL_NODE_XLINK_CHANNEL + 1;
-			break;
-		}
+	switch (hddl_get_kmb_id()) {
+	default:
+	case 0:
+		chan_num = HDDL_NODE_XLINK_CHANNEL + 0;
+		break;
+
+	case 1:
+		chan_num = HDDL_NODE_XLINK_CHANNEL + 2;
+		break;
+
+	case 2:
+		chan_num = HDDL_NODE_XLINK_CHANNEL + 1;
+		break;
+}
 	#else
-		chan_num = HDDL_NODE_XLINK_CHANNEL + devH->node;
+	chan_num = HDDL_NODE_XLINK_CHANNEL + devH->node;
 	#endif
-
 	//chan_num = HDDL_NODE_XLINK_CHANNEL;
-	printk(KERN_INFO "HDDL:Channel Number: %u\n", chan_num);
+	printk(KERN_INFO "HDDL:Channel Number[%x]: %u\n", devH->sw_device_id, chan_num);
+
+	xlink_pcie_register_events(devH->sw_device_id, &ops);
 
 	while ((rc = xlink_open_channel(devH,
 			chan_num,
@@ -312,9 +397,9 @@ static int hddl_per_device_connect_thread(void *thread_param)
 	(uint8_t *) &board_id_rcvd, &size);
 	xlink_release_data(devH, chan_num, NULL);
 	printk(KERN_INFO
-	"HDDL: [%d]xlink_read_data completed Rcvd Size[%d]\n", rc, size);
-	printk(KERN_INFO "HDDL: Board Info[%x %x]\n", board_info,
-	board_id_rcvd);
+				"HDDL: [%d]xlink_read_data completed Rcvd Size[%d]\n", rc, size);
+	printk(KERN_INFO "HDDL: Board Info[%x %x]\n", board_info, board_id_rcvd);
+
 	if (board_info == ~(board_id_rcvd)) {
 		memcpy(&kmb_hddls[board_id].soc[kmb_id].devH, devH,
 		sizeof(struct xlink_handle));
@@ -329,12 +414,11 @@ static int hddl_per_device_connect_thread(void *thread_param)
 		);
 	}
 	#else
+
 	ktime_get_real_ts64(&ts);
 	printk(KERN_INFO "S[%llx] NS[%lx]\n", ts.tv_sec, ts.tv_nsec);
-	rc = xlink_write_volatile(devH, chan_num,
-	(uint8_t *) &ts, sizeof(struct timespec64));
-	printk(KERN_INFO "HDDL: Size Transferred[%d] = %ld\n",
-	rc, sizeof(struct timespec64));
+	rc = xlink_write_volatile(devH, chan_num, (uint8_t *) &ts, sizeof(struct timespec64));
+	printk(KERN_INFO "HDDL: Size Transferred[%d] = %ld\n", 	rc, sizeof(struct timespec64));
 
 	printk(KERN_INFO "HDDL: xlink_read_data to start...\n");
 	size = sizeof(board_id_rcvd);
@@ -363,6 +447,7 @@ static int hddl_per_device_connect_thread(void *thread_param)
 		kmb_hddls[board_id].soc[kmb_id].devH.link_id
 	);
 	#endif
+	soc = &kmb_hddls[board_id].soc[kmb_id];
 	for (j = 0; j < 2; ++j) {
 		xlink_i2c_info.name = "i2c_xlink";
 		xlink_i2c_info.id = board_id << 4 | kmb_id << 2 | j;
@@ -371,68 +456,84 @@ static int hddl_per_device_connect_thread(void *thread_param)
 		xlink_i2c_info.data = &kmb_hddls[board_id].soc[kmb_id];
 		xlink_i2c_info.size_data =
 				sizeof(kmb_hddls[board_id].soc[kmb_id]);
-		kmb_hddls[board_id].soc[kmb_id].xlink_i2c_plt_dev[j] =
+		soc->xlink_i2c_plt_dev[j] =
 		platform_device_register_full(&xlink_i2c_info);
-		kmb_hddls[board_id].soc[kmb_id].adap[j] = *
-		((struct i2c_adapter *)
-		platform_get_drvdata(
-		kmb_hddls[board_id].soc[kmb_id].xlink_i2c_plt_dev[j]));
-		printk(KERN_INFO "Adapter number = %d\n",
-		kmb_hddls[board_id].soc[kmb_id].adap[j].nr);
+		soc->adap[j] = *((struct i2c_adapter *)platform_get_drvdata(soc->xlink_i2c_plt_dev[j]));
+		printk(KERN_INFO "Adapter number = %d\n", soc->adap[j].nr);
 	}
 	#ifndef CONFIG_HDDL_LOCAL_HOST
+	soc->soc_xlinki2c_cnt = sizeof(host_xlinki2c_devices)/sizeof(struct i2c_board_info);
 
-	temp_host_i2c_device = host_i2c_devices[3];
+	soc->soc_smbus = kzalloc(sizeof(struct i2c_client *) * (kmb_hddls[board_id].soc[kmb_id].soc_xlinki2c_cnt), GFP_KERNEL);
 
-	if (board_id <= 4) {
-		/* slave address range 0x10 -- 0x1F */
-		temp_host_i2c_device.addr =
-					kmb_id + 0x10 + (board_id * 3);
-	} else {
-		/* Slave address range 0x60 -- 0x6F */
-		temp_host_i2c_device.addr =
-					kmb_id + 0x60 + ((board_id - 5) * 3);
-	}
-	temp_host_i2c_device.platform_data =
-			&kmb_hddls[board_id].soc[kmb_id].devH.sw_device_id;
-	j = 0;
-	while ((temp = i2c_get_adapter(j)) != NULL) {
-		if (strstr(temp->name, "SMBus I801") != NULL) {
-			i2c_new_client_device(temp, &temp_host_i2c_device);
-			break;
+	soc->soc_xlinki2c = kzalloc(sizeof(struct i2c_client *) * (kmb_hddls[board_id].soc[kmb_id].soc_xlinki2c_cnt), GFP_KERNEL);
+
+	for (i = 0; i < soc->soc_xlinki2c_cnt; i++) {
+		temp_host_i2c_device = host_xlinki2c_devices[i];
+
+		if (board_id <= 4) {
+			/* slave address range 0x10 -- 0x1F */
+			temp_host_i2c_device.addr =
+						kmb_id + 0x10 + (board_id * 3);
+		} else {
+			/* Slave address range 0x60 -- 0x6F */
+			temp_host_i2c_device.addr =
+						kmb_id + 0x60 + ((board_id - 5) * 3);
+		}
+		temp_host_i2c_device.platform_data = &(soc->devH.sw_device_id);
+
+		j = 0;
+		while ((temp = i2c_get_adapter(j)) != NULL) {
+			if (strstr(temp->name, "SMBus I801") != NULL) {
+				soc->soc_smbus[i] = i2c_new_client_device(temp, &temp_host_i2c_device);
+				printk("soc_smbus adapter %d", soc->soc_smbus[i]->adapter->nr);
+				break;
+			}
+			j++;
 		}
-		j++;
+		soc->soc_xlinki2c[i] = i2c_new_client_device(i2c_get_adapter(
+				soc->adap[1].nr),
+				&temp_host_i2c_device);
+		printk("soc_xlinki2c adapter %d", soc->soc_xlinki2c[i]->adapter->nr);
+
+		printk(KERN_INFO
+			"Host_kmb_tj [%s] %d\n",
+			temp_host_i2c_device.type,
+			temp_host_i2c_device.addr);
 	}
-	printk(KERN_INFO
-	"Host_kmb_tj [%s] %d\n",
-	temp_host_i2c_device.type, temp_host_i2c_device.addr);
-	i2c_new_client_device(i2c_get_adapter(
-	kmb_hddls[board_id].soc[kmb_id].adap[1].nr),
-	&temp_host_i2c_device); /* TODO */
+
+	soc->i2c_slaves_cnt = sizeof(soc_i2c_ext_devices)/sizeof(struct i2c_board_info);
+
+	soc->i2c_slaves_ext = kzalloc(sizeof(struct i2c_client *) * (soc->i2c_slaves_cnt), GFP_KERNEL);
 
 	mutex_lock(&my_mutex);
-	i2c_new_client_device(
-	i2c_get_adapter(kmb_hddls[board_id].soc[kmb_id].adap[0].nr),
-	&host_i2c_devices[0]); /* TODO */
-	i2c_new_client_device(
-	i2c_get_adapter(kmb_hddls[board_id].soc[kmb_id].adap[0].nr),
-	&host_i2c_devices[1]); /* TODO */
-	i2c_new_client_device(
-	i2c_get_adapter(kmb_hddls[board_id].soc[kmb_id].adap[0].nr),
-	&host_i2c_devices[2]); /* TODO */
-	i2c_new_client_device(
-	i2c_get_adapter(kmb_hddls[board_id].soc[kmb_id].adap[0].nr),
-	&host_i2c_devices[4]); /* TODO */
-	ssleep(1);
+
+	for (i = 0; i < soc->i2c_slaves_cnt; i++) {
+		soc->i2c_slaves_ext[i] = i2c_new_client_device(
+			i2c_get_adapter(soc->adap[0].nr),
+			&soc_i2c_ext_devices[i]);
+		printk("i2c_slaves_ext adapter %d", soc->i2c_slaves_ext[i]->adapter->nr);
+
+		ssleep(1);
+	}
 	mutex_unlock(&my_mutex);
+
 	#else
-		i2c_new_client_device(
-	i2c_get_adapter(kmb_hddls[board_id].soc[kmb_id].adap[1].nr),
-	&kmb_i2c_devices[0]); /* TODO */
+	soc->soc_xlinki2c_cnt = sizeof(kmb_i2c_devices)/sizeof(struct i2c_board_info);
+	soc->soc_xlinki2c = kzalloc(sizeof(struct i2c_client *) * (soc->soc_xlinki2c_cnt), GFP_KERNEL);
+	for (i = 0; i < soc->soc_xlinki2c_cnt; i++) {
+		soc->soc_xlinki2c[i] = i2c_new_client_device(
+			i2c_get_adapter(soc->adap[1].nr),
+			&kmb_i2c_devices[i]);
+	}
 	#endif
 	return 0;
 }
 
+
+
+
+
 #define SW_DEVICE_ID_INTERFACE_SHIFT 24U
 #define SW_DEVICE_ID_INTERFACE_MASK  0x7
 #define GET_INTERFACE_FROM_SW_DEVICE_ID(id) \
@@ -444,10 +545,10 @@ static int hddl_per_device_connect_thread(void *thread_param)
 static struct xlink_handle xdevH[6];
 static int hddl_device_thermal_init(void *thread_param)
 {
-	uint32_t num_devices = 0, i = 0;
+	uint32_t num_devices = 0;
 	uint32_t sw_device_id_list[XLINK_MAX_DEVICE_LIST_SIZE];
 	char device_name[XLINK_MAX_DEVICE_NAME_SIZE];
-	uint32_t rc = 0;
+	uint32_t i = 0;
 
 	printk(KERN_INFO "HDDL:Getting device list...\n");
 #ifndef CONFIG_HDDL_LOCAL_HOST
@@ -467,31 +568,19 @@ static int hddl_device_thermal_init(void *thread_param)
 		xdevH[i].sw_device_id = sw_device_id_list[i];
 		xlink_get_device_name(xdevH[i].sw_device_id,
 		device_name, XLINK_MAX_DEVICE_NAME_SIZE);
-		printk(KERN_INFO "HDDL:Device name: %d %s\n",
+		printk(KERN_INFO "HDDL:Device name: %x %s\n",
 		xdevH[i].sw_device_id, device_name);
 	}
+
 	for (i = 0; i < num_devices; i++) {
-		#ifdef XLINK_CONNECT_THREAD_BASED
 		struct task_struct *task_recv;
-		#endif
-		printk(KERN_INFO "HDDL:Booting device...\n");
 		if (GET_INTERFACE_FROM_SW_DEVICE_ID(xdevH[i].sw_device_id) == SW_DEVICE_ID_PCIE_INTERFACE) {
-			rc = xlink_boot_device(&xdevH[i], DEFAULT_NOMINAL_MAX);
-			if (rc > 0) {
-				printk(KERN_WARNING
-				"HDDL:Failed to boot device [EC%d] %s\n", rc,
-				device_name);
-				continue;
-			}
-			#ifdef XLINK_CONNECT_THREAD_BASED
+			printk(KERN_INFO "HDDL:Booting device...\n");
 			task_recv = kthread_run(hddl_per_device_connect_thread,
 			(void *)&xdevH[i],
 			"hddl_per_device_thread");
 			if (task_recv == NULL)
 				printk(KERN_WARNING "hddl_device_init Thread creation failed");
-			#else
-				hddl_per_device_connect_thread(&xdevH[i]);
-			#endif
 		}
 
 	}
diff --git a/drivers/misc/host_kmb_tj/host_kmb_tj.c b/drivers/misc/host_kmb_tj/host_kmb_tj.c
index 871ff137c2ce..7f3265c4d06d 100644
--- a/drivers/misc/host_kmb_tj/host_kmb_tj.c
+++ b/drivers/misc/host_kmb_tj/host_kmb_tj.c
@@ -30,7 +30,6 @@ static int keembay_get_temp_host(struct thermal_zone_device *thermal,
 	unsigned char rx_buf[4] = {0, 0, 0, 0};
 
 	spin_lock(&ktherm->lock);
-	*temp = 0;
 	switch (kmb_zone_info->sensor_type) {
 	case KEEMBAY_SENSOR_MSS_HOST:
 		rx_buf[0] = i2c_smbus_read_byte_data(ktherm->i2c_c, 8);
@@ -63,6 +62,7 @@ static int keembay_get_temp_host(struct thermal_zone_device *thermal,
 	default:
 		break;
 	}
+	//dev_info(&ktherm->i2c_c->dev, "HOST_KMB_TJ[%d] %d\n", kmb_zone_info->sensor_type, *temp);
 	spin_unlock(&ktherm->lock);
 
 	/* TODO: How to do error handling here */
@@ -140,7 +140,8 @@ static int keembay_unbind_host(struct thermal_zone_device *tz,
 		      struct thermal_cooling_device *cdev)
 {
 	int ret;
-
+	printk("inside unbind");
+	if (strncmp("keembay_thermal", cdev->type, THERMAL_NAME_LENGTH) == 0) {
 	ret = thermal_zone_unbind_cooling_device(tz, 0, cdev);
 	if (ret) {
 		dev_err(&tz->device,
@@ -148,6 +149,7 @@ static int keembay_unbind_host(struct thermal_zone_device *tz,
 			tz->type, cdev->type, ret);
 		return ret;
 	}
+		}
 	return 0;
 }
 
@@ -189,9 +191,9 @@ EXPORT_SYMBOL_GPL(keembay_thermal_zone_register_host);
 int keembay_thermal_zone_unregister_host(
 			struct kmb_trip_point_info *zone_trip_info)
 {
+	printk("inside unregister");
 	thermal_zone_device_unregister(zone_trip_info->tz);
-	if (zone_trip_info->thermal_info != NULL)
-		kfree(zone_trip_info->thermal_info);
+	printk("exiting unregister");
 	return 0;
 }
 
@@ -252,66 +254,79 @@ struct kmb_trip_point_info soc_max_zone_trip_info_host = {
 	NULL,
 };
 
+#define KMB_TJ_SENSORS 4
 static int host_kmb_tj_probe(struct i2c_client *client,
 				const struct i2c_device_id *id)
 {
-	struct kmb_trip_point_info *host_kmb_trip_info1 = NULL;
-	struct kmb_trip_point_info *host_kmb_trip_info2 = NULL;
-	struct kmb_trip_point_info *host_kmb_trip_info3 = NULL;
-	struct kmb_trip_point_info *host_kmb_trip_info4 = NULL;
 	char *i2c_str;
+	struct kmb_trip_point_info *host_kmb_trip_info;
 	uint32_t *device_id = client->dev.platform_data;
+	int i;
 
 	if (strstr(client->adapter->name, "SMBus I801") != NULL)
 		i2c_str = "smb";
 	else
 		i2c_str = "xlk";
 
-	host_kmb_trip_info1 = kzalloc(
-			sizeof(struct kmb_trip_point_info), GFP_KERNEL);
-	memcpy(host_kmb_trip_info1, &mss_zone_trip_info_host,
+
+	host_kmb_trip_info = (struct kmb_trip_point_info *)kzalloc(
+		sizeof(struct kmb_trip_point_info) * KMB_TJ_SENSORS, GFP_KERNEL);
+	for (i = 0; i < KMB_TJ_SENSORS; i++) {
+		switch (i) {
+		case 0:
+			memcpy(&host_kmb_trip_info[0], &mss_zone_trip_info_host,
 				sizeof(struct kmb_trip_point_info));
-	host_kmb_trip_info1->sensor_name = kasprintf(GFP_KERNEL,
+
+			host_kmb_trip_info[0].sensor_name = kasprintf(GFP_KERNEL,
 				"mss_%s-%x", i2c_str, *device_id);
-	host_kmb_trip_info1->thermal_info =  kzalloc(
+
+			host_kmb_trip_info[0].thermal_info =  kzalloc(
 			sizeof(struct keembay_therm_info), GFP_KERNEL);
-	host_kmb_trip_info1->thermal_info->i2c_c = client;
 
-	host_kmb_trip_info2 = kzalloc(
-			sizeof(struct kmb_trip_point_info), GFP_KERNEL);
-	memcpy(host_kmb_trip_info2, &css_zone_trip_info_host,
+			host_kmb_trip_info[0].thermal_info->i2c_c = client;
+			break;
+		case 1:
+			memcpy(&host_kmb_trip_info[1], &css_zone_trip_info_host,
 				sizeof(struct kmb_trip_point_info));
-	host_kmb_trip_info2->sensor_name = kasprintf(GFP_KERNEL,
+
+			host_kmb_trip_info[1].sensor_name = kasprintf(GFP_KERNEL,
 				"css_%s-%x", i2c_str, *device_id);
-	host_kmb_trip_info2->thermal_info =  kzalloc(
+
+			host_kmb_trip_info[1].thermal_info =  kzalloc(
 			sizeof(struct keembay_therm_info), GFP_KERNEL);
-	host_kmb_trip_info2->thermal_info->i2c_c = client;
 
-	host_kmb_trip_info3 = kzalloc(
-			sizeof(struct kmb_trip_point_info), GFP_KERNEL);
-	memcpy(host_kmb_trip_info3, &nce_max_zone_trip_info_host,
+			host_kmb_trip_info[1].thermal_info->i2c_c = client;
+			break;
+		case 2:
+			memcpy(&host_kmb_trip_info[2], &nce_max_zone_trip_info_host,
 				sizeof(struct kmb_trip_point_info));
-	host_kmb_trip_info3->sensor_name = kasprintf(GFP_KERNEL,
+
+			host_kmb_trip_info[2].sensor_name = kasprintf(GFP_KERNEL,
 				"nce_%s-%x", i2c_str, *device_id);
-	host_kmb_trip_info3->thermal_info =
+
+			host_kmb_trip_info[2].thermal_info =
 		kzalloc(sizeof(struct keembay_therm_info), GFP_KERNEL);
-	host_kmb_trip_info3->thermal_info->i2c_c = client;
 
-	host_kmb_trip_info4 = kzalloc(
-			sizeof(struct kmb_trip_point_info), GFP_KERNEL);
-	memcpy(host_kmb_trip_info4, &soc_max_zone_trip_info_host,
+			host_kmb_trip_info[2].thermal_info->i2c_c = client;
+			break;
+		case 3:
+			memcpy(&host_kmb_trip_info[3], &soc_max_zone_trip_info_host,
 				sizeof(struct kmb_trip_point_info));
-	host_kmb_trip_info4->sensor_name = kasprintf(
+
+			host_kmb_trip_info[3].sensor_name = kasprintf(
 			GFP_KERNEL, "soc_%s-%x", i2c_str, *device_id);
-	host_kmb_trip_info4->thermal_info =  kzalloc(
+
+			host_kmb_trip_info[3].thermal_info =  kzalloc(
 			sizeof(struct keembay_therm_info), GFP_KERNEL);
-	host_kmb_trip_info4->thermal_info->i2c_c = client;
 
-	/* i2c_set_clientdata(client, host_kmb_trip_info); */
-	keembay_thermal_zone_register_host(host_kmb_trip_info1);
-	keembay_thermal_zone_register_host(host_kmb_trip_info2);
-	keembay_thermal_zone_register_host(host_kmb_trip_info3);
-	keembay_thermal_zone_register_host(host_kmb_trip_info4);
+			host_kmb_trip_info[3].thermal_info->i2c_c = client;
+			break;
+		default:
+			break;
+		}
+		keembay_thermal_zone_register_host(&host_kmb_trip_info[i]);
+	}
+	i2c_set_clientdata(client, host_kmb_trip_info);
 
 	printk(KERN_INFO "host_kmb_tj: probe success\n");
 
@@ -322,14 +337,18 @@ static int host_kmb_tj_exit(struct i2c_client *client)
 {
 	struct kmb_trip_point_info *host_kmb_trip_info =
 					i2c_get_clientdata(client);
+	int i;
+	for (i = 0; i < KMB_TJ_SENSORS; i++) {
 
-	kfree(host_kmb_trip_info->thermal_info);
-	kfree(host_kmb_trip_info);
+		keembay_thermal_zone_unregister_host(&host_kmb_trip_info[i]);
 
+		if (host_kmb_trip_info[i].thermal_info != NULL)
+			kfree (host_kmb_trip_info[i].thermal_info);
+	}
+	kfree (host_kmb_trip_info);
 	return 0;
 }
 
-
 static const struct i2c_device_id i2c_host_kmb_tj_id[] = {
 	{ "host_kmb_tj", 16 },
 	{}
diff --git a/drivers/misc/xlink-smbus/xlink-smbus.c b/drivers/misc/xlink-smbus/xlink-smbus.c
index dc16e404013c..5a2cd132821c 100644
--- a/drivers/misc/xlink-smbus/xlink-smbus.c
+++ b/drivers/misc/xlink-smbus/xlink-smbus.c
@@ -51,6 +51,7 @@ struct xlink_adapter_data {
 	struct task_struct *task_recv;
 	struct i2c_client *slave;
 	struct list_head head;
+	struct i2c_adapter *adap;
 };
 
 
@@ -231,7 +232,7 @@ static s32 xlink_smbus_xfer(struct i2c_adapter *adap, u16 addr,
 		dev_info(dbgxi2c, "xlink_write_data failed (%d)"
 			"dropping packet.\n",
 			xerr);
-		return xerr;
+		return -ENODEV;
 	}
 	//dev_info(dbgxi2c, "xlink_write_data - success[%d]\n", xerr);
 /* TODO: handle timeout and return time out error code to the caller of xfer */
@@ -259,6 +260,7 @@ static int xlinki2c_receive_thread(void *param)
 				(struct xlink_adapter_data *)param;
 	u32 size;
 	struct xlink_msg *msg;
+	struct device *dev = &adapt_data->adap->dev;
 
 	//dev_info(dbgxi2c, "xlinknet receive thread started [%p].\n",
 	//adapt_data);
@@ -274,15 +276,18 @@ static int xlinki2c_receive_thread(void *param)
 						adapt_data->channel,
 						(uint8_t *)msg, &size);
 		if (xerr != X_LINK_SUCCESS) {
-			dev_warn(dbgxi2c, "xlink_read_data failed (%d)"
-			"dropping packet.\n",
-				xerr);
+			if (xerr != X_LINK_TIMEOUT) {
+				dev_warn(dev, "[%d]xlink_read_data failed (%d)"
+					"dropping packet.\n",
+					adapt_data->adap->nr, xerr);
+			}
+			kfree(msg);
 			continue;
 		}
 		//dev_info(dbgxi2c, "xlink_read_data_to_buffer[%d][%d]\n",
 		//xerr, size);
 		xlink_release_data(adapt_data->xhandle, adapt_data->channel,
-		NULL);
+						NULL);
 		//dev_info(dbgxi2c, "xlink_release_data\n");
 		adap = get_adapter_from_channel(adapt_data->channel);
 		if (adap) {
@@ -333,6 +338,8 @@ static int xlinki2c_receive_thread(void *param)
 			//dev_info(dbgxi2c, "signal completed\n");
 		}
 	}
+	dev_info(dev, "[%d]xlinki2c_receive_thread stopped.\n",
+			adapt_data->adap->nr);
 
 	return 0;
 }
@@ -384,15 +391,16 @@ static struct i2c_algorithm xlink_algorithm = {
 static int xlink_i2c_probe(struct platform_device *pdev)
 {
 	struct xlink_adapter_data *adapt_data;
-	struct task_struct *task_recv;
 	uint32_t rc = 0;
 	struct kmb *hddl_device = pdev->dev.platform_data;
 	struct xlink_handle *devH = &hddl_device->devH;
 	struct i2c_adapter *adap = &hddl_device->adap[pdev->id & 0x3];
+	struct device *dev = &pdev->dev;
 
-	dev_info(dbgxi2c, "Registering xlink I2C adapter...\n");
+	dev_info(dev, "Registering xlink I2C adapter...\n");
 
 	//adap = kzalloc(sizeof(struct i2c_adapter), GFP_KERNEL);
+	memset(adap, 0, sizeof(struct i2c_adapter));
 	adap->class = 0; //I2C_CLASS_HWMON;
 	adap->owner  = THIS_MODULE;
 	adap->algo   = &xlink_algorithm;
@@ -408,13 +416,14 @@ static int xlink_i2c_probe(struct platform_device *pdev)
 	adapt_data->channel = hddl_device->xlink_i2c_ch[pdev->id & 0x3];
 	adapt_data->slave = NULL;
 	adapt_data->xhandle = devH;
+	adapt_data->adap = adap;
 
 	rc = xlink_open_channel(devH,
 			adapt_data->channel,
 			RXB_TXB,  /* mode */
 			64*1024,
 			0   /* timeout */);
-	dev_info(dbgxi2c, "xlink_open_channel completed[%d][%d][%p]\n", rc,
+	dev_info(dev, "xlink_open_channel completed[%d][%d][%p]\n", rc,
 		adapt_data->channel,
 		adapt_data->xhandle);
 
@@ -422,12 +431,12 @@ static int xlink_i2c_probe(struct platform_device *pdev)
 
 	rc = i2c_add_adapter(adap);
 
-	dev_info(dbgxi2c, "xlink_smbus_adapter[%d] [%d]\n", rc, adap->nr);
+	dev_info(&adap->dev, "xlink_smbus_adapter[%d] [%d]\n", rc, adap->nr);
 	/* create receiver thread */
-	task_recv = kthread_run(xlinki2c_receive_thread,
-			adapt_data,
-			"xlinki2c_receive_thread");
-	if (task_recv == NULL) {
+	adapt_data->task_recv = kthread_run(xlinki2c_receive_thread,
+															adapt_data,
+															"xlinki2c_receive_thread");
+	if (adapt_data->task_recv == NULL) {
 		printk("xlinki2c_receive_thread Thread creation failed");
 	}
 	return rc;
@@ -436,10 +445,19 @@ static int xlink_i2c_probe(struct platform_device *pdev)
 static int xlink_i2c_remove(struct platform_device *pdev)
 {
 	struct i2c_adapter *adap = platform_get_drvdata(pdev);
-
-	dev_info(dbgxi2c, "Removing xlink I2C adapter...\n");
-	/* TODO: close the channel and disconnect */
-	i2c_del_adapter(adap);
+	struct xlink_adapter_data *adapt_data = i2c_get_adapdata(adap);
+	struct device *dev = &adapt_data->adap->dev;
+
+	dev_info(dev, "Removing xlink I2C adapter...\n");
+	kthread_stop(adapt_data->task_recv);
+	dev_info(dev, "stop the kthread...\n");
+
+	/* close the channel and disconnect */
+	xlink_close_channel(adapt_data->xhandle, adapt_data->channel);
+	dev_info(dev, "close the channel...\n");
+	i2c_del_adapter(adapt_data->adap); /* This will block the dynamic registeration */
+	kfree(adapt_data);
+	dev_info(dev, "delete the adapter...\n");
 
 	return 0;
 }
diff --git a/include/linux/hddl_device.h b/include/linux/hddl_device.h
index 5c9046e5b91d..aec4ebfb9aea 100644
--- a/include/linux/hddl_device.h
+++ b/include/linux/hddl_device.h
@@ -21,7 +21,12 @@ typedef struct hddl_device_kmb_st {
 		struct platform_device *host_kmb_tj_plt_dev;
 		uint32_t xlink_i2c_ch[2];
 		struct i2c_adapter adap[2];
+		struct i2c_client **i2c_slaves_ext;
+		struct i2c_client **soc_smbus;
+		struct i2c_client **soc_xlinki2c;
 		struct platform_device *xlink_i2c_plt_dev[2];
+		uint32_t i2c_slaves_cnt;
+		uint32_t soc_xlinki2c_cnt;
 	} soc[3];
 } T_HDDL_DEVICE_KMB_NODE;
 
-- 
2.17.1

