From c2198809408cf67767651a83f3024c6340602479 Mon Sep 17 00:00:00 2001
From: Ong Boon Leong <boon.leong.ong@intel.com>
Date: Thu, 9 Apr 2020 15:32:25 +0800
Subject: [PATCH 24/42] net: stmmac: clean all pending Tx buffers during
 suspend

To ensure driver enters low power state without leaving behind Tx frame
that are in Tx DMA ring but not yet returned through Tx Done operation,
we introduce a function here to clean them.

Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
---
 .../net/ethernet/stmicro/stmmac/stmmac_main.c | 33 +++++++++++++++++++
 1 file changed, 33 insertions(+)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index fe6620cd5185..2148d1362e50 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -6271,6 +6271,37 @@ int stmmac_reinit_ringparam(struct net_device *dev, u32 rx_size, u32 tx_size)
 	return ret;
 }
 
+static void stmmac_clean_tx_queue(struct stmmac_priv *priv,
+				  struct stmmac_tx_queue *tx_q)
+{
+	u32 queue = tx_q->queue_index;
+	unsigned int entry;
+
+	entry = tx_q->dirty_tx;
+	while (entry != tx_q->cur_tx) {
+		/* Free all the Tx ring sk_buffs */
+		stmmac_free_tx_buffer(priv, queue, entry);
+
+		entry = STMMAC_GET_ENTRY(entry, priv->dma_tx_size);
+	}
+	tx_q->dirty_tx = entry;
+
+	/* reset BQL for queue */
+	netdev_tx_reset_queue(netdev_get_tx_queue(priv->dev, queue));
+}
+
+void stmmac_clean_all_tx_rings(struct stmmac_priv *priv)
+{
+	u32 tx_count = priv->plat->tx_queues_to_use;
+	u32 queue;
+
+	for (queue = 0; queue < tx_count; queue++) {
+		struct stmmac_tx_queue *tx_q = get_tx_queue(priv, queue);
+
+		stmmac_clean_tx_queue(priv, tx_q);
+	}
+}
+
 /**
  * stmmac_dvr_probe
  * @device: device pointer
@@ -6764,6 +6795,8 @@ int stmmac_suspend(struct device *dev)
 		stmmac_fpe_set_enable(priv, priv->hw, ndev, false);
 	}
 
+	stmmac_clean_all_tx_rings(priv);
+
 	mutex_unlock(&priv->lock);
 
 	priv->speed = SPEED_UNKNOWN;
-- 
2.17.1

