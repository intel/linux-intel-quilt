From 3cf94f0243b2915c2484db6a80cd18057b738693 Mon Sep 17 00:00:00 2001
From: Voon Weifeng <weifeng.voon@intel.com>
Date: Thu, 7 Nov 2019 16:32:38 +0800
Subject: [PATCH 087/103] HOTFIX: net: stmmac: added phy ingress and egress
 path latency

Phy path latency will contribute to the total link path delay.
Hence, the actual tx hw timestamp will be the tx hw timestamp by MAC
subtract the phy tx path latency. On other hand, the actual rx hw timestamp
will be the rx hw timestamp by MAC add with the phy rx path latency.
The EHL new platform data phy path latency values are based on the
Marvell 88E1512 PHY.

Signed-off-by: Voon Weifeng <weifeng.voon@intel.com>
---
 .../net/ethernet/stmicro/stmmac/stmmac_main.c | 29 +++++++++++++++++++
 .../net/ethernet/stmicro/stmmac/stmmac_pci.c  |  8 +++++
 include/linux/stmmac.h                        |  7 +++++
 3 files changed, 44 insertions(+)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 98cbac3b583e..94b461d67047 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -422,6 +422,7 @@ static void stmmac_get_tx_hwtstamp(struct stmmac_priv *priv,
 {
 	struct skb_shared_hwtstamps shhwtstamp;
 	bool found = false;
+	u64 adjust = 0;
 	u64 ns = 0;
 
 	if (!priv->hwts_tx_en)
@@ -440,6 +441,19 @@ static void stmmac_get_tx_hwtstamp(struct stmmac_priv *priv,
 	}
 
 	if (found) {
+		switch (priv->speed) {
+		case SPEED_10:
+			adjust = priv->plat->phy_tx_latency_10;
+			break;
+		case SPEED_100:
+			adjust = priv->plat->phy_tx_latency_100;
+			break;
+		case SPEED_1000:
+			adjust = priv->plat->phy_tx_latency_1000;
+			break;
+		}
+
+		ns += adjust;
 		memset(&shhwtstamp, 0, sizeof(struct skb_shared_hwtstamps));
 		shhwtstamp.hwtstamp = ns_to_ktime(ns);
 
@@ -463,6 +477,7 @@ static void stmmac_get_rx_hwtstamp(struct stmmac_priv *priv, struct dma_desc *p,
 {
 	struct skb_shared_hwtstamps *shhwtstamp = NULL;
 	struct dma_desc *desc = p;
+	u64 adjust = 0;
 	u64 ns = 0;
 
 	if (!priv->hwts_rx_en)
@@ -474,6 +489,20 @@ static void stmmac_get_rx_hwtstamp(struct stmmac_priv *priv, struct dma_desc *p,
 	/* Check if timestamp is available */
 	if (stmmac_get_rx_timestamp_status(priv, p, np, priv->adv_ts)) {
 		stmmac_get_timestamp(priv, desc, priv->adv_ts, &ns);
+
+		switch (priv->speed) {
+		case SPEED_10:
+			adjust = priv->plat->phy_rx_latency_10;
+			break;
+		case SPEED_100:
+			adjust = priv->plat->phy_rx_latency_100;
+			break;
+		case SPEED_1000:
+			adjust = priv->plat->phy_rx_latency_1000;
+			break;
+		}
+
+		ns -= adjust;
 		netdev_dbg(priv->dev, "get valid RX hw timestamp %llu\n", ns);
 		shhwtstamp = skb_hwtstamps(skb);
 		memset(shhwtstamp, 0, sizeof(struct skb_shared_hwtstamps));
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
index 15f95ed0b4d3..80e72754594f 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -292,6 +292,14 @@ static int ehl_common_data(struct pci_dev *pdev,
 	plat->rx_queues_to_use = 8;
 	plat->tx_queues_to_use = 8;
 
+	/* TX and RX PHY latency (ns) */
+	plat->phy_tx_latency_10 = 6066;
+	plat->phy_tx_latency_100 = 657;
+	plat->phy_tx_latency_1000 = 224;
+	plat->phy_rx_latency_10 = 2130;
+	plat->phy_rx_latency_100 = 362;
+	plat->phy_rx_latency_1000 = 231;
+
 	ret = intel_mgbe_common_data(pdev, plat);
 	if (ret)
 		return ret;
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
index b65cb603b9d0..5d3d1d4018c0 100644
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -228,5 +228,12 @@ struct plat_stmmacenet_data {
 	bool has_safety_feat;
 	bool is_hfpga;
 	bool ehl_ao_wa;
+	/* TX and RX PHY latency (ns) */
+	u64 phy_tx_latency_1000;
+	u64 phy_tx_latency_100;
+	u64 phy_tx_latency_10;
+	u64 phy_rx_latency_1000;
+	u64 phy_rx_latency_100;
+	u64 phy_rx_latency_10;
 };
 #endif
-- 
2.17.1

