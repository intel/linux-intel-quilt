From c79ddf9e47be8ea98a24c1c487fb2787469ae4e9 Mon Sep 17 00:00:00 2001
From: Meng Wei <wei.meng@intel.com>
Date: Tue, 27 Nov 2018 19:31:19 +0800
Subject: [PATCH 15/70] v4l: add IPU platform configuration data

These data are used for i2c device detection and resource
revervation.

Signed-off-by: Meng Wei <wei.meng@intel.com>
---
 drivers/media/platform/Kconfig                |    1 +
 drivers/media/platform/Makefile               |    1 +
 drivers/media/platform/intel/Kconfig          |   95 ++
 drivers/media/platform/intel/Makefile         |   21 +
 .../media/platform/intel/ipu4-bxt-gp-pdata.c  |  123 ++
 .../media/platform/intel/ipu4-bxt-p-pdata.c   | 1161 +++++++++++++++++
 .../platform/intel/ipu4p-icl-rvp-pdata.c      |  181 +++
 7 files changed, 1583 insertions(+)
 create mode 100644 drivers/media/platform/intel/Kconfig
 create mode 100644 drivers/media/platform/intel/Makefile
 create mode 100644 drivers/media/platform/intel/ipu4-bxt-gp-pdata.c
 create mode 100644 drivers/media/platform/intel/ipu4-bxt-p-pdata.c
 create mode 100644 drivers/media/platform/intel/ipu4p-icl-rvp-pdata.c

diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index f2b5f27ebacb..0eadea2775cf 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -148,6 +148,7 @@ source "drivers/media/platform/xilinx/Kconfig"
 source "drivers/media/platform/rcar-vin/Kconfig"
 source "drivers/media/platform/atmel/Kconfig"
 source "drivers/media/platform/sunxi/sun6i-csi/Kconfig"
+source "drivers/media/platform/intel/Kconfig"
 
 config VIDEO_TI_CAL
 	tristate "TI CAL (Camera Adaptation Layer) driver"
diff --git a/drivers/media/platform/Makefile b/drivers/media/platform/Makefile
index 7cbbd925124c..37e3ddd5e0ba 100644
--- a/drivers/media/platform/Makefile
+++ b/drivers/media/platform/Makefile
@@ -101,3 +101,4 @@ obj-y					+= meson/
 obj-y					+= cros-ec-cec/
 
 obj-$(CONFIG_VIDEO_SUN6I_CSI)		+= sunxi/sun6i-csi/
+obj-y += intel/
diff --git a/drivers/media/platform/intel/Kconfig b/drivers/media/platform/intel/Kconfig
new file mode 100644
index 000000000000..7dc176af66f2
--- /dev/null
+++ b/drivers/media/platform/intel/Kconfig
@@ -0,0 +1,95 @@
+config INTEL_IPU4_BXT_P_PDATA
+	bool "Enable built in platform data for Broxton-P"
+	depends on VIDEO_INTEL_IPU && VIDEO_INTEL_IPU4
+	---help---
+	Pre-ACPI system platform data is compiled inside kernel
+
+config INTEL_IPU4_BXT_GP_PDATA
+	bool "Enable built in platform data for Broxton-P"
+	depends on VIDEO_INTEL_IPU && VIDEO_INTEL_IPU4
+	---help---
+	Pre-ACPI system platform data is compiled inside kernel
+
+config INTEL_IPU4P_ICL_RVP_PDATA
+	bool "Enable built in platform data for ipu4p"
+	depends on VIDEO_INTEL_IPU && VIDEO_INTEL_IPU4P
+	---help---
+	Pre-ACPI system platform data is compiled inside kernel
+
+config INTEL_IPU4_OV2740
+	bool "Compile platform data for OV2740"
+	depends on INTEL_IPU4_BXT_P_PDATA
+
+config INTEL_IPU4_IMX185
+	bool "Compile platform data for IMX185"
+	depends on INTEL_IPU4_BXT_P_PDATA
+
+config INTEL_IPU4_AR023Z
+	bool "Compile platform data for AR023Z"
+	---help---
+	Onsemi 2MP AR023Z camera sensor
+
+config INTEL_IPU4_IMX477
+	bool "Compile platform data for IMX477 camera sensor"
+	depends on INTEL_IPU4_BXT_P_PDATA
+	---help---
+	Sony IMX477 sensor is enabled for DUAL Camera input.
+
+config INTEL_IPU4_OV13860
+	bool "Compile platform data for OV13860"
+	---help---
+	Omnivision 13MP camera sensor
+
+config INTEL_IPU4_OV9281
+	bool "Compile platform data for OV9281"
+	---help---
+	Omnivision 1MP camera sensor
+
+config INTEL_IPU4_OV10635
+	bool "Compile platform data for OV10635"
+	---help---
+	Omnivision 1MP camera sensor
+
+config INTEL_IPU4_AR0231AT
+        bool "Compile platform data for AR0231AT"
+        ---help---
+        AR0231 camera sensor for MAXIM 9286
+
+config INTEL_IPU4_MAGNA
+	bool "Compile platform data for MAGNA"
+        depends on INTEL_IPU4_BXT_P_PDATA
+	---help---
+	MAGNA Camera Sensor
+
+config INTEL_IPU4_IMX274
+	bool "Compile platform data for IMX274 camera sensor"
+	depends on INTEL_IPU4_BXT_P_PDATA
+	---help---
+	Sony 14MP camera sensor is enabled for HDR function.
+
+config INTEL_IPU4_OV10640
+	bool "Compile platform data for OV10640"
+	---help---
+	  Omnivision 1.4MP camera sensor
+
+config INTEL_IPU4_ADV7481
+	bool "Compile platform data for ADV7481"
+	---help---
+	HDMI2MIPI convertor device ADV7481
+
+config INTEL_IPU4_ADV7481_EVAL
+	bool "Compile platform data for ADV7481 evaluation board"
+	---help---
+	HDMI2MIPI convertor device ADV7481 eval board
+
+config INTEL_IPU4_IMX290
+	bool "Compile platform data for IMX290"
+	depends on INTEL_IPU4_BXT_P_PDATA
+	---help---
+	"Sony 8MB camera sensor is enabled for HDR function"
+
+config INTEL_IPU4_OX03A10
+	bool "Compile platorm data for OX03A10"
+	depends on INTEL_IPU4_BXT_P_PDATA
+	---help---
+	"ox03a10 camera sensor"
diff --git a/drivers/media/platform/intel/Makefile b/drivers/media/platform/intel/Makefile
new file mode 100644
index 000000000000..b6d4f786f20b
--- /dev/null
+++ b/drivers/media/platform/intel/Makefile
@@ -0,0 +1,21 @@
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (c) 2010 - 2018, Intel Corporation.
+
+ifneq ($(EXTERNAL_BUILD), 1)
+srcpath := $(srctree)
+endif
+
+# force check the compile warning to make sure zero warnings
+# note we may have build issue when gcc upgraded.
+ccflags-y := -Wall -Wextra
+ccflags-y += $(call cc-disable-warning, unused-parameter)
+ccflags-y += $(call cc-disable-warning, implicit-fallthrough)
+ccflags-y += $(call cc-disable-warning, missing-field-initializers)
+ccflags-$(CONFIG_VIDEO_INTEL_IPU_WERROR) += -Werror
+
+ccflags-y += -I$(srcpath)/$(src)/../../../../include/
+ccflags-y += -I$(srcpath)/$(src)/../../pci/intel/
+
+obj-$(CONFIG_INTEL_IPU4_BXT_P_PDATA)   += ipu4-bxt-p-pdata.o
+obj-$(CONFIG_INTEL_IPU4_BXT_GP_PDATA)   += ipu4-bxt-gp-pdata.o
+obj-$(CONFIG_INTEL_IPU4P_ICL_RVP_PDATA)   += ipu4p-icl-rvp-pdata.o
diff --git a/drivers/media/platform/intel/ipu4-bxt-gp-pdata.c b/drivers/media/platform/intel/ipu4-bxt-gp-pdata.c
new file mode 100644
index 000000000000..9acfafc9cf42
--- /dev/null
+++ b/drivers/media/platform/intel/ipu4-bxt-gp-pdata.c
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2016--2017 Intel Corporation.
+ *
+ * Author: Jouni Ukkonen <jouni.ukkonen@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+
+#include <media/ipu-isys.h>
+#include <media/crlmodule.h>
+#include "ipu.h"
+
+#define ADV7481_HDMI_LANES      4
+#define ADV7481_HDMI_I2C_ADDRESS 0xe0
+
+#define ADV7481_LANES		1
+/*
+ * below i2c address is dummy one, to be able to register single
+ * ADV7481 chip as two sensors
+ */
+#define ADV7481_I2C_ADDRESS	0xe1
+
+
+#define GPIO_BASE		434
+
+
+static struct crlmodule_platform_data adv7481_cvbs_pdata = {
+	.ext_clk = 286363636,
+	.xshutdown = GPIO_BASE + 64, /*dummy for now*/
+	.lanes = ADV7481_LANES,
+	.module_name = "ADV7481 CVBS",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config adv7481_cvbs_csi2_cfg = {
+	.nlanes = ADV7481_LANES,
+	.port = 4,
+};
+
+static struct ipu_isys_subdev_info adv7481_cvbs_crl_sd = {
+	.csi2 = &adv7481_cvbs_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = CRLMODULE_NAME,
+			 .flags = I2C_CLIENT_TEN,
+			 .addr = ADV7481_I2C_ADDRESS,
+			 .platform_data = &adv7481_cvbs_pdata,
+		},
+		.i2c_adapter_id = 0,
+	}
+};
+
+static struct crlmodule_platform_data adv7481_hdmi_pdata = {
+	/* FIXME: may need to revisit */
+	.ext_clk = 286363636,
+	.xshutdown = GPIO_BASE + 30,
+	.lanes = ADV7481_HDMI_LANES,
+	.module_name = "ADV7481 HDMI",
+	.crl_irq_pin = GPIO_BASE + 22,
+	.irq_pin_flags = (IRQF_TRIGGER_RISING | IRQF_ONESHOT),
+	.irq_pin_name = "ADV7481_HDMI_IRQ",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config adv7481_hdmi_csi2_cfg = {
+	.nlanes = ADV7481_HDMI_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info adv7481_hdmi_crl_sd = {
+	.csi2 = &adv7481_hdmi_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = CRLMODULE_NAME,
+			 .flags = I2C_CLIENT_TEN,
+			 .addr = ADV7481_HDMI_I2C_ADDRESS,
+			 .platform_data = &adv7481_hdmi_pdata,
+		},
+		.i2c_adapter_id = 0,
+	}
+};
+
+
+
+/*
+ * Map buttress output sensor clocks to sensors -
+ * this should be coming from ACPI, in Gordon Peak
+ * ADV7481 have its own oscillator, no buttres clock
+ * needed.
+ */
+struct ipu_isys_clk_mapping gp_mapping[] = {
+	{ CLKDEV_INIT(NULL, NULL, NULL), NULL }
+};
+
+static struct ipu_isys_subdev_pdata pdata = {
+	.subdevs = (struct ipu_isys_subdev_info *[]) {
+		&adv7481_hdmi_crl_sd,
+		&adv7481_cvbs_crl_sd,
+		NULL,
+	},
+	.clk_map = gp_mapping,
+};
+
+static void ipu4_quirk(struct pci_dev *pci_dev)
+{
+	pci_dev->dev.platform_data = &pdata;
+}
+
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, IPU_PCI_ID,
+			ipu4_quirk);
diff --git a/drivers/media/platform/intel/ipu4-bxt-p-pdata.c b/drivers/media/platform/intel/ipu4-bxt-p-pdata.c
new file mode 100644
index 000000000000..69157b08ea68
--- /dev/null
+++ b/drivers/media/platform/intel/ipu4-bxt-p-pdata.c
@@ -0,0 +1,1161 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2015 - 2018 Intel Corporation
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+
+#include <media/ipu-isys.h>
+#include <media/crlmodule.h>
+#include <media/ti964.h>
+#include <media/ti960.h>
+#include <media/max9286.h>
+#include "ipu.h"
+
+#define GPIO_BASE		422
+
+#ifdef CONFIG_INTEL_IPU4_OV2740
+#define OV2740_LANES		2
+#define OV2740_I2C_ADDRESS	0x36
+static struct crlmodule_platform_data ov2740_pdata = {
+	.xshutdown = GPIO_BASE + 64,
+	.lanes = OV2740_LANES,
+	.ext_clk = 19200000,
+	.op_sys_clock = (uint64_t []){ 72000000 },
+	.module_name = "INT3474",
+	.id_string = "0x27 0x40",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config ov2740_csi2_cfg = {
+	.nlanes = OV2740_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info ov2740_crl_sd = {
+	.csi2 = &ov2740_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 I2C_BOARD_INFO(CRLMODULE_NAME, OV2740_I2C_ADDRESS),
+			.platform_data = &ov2740_pdata,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_IMX185
+#define IMX185_LANES		4
+#define IMX185_I2C_ADDRESS	0x1a
+
+static struct crlmodule_platform_data imx185_pdata = {
+	.xshutdown = GPIO_BASE + 71,
+	.lanes = IMX185_LANES,
+	.ext_clk = 27000000,
+	.op_sys_clock = (uint64_t []){ 55687500, 111375000,
+					111375000, 222750000 },
+	.module_name = "IMX185",
+	.id_string = "0x1 0x85",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config imx185_csi2_cfg = {
+	.nlanes = IMX185_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info imx185_crl_sd = {
+	.csi2 = &imx185_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 I2C_BOARD_INFO(CRLMODULE_NAME, IMX185_I2C_ADDRESS),
+			.platform_data = &imx185_pdata,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+
+static struct crlmodule_platform_data imx185_b_pdata = {
+	.xshutdown = GPIO_BASE + 73,
+	.lanes = IMX185_LANES,
+	.ext_clk = 27000000,
+	.op_sys_clock = (uint64_t []){ 55687500, 111375000,
+					111375000, 222750000 },
+	.module_name = "IMX185",
+	.id_string = "0x1 0x85",
+	.suffix = 'b',
+};
+
+static struct ipu_isys_csi2_config imx185_b_csi2_cfg = {
+	.nlanes = IMX185_LANES,
+	.port = 4,
+};
+
+static struct ipu_isys_subdev_info imx185_b_crl_sd = {
+	.csi2 = &imx185_b_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 I2C_BOARD_INFO(CRLMODULE_NAME, IMX185_I2C_ADDRESS),
+			.platform_data = &imx185_b_pdata,
+		},
+		.i2c_adapter_id = 4,
+	}
+};
+
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_AR023Z
+#define AR023Z_MIPI_LANES	2
+/* Toshiba TC358778 Parallel-MIPI Bridge */
+#define TC358778_I2C_ADDRESS	0x0e
+
+static struct crlmodule_platform_data ar023z_pdata = {
+	.xshutdown = GPIO_BASE + 64,
+	.lanes = AR023Z_MIPI_LANES,
+	.ext_clk = 27000000,
+	.op_sys_clock = (uint64_t []){317250000},
+	.module_name = "AR023Z",
+	.id_string = "0x4401 0x64",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config ar023z_csi2_cfg = {
+	.nlanes = AR023Z_MIPI_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info ar023z_crl_sd = {
+	.csi2 = &ar023z_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(CRLMODULE_NAME, TC358778_I2C_ADDRESS),
+			.platform_data = &ar023z_pdata,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+
+static struct crlmodule_platform_data ar023z_b_pdata = {
+	.xshutdown = GPIO_BASE + 67,
+	.lanes = AR023Z_MIPI_LANES,
+	.ext_clk = 27000000,
+	.op_sys_clock = (uint64_t []){317250000},
+	.module_name = "AR023Z",
+	.id_string = "0x4401 0x64",
+	.suffix = 'b',
+};
+
+static struct ipu_isys_csi2_config ar023z_b_csi2_cfg = {
+	.nlanes = AR023Z_MIPI_LANES,
+	.port = 4,
+};
+
+static struct ipu_isys_subdev_info ar023z_b_crl_sd = {
+	.csi2 = &ar023z_b_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(CRLMODULE_NAME, TC358778_I2C_ADDRESS),
+			.platform_data = &ar023z_b_pdata,
+		},
+		.i2c_adapter_id = 4,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_IMX477
+#define IMX477_LANES	   2
+
+#define IMX477_I2C_ADDRESS 0x10
+
+static struct crlmodule_platform_data imx477_pdata_master = {
+	.xshutdown = GPIO_BASE + 64,
+	.lanes = IMX477_LANES,
+	.ext_clk = 19200000,
+	.op_sys_clock = (uint64_t []){600000000},
+	.module_name = "IMX477-MASTER",
+	.id_string = "0x4 0x77",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config imx477_csi2_cfg_master = {
+	.nlanes = IMX477_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info imx477_crl_sd_master = {
+	.csi2 = &imx477_csi2_cfg_master,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(CRLMODULE_NAME, IMX477_I2C_ADDRESS),
+			.platform_data = &imx477_pdata_master,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+
+static struct crlmodule_platform_data imx477_pdata_slave_1 = {
+	.xshutdown = GPIO_BASE + 67,
+	.lanes = IMX477_LANES,
+	.ext_clk = 19200000,
+	.op_sys_clock = (uint64_t []){600000000},
+	.module_name = "IMX477-SLAVE-1",
+	.id_string = "0x4 0x77",
+	.suffix = 'b',
+};
+
+static struct ipu_isys_csi2_config imx477_csi2_cfg_slave_1 = {
+	.nlanes = IMX477_LANES,
+	.port = 4,
+};
+
+static struct ipu_isys_subdev_info imx477_crl_sd_slave_1 = {
+	.csi2 = &imx477_csi2_cfg_slave_1,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(CRLMODULE_NAME, IMX477_I2C_ADDRESS),
+			.platform_data = &imx477_pdata_slave_1,
+		},
+		.i2c_adapter_id = 4,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_IMX274
+
+#define IMX274_LANES		4
+#define IMX274_I2C_ADDRESS	0x1a
+
+static struct crlmodule_platform_data imx274_pdata = {
+	.xshutdown = GPIO_BASE + 64,
+	.lanes = IMX274_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){720000000},
+	.module_name = "IMX274",
+	.id_string = "0x6 0x9",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config imx274_csi2_cfg = {
+	.nlanes = IMX274_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info imx274_crl_sd = {
+	.csi2 = &imx274_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(CRLMODULE_NAME, IMX274_I2C_ADDRESS),
+			.platform_data = &imx274_pdata
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+
+static struct crlmodule_platform_data imx274_b_pdata = {
+	.xshutdown = GPIO_BASE + 67,
+	.lanes = IMX274_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){720000000},
+	.module_name = "IMX274",
+	.id_string = "0x6 0x9",
+	.suffix = 'b',
+};
+
+static struct ipu_isys_csi2_config imx274_b_csi2_cfg = {
+	.nlanes = IMX274_LANES,
+	.port = 4,
+};
+
+static struct ipu_isys_subdev_info imx274_b_crl_sd = {
+	.csi2 = &imx274_b_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(CRLMODULE_NAME, IMX274_I2C_ADDRESS),
+			.platform_data = &imx274_b_pdata
+		},
+		.i2c_adapter_id = 4,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_IMX290
+
+#define IMX290_LANES		4
+#define IMX290_I2C_ADDRESS	0x1a
+
+static struct crlmodule_platform_data imx290_pdata = {
+	.xshutdown = GPIO_BASE + 64,
+	.lanes = IMX290_LANES,
+	.ext_clk = 37125000,
+	.op_sys_clock = (uint64_t []){222750000, 445500000},
+	.module_name = "IMX290",
+	.id_string = "0x2 0x90",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config imx290_csi2_cfg = {
+	.nlanes = IMX290_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info imx290_crl_sd = {
+	.csi2 = &imx290_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(CRLMODULE_NAME, IMX290_I2C_ADDRESS),
+			.platform_data = &imx290_pdata
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_OV13860
+
+#define OV13860_LANES		2
+#define OV13860_I2C_ADDRESS	0x10
+
+static struct crlmodule_platform_data ov13860_pdata = {
+	.xshutdown = GPIO_BASE + 71,
+	.lanes = OV13860_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){ 600000000, 300000000},
+	.module_name = "OV13860",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config ov13860_csi2_cfg = {
+	.nlanes = OV13860_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info ov13860_crl_sd = {
+	.csi2 = &ov13860_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 I2C_BOARD_INFO(CRLMODULE_NAME, OV13860_I2C_ADDRESS),
+			 .platform_data = &ov13860_pdata,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_OV9281
+
+#define OV9281_LANES		2
+#define OV9281_I2C_ADDRESS	0x10
+
+static struct crlmodule_platform_data ov9281_pdata = {
+	.xshutdown = GPIO_BASE + 71,
+	.lanes = OV9281_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){400000000},
+	.module_name = "OV9281",
+	.id_string = "0x92 0x81",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config ov9281_csi2_cfg = {
+	.nlanes = OV9281_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info ov9281_crl_sd = {
+	.csi2 = &ov9281_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 I2C_BOARD_INFO(CRLMODULE_NAME, OV9281_I2C_ADDRESS),
+			 .platform_data = &ov9281_pdata,
+		},
+		.i2c_adapter_id = 0,
+	}
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_BU64295)
+
+#define BU64295_VCM_ADDR	0x0c
+#define BU64295_NAME		"bu64295"
+
+static struct ipu_isys_subdev_info bu64295_sd = {
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(BU64295_NAME,  BU64295_VCM_ADDR),
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_ADV7481
+
+#define ADV7481_LANES		4
+#define ADV7481_I2C_ADDRESS	0xe0
+#define ADV7481B_I2C_ADDRESS	0xe2
+
+static struct crlmodule_platform_data adv7481_pdata = {
+	.xshutdown = GPIO_BASE + 63,
+	.lanes = ADV7481_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){600000000},
+	.module_name = "ADV7481",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config adv7481_csi2_cfg = {
+	.nlanes = ADV7481_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info adv7481_crl_sd = {
+	.csi2 = &adv7481_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = CRLMODULE_NAME,
+			 .flags = I2C_CLIENT_TEN,
+			 .addr = ADV7481_I2C_ADDRESS,
+			 .platform_data = &adv7481_pdata,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_ADV7481_EVAL
+
+#define ADV7481_LANES		4
+#define ADV7481_I2C_ADDRESS	0xe0
+#define ADV7481B_I2C_ADDRESS	0xe2
+
+static struct crlmodule_platform_data adv7481_eval_pdata = {
+	.xshutdown = GPIO_BASE + 63,
+	.lanes = ADV7481_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){600000000},
+	.module_name = "ADV7481_EVAL",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config adv7481_eval_csi2_cfg = {
+	.nlanes = ADV7481_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info adv7481_eval_crl_sd = {
+	.csi2 = &adv7481_eval_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = CRLMODULE_NAME,
+			 .flags = I2C_CLIENT_TEN,
+			 .addr = ADV7481_I2C_ADDRESS,
+			 .platform_data = &adv7481_eval_pdata,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+
+static struct crlmodule_platform_data adv7481b_eval_pdata = {
+	.xshutdown = GPIO_BASE + 63,
+	.lanes = ADV7481_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){600000000},
+	.module_name = "ADV7481B_EVAL",
+	.suffix = 'b',
+};
+
+static struct ipu_isys_csi2_config adv7481b_eval_csi2_cfg = {
+	.nlanes = ADV7481_LANES,
+	.port = 4,
+};
+
+static struct ipu_isys_subdev_info adv7481b_eval_crl_sd = {
+	.csi2 = &adv7481b_eval_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = CRLMODULE_NAME,
+			 .flags = I2C_CLIENT_TEN,
+			 .addr = ADV7481B_I2C_ADDRESS,
+			 .platform_data = &adv7481b_eval_pdata,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_AGGREGATOR_STUB)
+
+#define VIDEO_AGGRE_LANES	4
+#define VIDEO_AGGRE_I2C_ADDRESS	0x3b
+#define VIDEO_AGGRE_B_I2C_ADDRESS	0x3c
+
+static struct ipu_isys_csi2_config video_aggre_csi2_cfg = {
+	.nlanes = VIDEO_AGGRE_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info video_aggre_stub_sd = {
+	.csi2 = &video_aggre_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = "video-aggre",
+			 .addr = VIDEO_AGGRE_I2C_ADDRESS,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+
+static struct ipu_isys_csi2_config video_aggre_b_csi2_cfg = {
+	.nlanes = VIDEO_AGGRE_LANES,
+	.port = 4,
+};
+
+static struct ipu_isys_subdev_info video_aggre_b_stub_sd = {
+	.csi2 = &video_aggre_b_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = "video-aggre",
+			 .addr = VIDEO_AGGRE_B_I2C_ADDRESS,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_MAGNA
+#define MAGNA_LANES		4
+#define MAGNA_PHY_ADDR	0x60 /* 0x30 for 7bit addr */
+#define MAGNA_ADDRESS_A	0x61
+
+static struct crlmodule_platform_data magna_pdata = {
+	.lanes = MAGNA_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){ 400000000 },
+	.module_name = "MAGNA",
+	.id_string = "0xa6 0x35",
+	/*
+	 * The pin number of xshutdown will be determined
+	 * and replaced inside TI964 driver.
+	 * The number here stands for which GPIO to connect with.
+	 * 1 means to connect sensor xshutdown to GPIO1
+	 */
+	.xshutdown = 1,
+	/*
+	 * this flags indicates the expected polarity for the LineValid
+	 * indication received in Raw mode.
+	 * 1 means LineValid is high for the duration of the video frame.
+	 */
+	.high_framevalid_flags = 1,
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_OV10635
+#define OV10635_LANES		4
+#define OV10635_I2C_PHY_ADDR	0x60 /* 0x30 for 7bit addr */
+#define OV10635A_I2C_ADDRESS	0x61
+#define OV10635B_I2C_ADDRESS	0x62
+#define OV10635C_I2C_ADDRESS	0x63
+#define OV10635D_I2C_ADDRESS	0x64
+
+static struct crlmodule_platform_data ov10635_pdata = {
+	.lanes = OV10635_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){ 400000000 },
+	.module_name = "OV10635",
+	.id_string = "0xa6 0x35",
+	/*
+	 * The pin number of xshutdown will be determined
+	 * and replaced inside TI964 driver.
+	 * The number here stands for which GPIO to connect with.
+	 * 1 means to connect sensor xshutdown to GPIO1
+	 */
+	.xshutdown = 0,
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_OV10640
+#define OV10640_LANES			4
+#define OV10640_I2C_PHY_ADDR	0x60 /* 0x30 for 7bit addr */
+#define OV10640A_I2C_ADDRESS	0x61
+#define OV10640B_I2C_ADDRESS	0x62
+#define OV10640C_I2C_ADDRESS	0x63
+#define OV10640D_I2C_ADDRESS	0x64
+
+static struct crlmodule_platform_data ov10640_pdata = {
+	.lanes = OV10640_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){ 400000000 },
+	.module_name = "OV10640",
+	.id_string = "0xa6 0x40",
+	/*
+	 * The pin number of xshutdown will be determined
+	 * and replaced inside TI964 driver.
+	 * The number here stands for which GPIO to connect with.
+	 * 1 means to connect sensor xshutdown to GPIO1
+	 */
+	.xshutdown = 1,
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_TI964)
+#define TI964_I2C_ADAPTER	0
+#define TI964_I2C_ADAPTER_2	7
+#define TI964_I2C_ADDRESS	0x3d
+#define TI964_LANES		4
+
+static struct ipu_isys_csi2_config ti964_csi2_cfg = {
+	.nlanes = TI964_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_csi2_config ti964_csi2_cfg_2 = {
+	.nlanes = TI964_LANES,
+	.port = 4,
+};
+
+static struct ti964_subdev_info ti964_subdevs[] = {
+#ifdef CONFIG_INTEL_IPU4_OV10635
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635A_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 0,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635B_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 1,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'b',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635C_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 2,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'c',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635D_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 3,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'd',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_OV10640
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640A_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 0,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640B_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 1,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'b',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640C_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 2,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'c',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640D_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 3,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'd',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_MAGNA
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = MAGNA_ADDRESS_A,
+			.platform_data = &magna_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 0,
+		.phy_i2c_addr = MAGNA_PHY_ADDR,
+		.suffix = 'a',
+	},
+#endif
+};
+
+static struct ti964_subdev_info ti964_subdevs_2[] = {
+#ifdef CONFIG_INTEL_IPU4_OV10635
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635A_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 0,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'e',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635B_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 1,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'f',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635C_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 2,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'g',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635D_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 3,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'h',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_OV10640
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640A_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 0,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'e',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640B_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 1,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'f',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640C_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 2,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'g',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640D_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 3,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'h',
+	},
+#endif
+};
+
+static struct ti964_pdata ti964_pdata = {
+	.subdev_info = ti964_subdevs,
+	.subdev_num = ARRAY_SIZE(ti964_subdevs),
+	.reset_gpio = GPIO_BASE + 63,
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info ti964_sd = {
+	.csi2 = &ti964_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = "ti964",
+			 .addr = TI964_I2C_ADDRESS,
+			 .platform_data = &ti964_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+	}
+};
+
+static struct ti964_pdata ti964_pdata_2 = {
+	.subdev_info = ti964_subdevs_2,
+	.subdev_num = ARRAY_SIZE(ti964_subdevs_2),
+	.reset_gpio = GPIO_BASE + 66,
+	.suffix = 'b',
+};
+
+static struct ipu_isys_subdev_info ti964_sd_2 = {
+	.csi2 = &ti964_csi2_cfg_2,
+	.i2c = {
+		.board_info = {
+			 .type = "ti964",
+			 .addr = TI964_I2C_ADDRESS,
+			 .platform_data = &ti964_pdata_2,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_OX03A10
+#define OX03A10_LANES	4
+#define OX03A10_I2C_PHY_ADDR   0x6c
+#define OX03A10A_I2C_ADDRESS   0x30
+#define OX03A10B_I2C_ADDRESS   0x31
+
+#define OX03A10A_SER_ADDRESS   0x58
+#define OX03A10B_SER_ADDRESS   0x59
+
+static struct crlmodule_platform_data ox03a10_pdata = {
+	.lanes = OX03A10_LANES,
+	.ext_clk = 27000000,
+	.op_sys_clock = (uint64_t[]){ 87750000 },
+	.module_name = "OX03A10",
+	.id_string = "0x58 0x3 0x41",
+	.xshutdown = 1,
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_TI960)
+#define TI960_I2C_ADAPTER	2
+#define TI960_I2C_ADAPTER_2	7
+#define TI960_LANES	4
+
+static struct ipu_isys_csi2_config ti960_csi2_cfg = {
+	.nlanes = TI960_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_csi2_config ti960_csi2_cfg_2 = {
+	.nlanes = TI960_LANES,
+	.port = 4,
+};
+
+static struct ti960_subdev_info ti960_subdevs[] = {
+#ifdef CONFIG_INTEL_IPU4_OX03A10
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OX03A10A_I2C_ADDRESS,
+			.platform_data = &ox03a10_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER,
+		.rx_port = 0,
+		.phy_i2c_addr = OX03A10_I2C_PHY_ADDR,
+		.ser_alias = OX03A10A_SER_ADDRESS,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OX03A10B_I2C_ADDRESS,
+			.platform_data = &ox03a10_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER,
+		.rx_port = 1,
+		.phy_i2c_addr = OX03A10_I2C_PHY_ADDR,
+		.ser_alias = OX03A10B_SER_ADDRESS,
+		.suffix = 'b',
+	},
+#endif
+};
+
+static struct ti960_subdev_info ti960_subdevs_2[] = {
+#ifdef CONFIG_INTEL_IPU4_OX03A10
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OX03A10A_I2C_ADDRESS,
+			.platform_data = &ox03a10_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER_2,
+		.rx_port = 0,
+		.phy_i2c_addr = OX03A10_I2C_PHY_ADDR,
+		.ser_alias = OX03A10A_SER_ADDRESS,
+		.suffix = 'e',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OX03A10B_I2C_ADDRESS,
+			.platform_data = &ox03a10_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER_2,
+		.rx_port = 1,
+		.phy_i2c_addr = OX03A10_I2C_PHY_ADDR,
+		.ser_alias = OX03A10B_SER_ADDRESS,
+		.suffix = 'f',
+	},
+#endif
+};
+
+static struct ti960_pdata ti960_pdata = {
+	.subdev_info = ti960_subdevs,
+	.subdev_num = ARRAY_SIZE(ti960_subdevs),
+	.reset_gpio = GPIO_BASE + 63,
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info ti960_sd = {
+	.csi2 = &ti960_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = "ti960",
+			 .addr = TI960_I2C_ADDRESS,
+			 .platform_data = &ti960_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER,
+	}
+};
+
+static struct ti960_pdata ti960_pdata_2 = {
+	.subdev_info = ti960_subdevs_2,
+	.subdev_num = ARRAY_SIZE(ti960_subdevs_2),
+	.reset_gpio = GPIO_BASE + 66,
+	.suffix = 'b',
+};
+
+static struct ipu_isys_subdev_info ti960_sd_2 = {
+	.csi2 = &ti960_csi2_cfg_2,
+	.i2c = {
+		.board_info = {
+			 .type = "ti960",
+			 .addr = TI960_I2C_ADDRESS,
+			 .platform_data = &ti960_pdata_2,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER_2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_AR0231AT
+#define AR0231AT_LANES            4
+#define AR0231ATA_I2C_ADDRESS      0x11
+#define AR0231ATB_I2C_ADDRESS      0x12
+#define AR0231ATC_I2C_ADDRESS      0x13
+#define AR0231ATD_I2C_ADDRESS      0x14
+
+static struct crlmodule_platform_data ar0231at_pdata = {
+	.lanes = AR0231AT_LANES,
+	.ext_clk = 27000000,
+	.op_sys_clock = (uint64_t[]){ 87750000 },
+	.module_name = "AR0231AT",
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_MAX9286)
+#define DS_MAX9286_LANES                4
+#define DS_MAX9286_I2C_ADAPTER          4
+#define DS_MAX9286_I2C_ADDRESS          0x48
+
+static struct ipu_isys_csi2_config max9286_csi2_cfg = {
+	.nlanes = DS_MAX9286_LANES,
+	.port = 4,
+};
+
+static struct max9286_subdev_i2c_info max9286_subdevs[] = {
+#ifdef CONFIG_INTEL_IPU4_AR0231AT
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATA_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER,
+			.suffix = 'a',
+		},
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATB_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER,
+			.suffix = 'b',
+		},
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATC_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER,
+			.suffix = 'c',
+		},
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATD_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER,
+			.suffix = 'd',
+		},
+#endif
+};
+
+static struct max9286_pdata max9286_pdata = {
+	.subdev_info = max9286_subdevs,
+	.subdev_num = ARRAY_SIZE(max9286_subdevs),
+	.reset_gpio = GPIO_BASE + 63,
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info max9286_sd = {
+	.csi2 = &max9286_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			.type = "max9286",
+			.addr = DS_MAX9286_I2C_ADDRESS,
+			.platform_data = &max9286_pdata,
+		},
+		.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER,
+	}
+};
+#endif
+
+/*
+ * Map buttress output sensor clocks to sensors -
+ * this should be coming from ACPI
+ */
+static struct ipu_isys_clk_mapping clk_mapping[] = {
+	{ CLKDEV_INIT("2-0036", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("2-001a", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("4-001a", NULL, NULL), "OSC_CLK_OUT1" },
+	{ CLKDEV_INIT("2-0010", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("4-0010", NULL, NULL), "OSC_CLK_OUT1" },
+	{ CLKDEV_INIT("2-a0e0", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("2-a0e2", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("0-0010", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("2-000e", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("4-000e", NULL, NULL), "OSC_CLK_OUT1" },
+	{ CLKDEV_INIT("0-0048", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("4-0048", NULL, NULL), "OSC_CLK_OUT1" },
+	{ CLKDEV_INIT(NULL, NULL, NULL), NULL }
+};
+
+static struct ipu_isys_subdev_pdata pdata = {
+	.subdevs = (struct ipu_isys_subdev_info *[]) {
+#ifdef CONFIG_INTEL_IPU4_OV2740
+		&ov2740_crl_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_IMX185
+		&imx185_crl_sd,
+		&imx185_b_crl_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_AR023Z
+		&ar023z_crl_sd,
+		&ar023z_b_crl_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_IMX477
+		&imx477_crl_sd_slave_1,
+		&imx477_crl_sd_master,
+#endif
+#ifdef CONFIG_INTEL_IPU4_IMX274
+		&imx274_crl_sd,
+		&imx274_b_crl_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_IMX290
+		&imx290_crl_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_OV13860
+		&ov13860_crl_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_OV9281
+		&ov9281_crl_sd,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_BU64295)
+		&bu64295_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_ADV7481
+		&adv7481_crl_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_ADV7481_EVAL
+		&adv7481_eval_crl_sd,
+		&adv7481b_eval_crl_sd,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_AGGREGATOR_STUB)
+		&video_aggre_stub_sd,
+		&video_aggre_b_stub_sd,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_TI964)
+		&ti964_sd,
+		&ti964_sd_2,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_TI960)
+		&ti960_sd,
+		&ti960_sd_2,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_MAX9286)
+		&max9286_sd,
+#endif
+		NULL,
+	},
+	.clk_map = clk_mapping,
+};
+
+static void ipu4_quirk(struct pci_dev *pci_dev)
+{
+	pci_dev->dev.platform_data = &pdata;
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, IPU_PCI_ID, ipu4_quirk);
diff --git a/drivers/media/platform/intel/ipu4p-icl-rvp-pdata.c b/drivers/media/platform/intel/ipu4p-icl-rvp-pdata.c
new file mode 100644
index 000000000000..f3906f4d4fa1
--- /dev/null
+++ b/drivers/media/platform/intel/ipu4p-icl-rvp-pdata.c
@@ -0,0 +1,181 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2018 Intel Corporation
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+
+#include <media/ipu-isys.h>
+#include <media/max9286.h>
+#include "ipu.h"
+#include <media/crlmodule.h>
+
+#define IMX355_LANES		4
+#define IMX355_I2C_ADDRESS	0x1a
+#define IMX319_LANES		4
+#define IMX319_I2C_ADDRESS	0x10
+#define AK7375_I2C_ADDRESS	0xc
+
+static struct ipu_isys_csi2_config imx355_csi2_cfg = {
+	.nlanes = IMX355_LANES,
+	.port = 4, /* WF camera */
+};
+
+static struct ipu_isys_subdev_info imx355_sd = {
+	.csi2 = &imx355_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO("imx355", IMX355_I2C_ADDRESS),
+		},
+		.i2c_adapter_id = 9,
+	}
+};
+
+/* FIXME: Remove this after hardware transition. */
+static struct ipu_isys_subdev_info imx355_sd2 = {
+	.csi2 = &imx355_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 I2C_BOARD_INFO("imx355", 0x10),
+		},
+		.i2c_adapter_id = 9,
+	}
+};
+
+static struct ipu_isys_subdev_info ak7375_sd = {
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO("ak7375", AK7375_I2C_ADDRESS),
+		},
+		.i2c_adapter_id = 9,
+	}
+};
+
+static struct ipu_isys_csi2_config imx319_csi2_cfg = {
+	.nlanes = IMX319_LANES,
+	.port = 0, /* UF camera */
+};
+
+static struct ipu_isys_subdev_info imx319_sd = {
+	.csi2 = &imx319_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO("imx319", IMX319_I2C_ADDRESS),
+		},
+		.i2c_adapter_id = 8,
+	}
+};
+
+#ifdef CONFIG_INTEL_IPU4_AR0231AT
+#define AR0231AT_LANES            4
+#define AR0231ATA_I2C_ADDRESS      0x11
+#define AR0231ATB_I2C_ADDRESS      0x12
+#define AR0231ATC_I2C_ADDRESS      0x13
+#define AR0231ATD_I2C_ADDRESS      0x14
+
+static struct crlmodule_platform_data ar0231at_pdata = {
+	.lanes = AR0231AT_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t[]){ 264000000 },
+	.module_name = "AR0231AT",
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_MAX9286)
+#define DS_MAX9286_LANES                4
+#define DS_MAX9286_I2C_ADAPTER_B        3
+#define DS_MAX9286_I2C_ADDRESS          0x48
+
+static struct ipu_isys_csi2_config max9286_b_csi2_cfg = {
+	.nlanes = DS_MAX9286_LANES,
+	.port = 4,
+};
+
+struct max9286_subdev_i2c_info max9286_b_subdevs[] = {
+#ifdef CONFIG_INTEL_IPU4_AR0231AT
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATA_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER_B,
+		},
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATB_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER_B,
+		},
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATC_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER_B,
+		},
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATD_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER_B,
+		},
+#endif
+};
+
+static struct max9286_pdata max9286_b_pdata = {
+	.subdev_info = max9286_b_subdevs,
+	.subdev_num = ARRAY_SIZE(max9286_b_subdevs),
+	.reset_gpio = 195,
+};
+
+static struct ipu_isys_subdev_info max9286_b_sd = {
+	.csi2 = &max9286_b_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			.type = "max9286",
+			.addr = DS_MAX9286_I2C_ADDRESS,
+			.platform_data = &max9286_b_pdata,
+		},
+		.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER_B,
+	}
+};
+#endif
+
+static struct ipu_isys_clk_mapping clk_mapping[] = {
+	{ CLKDEV_INIT("3-0048", NULL, NULL), "OSC_CLK_OUT1" },
+	{ CLKDEV_INIT(NULL, NULL, NULL), NULL }
+};
+
+static struct ipu_isys_subdev_pdata pdata = {
+	.subdevs = (struct ipu_isys_subdev_info *[]) {
+		&imx355_sd,
+		&imx355_sd2,
+		&imx319_sd,
+		&ak7375_sd,
+#if IS_ENABLED(CONFIG_VIDEO_MAX9286)
+		&max9286_b_sd,
+#endif
+		NULL,
+	},
+	.clk_map = clk_mapping,
+};
+
+static void ipu4p_quirk(struct pci_dev *pci_dev)
+{
+	pr_info("Intel platform data PCI quirk for IPU4P\n");
+	pci_dev->dev.platform_data = &pdata;
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, IPU_PCI_ID, ipu4p_quirk);
+
+MODULE_AUTHOR("Bingbu Cao <bingbu.cao@intel.com>");
+MODULE_AUTHOR("Qiu, Tianshu <tian.shu.qiu@intel.com>");
+MODULE_AUTHOR("Kun Jiang <kun.jiang@intel.com>");
+MODULE_LICENSE("GPL");
-- 
2.17.1

