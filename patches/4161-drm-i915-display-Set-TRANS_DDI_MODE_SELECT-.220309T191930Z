From 70e08dc183e29bf0ddb978939ecbe9b07624af9e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jos=C3=A9=20Roberto=20de=20Souza?= <jose.souza@intel.com>
Date: Mon, 3 Feb 2020 14:55:49 -0800
Subject: [PATCH 4161/4530] drm/i915/display: Set TRANS_DDI_MODE_SELECT to
 default value when clearing DDI select
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

TGL is suffering of timeouts and fifo underruns when disabling
transcoder in MST mode, this is fixed by set TRANS_DDI_MODE_SELECT to
0(HDMI mode) when clearing DDI select.

Although BSpec disable sequence don't require this step, it is a
harmless change and it is also done by Windows driver.
Anyhow HW team was notified about that but it can take some time to
documentation to be updated.

A case that always lead to those issues is:
- do a modeset enabling pipe A and pipe B in the same MST stream
leaving A as master
- disable pipe A, promote B as master doing a full modeset in A
- enable pipe A, changing the master transcoder back to A(doing a
full modeset in B)
- Pow: underruns and timeouts

The transcoders involved will only work again when complete disabled
and their power wells turned off causing a reset in their registers.

v2: Setting TRANS_DDI_MODE_SELECT to default when clearing DDI select
not anymore when disabling TRANS_DDI, both work but this one looks
more safe. (Ville comment)

Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200203225549.152301-1-jose.souza@intel.com
---
 drivers/gpu/drm/i915/display/intel_ddi.c | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_ddi.c b/drivers/gpu/drm/i915/display/intel_ddi.c
index e36f2c38908d..ff638fc6e3f5 100644
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@ -1988,10 +1988,12 @@ void intel_ddi_disable_transcoder_func(const struct intel_crtc_state *crtc_state
 	val &= ~TRANS_DDI_FUNC_ENABLE;
 
 	if (INTEL_GEN(dev_priv) >= 12) {
-		if (!intel_dp_mst_is_master_trans(crtc_state))
-			val &= ~TGL_TRANS_DDI_PORT_MASK;
+		if (!intel_dp_mst_is_master_trans(crtc_state)) {
+			val &= ~(TGL_TRANS_DDI_PORT_MASK |
+				 TRANS_DDI_MODE_SELECT_MASK);
+		}
 	} else {
-		val &= ~TRANS_DDI_PORT_MASK;
+		val &= ~(TRANS_DDI_PORT_MASK | TRANS_DDI_MODE_SELECT_MASK);
 	}
 	intel_de_write(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder), val);
 
@@ -3728,7 +3730,8 @@ static void intel_ddi_post_disable_dp(struct intel_encoder *encoder,
 
 			val = intel_de_read(dev_priv,
 					    TRANS_DDI_FUNC_CTL(cpu_transcoder));
-			val &= ~TGL_TRANS_DDI_PORT_MASK;
+			val &= ~(TGL_TRANS_DDI_PORT_MASK |
+				 TRANS_DDI_MODE_SELECT_MASK);
 			intel_de_write(dev_priv,
 				       TRANS_DDI_FUNC_CTL(cpu_transcoder),
 				       val);
-- 
2.17.1

