From f6b8f87b270ddaa3e8f55f979cdf3c57cdc99cf0 Mon Sep 17 00:00:00 2001
From: Shruthi Sanil <shruthi.sanil@intel.com>
Date: Fri, 5 Feb 2021 00:24:41 +0530
Subject: [PATCH 045/109] Add XLink USB driver

---
 drivers/misc/Kconfig                          |    2 +-
 drivers/misc/Makefile                         |    2 +-
 drivers/misc/xlink-usb/Kconfig                |   30 +
 drivers/misc/xlink-usb/Makefile               |    2 +
 drivers/misc/xlink-usb/local_host/Makefile    |    9 +
 drivers/misc/xlink-usb/local_host/f_vpuusb.c  |  833 +++++++
 .../xlink-usb/local_host/mxlk_interface.c     |  113 +
 .../xlink-usb/local_host/serial_vpu_usb.c     |  226 ++
 drivers/misc/xlink-usb/local_host/u_xlink.c   | 1397 ++++++++++++
 drivers/misc/xlink-usb/local_host/u_xlink.h   |   82 +
 drivers/misc/xlink-usb/remote_host/Makefile   |    7 +
 .../remote_host/mxlk_interface_host.c         |   90 +
 .../misc/xlink-usb/remote_host/vpu-cdc-acm.c  | 1974 +++++++++++++++++
 .../misc/xlink-usb/remote_host/vpu-cdc-acm.h  |  112 +
 include/linux/xlink_drv_inf.h                 |   91 +
 15 files changed, 4968 insertions(+), 2 deletions(-)
 create mode 100644 drivers/misc/xlink-usb/Kconfig
 create mode 100644 drivers/misc/xlink-usb/Makefile
 create mode 100644 drivers/misc/xlink-usb/local_host/Makefile
 create mode 100644 drivers/misc/xlink-usb/local_host/f_vpuusb.c
 create mode 100644 drivers/misc/xlink-usb/local_host/mxlk_interface.c
 create mode 100644 drivers/misc/xlink-usb/local_host/serial_vpu_usb.c
 create mode 100644 drivers/misc/xlink-usb/local_host/u_xlink.c
 create mode 100644 drivers/misc/xlink-usb/local_host/u_xlink.h
 create mode 100644 drivers/misc/xlink-usb/remote_host/Makefile
 create mode 100644 drivers/misc/xlink-usb/remote_host/mxlk_interface_host.c
 create mode 100644 drivers/misc/xlink-usb/remote_host/vpu-cdc-acm.c
 create mode 100644 drivers/misc/xlink-usb/remote_host/vpu-cdc-acm.h
 create mode 100644 include/linux/xlink_drv_inf.h

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 9870d295700e..92f4f021a366 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -490,9 +490,9 @@ source "drivers/misc/pvpanic/Kconfig"
 source "drivers/misc/vpumgr/Kconfig"
 source "drivers/misc/Gpio-asm28xx/Kconfig"
 source "drivers/misc/gna/Kconfig"
-source "drivers/misc/noc/Kconfig"
 source "drivers/misc/intel_tsens/Kconfig"
 source "drivers/misc/xlink-smbus/Kconfig"
 source "drivers/misc/hddl_device/Kconfig"
 source "drivers/misc/i3c_test/Kconfig"
+source "drivers/misc/xlink-usb/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 1a20344a0a64..27226cc477e5 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -62,8 +62,8 @@ obj-$(CONFIG_HI6421V600_IRQ)	+= hi6421v600-irq.o
 obj-$(CONFIG_VPUMGR)		+= vpumgr/
 obj-$(CONFIG_HOST_KMB_TJ)       += Gpio-asm28xx/
 obj-$(CONFIG_INTEL_GNA)		+= gna/
-obj-$(CONFIG_NOC_DSS)		+= noc/
 obj-y                           += intel_tsens/
 obj-$(CONFIG_XLINK_SMBUS)	+= xlink-smbus/
 obj-y				+= hddl_device/
 obj-$(CONFIG_I3C_TEST) 		+= i3c_test/
+obj-y				+= xlink-usb/
diff --git a/drivers/misc/xlink-usb/Kconfig b/drivers/misc/xlink-usb/Kconfig
new file mode 100644
index 000000000000..c40fd8f49218
--- /dev/null
+++ b/drivers/misc/xlink-usb/Kconfig
@@ -0,0 +1,30 @@
+config XLINK_USB_LH_DRIVER
+	tristate "XLink USB Local Host driver"
+	depends on TTY
+	select USB_LIBCOMPOSITE
+	select USB_U_XLINK
+	select USB_F_VPUUSB
+	select USB_GADGET
+	help
+	  This option enables XLink USB Local Host driver.
+
+          This driver exposes a char device for use.
+
+          Choose M here to compile this driver as a module.
+
+config USB_U_XLINK
+	tristate
+
+config USB_F_VPUUSB
+	tristate
+
+config XLINK_USB_RH_DRIVER
+	tristate "XLink USB Remote Host driver"
+	depends on TTY
+	depends on !XLINK_USB_LH_DRIVER
+	help
+	  This driver supports USB modems and ISDN adapters which support the
+	  Communication Device Class Abstract Control Model interface.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cdc-acm.
diff --git a/drivers/misc/xlink-usb/Makefile b/drivers/misc/xlink-usb/Makefile
new file mode 100644
index 000000000000..41dbb94fdbff
--- /dev/null
+++ b/drivers/misc/xlink-usb/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_XLINK_USB_LH_DRIVER) += local_host/
+obj-$(CONFIG_XLINK_USB_RH_DRIVER) += remote_host/
\ No newline at end of file
diff --git a/drivers/misc/xlink-usb/local_host/Makefile b/drivers/misc/xlink-usb/local_host/Makefile
new file mode 100644
index 000000000000..6cb8bdab8aab
--- /dev/null
+++ b/drivers/misc/xlink-usb/local_host/Makefile
@@ -0,0 +1,9 @@
+obj-$(CONFIG_XLINK_USB_LH_DRIVER)	+= g_serial_vpu_usb.o
+g_serial_vpu_usb-y	:= serial_vpu_usb.o
+g_serial_vpu_usb-y += mxlk_interface.o
+
+obj-$(CONFIG_USB_U_XLINK)	+= usb_u_xlink.o
+usb_u_xlink-y			:= u_xlink.o
+
+obj-$(CONFIG_USB_F_VPUUSB)	+= usb_f_vpuusb.o
+usb_f_vpuusb-y			:= f_vpuusb.o
diff --git a/drivers/misc/xlink-usb/local_host/f_vpuusb.c b/drivers/misc/xlink-usb/local_host/f_vpuusb.c
new file mode 100644
index 000000000000..1e351889a6e0
--- /dev/null
+++ b/drivers/misc/xlink-usb/local_host/f_vpuusb.c
@@ -0,0 +1,833 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * f_vpuusb.c - vpu usb serial function driver
+ *
+ * Copyright (C) 2019 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2, as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include "u_xlink.h"
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/reboot.h>
+#include <linux/xlink_drv_inf.h>
+
+/*
+ * This VPU CDC ACM function support just wraps control functions and
+ * notifications around the generic serial-over-usb code.
+ *
+ */
+
+struct f_acm {
+	struct gserial			port;
+	u8				ctrl_id, data_id;
+	u8				port_num;
+
+	u8				pending;
+
+	/* lock is mostly for pending and notify_req ... they get accessed
+	 * by callbacks both from tty (open/close/break) under its spinlock,
+	 * and notify_req.complete() which can't use that lock.
+	 */
+	spinlock_t			lock;
+	struct device           *device;
+	struct usb_ep			*notify;
+	struct usb_request		*notify_req;
+
+	struct usb_cdc_line_coding	port_line_coding;	/* 8-N-1 etc */
+
+	/* SetControlLineState request -- CDC 1.1 section 6.2.14 (INPUT) */
+	u16				port_handshake_bits;
+#define ACM_CTRL_RTS	(1 << 1)	/* unused with full duplex */
+#define ACM_CTRL_DTR	(1 << 0)	/* host is ready for data r/w */
+
+	/* SerialState notification -- CDC 1.1 section 6.3.5 (OUTPUT) */
+	u16				serial_state;
+#define ACM_CTRL_OVERRUN	(1 << 6)
+#define ACM_CTRL_PARITY		(1 << 5)
+#define ACM_CTRL_FRAMING	(1 << 4)
+#define ACM_CTRL_RI		(1 << 3)
+#define ACM_CTRL_BRK		(1 << 2)
+#define ACM_CTRL_DSR		(1 << 1)
+#define ACM_CTRL_DCD		(1 << 0)
+};
+
+static inline struct f_acm *func_to_acm(struct usb_function *f)
+{
+	return container_of(f, struct f_acm, port.func);
+}
+
+static inline struct f_acm *port_to_acm(struct gserial *p)
+{
+	return container_of(p, struct f_acm, port);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* notification endpoint uses smallish and infrequent fixed-size messages */
+
+#define VPU_NOTIFY_INTERVAL_MS		32
+#define VPU_NOTIFY_MAXPACKET		10	/* notification + 2 bytes */
+
+/* interface and class descriptors: */
+
+static struct usb_interface_assoc_descriptor
+vpu_iad_descriptor = {
+	.bLength =		sizeof vpu_iad_descriptor,
+	.bDescriptorType =	USB_DT_INTERFACE_ASSOCIATION,
+
+	/* .bFirstInterface =	DYNAMIC, */
+	.bInterfaceCount = 	2,	// control + data
+	.bFunctionClass =	USB_CLASS_COMM,
+	.bFunctionSubClass =	USB_CDC_SUBCLASS_ACM,
+	.bFunctionProtocol =	USB_CDC_ACM_PROTO_AT_V25TER,
+	/* .iFunction =		DYNAMIC */
+};
+
+
+static struct usb_interface_descriptor vpu_control_interface_desc = {
+	.bLength =		USB_DT_INTERFACE_SIZE,
+	.bDescriptorType =	USB_DT_INTERFACE,
+	/* .bInterfaceNumber = DYNAMIC */
+	.bNumEndpoints =	1,
+	.bInterfaceClass =	USB_CLASS_COMM,
+	.bInterfaceSubClass =	USB_CDC_SUBCLASS_ACM,
+	.bInterfaceProtocol =	USB_CDC_ACM_PROTO_AT_V25TER,
+	/* .iInterface = DYNAMIC */
+};
+
+static struct usb_interface_descriptor vpu_data_interface_desc = {
+	.bLength =		USB_DT_INTERFACE_SIZE,
+	.bDescriptorType =	USB_DT_INTERFACE,
+	/* .bInterfaceNumber = DYNAMIC */
+	.bNumEndpoints =	2,
+	.bInterfaceClass =	USB_CLASS_CDC_DATA,
+	.bInterfaceSubClass =	0,
+	.bInterfaceProtocol =	0,
+	/* .iInterface = DYNAMIC */
+};
+
+static struct usb_cdc_header_desc vpu_header_desc = {
+	.bLength =		sizeof(vpu_header_desc),
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubType =	USB_CDC_HEADER_TYPE,
+	.bcdCDC =		cpu_to_le16(0x0110),
+};
+
+static struct usb_cdc_call_mgmt_descriptor
+vpu_call_mgmt_descriptor = {
+	.bLength =		sizeof(vpu_call_mgmt_descriptor),
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubType =	USB_CDC_CALL_MANAGEMENT_TYPE,
+	.bmCapabilities =	0,
+	/* .bDataInterface = DYNAMIC */
+};
+
+static struct usb_cdc_acm_descriptor vpu_descriptor = {
+	.bLength =		sizeof(vpu_descriptor),
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubType =	USB_CDC_ACM_TYPE,
+	.bmCapabilities =	USB_CDC_CAP_LINE,
+};
+
+static struct usb_cdc_union_desc vpu_union_desc = {
+	.bLength =		sizeof(vpu_union_desc),
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubType =	USB_CDC_UNION_TYPE,
+	/* .bMasterInterface0 =	DYNAMIC */
+	/* .bSlaveInterface0 =	DYNAMIC */
+};
+
+/* full speed support: */
+
+static struct usb_endpoint_descriptor vpu_fs_notify_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_IN,
+	.bmAttributes =		USB_ENDPOINT_XFER_INT,
+	.wMaxPacketSize =	cpu_to_le16(VPU_NOTIFY_MAXPACKET),
+	.bInterval =		VPU_NOTIFY_INTERVAL_MS,
+};
+
+static struct usb_endpoint_descriptor vpu_fs_in_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_IN,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor vpu_fs_out_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_OUT,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_descriptor_header *vpu_fs_function[] = {
+	(struct usb_descriptor_header *) &vpu_iad_descriptor,
+	(struct usb_descriptor_header *) &vpu_control_interface_desc,
+	(struct usb_descriptor_header *) &vpu_header_desc,
+	(struct usb_descriptor_header *) &vpu_call_mgmt_descriptor,
+	(struct usb_descriptor_header *) &vpu_descriptor,
+	(struct usb_descriptor_header *) &vpu_union_desc,
+	(struct usb_descriptor_header *) &vpu_fs_notify_desc,
+	(struct usb_descriptor_header *) &vpu_data_interface_desc,
+	(struct usb_descriptor_header *) &vpu_fs_in_desc,
+	(struct usb_descriptor_header *) &vpu_fs_out_desc,
+	NULL,
+};
+
+/* high speed support: */
+static struct usb_endpoint_descriptor vpu_hs_notify_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_IN,
+	.bmAttributes =		USB_ENDPOINT_XFER_INT,
+	.wMaxPacketSize =	cpu_to_le16(VPU_NOTIFY_MAXPACKET),
+	.bInterval =		USB_MS_TO_HS_INTERVAL(VPU_NOTIFY_INTERVAL_MS),
+};
+
+static struct usb_endpoint_descriptor vpu_hs_in_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor vpu_hs_out_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	cpu_to_le16(512),
+};
+
+static struct usb_descriptor_header *vpu_hs_function[] = {
+	(struct usb_descriptor_header *) &vpu_iad_descriptor,
+	(struct usb_descriptor_header *) &vpu_control_interface_desc,
+	(struct usb_descriptor_header *) &vpu_header_desc,
+	(struct usb_descriptor_header *) &vpu_call_mgmt_descriptor,
+	(struct usb_descriptor_header *) &vpu_descriptor,
+	(struct usb_descriptor_header *) &vpu_union_desc,
+	(struct usb_descriptor_header *) &vpu_hs_notify_desc,
+	(struct usb_descriptor_header *) &vpu_data_interface_desc,
+	(struct usb_descriptor_header *) &vpu_hs_in_desc,
+	(struct usb_descriptor_header *) &vpu_hs_out_desc,
+	NULL,
+};
+
+static struct usb_endpoint_descriptor vpu_ss_in_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	cpu_to_le16(1024),
+};
+
+static struct usb_endpoint_descriptor vpu_ss_out_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	cpu_to_le16(1024),
+};
+
+static struct usb_ss_ep_comp_descriptor vpu_ss_bulk_comp_desc = {
+	.bLength =              sizeof vpu_ss_bulk_comp_desc,
+	.bDescriptorType =      USB_DT_SS_ENDPOINT_COMP,
+};
+
+static struct usb_descriptor_header *vpu_ss_function[] = {
+	(struct usb_descriptor_header *) &vpu_iad_descriptor,
+	(struct usb_descriptor_header *) &vpu_control_interface_desc,
+	(struct usb_descriptor_header *) &vpu_header_desc,
+	(struct usb_descriptor_header *) &vpu_call_mgmt_descriptor,
+	(struct usb_descriptor_header *) &vpu_descriptor,
+	(struct usb_descriptor_header *) &vpu_union_desc,
+	(struct usb_descriptor_header *) &vpu_hs_notify_desc,
+	(struct usb_descriptor_header *) &vpu_ss_bulk_comp_desc,
+	(struct usb_descriptor_header *) &vpu_data_interface_desc,
+	(struct usb_descriptor_header *) &vpu_ss_in_desc,
+	(struct usb_descriptor_header *) &vpu_ss_bulk_comp_desc,
+	(struct usb_descriptor_header *) &vpu_ss_out_desc,
+	(struct usb_descriptor_header *) &vpu_ss_bulk_comp_desc,
+	NULL,
+};
+
+/* string descriptors: */
+
+#define ACM_CTRL_IDX	0
+#define ACM_DATA_IDX	1
+#define ACM_IAD_IDX	2
+
+/* static strings, in UTF-8 */
+static struct usb_string vpu_string_defs[] = {
+	[ACM_CTRL_IDX].s = "CDC Abstract Control Model (ACM)",
+	[ACM_DATA_IDX].s = "CDC ACM Data",
+	[ACM_IAD_IDX].s = "CDC Serial",
+	{  } /* end of list */
+};
+
+static struct usb_gadget_strings vpu_string_table = {
+	.language =		0x0409,	/* en-us */
+	.strings =		vpu_string_defs,
+};
+
+static struct usb_gadget_strings *vpu_strings[] = {
+	&vpu_string_table,
+	NULL,
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* ACM control ... data handling is delegated to tty library code.
+ * The main task of this function is to activate and deactivate
+ * that code based on device state; track parameters like line
+ * speed, handshake state, and so on; and issue notifications.
+ */
+
+static void vpu_complete_set_line_coding(struct usb_ep *ep,
+		struct usb_request *req)
+{
+	struct f_acm	*acm = ep->driver_data;
+	if (req->status != 0)
+		return;
+
+	/* normal completion */
+	if (req->actual != sizeof(acm->port_line_coding))
+		usb_ep_set_halt(ep);
+	else {
+		struct usb_cdc_line_coding	*value = req->buf;
+
+		/* REVISIT:  we currently just remember this data.
+		 * If we change that, (a) validate it first, then
+		 * (b) update whatever hardware needs updating,
+		 * (c) worry about locking.  This is information on
+		 * the order of 9600-8-N-1 ... most of which means
+		 * nothing unless we control a real RS232 line.
+		 */
+		acm->port_line_coding = *value;
+	}
+}
+
+u32 bus_num;
+u32 dev_num;
+u32 xlink_usb_sw_id;
+int usb_sw_id (int pid)
+{
+	xlink_usb_sw_id = (XLINK_DEV_INF_USB << XLINK_DEV_INF_TYPE_SHIFT) |
+		      ((bus_num << 8 | dev_num) << XLINK_DEV_PHYS_ID_SHIFT) |
+			  (XLINK_DEV_TYPE_KMB << XLINK_DEV_TYPE_SHIFT) |
+		      (XLINK_DEV_SLICE_0 << XLINK_DEV_SLICE_ID_SHIFT) |
+		      (XLINK_DEV_FUNC_VPU << XLINK_DEV_FUNC_SHIFT);
+	return xlink_usb_sw_id;
+}
+EXPORT_SYMBOL_GPL(usb_sw_id);
+
+int usb_get_by_id (uint32_t sw_device_id)
+{
+	return (sw_device_id == xlink_usb_sw_id);
+}
+EXPORT_SYMBOL_GPL(usb_get_by_id);
+
+int mxlk_trigger_reset(void *arg)
+{
+	orderly_reboot();
+	return 0;
+}
+
+int intr;
+static irqreturn_t keembay_usb_irq_handler(int irq, void *arg)
+{
+	int *data = vpu_read_swid();
+	if (data != 0) {
+		if (*(data) == 0)
+			mxlk_trigger_reset(arg);
+		else {
+			if (!intr) {
+				bus_num = *(data);
+				intr = 1;
+			} else {
+				dev_num = *(data);
+				intr = 0;
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+int vpu_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)
+{
+	struct f_acm		*acm = func_to_acm(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	struct usb_request	*req = cdev->req;
+	int			value = -EOPNOTSUPP;
+	u16			w_index = le16_to_cpu(ctrl->wIndex);
+	u16			w_value = le16_to_cpu(ctrl->wValue);
+	u16			w_length = le16_to_cpu(ctrl->wLength);
+
+	/* composite driver infrastructure handles everything except
+	 * CDC class messages; interface activation uses set_alt().
+	 *
+	 * Note CDC spec table 4 lists the ACM request profile.  It requires
+	 * encapsulated command support ... we don't handle any, and respond
+	 * to them by stalling.  Options include get/set/clear comm features
+	 * (not that useful) and SEND_BREAK.
+	 */
+	switch ((ctrl->bRequestType << 8) | ctrl->bRequest) {
+
+	/* SET_LINE_CODING ... just read and save what the host sends */
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)
+			| USB_CDC_REQ_SET_LINE_CODING:
+		if (w_length != sizeof(struct usb_cdc_line_coding)
+				|| w_index != acm->ctrl_id)
+			goto invalid;
+
+		value = w_length;
+		cdev->gadget->ep0->driver_data = acm;
+		req->complete = vpu_complete_set_line_coding;
+		break;
+
+	/* GET_LINE_CODING ... return what host sent, or initial value */
+	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)
+			| USB_CDC_REQ_GET_LINE_CODING:
+
+		if (w_index != acm->ctrl_id)
+			goto invalid;
+
+		value = min_t(unsigned, w_length,
+				sizeof(struct usb_cdc_line_coding));
+
+		memcpy(req->buf, &acm->port_line_coding, value);
+
+		break;
+
+	/* SET_CONTROL_LINE_STATE ... save what the host sent */
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)
+			| USB_CDC_REQ_SET_CONTROL_LINE_STATE:
+		if (w_index != acm->ctrl_id)
+			goto invalid;
+
+		value = 0;
+
+		/* FIXME we should not allow data to flow until the
+		 * host sets the ACM_CTRL_DTR bit; and when it clears
+		 * that bit, we should return to that no-flow state.
+		 */
+		acm->port_handshake_bits = w_value;
+		break;
+
+	default:
+invalid:
+		dev_vdbg(&cdev->gadget->dev,
+			 "invalid control req%02x.%02x v%04x i%04x l%d\n",
+			 ctrl->bRequestType, ctrl->bRequest,
+			 w_value, w_index, w_length);
+	}
+
+	/* respond with data transfer or status phase? */
+	if (value >= 0) {
+		req->zero = 0;
+		req->length = value;
+		value = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
+		if (value < 0)
+			ERROR(cdev, "acm response err %d\n",
+					value);
+	}
+
+	/* device either stalls (value < 0) or reports success */
+	return value;
+}
+EXPORT_SYMBOL_GPL(vpu_setup);
+
+static int vpu_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
+{
+	struct f_acm		*acm = func_to_acm(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	/* we know alt == 0, so this is an activation or a reset */
+
+	if (intf == acm->ctrl_id) {
+		dev_vdbg(&cdev->gadget->dev,
+				"reset acm control interface %d\n", intf);
+		usb_ep_disable(acm->notify);
+
+		if (!acm->notify->desc)
+			if (config_ep_by_speed(cdev->gadget, f, acm->notify))
+				return -EINVAL;
+
+		usb_ep_enable(acm->notify);
+
+	} else if (intf == acm->data_id) {
+		if (acm->notify->enabled)
+			vpu_disconnect(&acm->port);
+
+		if (!acm->port.in->desc || !acm->port.out->desc) {
+			if (config_ep_by_speed(cdev->gadget, f,
+					       acm->port.in) ||
+			    config_ep_by_speed(cdev->gadget, f,
+					       acm->port.out)) {
+				acm->port.in->desc = NULL;
+				acm->port.out->desc = NULL;
+				return -EINVAL;
+			}
+		}
+
+		vpu_connect(&acm->port, acm->port_num);
+
+	} else
+		return -EINVAL;
+	return 0;
+}
+
+static void vpu_disable(struct usb_function *f)
+{
+	struct f_acm	*acm = func_to_acm(f);
+	vpu_disconnect(&acm->port);
+
+	usb_ep_disable(acm->notify);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/**
+ * vpu_cdc_notify - issue CDC notification to host
+ * @acm: wraps host to be notified
+ * @type: notification type
+ * @value: Refer to cdc specs, wValue field.
+ * @data: data to be sent
+ * @length: size of data
+ * Context: irqs blocked, acm->lock held, vpu_notify_req non-null
+ *
+ * Returns zero on success or a negative errno.
+ *
+ * See section 6.3.5 of the CDC 1.1 specification for information
+ * about the only notification we issue:  SerialState change.
+ */
+int vpu_cdc_notify(struct f_acm *acm, u8 type, u16 value,
+		void *data, unsigned length)
+{
+	struct usb_ep			*ep = acm->notify;
+	struct usb_request		*req;
+	struct usb_cdc_notification	*notify;
+	const unsigned			len = sizeof(*notify) + length;
+	void				*buf;
+	int				status;
+	req = acm->notify_req;
+	acm->notify_req = NULL;
+	acm->pending = false;
+	req->length = len;
+	notify = req->buf;
+	buf = notify + 1;
+
+	notify->bmRequestType = USB_DIR_IN | USB_TYPE_CLASS
+			| USB_RECIP_INTERFACE;
+	notify->bNotificationType = type;
+	notify->wValue = cpu_to_le16(value);
+	notify->wIndex = cpu_to_le16(acm->ctrl_id);
+	notify->wLength = cpu_to_le16(length);
+	memcpy(buf, data, length);
+
+	/* ep_queue() can complete immediately if it fills the fifo... */
+	spin_unlock(&acm->lock);
+	status = usb_ep_queue(ep, req, GFP_ATOMIC);
+	spin_lock(&acm->lock);
+
+	if (status < 0)
+		acm->notify_req = req;
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(vpu_cdc_notify);
+
+int vpu_notify_serial_state(struct f_acm *acm)
+{
+	int			status;
+	__le16			serial_state;
+	spin_lock(&acm->lock);
+	if (acm->notify_req) {
+		serial_state = cpu_to_le16(acm->serial_state);
+		status = vpu_cdc_notify(acm, USB_CDC_NOTIFY_SERIAL_STATE,
+				0, &serial_state, sizeof(acm->serial_state));
+	} else {
+		acm->pending = true;
+		status = 0;
+	}
+	spin_unlock(&acm->lock);
+	return status;
+}
+EXPORT_SYMBOL_GPL(vpu_notify_serial_state);
+
+static void vpu_cdc_notify_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct f_acm		*acm = req->context;
+	u8			doit = false;
+	/* on this call path we do NOT hold the port spinlock,
+	 * which is why ACM needs its own spinlock
+	 */
+	spin_lock(&acm->lock);
+	if (req->status != -ESHUTDOWN)
+		doit = acm->pending;
+	acm->notify_req = req;
+	spin_unlock(&acm->lock);
+
+	if (doit)
+		vpu_notify_serial_state(acm);
+}
+
+static void vpu_acm_connect(struct gserial *port)
+{
+	struct f_acm		*acm = port_to_acm(port);
+	acm->serial_state |= ACM_CTRL_DSR | ACM_CTRL_DCD;
+	vpu_notify_serial_state(acm);
+}
+
+static void vpu_acm_disconnect(struct gserial *port)
+{
+	struct f_acm		*acm = port_to_acm(port);
+	acm->serial_state &= ~(ACM_CTRL_DSR | ACM_CTRL_DCD);
+	vpu_notify_serial_state(acm);
+}
+
+static int vpu_send_break(struct gserial *port, int duration)
+{
+	struct f_acm		*acm = port_to_acm(port);
+	u16			state;
+	state = acm->serial_state;
+	state &= ~ACM_CTRL_BRK;
+	if (duration)
+		state |= ACM_CTRL_BRK;
+
+	acm->serial_state = state;
+	return vpu_notify_serial_state(acm);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* ACM function driver setup/binding */
+static int
+vpu_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct f_acm		*acm = func_to_acm(f);
+	struct usb_string	*us;
+	int			status;
+	struct usb_ep		*ep;
+
+	struct usb_gadget *gadget = cdev->gadget;
+	struct device *dev = &gadget->dev;
+	/* REVISIT might want instance-specific strings to help
+	 * distinguish instances ...
+	 */
+
+	int err = devm_request_irq(dev, 47, keembay_usb_irq_handler,
+			       IRQF_SHARED | IRQF_NO_THREAD, "xlink-usb", cdev);
+	if (err)
+		dev_err(dev, "failed to request IRQ: %d\n", err);
+
+
+	/* maybe allocate device-global string IDs, and patch descriptors */
+	us = usb_gstrings_attach(cdev, vpu_strings,
+			ARRAY_SIZE(vpu_string_defs));
+	if (IS_ERR(us))
+		return PTR_ERR(us);
+	vpu_control_interface_desc.iInterface = us[ACM_CTRL_IDX].id;
+	vpu_data_interface_desc.iInterface = us[ACM_DATA_IDX].id;
+	vpu_iad_descriptor.iFunction = us[ACM_IAD_IDX].id;
+
+	/* allocate instance-specific interface IDs, and patch descriptors */
+	status = usb_interface_id(c, f);
+	if (status < 0)
+		goto fail;
+	acm->ctrl_id = status;
+	vpu_iad_descriptor.bFirstInterface = status;
+
+	vpu_control_interface_desc.bInterfaceNumber = status;
+	vpu_union_desc .bMasterInterface0 = status;
+
+	status = usb_interface_id(c, f);
+	if (status < 0)
+		goto fail;
+	acm->data_id = status;
+
+	vpu_data_interface_desc.bInterfaceNumber = status;
+	vpu_union_desc.bSlaveInterface0 = status;
+	vpu_call_mgmt_descriptor.bDataInterface = status;
+
+	status = -ENODEV;
+
+	/* allocate instance-specific endpoints */
+	ep = usb_ep_autoconfig(cdev->gadget, &vpu_fs_in_desc);
+	if (!ep)
+		goto fail;
+	acm->port.in = ep;
+
+	ep = usb_ep_autoconfig(cdev->gadget, &vpu_fs_out_desc);
+	if (!ep)
+		goto fail;
+	acm->port.out = ep;
+
+	ep = usb_ep_autoconfig(cdev->gadget, &vpu_fs_notify_desc);
+	if (!ep)
+		goto fail;
+	acm->notify = ep;
+
+	/* allocate notification */
+	acm->notify_req = vpu_alloc_req(ep,
+			sizeof(struct usb_cdc_notification) + 2,
+			GFP_KERNEL);
+	if (!acm->notify_req)
+		goto fail;
+
+	acm->notify_req->complete = vpu_cdc_notify_complete;
+	acm->notify_req->context = acm;
+
+	/* support all relevant hardware speeds... we expect that when
+	 * hardware is dual speed, all bulk-capable endpoints work at
+	 * both speeds
+	 */
+	vpu_hs_in_desc.bEndpointAddress = vpu_fs_in_desc.bEndpointAddress;
+	vpu_hs_out_desc.bEndpointAddress = vpu_fs_out_desc.bEndpointAddress;
+	vpu_hs_notify_desc.bEndpointAddress =
+		vpu_fs_notify_desc.bEndpointAddress;
+
+	vpu_ss_in_desc.bEndpointAddress = vpu_fs_in_desc.bEndpointAddress;
+	vpu_ss_out_desc.bEndpointAddress = vpu_fs_out_desc.bEndpointAddress;
+
+	status = usb_assign_descriptors(f, vpu_fs_function, vpu_hs_function,
+			vpu_ss_function, NULL);
+	if (status)
+		goto fail;
+	kfree(us);
+	return 0;
+
+fail:
+	if (acm->notify_req)
+		vpu_free_req(acm->notify, acm->notify_req);
+
+	ERROR(cdev, "%s/%p: can't bind, err %d\n", f->name, f, status);
+	kfree(us);
+	return status;
+}
+
+static void vpu_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct f_acm		*acm = func_to_acm(f);
+	vpu_string_defs[0].id = 0;
+	usb_free_all_descriptors(f);
+	if (acm->notify_req)
+		vpu_free_req(acm->notify, acm->notify_req);
+}
+
+static void vpu_free_func(struct usb_function *f)
+{
+	struct f_acm		*acm = func_to_acm(f);
+
+	kfree(acm);
+}
+
+static struct usb_function *vpu_alloc_func(struct usb_function_instance *fi)
+{
+	struct f_serial_opts *opts;
+	struct f_acm *acm;
+	acm = kzalloc(sizeof(*acm), GFP_KERNEL);
+	if (!acm)
+		return ERR_PTR(-ENOMEM);
+
+	spin_lock_init(&acm->lock);
+
+	acm->port.connect = vpu_acm_connect;
+	acm->port.disconnect = vpu_acm_disconnect;
+	acm->port.send_break = vpu_send_break;
+
+	acm->port.func.name = "vpu";
+	acm->port.func.strings = vpu_strings;
+	/* descriptors are per-instance copies */
+	acm->port.func.bind = vpu_bind;
+	acm->port.func.set_alt = vpu_set_alt;
+	acm->port.func.setup = vpu_setup;
+	acm->port.func.disable = vpu_disable;
+
+	opts = container_of(fi, struct f_serial_opts, func_inst);
+	acm->port_num = opts->port_num;
+	acm->port.func.unbind = vpu_unbind;
+	acm->port.func.free_func = vpu_free_func;
+	return &acm->port.func;
+}
+
+static inline struct f_serial_opts *to_f_serial_opts(struct config_item *item)
+{
+	return container_of(to_config_group(item), struct f_serial_opts,
+			func_inst.group);
+}
+
+static void vpu_attr_release(struct config_item *item)
+{
+	struct f_serial_opts *opts = to_f_serial_opts(item);
+
+	usb_put_function_instance(&opts->func_inst);
+}
+
+static struct configfs_item_operations vpu_item_ops = {
+	.release                = vpu_attr_release,
+};
+
+static ssize_t f_acm_port_num_show(struct config_item *item, char *page)
+{
+	return 0;
+}
+
+CONFIGFS_ATTR_RO(f_acm_, port_num);
+
+static struct configfs_attribute *vpu_attrs[] = {
+	&f_acm_attr_port_num,
+	NULL,
+};
+
+static const struct config_item_type vpu_func_type = {
+	.ct_item_ops    = &vpu_item_ops,
+	.ct_attrs	= vpu_attrs,
+	.ct_owner       = THIS_MODULE,
+};
+
+static void vpu_free_instance(struct usb_function_instance *fi)
+{
+	struct f_serial_opts *opts;
+	opts = container_of(fi, struct f_serial_opts, func_inst);
+	vpu_free_line(opts->port_num);
+	kfree(opts);
+}
+
+static struct usb_function_instance *vpu_alloc_instance(void)
+{
+	struct f_serial_opts *opts;
+	int ret;
+	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
+	if (!opts)
+		return ERR_PTR(-ENOMEM);
+	opts->func_inst.free_func_inst = vpu_free_instance;
+	ret = vpu_alloc_line(&opts->port_num);
+	if (ret) {
+		kfree(opts);
+		return ERR_PTR(ret);
+	}
+	config_group_init_type_name(&opts->func_inst.group, "",
+			&vpu_func_type);
+	return &opts->func_inst;
+}
+DECLARE_USB_FUNCTION_INIT(vpu, vpu_alloc_instance, vpu_alloc_func);
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/xlink-usb/local_host/mxlk_interface.c b/drivers/misc/xlink-usb/local_host/mxlk_interface.c
new file mode 100644
index 000000000000..f3994b0d23ce
--- /dev/null
+++ b/drivers/misc/xlink-usb/local_host/mxlk_interface.c
@@ -0,0 +1,113 @@
+/*****************************************************************************
+ *
+ * Intel Keem Bay XLink VPU USB Driver
+ *
+ * Copyright (C) 2019 Intel Corporation
+ *
+ ****************************************************************************/
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/xlink_drv_inf.h>
+#include "u_xlink.h"
+
+#define USB_VENDOR_ID_INTEL_KEEMBAY  0x03e7
+#define MXLK_DRIVER_NAME "mxlk_usb_epf"
+
+int xlink_usb_get_device_list(uint32_t *sw_device_id_list,
+			       uint32_t *num_devices)
+{
+	int pid = 0;
+	u32 xlink_usb_sw_id;
+	xlink_usb_sw_id = usb_sw_id(pid);
+	if (xlink_usb_sw_id != 0) {
+		*num_devices = 1;
+		*sw_device_id_list = xlink_usb_sw_id;
+	} else {
+		*num_devices = 0;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(xlink_usb_get_device_list);
+
+int xlink_usb_get_device_name(uint32_t sw_device_id, char *device_name,
+			       size_t name_size)
+{
+	int mxlk;
+	mxlk = usb_get_by_id(sw_device_id);
+	if (!mxlk)
+		return -ENODEV;
+
+	memset(device_name, 0, name_size);
+	if (name_size > strlen(MXLK_DRIVER_NAME))
+		name_size = strlen(MXLK_DRIVER_NAME);
+	strncpy(device_name, MXLK_DRIVER_NAME, name_size);
+
+	return 0;
+}
+EXPORT_SYMBOL(xlink_usb_get_device_name);
+
+int xlink_usb_get_device_status(uint32_t sw_device_id,
+				 uint32_t *device_status)
+{
+	int mxlk;
+	mxlk = usb_get_by_id(sw_device_id);
+	if (!mxlk) {
+		*device_status = 1;
+		return -ENODEV;
+	}
+	*device_status = 4;
+	return 0;
+}
+EXPORT_SYMBOL(xlink_usb_get_device_status);
+
+int xlink_usb_boot_device(uint32_t sw_device_id, const char *binary_name)
+{
+	return 0;
+}
+EXPORT_SYMBOL(xlink_usb_boot_device);
+
+int xlink_usb_connect(uint32_t sw_device_id)
+{
+	int mxlk;
+	mxlk = usb_get_by_id(sw_device_id);
+	if (!mxlk)
+		return -ENODEV;
+
+	return 0;
+}
+EXPORT_SYMBOL(xlink_usb_connect);
+
+int xlink_usb_read(uint32_t sw_device_id, void *data, size_t *const size,
+		    uint32_t timeout)
+{
+	int mxlk;
+	mxlk = usb_get_by_id(sw_device_id);
+	if (!mxlk)
+		return -ENODEV;
+	return vpu_read(data, size, timeout);
+}
+EXPORT_SYMBOL(xlink_usb_read);
+
+int xlink_usb_write(uint32_t sw_device_id, void *data, size_t *const size,
+		     uint32_t timeout)
+{
+	int mxlk;
+	int rc;
+
+	mxlk = usb_get_by_id(sw_device_id);
+	if (!mxlk)
+		return -ENODEV;
+
+	rc = vpu_write1(data, size, timeout);
+	if (rc < 0)
+		return rc;
+	return vpu_close1();
+}
+EXPORT_SYMBOL(xlink_usb_write);
+
+int xlink_usb_reset_device(uint32_t sw_device_id)
+{
+	return 0;
+}
+EXPORT_SYMBOL(xlink_usb_reset_device);
\ No newline at end of file
diff --git a/drivers/misc/xlink-usb/local_host/serial_vpu_usb.c b/drivers/misc/xlink-usb/local_host/serial_vpu_usb.c
new file mode 100644
index 000000000000..c0a2c95384b4
--- /dev/null
+++ b/drivers/misc/xlink-usb/local_host/serial_vpu_usb.c
@@ -0,0 +1,226 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * serial_vpu_usb.c -- USB gadget serial driver
+ *
+ * Copyright (C) 2019 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2, as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include "u_xlink.h"
+
+/* Defines */
+#define MX_VERSION_STR			"v1.0"
+#define MX_VERSION_NUM			0x1000
+#define MX_VERSION_NAME			"Keembay VPU USB" " " MX_VERSION_STR
+
+/*-------------------------------------------------------------------------*/
+USB_GADGET_COMPOSITE_OPTIONS();
+
+#define MX_VENDOR_ID			0x03e7	/* MyraidX Vendor ID */
+#define MX_PRODUCT_ID		0x2485	/* MyraidX Product ID */
+
+/* string IDs are assigned dynamically */
+
+#define STRING_DESCRIPTION_IDX		USB_GADGET_FIRST_AVAIL_IDX
+
+static struct usb_string strings_dev[] = {
+	[USB_GADGET_MANUFACTURER_IDX].s = "",
+	[USB_GADGET_PRODUCT_IDX].s = MX_VERSION_NAME,
+	[USB_GADGET_SERIAL_IDX].s = "",
+	[STRING_DESCRIPTION_IDX].s = NULL,
+	{  } /* end of list */
+};
+
+static struct usb_gadget_strings stringtab_dev = {
+	.language	= 0x0409,	/* en-us */
+	.strings	= strings_dev,
+};
+
+static struct usb_gadget_strings *dev_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
+
+static struct usb_device_descriptor device_desc = {
+	.bLength =		USB_DT_DEVICE_SIZE,
+	.bDescriptorType =	USB_DT_DEVICE,
+	.bDeviceSubClass =	0,
+	.bDeviceProtocol =	0,
+	.idVendor =		cpu_to_le16(MX_VENDOR_ID),
+	.bcdDevice = cpu_to_le16(MX_VERSION_NUM),
+	.bNumConfigurations =	1,
+};
+
+static const struct usb_descriptor_header *otg_desc[2];
+
+/* Module */
+MODULE_DESCRIPTION(MX_VERSION_NAME);
+MODULE_AUTHOR("Tan Seng Kai");
+MODULE_AUTHOR("Lai Jun Ann");
+MODULE_LICENSE("GPL");
+
+static struct usb_configuration serial_config_driver = {
+	.bmAttributes	= USB_CONFIG_ATT_SELFPOWER,
+};
+
+static struct usb_function_instance *fi_serial[MAX_U_SERIAL_PORTS];
+static struct usb_function *f_serial[MAX_U_SERIAL_PORTS];
+
+static int serial_register_ports(struct usb_composite_dev *cdev,
+		struct usb_configuration *c, const char *f_name)
+{
+	int i;
+	int ret;
+
+	ret = usb_add_config_only(cdev, c);
+	if (ret)
+		goto out;
+
+	for (i = 0; i < 1; i++) {
+
+		fi_serial[i] = usb_get_function_instance(f_name);
+		if (IS_ERR(fi_serial[i])) {
+			ret = PTR_ERR(fi_serial[i]);
+			goto fail;
+		}
+
+		f_serial[i] = usb_get_function(fi_serial[i]);
+		if (IS_ERR(f_serial[i])) {
+			ret = PTR_ERR(f_serial[i]);
+			goto err_get_func;
+		}
+
+		ret = usb_add_function(c, f_serial[i]);
+		if (ret)
+			goto err_add_func;
+	}
+
+	return 0;
+
+err_add_func:
+	usb_put_function(f_serial[i]);
+err_get_func:
+	usb_put_function_instance(fi_serial[i]);
+
+fail:
+	i--;
+	while (i >= 0) {
+		usb_put_function(f_serial[i]);
+		usb_put_function_instance(fi_serial[i]);
+		i--;
+	}
+out:
+	return ret;
+}
+
+static int vpu_bind(struct usb_composite_dev *cdev)
+{
+	int			status;
+
+	/* Allocate string descriptor numbers ... note that string
+	 * contents can be overridden by the composite_dev glue.
+	 */
+
+	status = usb_string_ids_tab(cdev, strings_dev);
+	if (status < 0)
+		goto fail;
+	device_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;
+	device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;
+	status = strings_dev[STRING_DESCRIPTION_IDX].id;
+	serial_config_driver.iConfiguration = status;
+
+	if (gadget_is_otg(cdev->gadget)) {
+		if (!otg_desc[0]) {
+			struct usb_descriptor_header *usb_desc;
+
+			usb_desc = usb_otg_descriptor_alloc(cdev->gadget);
+			if (!usb_desc) {
+				status = -ENOMEM;
+				goto fail;
+			}
+			usb_otg_descriptor_init(cdev->gadget, usb_desc);
+			otg_desc[0] = usb_desc;
+			otg_desc[1] = NULL;
+		}
+		serial_config_driver.descriptors = otg_desc;
+		serial_config_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+	}
+	/* register our configuration */
+	status  = serial_register_ports(cdev, &serial_config_driver,
+			"vpu");
+	usb_ep_autoconfig_reset(cdev->gadget);
+
+	if (status < 0)
+		goto fail1;
+
+	usb_composite_overwrite_options(cdev, &coverwrite);
+	INFO(cdev, "%s\n", MX_VERSION_NAME);
+
+	return 0;
+fail1:
+	kfree(otg_desc[0]);
+	otg_desc[0] = NULL;
+fail:
+	return status;
+}
+
+static int vpu_unbind(struct usb_composite_dev *cdev)
+{
+	int i;
+
+	for (i = 0; i < 1; i++) {
+		usb_put_function(f_serial[i]);
+		usb_put_function_instance(fi_serial[i]);
+	}
+
+	kfree(otg_desc[0]);
+	otg_desc[0] = NULL;
+
+	return 0;
+}
+
+static struct usb_composite_driver gserial_driver = {
+	.name		= "vpu",
+	.dev		= &device_desc,
+	.strings	= dev_strings,
+	.max_speed	= USB_SPEED_SUPER,
+	.bind		= vpu_bind,
+	.unbind		= vpu_unbind,
+};
+
+static int __init init(void)
+{
+	/* We *could* export two configs; that'd be much cleaner...
+	 * but neither of these product IDs was defined that way.
+	 */
+	serial_config_driver.label = "VPU USB config";
+	serial_config_driver.bConfigurationValue = 2;
+	device_desc.bDeviceClass = USB_CLASS_COMM;
+	device_desc.idProduct =
+			cpu_to_le16(MX_PRODUCT_ID);
+
+	strings_dev[STRING_DESCRIPTION_IDX].s = serial_config_driver.label;
+
+	return usb_composite_probe(&gserial_driver);
+}
+module_init(init);
+
+static void __exit cleanup(void)
+{
+	usb_composite_unregister(&gserial_driver);
+}
+module_exit(cleanup);
diff --git a/drivers/misc/xlink-usb/local_host/u_xlink.c b/drivers/misc/xlink-usb/local_host/u_xlink.c
new file mode 100644
index 000000000000..12f2d7198da7
--- /dev/null
+++ b/drivers/misc/xlink-usb/local_host/u_xlink.c
@@ -0,0 +1,1397 @@
+/*
+ * u_xlink.c - utilities for USB gadget
+ *
+ * Copyright (C) 2019 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2, as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/slab.h>
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/console.h>
+#include <linux/kthread.h>
+#include <linux/workqueue.h>
+#include <linux/kfifo.h>
+#include "u_xlink.h"
+#include <linux/xlink_drv_inf.h>
+
+#define QUEUE_SIZE		(32*1024) //Matching the size with pcie buffer, USB max packet size is 1024 bytes for USB 3.0
+#define WRITE_BUF_SIZE		8192		/* TX only */
+#define GS_CONSOLE_BUF_SIZE	8192
+
+u8 PORT_NUM;
+
+/* console info */
+struct gscons_info {
+	struct gs_port		*port;
+	struct task_struct	*console_thread;
+	struct kfifo		con_buf;
+	/* protect the buf and busy flag */
+	spinlock_t		con_lock;
+	int			req_busy;
+	struct usb_request	*console_req;
+};
+
+/*
+ * The port structure holds info for each port, one for each minor number
+ * (and thus for each /dev/ node).
+ */
+struct gs_port {
+	struct tty_port		port;
+	spinlock_t		port_lock;	/* guard port_* access */
+
+	struct gserial		*port_usb;
+
+	bool			openclose;	/* open/close in progress */
+	u8			port_num;
+
+	struct list_head	read_pool;
+	struct list_head	read_req;
+	int read_started;
+	int read_allocated;
+	struct list_head	read_queue;
+	unsigned		n_read;
+	struct delayed_work	push;
+
+	struct list_head	write_pool;
+	int write_started;
+	int write_allocated;
+	struct kfifo		port_write_buf;
+	wait_queue_head_t	drain_wait;	/* wait while writes drain */
+	bool                    write_busy;
+	wait_queue_head_t	close_wait;
+
+	/* REVISIT this state ... */
+	struct usb_cdc_line_coding port_line_coding;	/* 8-N-1 etc */
+};
+
+static struct portmaster {
+	struct mutex	lock;			/* protect open/close */
+	struct gs_port	*port;
+} ports[MAX_U_SERIAL_PORTS];
+
+#define GS_CLOSE_TIMEOUT		15		/* seconds */
+
+#ifdef VERBOSE_DEBUG
+#ifndef pr_vdebug
+#define pr_vdebug(fmt, arg...) \
+	pr_debug(fmt, ##arg)
+#endif /* pr_vdebug */
+#else
+#ifndef pr_vdebug
+#define pr_vdebug(fmt, arg...) \
+	({ if (0) pr_debug(fmt, ##arg); })
+#endif /* pr_vdebug */
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+/* I/O glue between TTY (upper) and USB function (lower) driver layers */
+
+/*
+ * vpu_alloc_req
+ *
+ * Allocate a usb_request and its buffer.  Returns a pointer to the
+ * usb_request or NULL if there is an error.
+ */
+struct usb_request *
+vpu_alloc_req(struct usb_ep *ep, unsigned len, gfp_t kmalloc_flags)
+{
+	struct usb_request *req;
+	req = usb_ep_alloc_request(ep, kmalloc_flags);
+	if (req != NULL) {
+		req->length = len;
+		req->buf = kmalloc(len, kmalloc_flags);
+		if (req->buf == NULL) {
+			usb_ep_free_request(ep, req);
+			return NULL;
+		}
+	}
+	return req;
+}
+EXPORT_SYMBOL_GPL(vpu_alloc_req);
+
+/*
+ * vpu_free_req
+ *
+ * Free a usb_request and its buffer.
+ */
+void vpu_free_req(struct usb_ep *ep, struct usb_request *req)
+{
+	kfree(req->buf);
+	usb_ep_free_request(ep, req);
+}
+EXPORT_SYMBOL_GPL(vpu_free_req);
+
+/*
+ * vpu_send_packet
+ *
+ * If there is data to send, a packet is built in the given
+ * buffer and the size is returned.  If there is no data to
+ * send, 0 is returned.
+ *
+ * Called with port_lock held.
+ */
+static unsigned
+vpu_send_packet(struct gs_port *port, char *packet, unsigned size)
+{
+	unsigned len;
+
+	len = kfifo_len(&port->port_write_buf);
+	if (len < size)
+		size = len;
+
+	size = kfifo_out(&port->port_write_buf, packet, size);
+
+	return size;
+}
+
+/*
+ * vpu_start_tx
+ *
+ * This function finds available write requests, calls
+ * vpu_send_packet to fill these packets with data, and
+ * continues until either there are no more write requests
+ * available or no more data to send.  This function is
+ * run whenever data arrives or write requests are available.
+ *
+ * Context: caller owns port_lock; port_usb is non-null.
+ */
+static int vpu_start_tx(struct gs_port *port)
+/*
+__releases(&port->port_lock)
+__acquires(&port->port_lock)
+*/
+{
+	struct list_head	*pool = &port->write_pool;
+	struct usb_ep		*in;
+	int			status = 0;
+	if (!port->port_usb)
+		return status;
+
+	in = port->port_usb->in;
+
+	while (!port->write_busy && !list_empty(pool)) {
+		struct usb_request	*req;
+		int			len;
+
+		if (port->write_started >= QUEUE_SIZE)
+			break;
+
+		req = list_entry(pool->next, struct usb_request, list);
+		len = vpu_send_packet(port, req->buf, in->maxpacket);
+
+		if (len == 0) {
+			wake_up_interruptible(&port->drain_wait);
+			break;
+		}
+
+		req->length = len;
+		list_del(&req->list);
+		req->zero = kfifo_is_empty(&port->port_write_buf);
+
+		port->write_busy = true;
+		spin_unlock(&port->port_lock);
+		status = usb_ep_queue(in, req, GFP_ATOMIC);
+		spin_lock(&port->port_lock);
+		port->write_busy = false;
+
+		if (status) {
+			list_add(&req->list, pool);
+			break;
+		}
+
+		port->write_started++;
+
+		/* abort immediately after disconnect */
+		if (!port->port_usb)
+			break;
+	}
+
+	return status;
+}
+
+/*
+ * Context: caller owns port_lock, and port_usb is set
+ */
+unsigned vpu_start_rx(struct gs_port *port)
+/*
+__releases(&port->port_lock)
+__acquires(&port->port_lock)
+*/
+{
+	struct list_head	*pool = &port->read_req;
+	struct usb_ep		*out;
+
+	while (!list_empty(pool)) {
+		struct usb_request	*req;
+		int			status;
+
+		if (!port->port_usb)
+			break;
+
+		out = port->port_usb->out;
+
+		if (port->read_started >= QUEUE_SIZE)
+			break;
+
+		req = list_entry(pool->next, struct usb_request, list);
+		list_del(&req->list);
+		req->length = out->maxpacket;
+		/* drop lock while we call out; the controller driver
+		 * may need to call us back (e.g. for disconnect)
+		 */
+		spin_unlock(&port->port_lock);
+		status = usb_ep_queue(out, req, GFP_ATOMIC);
+		spin_lock(&port->port_lock);
+
+		if (status) {
+			pr_debug("%s: %s %s err %d\n",
+					__func__, "queue", out->name, status);
+			list_add(&req->list, pool);
+			break;
+		}
+		port->read_started++;
+
+		/* abort immediately after disconnect */
+	}
+
+	return port->read_started;
+}
+EXPORT_SYMBOL_GPL(vpu_start_rx);
+
+/*
+ * RX tasklet takes data out of the RX queue and hands it up to the TTY
+ * layer until it refuses to take any more data (or is throttled back).
+ * Then it issues reads for any further data.
+ *
+ * If the RX queue becomes full enough that no usb_request is queued,
+ * the OUT endpoint may begin NAKing as soon as its FIFO fills up.
+ * So QUEUE_SIZE packets plus however many the FIFO holds (usually two)
+ * can be buffered before the TTY layer's buffers (currently 64 KB).
+ */
+static void vpu_rx_push(struct work_struct *work)
+{
+	struct delayed_work	*w = to_delayed_work(work);
+	struct gs_port		*port = container_of(w, struct gs_port, push);
+	struct list_head	*queue = &port->read_queue;
+	bool			disconnect = false;
+	bool			do_push = false;
+
+	/* hand any queued data to the tty */
+	spin_lock_irq(&port->port_lock);
+	while (!list_empty(queue)) {
+		struct usb_request	*req;
+
+		req = list_first_entry(queue, struct usb_request, list);
+
+		switch (req->status) {
+		case -ESHUTDOWN:
+			disconnect = true;
+			pr_vdebug("ttyGS%d: shutdown\n", port->port_num);
+			break;
+
+		default:
+			/* presumably a transient fault */
+			pr_warn("ttyGS%d: unexpected RX status %d\n",
+				port->port_num, req->status);
+			/* FALLTHROUGH */
+		case 0:
+			/* normal completion */
+			break;
+		}
+
+		/* push data to (open) tty */
+		if (req->actual) {
+			char		*packet = req->buf;
+			unsigned	size = req->actual;
+			unsigned	n;
+			int		count;
+			/* we may have pushed part of this packet already... */
+			n = port->n_read;
+			if (n) {
+				packet += n;
+				size -= n;
+			}
+
+			count = tty_insert_flip_string(&port->port, packet,
+					size);
+			if (count)
+				do_push = true;
+			if (count != size) {
+				/* stop pushing; TTY layer can't handle more */
+				port->n_read += count;
+				pr_vdebug("ttyGS%d: rx block %d/%d\n",
+					  port->port_num, count, req->actual);
+				break;
+			}
+			port->n_read = 0;
+		}
+
+		list_move_tail(&req->list, &port->read_pool);
+		port->read_started--;
+	}
+
+	/* Push from tty to ldisc; this is handled by a workqueue,
+	 * so we won't get callbacks and can hold port_lock
+	 */
+	if (do_push)
+		tty_flip_buffer_push(&port->port);
+
+	spin_unlock_irq(&port->port_lock);
+}
+
+void vpu_read_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct gs_port	*port = ep->driver_data;
+	/* Queue all received data until the tty layer is ready for it. */
+	spin_lock(&port->port_lock);
+	list_add_tail(&req->list, &port->read_queue);
+
+	schedule_delayed_work(&port->push, 0);
+	spin_unlock(&port->port_lock);
+}
+EXPORT_SYMBOL_GPL(vpu_read_complete);
+
+static void vpu_write_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct gs_port	*port = ep->driver_data;
+	spin_lock(&port->port_lock);
+	list_add(&req->list, &port->write_pool);
+	port->write_started--;
+
+	switch (req->status) {
+	default:
+		/* presumably a transient fault */
+		pr_warn("%s: unexpected %s status %d\n",
+			__func__, ep->name, req->status);
+		/* FALL THROUGH */
+		break;
+	case 0:
+		/* normal completion */
+		vpu_start_tx(port);
+		break;
+
+	case -ESHUTDOWN:
+		/* disconnect */
+		pr_vdebug("%s: %s shutdown\n", __func__, ep->name);
+		break;
+	}
+
+	spin_unlock(&port->port_lock);
+}
+
+static void vpu_free_requests(struct usb_ep *ep, struct list_head *head,
+							 int *allocated)
+{
+	struct usb_request	*req;
+	while (!list_empty(head)) {
+		req = list_entry(head->next, struct usb_request, list);
+		list_del(&req->list);
+		vpu_free_req(ep, req);
+		if (allocated)
+			(*allocated)--;
+	}
+}
+
+int vpu_alloc_requests(struct usb_ep *ep, struct list_head *head,
+		void (*fn)(struct usb_ep *, struct usb_request *),
+		int *allocated)
+{
+	int			i;
+	struct usb_request	*req;
+	int n = allocated ? QUEUE_SIZE - *allocated : QUEUE_SIZE;
+	/* Pre-allocate up to QUEUE_SIZE transfers, but if we can't
+	 * do quite that many this time, don't fail ... we just won't
+	 * be as speedy as we might otherwise be.
+	 */
+	for (i = 0; i < n; i++) {
+		req = vpu_alloc_req(ep, ep->maxpacket, GFP_ATOMIC);
+		if (!req)
+			return list_empty(head) ? -ENOMEM : 0;
+		req->complete = fn;
+		list_add_tail(&req->list, head);
+		if (allocated)
+			(*allocated)++;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(vpu_alloc_requests);
+/**
+ * vpu_start_io - start USB I/O streams
+ * @dev: encapsulates endpoints to use
+ * Context: holding port_lock; port_tty and port_usb are non-null
+ *
+ * We only start I/O when something is connected to both sides of
+ * this port.  If nothing is listening on the host side, we may
+ * be pointlessly filling up our TX buffers and FIFO.
+ */
+int vpu_start_io(struct gs_port *port)
+{
+	struct list_head	*head = &port->read_req;
+	struct usb_ep		*ep = port->port_usb->out;
+	int			status;
+	unsigned		started;
+
+	/* Allocate RX and TX I/O buffers.  We can't easily do this much
+	 * earlier (with GFP_KERNEL) because the requests are coupled to
+	 * endpoints, as are the packet sizes we'll be using.  Different
+	 * configurations may use different endpoints with a given port;
+	 * and high speed vs full speed changes packet sizes too.
+	 */
+	status = vpu_alloc_requests(ep, head, vpu_read_complete,
+		&port->read_allocated);
+	if (status)
+		return status;
+
+	status = vpu_alloc_requests(port->port_usb->in, &port->write_pool,
+			vpu_write_complete, &port->write_allocated);
+	if (status) {
+		vpu_free_requests(ep, head, &port->read_allocated);
+		return status;
+	}
+
+	/* queue read requests */
+	port->n_read = 0;
+	started = vpu_start_rx(port);
+
+	/* unblock any pending writes into our circular buffer */
+	if (started) {
+		//tty_wakeup(port->port.tty);
+	} else {
+		vpu_free_requests(ep, head, &port->read_allocated);
+		vpu_free_requests(port->port_usb->in, &port->write_pool,
+			&port->write_allocated);
+		status = -EIO;
+	}
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(vpu_start_io);
+
+/*-------------------------------------------------------------------------*/
+
+/* TTY Driver */
+
+/*
+ * vpu_open sets up the link between a vpu_port and its associated TTY.
+ * That link is broken *only* by TTY close(), and all driver methods
+ * know that.
+ */
+static int vpu_open(struct tty_struct *tty, struct file *file)
+{
+	int		port_num = tty->index;
+	struct gs_port	*port;
+	int		status;
+
+	do {
+		mutex_lock(&ports[port_num].lock);
+		port = ports[port_num].port;
+		if (!port)
+			status = -ENODEV;
+		else {
+			spin_lock_irq(&port->port_lock);
+
+			/* already open?  Great. */
+			if (port->port.count) {
+				status = 0;
+				port->port.count++;
+
+			/* currently opening/closing? wait ... */
+			} else if (port->openclose) {
+				status = -EBUSY;
+
+			/* ... else we do the work */
+			} else {
+				status = -EAGAIN;
+				port->openclose = true;
+			}
+			spin_unlock_irq(&port->port_lock);
+		}
+		mutex_unlock(&ports[port_num].lock);
+
+		switch (status) {
+		default:
+			/* fully handled */
+			return status;
+		case -EAGAIN:
+			/* must do the work */
+			break;
+		case -EBUSY:
+			/* wait for EAGAIN task to finish */
+			msleep(1);
+			/* REVISIT could have a waitchannel here, if
+			 * concurrent open performance is important
+			 */
+			break;
+		}
+	} while (status != -EAGAIN);
+
+	/* Do the "real open" */
+	spin_lock_irq(&port->port_lock);
+
+	/* allocate circular buffer on first open */
+	if (!kfifo_initialized(&port->port_write_buf)) {
+
+		spin_unlock_irq(&port->port_lock);
+		status = kfifo_alloc(&port->port_write_buf,
+				     WRITE_BUF_SIZE, GFP_KERNEL);
+		spin_lock_irq(&port->port_lock);
+
+		if (status) {
+			port->openclose = false;
+			goto exit_unlock_port;
+		}
+	}
+
+	/* REVISIT if REMOVED (ports[].port NULL), abort the open
+	 * to let rmmod work faster (but this way isn't wrong).
+	 */
+
+	/* REVISIT maybe wait for "carrier detect" */
+
+	tty->driver_data = port;
+	port->port.tty = tty;
+
+	port->port.count = 1;
+	port->openclose = false;
+
+	/* if connected, start the I/O stream */
+	if (port->port_usb) {
+		struct gserial	*gser = port->port_usb;
+
+		pr_debug("vpu_open: start ttyGS%d\n", port->port_num);
+		vpu_start_io(port);
+
+		if (gser->connect)
+			gser->connect(gser);
+	}
+
+	status = 0;
+
+
+exit_unlock_port:
+	spin_unlock_irq(&port->port_lock);
+	return status;
+}
+
+static int vpu_writes_finished(struct gs_port *p)
+{
+	int cond;
+
+	/* return true on disconnect or empty buffer */
+	spin_lock_irq(&p->port_lock);
+	cond = (p->port_usb == NULL) || !kfifo_len(&p->port_write_buf);
+	spin_unlock_irq(&p->port_lock);
+
+	return cond;
+}
+
+
+static void vpu_close(struct tty_struct *tty, struct file *file)
+{
+	struct gs_port *port = tty->driver_data;
+	struct gserial	*gser;
+	spin_lock_irq(&port->port_lock);
+
+	if (port->port.count != 1) {
+		if (port->port.count == 0)
+			WARN_ON(1);
+		else
+			--port->port.count;
+		goto exit;
+	}
+
+	pr_debug("vpu_close: ttyGS%d (%p,%p) ...\n", port->port_num, tty, file);
+
+	/* mark port as closing but in use; we can drop port lock
+	 * and sleep if necessary
+	 */
+	port->openclose = true;
+	port->port.count = 0;
+
+	gser = port->port_usb;
+	if (gser && gser->disconnect)
+		gser->disconnect(gser);
+
+	/* wait for circular write buffer to drain, disconnect, or at
+	 * most GS_CLOSE_TIMEOUT seconds; then discard the rest
+	 */
+	if (kfifo_len(&port->port_write_buf) > 0 && gser) {
+
+		spin_unlock_irq(&port->port_lock);
+		wait_event_interruptible_timeout(port->drain_wait,
+					vpu_writes_finished(port),
+					GS_CLOSE_TIMEOUT * HZ);
+		spin_lock_irq(&port->port_lock);
+		gser = port->port_usb;
+	}
+
+	/* Iff we're disconnected, there can be no I/O in flight so it's
+	 * ok to free the circular buffer; else just scrub it.  And don't
+	 * let the push tasklet fire again until we're re-opened.
+	 */
+	if (gser == NULL)
+		kfifo_free(&port->port_write_buf);
+	else
+		kfifo_reset(&port->port_write_buf);
+
+	port->port.tty = NULL;
+
+	port->openclose = false;
+
+	pr_debug("vpu_close: ttyGS%d (%p,%p) done!\n",
+			port->port_num, tty, file);
+
+	wake_up(&port->close_wait);
+exit:
+	spin_unlock_irq(&port->port_lock);
+}
+
+static int vpu_write(struct tty_struct *tty, const unsigned char *buf, int count)
+{
+	struct gs_port	*port = tty->driver_data;
+	unsigned long	flags;
+	pr_vdebug("vpu_write: ttyGS%d (%p) writing %d bytes\n",
+			port->port_num, tty, count);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+	/* treat count == 0 as flush_chars() */
+	if (port->port_usb)
+		vpu_start_tx(port);
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	return count;
+}
+
+static int vpu_put_char(struct tty_struct *tty, unsigned char ch)
+{
+	struct gs_port	*port = tty->driver_data;
+	unsigned long	flags;
+	int		status;
+
+	pr_vdebug("vpu_put_char: (%d,%p) char=0x%x, called from %ps\n",
+		port->port_num, tty, ch, __builtin_return_address(0));
+
+	spin_lock_irqsave(&port->port_lock, flags);
+	status = kfifo_put(&port->port_write_buf, ch);
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	return status;
+}
+
+static void vpu_flush_chars(struct tty_struct *tty)
+{
+	struct gs_port	*port = tty->driver_data;
+	unsigned long	flags;
+	pr_vdebug("vpu_flush_chars: (%d,%p)\n", port->port_num, tty);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+	if (port->port_usb)
+		vpu_start_tx(port);
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+}
+
+static unsigned int vpu_write_room(struct tty_struct *tty)
+{
+	struct gs_port	*port = tty->driver_data;
+	unsigned long	flags;
+	int		room = 0;
+
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	pr_vdebug("vpu_write_room: (%d,%p) room=%d\n",
+		port->port_num, tty, room);
+
+	return room;
+}
+
+int vpu_write1 (const char *buf, size_t *size, unsigned int timeout_ms)
+{
+	struct gs_port *port = NULL;
+	int len = *size;
+	int status;
+	unsigned actual_write = 0;
+	long jiffies_passed = 0;
+	long jiffies_timeout = (long)msecs_to_jiffies(timeout_ms);
+	unsigned long	flags;
+	int room = 0;
+	struct list_head *pool = NULL;
+	struct usb_ep *in;
+	bool do_tty_wake = false;
+	int ret = 0;
+
+	port = ports[PORT_NUM].port;
+	pool = &port->write_pool;
+	*size = 0;
+	if (len == 0)
+		return -EINVAL;
+
+	ret = wait_event_interruptible_timeout(port->drain_wait,
+					vpu_writes_finished(port),
+					jiffies_timeout - jiffies_passed);
+	if (ret == 0)
+		return -ETIME;
+
+	do {
+		mutex_lock(&ports[PORT_NUM].lock);
+		port = ports[PORT_NUM].port;
+		if (!port)
+			status = -ENODEV;
+		else {
+			spin_lock_irq(&port->port_lock);
+
+			/* currently opening/closing? wait ... */
+			if (port->openclose) {
+				status = -EBUSY;
+
+			/* ... else we do the work */
+			} else {
+				status = -EAGAIN;
+				port->openclose = true;
+			}
+			spin_unlock_irq(&port->port_lock);
+		}
+		mutex_unlock(&ports[PORT_NUM].lock);
+
+		switch (status) {
+		default:
+			/* fully handled */
+		case -EAGAIN:
+			/* must do the work */
+			break;
+		case -EBUSY:
+			/* wait for EAGAIN task to finish */
+			msleep(1);
+			/* REVISIT could have a waitchannel here, if
+			 * concurrent open performance is important
+			 */
+			break;
+		}
+	} while (status != -EAGAIN);
+
+	/* Do the "real open" */
+	// spin_lock_irq(&port->port_lock);
+	// kfifo_initialized(&port->port_write_buf);
+	// spin_unlock_irq(&port->port_lock);
+	status = kfifo_alloc(&port->port_write_buf,
+		WRITE_BUF_SIZE, GFP_KERNEL);
+
+	spin_lock_irq(&port->port_lock);
+	/* allocate circular buffer on first open */
+	if (!kfifo_initialized(&port->port_write_buf)) {
+
+		spin_unlock_irq(&port->port_lock);
+		status = kfifo_alloc(&port->port_write_buf,
+			WRITE_BUF_SIZE, GFP_KERNEL);
+		spin_lock_irq(&port->port_lock);
+
+		port->openclose = false;
+		goto exit_unlock_port;
+	}
+
+	/* if connected, start the I/O stream */
+	if (port->port_usb) {
+		struct gserial	*gser = port->port_usb;
+
+		vpu_start_io(port);
+
+		if (gser->connect)
+			gser->connect(gser);
+	}
+
+	status = 0;
+	spin_unlock_irq(&port->port_lock);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+	if (port->port_usb)
+		room = kfifo_avail(&port->port_write_buf);
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+	kfifo_in(&port->port_write_buf, buf, len);
+	/* treat count == 0 as flush_chars() */
+	spin_unlock_irqrestore(&port->port_lock, flags);
+	spin_lock_irq(&port->port_lock);
+
+	status = 0;
+
+	if (!port->port_usb)
+		return -EINTR;
+
+	in = port->port_usb->in;
+
+	while (!port->write_busy && !list_empty(pool)) {
+		struct usb_request	*req;
+//		int			len;
+
+		if (port->write_started >= QUEUE_SIZE)
+			break;
+		req = list_entry(pool->next, struct usb_request, list);
+
+		len = vpu_send_packet(port, req->buf, in->maxpacket);
+
+		if (len == 0) {
+			wake_up_interruptible(&port->drain_wait);
+			break;
+		}
+		do_tty_wake = true;
+
+		req->length = len;
+		list_del(&req->list);
+		req->zero = kfifo_is_empty(&port->port_write_buf);
+
+		/* Drop lock while we call out of driver; completions
+		 * could be issued while we do so.  Disconnection may
+		 * happen too; maybe immediately before we queue this!
+		 *
+		 * NOTE that we may keep sending data for a while after
+		 * the TTY closed (dev->ioport->port_tty is NULL).
+		 */
+		port->write_busy = true;
+		spin_unlock(&port->port_lock);
+		status = usb_ep_queue(in, req, GFP_ATOMIC);
+		spin_lock(&port->port_lock);
+		port->write_busy = false;
+
+		if (status) {
+			list_add(&req->list, pool);
+			break;
+		}
+		actual_write += len;
+		port->write_started++;
+
+		/* abort immediately after disconnect */
+		if (!port->port_usb)
+			break;
+	}
+
+
+	if (port->port_usb)
+		vpu_start_tx(port);
+
+exit_unlock_port:
+	spin_unlock_irq(&port->port_lock);
+	*size = actual_write;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(vpu_write1);
+
+int vpu_close1 (void)
+{
+	struct gs_port *port;
+	struct gserial	*gser;
+
+	port = ports[PORT_NUM].port;
+	spin_lock_irq(&port->port_lock);
+
+	/* mark port as closing but in use; we can drop port lock
+	 * and sleep if necessary
+	 */
+	port->openclose = true;
+
+	gser = port->port_usb;
+	if (gser && gser->disconnect)
+		gser->disconnect(gser);
+
+	/* wait for circular write buffer to drain, disconnect, or at
+	 * most GS_CLOSE_TIMEOUT seconds; then discard the rest
+	 */
+	if (kfifo_len(&port->port_write_buf) > 0 && gser) {
+		spin_unlock_irq(&port->port_lock);
+		wait_event_interruptible_timeout(port->drain_wait,
+					vpu_writes_finished(port),
+					GS_CLOSE_TIMEOUT * HZ);
+		spin_lock_irq(&port->port_lock);
+		gser = port->port_usb;
+	}
+
+	/* Iff we're disconnected, there can be no I/O in flight so it's
+
+	 * ok to free the circular buffer; else just scrub it.  And don't
+	 * let the push tasklet fire again until we're re-opened.
+	 */
+	if (gser == NULL) {
+		kfifo_free(&port->port_write_buf);
+	} else {
+		kfifo_reset(&port->port_write_buf);
+	}
+
+	port->openclose = false;
+
+	spin_unlock_irq(&port->port_lock);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(vpu_close1);
+
+int vpu_read (void *data, size_t *size, unsigned int timeout_ms)
+{
+	struct gs_port *port;
+
+	size_t len = *size;
+	size_t remaining = len;
+	int ret = 0;
+	long jiffies_passed = 0;
+	long jiffies_timeout = (long)msecs_to_jiffies(timeout_ms);
+	unsigned long jiffies_start = jiffies;
+	struct list_head *pool = NULL;
+	struct usb_request	*req;
+
+	*size = 0;
+	if (len == 0)
+		return -EINVAL;
+	port = ports[PORT_NUM].port;
+	ret = wait_event_interruptible_timeout(port->drain_wait,
+					vpu_writes_finished(port),
+					jiffies_timeout - jiffies_passed);
+	if (ret == 0)
+		return -ETIME;
+
+	pool = &port->read_pool;
+
+	if (list_empty(pool))
+		return -ENODATA;
+
+	spin_lock_irq(&port->port_lock);
+
+	do {
+		size_t bcopy;
+
+		req = list_first_entry(pool, struct usb_request, list);
+		bcopy = min(remaining, (size_t)req->actual);
+		memcpy(data, req->buf, bcopy);
+		data += bcopy;
+		remaining -= bcopy;
+		list_move_tail(&req->list, &port->read_req);
+
+		jiffies_passed = (long)jiffies - (long)jiffies_start;
+	}	while (!list_empty(pool) && remaining > 0 && (jiffies_passed < jiffies_timeout ||
+			timeout_ms == 0));
+
+	spin_unlock_irq(&port->port_lock);
+	*size = len - remaining;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(vpu_read);
+
+int *vpu_read_swid(void)
+{
+	struct gs_port *port;
+	struct list_head *pool = NULL;
+	int *BUF4 = NULL;
+	struct usb_request *req;
+
+	port = ports[PORT_NUM].port;
+	pool = &port->read_pool;
+	while (!list_empty(pool)) {
+		req = list_entry(pool->next, struct usb_request, list);
+		list_del(&req->list);
+		BUF4 = req->buf;
+		break;
+	}
+	return BUF4;
+}
+EXPORT_SYMBOL_GPL(vpu_read_swid);
+
+static unsigned int vpu_chars_in_buffer(struct tty_struct *tty)
+{
+	struct gs_port	*port = tty->driver_data;
+	unsigned long	flags;
+	int		chars = 0;
+
+	spin_lock_irqsave(&port->port_lock, flags);
+	chars = kfifo_len(&port->port_write_buf);
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	pr_vdebug("gs_chars_in_buffer: (%d,%p) chars=%d\n",
+		port->port_num, tty, chars);
+
+	return chars;
+}
+
+/* undo side effects of setting TTY_THROTTLED */
+static void vpu_unthrottle(struct tty_struct *tty)
+{
+	struct gs_port		*port = tty->driver_data;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&port->port_lock, flags);
+	if (port->port_usb) {
+		/* Kickstart read queue processing.  We don't do xon/xoff,
+		 * rts/cts, or other handshaking with the host, but if the
+		 * read queue backs up enough we'll be NAKing OUT packets.
+		 */
+		pr_vdebug("ttyGS%d: unthrottle\n", port->port_num);
+		schedule_delayed_work(&port->push, 0);
+	}
+	spin_unlock_irqrestore(&port->port_lock, flags);
+}
+
+static int vpu_break_ctl(struct tty_struct *tty, int duration)
+{
+	struct gs_port	*port = tty->driver_data;
+	int		status = 0;
+	struct gserial	*gser;
+
+	pr_vdebug("vpu_break_ctl: ttyGS%d, send break (%d) \n",
+			port->port_num, duration);
+
+	spin_lock_irq(&port->port_lock);
+	gser = port->port_usb;
+	if (gser && gser->send_break)
+		status = gser->send_break(gser, duration);
+	spin_unlock_irq(&port->port_lock);
+
+	return status;
+}
+
+static const struct tty_operations vpu_tty_ops = {
+	.open =			vpu_open,
+	.close =		vpu_close,
+	.write =		vpu_write,
+	.put_char =		vpu_put_char,
+	.flush_chars =		vpu_flush_chars,
+	.write_room =		vpu_write_room,
+	.chars_in_buffer =	vpu_chars_in_buffer,
+	.unthrottle =		vpu_unthrottle,
+	.break_ctl =		vpu_break_ctl,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static struct tty_driver *vpu_tty_driver;
+
+int
+vpu_port_alloc(unsigned port_num, struct usb_cdc_line_coding *coding)
+{
+	struct gs_port	*port;
+	int		ret = 0;
+
+	mutex_lock(&ports[port_num].lock);
+	if (ports[port_num].port) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	port = kzalloc(sizeof(struct gs_port), GFP_KERNEL);
+	if (port == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	tty_port_init(&port->port);
+	spin_lock_init(&port->port_lock);
+	init_waitqueue_head(&port->drain_wait);
+	init_waitqueue_head(&port->close_wait);
+
+	INIT_DELAYED_WORK(&port->push, vpu_rx_push);
+
+	INIT_LIST_HEAD(&port->read_pool);
+	INIT_LIST_HEAD(&port->read_queue);
+	INIT_LIST_HEAD(&port->read_req);
+	INIT_LIST_HEAD(&port->write_pool);
+
+	port->port_num = port_num;
+	port->port_line_coding = *coding;
+
+	ports[port_num].port = port;
+out:
+	mutex_unlock(&ports[port_num].lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(vpu_port_alloc);
+
+static int vpu_closed(struct gs_port *port)
+{
+	int cond;
+
+	spin_lock_irq(&port->port_lock);
+	cond = (port->port.count == 0) && !port->openclose;
+	spin_unlock_irq(&port->port_lock);
+
+	return cond;
+}
+
+static void vpu_free_port(struct gs_port *port)
+{
+	cancel_delayed_work_sync(&port->push);
+
+	/* wait for old opens to finish */
+	wait_event(port->close_wait, vpu_closed(port));
+	WARN_ON(port->port_usb != NULL);
+	tty_port_destroy(&port->port);
+	kfree(port);
+}
+
+void vpu_free_line(unsigned char port_num)
+{
+	struct gs_port	*port;
+
+	mutex_lock(&ports[port_num].lock);
+	if (WARN_ON(!ports[port_num].port)) {
+		mutex_unlock(&ports[port_num].lock);
+		return;
+	}
+	port = ports[port_num].port;
+	ports[port_num].port = NULL;
+	mutex_unlock(&ports[port_num].lock);
+
+	vpu_free_port(port);
+	tty_unregister_device(vpu_tty_driver, port_num);
+
+}
+EXPORT_SYMBOL_GPL(vpu_free_line);
+
+int vpu_alloc_line(unsigned char *line_num)
+{
+	struct usb_cdc_line_coding	coding;
+	struct device			*tty_dev;
+	int				ret;
+	int				port_num;
+
+	coding.dwDTERate = cpu_to_le32(9600);
+	coding.bCharFormat = 8;
+	coding.bParityType = USB_CDC_NO_PARITY;
+	coding.bDataBits = USB_CDC_1_STOP_BITS;
+
+	for (port_num = 0; port_num < MAX_U_SERIAL_PORTS; port_num++) {
+		ret = vpu_port_alloc(port_num, &coding);
+		if (ret == -EBUSY)
+			continue;
+		if (ret)
+			return ret;
+		break;
+	}
+	if (ret)
+		return ret;
+
+	/* ... and sysfs class devices, so mdev/udev make /dev/ttyGS* */
+
+	tty_dev = tty_port_register_device(&ports[port_num].port->port,
+			vpu_tty_driver, port_num, NULL);
+	if (IS_ERR(tty_dev)) {
+		struct gs_port	*port;
+		pr_err("%s: failed to register tty for port %d, err %ld\n",
+				__func__, port_num, PTR_ERR(tty_dev));
+
+		ret = PTR_ERR(tty_dev);
+		port = ports[port_num].port;
+		ports[port_num].port = NULL;
+		vpu_free_port(port);
+		goto err;
+	}
+	*line_num = port_num;
+
+err:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(vpu_alloc_line);
+
+/**
+ * vpu_connect - notify TTY I/O glue that USB link is active
+ * @gser: the function, set up with endpoints and descriptors
+ * @port_num: which port is active
+ * Context: any (usually from irq)
+ *
+ * This is called activate endpoints and let the TTY layer know that
+ * the connection is active ... not unlike "carrier detect".  It won't
+ * necessarily start I/O queues; unless the TTY is held open by any
+ * task, there would be no point.  However, the endpoints will be
+ * activated so the USB host can perform I/O, subject to basic USB
+ * hardware flow control.
+ *
+ * Caller needs to have set up the endpoints and USB function in @dev
+ * before calling this, as well as the appropriate (speed-specific)
+ * endpoint descriptors, and also have allocate @port_num by calling
+ * @vpu_alloc_line().
+ *
+ * Returns negative errno or zero.
+ * On success, ep->driver_data will be overwritten.
+ */
+
+int vpu_connect(struct gserial *gser, u8 port_num)
+{
+	struct gs_port	*port;
+	unsigned long	flags;
+	int		status;
+
+	if (port_num >= MAX_U_SERIAL_PORTS)
+		return -ENXIO;
+
+	PORT_NUM = port_num;
+	port = ports[port_num].port;
+	if (!port) {
+		pr_err("serial line %d not allocated.\n", port_num);
+		return -EINVAL;
+	}
+	if (port->port_usb) {
+		pr_err("serial line %d is in use.\n", port_num);
+		return -EBUSY;
+	}
+
+	/* activate the endpoints */
+	status = usb_ep_enable(gser->in);
+	if (status < 0)
+		return status;
+	gser->in->driver_data = port;
+
+	status = usb_ep_enable(gser->out);
+	if (status < 0)
+		goto fail_out;
+	gser->out->driver_data = port;
+
+	/* then tell the tty glue that I/O can work */
+	spin_lock_irqsave(&port->port_lock, flags);
+	gser->ioport = port;
+	port->port_usb = gser;
+
+	/* REVISIT unclear how best to handle this state...
+	 * we don't really couple it with the Linux TTY.
+	 */
+	gser->port_line_coding = port->port_line_coding;
+
+	vpu_start_io(port);
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	return 0;
+
+fail_out:
+	usb_ep_disable(gser->in);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(vpu_connect);
+
+/**
+ * vpu_disconnect - notify TTY I/O glue that USB link is inactive
+ * @gser: the function, on which vpu_connect() was called
+ * Context: any (usually from irq)
+ *
+ * This is called to deactivate endpoints and let the TTY layer know
+ * that the connection went inactive ... not unlike "hangup".
+ *
+ * On return, the state is as if vpu_connect() had never been called;
+ * there is no active USB I/O on these endpoints.
+ */
+
+void vpu_disconnect(struct gserial *gser)
+{
+	struct gs_port	*port = gser->ioport;
+	unsigned long	flags;
+
+	if (!port)
+		return;
+
+	/* tell the TTY glue not to do I/O here any more */
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	/* REVISIT as above: how best to track this? */
+	port->port_line_coding = gser->port_line_coding;
+
+	port->port_usb = NULL;
+	gser->ioport = NULL;
+	if (port->port.count > 0 || port->openclose) {
+		wake_up_interruptible(&port->drain_wait);
+		if (port->port.tty)
+			tty_hangup(port->port.tty);
+	}
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	/* disable endpoints, aborting down any active I/O */
+	usb_ep_disable(gser->out);
+	usb_ep_disable(gser->in);
+
+	/* finally, free any unused/unusable I/O buffers */
+	spin_lock_irqsave(&port->port_lock, flags);
+	if (port->port.count == 0 && !port->openclose)
+		kfifo_free(&port->port_write_buf);
+	vpu_free_requests(gser->out, &port->read_pool, NULL);
+	vpu_free_requests(gser->out, &port->read_queue, NULL);
+	vpu_free_requests(gser->out, &port->read_req, NULL);
+	vpu_free_requests(gser->in, &port->write_pool, NULL);
+
+	port->read_allocated = port->read_started =
+		port->write_allocated = port->write_started = 0;
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+}
+EXPORT_SYMBOL_GPL(vpu_disconnect);
+
+static int uxlink_init(void)
+{
+	unsigned			i;
+	int				status;
+
+	vpu_tty_driver = tty_alloc_driver(MAX_U_SERIAL_PORTS, TTY_DRIVER_REAL_RAW);
+	if (!vpu_tty_driver)
+		return -ENOMEM;
+
+	vpu_tty_driver->driver_name = "g_serial";
+	vpu_tty_driver->name = "ttyGS";
+	/* uses dynamically assigned dev_t values */
+
+	vpu_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;
+	vpu_tty_driver->subtype = SERIAL_TYPE_NORMAL;
+	vpu_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	vpu_tty_driver->init_termios = tty_std_termios;
+
+	/* 9600-8-N-1 ... matches defaults expected by "usbser.sys" on
+	 * MS-Windows.  Otherwise, most of these flags shouldn't affect
+	 * anything unless we were to actually hook up to a serial line.
+	 */
+	vpu_tty_driver->init_termios.c_cflag =
+			B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	vpu_tty_driver->init_termios.c_ispeed = 9600;
+	vpu_tty_driver->init_termios.c_ospeed = 9600;
+
+	tty_set_operations(vpu_tty_driver, &vpu_tty_ops);
+	for (i = 0; i < MAX_U_SERIAL_PORTS; i++)
+		mutex_init(&ports[i].lock);
+
+	/* export the driver ... */
+	status = tty_register_driver(vpu_tty_driver);
+	if (status) {
+		pr_err("%s: cannot register, err %d\n",
+				__func__, status);
+		goto fail;
+	}
+
+	return status;
+fail:
+	tty_driver_kref_put(vpu_tty_driver);
+	vpu_tty_driver = NULL;
+	return status;
+
+}
+module_init(uxlink_init);
+
+static void uxlink_cleanup(void)
+{
+	tty_unregister_driver(vpu_tty_driver);
+	tty_driver_kref_put(vpu_tty_driver);
+	vpu_tty_driver = NULL;
+
+}
+module_exit(uxlink_cleanup);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/xlink-usb/local_host/u_xlink.h b/drivers/misc/xlink-usb/local_host/u_xlink.h
new file mode 100644
index 000000000000..e2deeaf22be7
--- /dev/null
+++ b/drivers/misc/xlink-usb/local_host/u_xlink.h
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * u_xlink.h - interface to USB gadget "serial port"/TTY utilities
+ *
+ * Copyright (C) 2008 David Brownell
+ * Copyright (C) 2008 by Nokia Corporation
+ */
+
+#ifndef __U_SERIAL_H
+#define __U_SERIAL_H
+
+#include <linux/usb/composite.h>
+#include <linux/usb/cdc.h>
+
+#define MAX_U_SERIAL_PORTS	4
+
+struct f_serial_opts {
+	struct usb_function_instance func_inst;
+	u8 port_num;
+};
+
+/*
+ * One non-multiplexed "serial" I/O port ... there can be several of these
+ * on any given USB peripheral device, if it provides enough endpoints.
+ *
+ * The "u_serial" utility component exists to do one thing:  manage TTY
+ * style I/O using the USB peripheral endpoints listed here, including
+ * hookups to sysfs and /dev for each logical "tty" device.
+ *
+ * REVISIT at least ACM could support tiocmget() if needed.
+ *
+ * REVISIT someday, allow multiplexing several TTYs over these endpoints.
+ */
+struct gserial {
+	struct usb_function		func;
+
+	/* port is managed by gserial_{connect,disconnect} */
+	struct gs_port			*ioport;
+
+	struct usb_ep			*in;
+	struct usb_ep			*out;
+
+	/* REVISIT avoid this CDC-ACM support harder ... */
+	struct usb_cdc_line_coding port_line_coding;	/* 9600-8-N-1 etc */
+
+	/* notification callbacks */
+	void (*connect)(struct gserial *p);
+	void (*disconnect)(struct gserial *p);
+	int (*send_break)(struct gserial *p, int duration);
+};
+
+/* utilities to allocate/free request and buffer */
+struct usb_request *vpu_alloc_req(struct usb_ep *ep, unsigned len, gfp_t flags);
+void vpu_free_req(struct usb_ep *, struct usb_request *req);
+void vpu_read_complete(struct usb_ep *ep, struct usb_request *req);
+unsigned vpu_start_rx(struct gs_port *port);
+int vpu_alloc_requests(struct usb_ep *ep, struct list_head *head,
+		void (*fn)(struct usb_ep *, struct usb_request *),
+		int *allocated);
+int vpu_port_alloc(unsigned port_num, struct usb_cdc_line_coding *coding);
+//int vpu_open(struct tty_struct *tty, struct file *file);
+/* management of individual TTY ports */
+int vpu_alloc_line(unsigned char *port_line);
+void vpu_free_line(unsigned char port_line);
+
+/* connect/disconnect is handled by individual functions */
+int vpu_connect(struct gserial *, u8 port_num);
+void vpu_disconnect(struct gserial *);
+int vpu_start_io(struct gs_port *);
+
+int vpu_read (void *data, size_t *size, unsigned int timeout_ms);
+int *vpu_read_swid(void);
+int vpu_write1 (const char *buf, size_t *size, unsigned int timeout_ms);
+int vpu_close1 (void);
+int usb_sw_id (int pid);
+int usb_get_by_id (uint32_t sw_device_id);
+
+/* functions are bound to configurations by a config or gadget driver */
+int gser_bind_config(struct usb_configuration *c, u8 port_num);
+int obex_bind_config(struct usb_configuration *c, u8 port_num);
+
+#endif /* __U_SERIAL_H */
diff --git a/drivers/misc/xlink-usb/remote_host/Makefile b/drivers/misc/xlink-usb/remote_host/Makefile
new file mode 100644
index 000000000000..171cc612ce65
--- /dev/null
+++ b/drivers/misc/xlink-usb/remote_host/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for VPU USB Class drivers
+#
+
+obj-$(CONFIG_XLINK_USB_RH_DRIVER)		+= vpu_usb.o
+vpu_usb-objs			:= vpu-cdc-acm.o
+vpu_usb-objs			+= mxlk_interface_host.o
diff --git a/drivers/misc/xlink-usb/remote_host/mxlk_interface_host.c b/drivers/misc/xlink-usb/remote_host/mxlk_interface_host.c
new file mode 100644
index 000000000000..83528f79c6bd
--- /dev/null
+++ b/drivers/misc/xlink-usb/remote_host/mxlk_interface_host.c
@@ -0,0 +1,90 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Intel Keem Bay XLink VPU USB host Driver
+ *
+ * Copyright (C) 2019 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2, as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include "vpu-cdc-acm.h"
+#include <linux/xlink_drv_inf.h>
+
+int xlink_usb_read(uint32_t sw_device_id, void *data, size_t *const size,
+		    uint32_t timeout)
+{
+	return vpu_read_host(sw_device_id, data, size, timeout);
+}
+EXPORT_SYMBOL(xlink_usb_read);
+
+int xlink_usb_write(uint32_t sw_device_id, void *data, size_t *const size,
+		     uint32_t timeout)
+{
+	int rc;
+	rc = vpu_write_host(sw_device_id, data, size, timeout);
+	if (rc < 0)
+		return rc;
+	return vpu_close_host(sw_device_id);
+}
+EXPORT_SYMBOL(xlink_usb_write);
+
+int xlink_usb_get_device_list(uint32_t *sw_device_id_list,
+			       uint32_t *num_devices)
+{
+	*num_devices = usb_get_device_num(sw_device_id_list);
+	return 0;
+}
+EXPORT_SYMBOL(xlink_usb_get_device_list);
+
+int xlink_usb_get_device_name(uint32_t sw_device_id, char *device_name,
+			       size_t name_size)
+{
+	return usb_get_device_name_by_id(sw_device_id, device_name, name_size);
+}
+EXPORT_SYMBOL(xlink_usb_get_device_name);
+
+int xlink_usb_get_device_status(uint32_t sw_device_id,
+				 uint32_t *device_status)
+{
+	usb_get_device_status_by_id(sw_device_id, device_status);
+	return 0;
+}
+EXPORT_SYMBOL(xlink_usb_get_device_status);
+
+int xlink_usb_boot_device(uint32_t sw_device_id, const char *binary_name)
+{
+	return 0;
+}
+EXPORT_SYMBOL(xlink_usb_boot_device);
+
+int xlink_usb_connect(uint32_t sw_device_id)
+{
+	return usb_connect_device(sw_device_id);
+}
+EXPORT_SYMBOL(xlink_usb_connect);
+
+int xlink_usb_reset_device(uint32_t sw_device_id)
+{
+	int rc;
+
+	rc = vpu_write_reset_host(sw_device_id);
+	if (rc != 0)
+		return rc;
+	rc = vpu_close_reset_host(sw_device_id);
+	if (rc != 0)
+		return rc;
+	return usb_device_reset(sw_device_id);
+}
+EXPORT_SYMBOL(xlink_usb_reset_device);
diff --git a/drivers/misc/xlink-usb/remote_host/vpu-cdc-acm.c b/drivers/misc/xlink-usb/remote_host/vpu-cdc-acm.c
new file mode 100644
index 000000000000..a4def2a2224b
--- /dev/null
+++ b/drivers/misc/xlink-usb/remote_host/vpu-cdc-acm.c
@@ -0,0 +1,1974 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * vpu-cdc-acm.c - XLink USB Remote Host driver
+ *
+ * Copyright (C) 2019 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2, as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#undef DEBUG
+#undef VERBOSE_DEBUG
+
+#include <linux/kernel.h>
+#include <linux/sched/signal.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/log2.h>
+#include <linux/serial.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/uaccess.h>
+#include <linux/usb.h>
+#include <linux/usb/cdc.h>
+#include <asm/byteorder.h>
+#include <asm/unaligned.h>
+#include <linux/idr.h>
+#include <linux/list.h>
+#include <linux/completion.h>
+
+#include "vpu-cdc-acm.h"
+#include <linux/xlink_drv_inf.h>
+
+#define DRIVER_AUTHOR "Tan Seng Kai, Lai Jun Ann"
+#define DRIVER_DESC "XLink USB Remote Host driver"
+
+static struct usb_driver vpu_acm_driver;
+
+static DEFINE_IDR(vpu_acm_minors);
+static DEFINE_MUTEX(vpu_acm_minors_lock);
+#define MXLK_MAX_NAME_LEN (32)
+static LIST_HEAD(dev_list);
+static DEFINE_MUTEX(dev_list_mutex);
+
+struct acm {
+	struct usb_device *dev;				/* the corresponding usb device */
+	struct usb_interface *control;			/* control interface */
+	struct usb_interface *data;			/* data interface */
+	unsigned in, out;				/* i/o pipes */
+	struct urb *ctrlurb;				/* urbs */
+	u8 *ctrl_buffer;				/* buffers of urbs */
+	dma_addr_t ctrl_dma;				/* dma handles of buffers */
+	u8 *country_codes;				/* country codes from device */
+	unsigned int country_code_size;			/* size of this buffer */
+	unsigned int country_rel_date;			/* release date of version */
+	struct acm_wb wb[ACM_NW];
+	unsigned long read_urbs_free;
+	struct urb *read_urbs[ACM_NR];
+	struct acm_rb read_buffers[ACM_NR];
+	int rx_buflimit;
+	spinlock_t read_lock;
+	u8 *notification_buffer;			/* to reassemble fragmented notifications */
+	unsigned int nb_index;
+	unsigned int nb_size;
+	int transmitting;
+	spinlock_t write_lock;
+	struct mutex mutex;
+	bool disconnected;
+	unsigned long flags;
+#		define EVENT_TTY_WAKEUP	0
+#		define EVENT_RX_STALL	1
+#		define ACM_THROTTLED	2
+	struct usb_cdc_line_coding line;		/* bits, stop, parity */
+	struct work_struct work;			/* work queue entry for line discipline waking up */
+	unsigned int ctrlin;				/* input control lines (DCD, DSR, RI, break, overruns) */
+	unsigned int ctrlout;				/* output control lines (DTR, RTS) */
+	struct async_icount iocount;			/* counters for control line changes */
+	struct async_icount oldcount;			/* for comparison of counter */
+	wait_queue_head_t wioctl;			/* for ioctl */
+	unsigned int writesize;				/* max packet size for the output bulk endpoint */
+	unsigned int readsize, ctrlsize;			/* buffer sizes for freeing */
+	unsigned int minor;				/* acm minor number */
+	unsigned char clocal;				/* termios CLOCAL */
+	unsigned int ctrl_caps;				/* control capabilities from the class specific header */
+	unsigned int susp_count;			/* number of suspended interfaces */
+	unsigned int combined_interfaces:1;		/* control and data collapsed */
+	u8 bInterval;
+	struct usb_anchor delayed;			/* writes queued for a device about to be woken */
+	unsigned long quirks;
+	char name[MXLK_MAX_NAME_LEN];
+	u32 devid;
+	struct list_head list;
+	u32 status;
+	const char *buf;
+};
+/*
+ * vpu_acm_minors accessors
+ */
+
+/*
+ * Look up an ACM structure by minor. If found and not disconnected, increment
+ * its refcount and return it with its mutex held.
+ */
+static struct acm *vpu_acm_get_by_minor(unsigned int minor)
+{
+	struct acm *acm;
+	mutex_lock(&vpu_acm_minors_lock);
+	acm = idr_find(&vpu_acm_minors, minor);
+	if (acm) {
+		mutex_lock(&acm->mutex);
+		if (acm->disconnected) {
+			mutex_unlock(&acm->mutex);
+		} else {
+			mutex_unlock(&acm->mutex);
+		}
+	}
+	mutex_unlock(&vpu_acm_minors_lock);
+	return acm;
+}
+
+/*
+ * Try to find an available minor number and if found, associate it with 'acm'.
+ */
+static int vpu_acm_alloc_minor(struct acm *acm)
+{
+	int minor;
+	mutex_lock(&vpu_acm_minors_lock);
+	minor = idr_alloc(&vpu_acm_minors, acm, 0, ACM_TTY_MINORS, GFP_KERNEL);
+	mutex_unlock(&vpu_acm_minors_lock);
+
+	return minor;
+}
+
+/*
+ * Functions for ACM control messages.
+ */
+
+static int vpu_acm_ctrl_msg(struct acm *acm, int request, int value,
+							void *buf, int len)
+{
+	int retval;
+	retval = usb_autopm_get_interface(acm->control);
+	if (retval)
+		return retval;
+
+	retval = usb_control_msg(acm->dev, usb_sndctrlpipe(acm->dev, 0),
+		request, USB_RT_ACM, value,
+		acm->control->altsetting[0].desc.bInterfaceNumber,
+		buf, len, 5000);
+
+	usb_autopm_put_interface(acm->control);
+
+	return retval < 0 ? retval : 0;
+}
+
+/* devices aren't required to support these requests.
+ * the cdc acm descriptor tells whether they do...
+ */
+static inline int vpu_acm_set_control(struct acm *acm, int control)
+{
+	if (acm->quirks & QUIRK_CONTROL_LINE_STATE)
+		return -EOPNOTSUPP;
+
+	return vpu_acm_ctrl_msg(acm, USB_CDC_REQ_SET_CONTROL_LINE_STATE,
+			control, NULL, 0);
+}
+
+#define vpu_acm_set_line(acm, line) \
+	vpu_acm_ctrl_msg(acm, USB_CDC_REQ_SET_LINE_CODING, 0, line, sizeof *(line))
+#define vpu_acm_send_break(acm, ms) \
+	vpu_acm_ctrl_msg(acm, USB_CDC_REQ_SEND_BREAK, ms, NULL, 0)
+
+static void vpu_acm_kill_urbs(struct acm *acm)
+{
+	int i;
+	usb_kill_urb(acm->ctrlurb);
+	for (i = 0; i < ACM_NW; i++)
+		usb_kill_urb(acm->wb[i].urb);
+	for (i = 0; i < acm->rx_buflimit; i++)
+		usb_kill_urb(acm->read_urbs[i]);
+}
+
+/*
+ * Write buffer management.
+ * All of these assume proper locks taken by the caller.
+ */
+
+static int vpu_acm_wb_alloc(struct acm *acm)
+{
+	int i, wbn;
+	struct acm_wb *wb;
+	wbn = 0;
+	i = 0;
+	for (;;) {
+		wb = &acm->wb[wbn];
+		if (!wb->use) {
+			wb->use = 1;
+			wb->len = 0;
+			return wbn;
+		}
+		wbn = (wbn + 1) % ACM_NW;
+		if (++i >= ACM_NW)
+			return -1;
+	}
+}
+
+
+/*
+ * Finish write. Caller must hold acm->write_lock
+ */
+static void vpu_acm_write_done(struct acm *acm, struct acm_wb *wb)
+{
+	wb->use = 0;
+	acm->transmitting--;
+	usb_autopm_put_interface_async(acm->control);
+}
+
+/*
+ * Poke write.
+ *
+ * the caller is responsible for locking
+ */
+
+static int vpu_acm_start_wb(struct acm *acm, struct acm_wb *wb)
+{
+	int rc;
+	acm->transmitting++;
+
+	wb->urb->transfer_buffer = wb->buf;
+	wb->urb->transfer_dma = wb->dmah;
+	wb->urb->transfer_buffer_length = wb->len;
+	wb->urb->dev = acm->dev;
+
+	rc = usb_submit_urb(wb->urb, GFP_ATOMIC);
+	if (rc < 0) {
+		dev_err(&acm->data->dev,
+			"%s - usb_submit_urb(write bulk) failed: %d\n",
+			__func__, rc);
+		vpu_acm_write_done(acm, wb);
+	}
+	return rc;
+}
+
+/*
+ * attributes exported through sysfs
+ */
+static ssize_t bmCapabilities_show
+(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+static DEVICE_ATTR_RO(bmCapabilities);
+
+static ssize_t wCountryCodes_show
+(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct usb_interface *intf = to_usb_interface(dev);
+	struct acm *acm = usb_get_intfdata(intf);
+	memcpy(buf, acm->country_codes, acm->country_code_size);
+	return acm->country_code_size;
+}
+
+static DEVICE_ATTR_RO(wCountryCodes);
+
+static ssize_t iCountryCodeRelDate_show
+(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+
+static DEVICE_ATTR_RO(iCountryCodeRelDate);
+/*
+ * Interrupt handlers for various ACM device responses
+ */
+
+static void vpu_acm_process_notification(struct acm *acm, unsigned char *buf)
+{
+	int newctrl;
+	int difference;
+	unsigned long flags;
+	struct usb_cdc_notification *dr = (struct usb_cdc_notification *)buf;
+	unsigned char *data = buf + sizeof(struct usb_cdc_notification);
+	switch (dr->bNotificationType) {
+	case USB_CDC_NOTIFY_NETWORK_CONNECTION:
+		break;
+
+	case USB_CDC_NOTIFY_SERIAL_STATE:
+		if (le16_to_cpu(dr->wLength) != 2) {
+			break;
+		}
+
+		newctrl = get_unaligned_le16(data);
+
+		difference = acm->ctrlin ^ newctrl;
+		spin_lock_irqsave(&acm->read_lock, flags);
+		acm->ctrlin = newctrl;
+		acm->oldcount = acm->iocount;
+
+		if (difference & ACM_CTRL_DSR)
+			acm->iocount.dsr++;
+		if (difference & ACM_CTRL_DCD)
+			acm->iocount.dcd++;
+		if (newctrl & ACM_CTRL_BRK)
+			acm->iocount.brk++;
+		if (newctrl & ACM_CTRL_RI)
+			acm->iocount.rng++;
+		if (newctrl & ACM_CTRL_FRAMING)
+			acm->iocount.frame++;
+		if (newctrl & ACM_CTRL_PARITY)
+			acm->iocount.parity++;
+		if (newctrl & ACM_CTRL_OVERRUN)
+			acm->iocount.overrun++;
+		spin_unlock_irqrestore(&acm->read_lock, flags);
+
+		if (difference)
+			wake_up_all(&acm->wioctl);
+
+		break;
+
+	default:
+		break;
+	}
+}
+
+/* control interface reports status changes with "interrupt" transfers */
+static void vpu_acm_ctrl_irq(struct urb *urb)
+{
+	struct acm *acm = urb->context;
+	struct usb_cdc_notification *dr = urb->transfer_buffer;
+	unsigned int current_size = urb->actual_length;
+	unsigned int expected_size, copy_size, alloc_size;
+	int retval;
+	int status = urb->status;
+	switch (status) {
+	case 0:
+		/* success */
+		break;
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		/* this urb is terminated, clean up */
+		return;
+	default:
+		goto exit;
+	}
+
+	usb_mark_last_busy(acm->dev);
+
+	if (acm->nb_index)
+		dr = (struct usb_cdc_notification *)acm->notification_buffer;
+
+	/* size = notification-header + (optional) data */
+	expected_size = sizeof(struct usb_cdc_notification) +
+					le16_to_cpu(dr->wLength);
+
+	if (current_size < expected_size) {
+		/* notification is transmitted fragmented, reassemble */
+		if (acm->nb_size < expected_size) {
+			if (acm->nb_size) {
+				kfree(acm->notification_buffer);
+				acm->nb_size = 0;
+			}
+			alloc_size = roundup_pow_of_two(expected_size);
+			/*
+			 * kmalloc ensures a valid notification_buffer after a
+			 * use of kfree in case the previous allocation was too
+			 * small. Final freeing is done on disconnect.
+			 */
+			acm->notification_buffer =
+				kmalloc(alloc_size, GFP_ATOMIC);
+			if (!acm->notification_buffer)
+				goto exit;
+			acm->nb_size = alloc_size;
+		}
+
+		copy_size = min(current_size,
+				expected_size - acm->nb_index);
+		memcpy(&acm->notification_buffer[acm->nb_index],
+		       urb->transfer_buffer, copy_size);
+		acm->nb_index += copy_size;
+		current_size = acm->nb_index;
+	} else {
+	/* notification complete */
+		vpu_acm_process_notification(acm, (unsigned char *)dr);
+		acm->nb_index = 0;
+	}
+
+exit:
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval && retval != -EPERM)
+		dev_err(&acm->control->dev,
+			"%s - usb_submit_urb failed: %d\n", __func__, retval);
+}
+
+
+static int vpu_acm_submit_read_urb(struct acm *acm, int index, gfp_t mem_flags)
+{
+	int res;
+
+	if (!test_and_clear_bit(index, &acm->read_urbs_free))
+		return 0;
+
+	res = usb_submit_urb(acm->read_urbs[index], mem_flags);
+	if (res) {
+		if (res != -EPERM && res != -ENODEV) {
+			dev_err(&acm->data->dev,
+				"urb %d failed submission with %d\n",
+				index, res);
+		}
+		set_bit(index, &acm->read_urbs_free);
+		return res;
+	} else {
+		dev_vdbg(&acm->data->dev, "submitted urb %d\n", index);
+	}
+
+	return 0;
+}
+
+static int vpu_acm_submit_read_urbs(struct acm *acm, gfp_t mem_flags)
+{
+	int res;
+	int i;
+	for (i = 0; i < acm->rx_buflimit; ++i) {
+		res = vpu_acm_submit_read_urb(acm, i, mem_flags);
+		if (res)
+			return res;
+	}
+
+	return 0;
+}
+
+static void vpu_acm_process_read_urb(struct acm *acm, struct urb *urb)
+{
+	if (!urb->actual_length)
+		return;
+}
+
+static void vpu_acm_read_bulk_callback(struct urb *urb)
+{
+	struct acm_rb *rb = urb->context;
+	struct acm *acm = rb->instance;
+	int status = urb->status;
+	bool stopped = false;
+	bool stalled = false;
+	dev_vdbg(&acm->data->dev, "got urb %d, len %d, status %d\n",
+		rb->index, urb->actual_length, status);
+
+	if (!acm->dev) {
+		return;
+	}
+
+	switch (status) {
+	case 0:
+		usb_mark_last_busy(acm->dev);
+		vpu_acm_process_read_urb(acm, urb);
+		break;
+	case -EPIPE:
+		set_bit(EVENT_RX_STALL, &acm->flags);
+		stalled = true;
+		break;
+	case -ENOENT:
+	case -ECONNRESET:
+	case -ESHUTDOWN:
+		stopped = true;
+		break;
+	default:
+		break;
+	}
+
+	/*
+	 * Make sure URB processing is done before marking as free to avoid
+	 * racing with unthrottle() on another CPU. Matches the barriers
+	 * implied by the test_and_clear_bit() in vpu_acm_submit_read_urb().
+	 */
+	smp_mb__before_atomic();
+	set_bit(rb->index, &acm->read_urbs_free);
+	/*
+	 * Make sure URB is marked as free before checking the throttled flag
+	 * to avoid racing with unthrottle() on another CPU. Matches the
+	 * smp_mb() in unthrottle().
+	 */
+	smp_mb__after_atomic();
+
+	if (stopped || stalled) {
+		if (stalled)
+			schedule_work(&acm->work);
+		return;
+	}
+
+	if (test_bit(ACM_THROTTLED, &acm->flags))
+		return;
+
+	vpu_acm_submit_read_urb(acm, rb->index, GFP_ATOMIC);
+}
+
+/* data interface wrote those outgoing bytes */
+static void vpu_acm_write_bulk(struct urb *urb)
+{
+	struct acm_wb *wb = urb->context;
+	struct acm *acm = wb->instance;
+	unsigned long flags;
+	int status = urb->status;
+	if (status || (urb->actual_length != urb->transfer_buffer_length))
+		dev_vdbg(&acm->data->dev, "wrote len %d/%d, status %d\n",
+			urb->actual_length,
+			urb->transfer_buffer_length,
+			status);
+
+	spin_lock_irqsave(&acm->write_lock, flags);
+	vpu_acm_write_done(acm, wb);
+	spin_unlock_irqrestore(&acm->write_lock, flags);
+	set_bit(EVENT_TTY_WAKEUP, &acm->flags);
+	schedule_work(&acm->work);
+}
+
+static void vpu_acm_softint(struct work_struct *work)
+{
+	int i;
+	struct acm *acm = container_of(work, struct acm, work);
+	if (test_bit(EVENT_RX_STALL, &acm->flags)) {
+		if (!(usb_autopm_get_interface(acm->data))) {
+			for (i = 0; i < acm->rx_buflimit; i++)
+				usb_kill_urb(acm->read_urbs[i]);
+			usb_clear_halt(acm->dev, acm->in);
+			vpu_acm_submit_read_urbs(acm, GFP_KERNEL);
+			usb_autopm_put_interface(acm->data);
+		}
+		clear_bit(EVENT_RX_STALL, &acm->flags);
+	}
+
+}
+
+int usb_get_device_num(uint32_t *id_list)
+{
+	int num = 0;
+	struct acm *p;
+
+	mutex_lock(&dev_list_mutex);
+	list_for_each_entry(p, &dev_list, list) {
+		*id_list++ = p->devid;
+		num++;
+	}
+	mutex_unlock(&dev_list_mutex);
+	return num;
+}
+
+static struct acm *usb_get_device_by_id(u32 id)
+{
+	struct acm *xdev;
+	mutex_lock(&dev_list_mutex);
+	list_for_each_entry(xdev, &dev_list, list) {
+		if (xdev->devid == id)
+			break;
+	}
+	mutex_unlock(&dev_list_mutex);
+
+	return xdev;
+}
+
+int usb_get_device_name_by_id(uint32_t id, char *device_name, size_t name_size)
+{
+	struct acm *xdev;
+	size_t size;
+	xdev = usb_get_device_by_id(id);
+	if (!xdev)
+		return -ENODEV;
+
+	size = (name_size > MXLK_MAX_NAME_LEN) ? MXLK_MAX_NAME_LEN : name_size;
+	strncpy(device_name, xdev->name, size);
+	return 0;
+}
+
+// static struct acm *usb_get_device_by_name(const char *name)
+// {
+// 	struct acm *p;
+
+// 	mutex_lock(&dev_list_mutex);
+// 	list_for_each_entry(p, &dev_list, list) {
+// 		if (!strncmp(p->name, name, MXLK_MAX_NAME_LEN))
+// 			break;
+// 	}
+// 	mutex_unlock(&dev_list_mutex);
+
+// 	return p;
+// }
+
+int usb_get_device_status_by_id(u32 id, uint32_t *status)
+{
+	struct acm *xdev = usb_get_device_by_id(id);
+	//	struct acm *p;
+	u32 num = 0;
+
+	if (!xdev)
+		return -ENODEV;
+//	mutex_lock(&dev_list_mutex);
+//	*status = xdev->status;
+//	mutex_unlock(&dev_list_mutex);
+//	return 0;
+
+	mutex_lock(&dev_list_mutex);
+	list_for_each_entry(xdev, &dev_list, list) {
+		*status++ = xdev->status;
+		num++;
+	}
+	mutex_unlock(&dev_list_mutex);
+	return 0;
+}
+
+struct api_context {
+	struct completion	done;
+	int			status;
+};
+
+int usb_interrupt(struct usb_device *usb_dev, unsigned int pipe,
+		      void *data, int len, int *actual_length, int timeout)
+{
+	struct urb *urb;
+	struct usb_host_endpoint *ep;
+
+	ep = usb_pipe_endpoint(usb_dev, pipe);
+
+	urb = usb_alloc_urb(0, GFP_KERNEL);
+	return 0;
+}
+
+int usb_connect_device(uint32_t sw_device_id)
+{
+//	int rc = 0;
+
+	struct acm *xdev = usb_get_device_by_id(sw_device_id);
+	if (!xdev)
+		return -ENODEV;
+
+/*	if (mutex_lock_interruptible(&xdev->lock))
+		return -EINTR;
+
+	if (xdev->status)
+		goto connect_cleanup;
+
+	rc = mxlk_core_init(&xdev->mxlk);
+	if (rc < 0) {
+		dev_err(&xdev->pci->dev, "failed to sync with device\n");
+		goto connect_cleanup;
+	}
+*/
+//connect_cleanup:
+//	if (xdev->status)
+//		*fd = xdev;
+
+	return 0;
+}
+
+int usb_device_reset(u8 cmd)
+{
+	int ret;
+	int index = 0;
+	unsigned int pipe = 1;
+	struct acm *acm = vpu_acm_get_by_minor(index);
+	int actual_len;
+	u8 *buffer_cmd = NULL;
+	struct usb_host_endpoint *ep;
+	struct usb_interface *data_interface = acm->data;
+	struct usb_endpoint_descriptor *epwrite = NULL;
+	epwrite = &data_interface->cur_altsetting->endpoint[1].desc;
+	ep = usb_pipe_endpoint(acm->dev, pipe);
+
+	buffer_cmd = kzalloc(sizeof(cmd), GFP_KERNEL);
+	if (!buffer_cmd)
+		return -ENOMEM;
+
+	*buffer_cmd = cmd;
+
+	pipe = (pipe & ~(3 << 30)) | (PIPE_INTERRUPT << 30);
+
+	ret = usb_interrupt(acm->dev,
+		usb_sndintpipe(acm->dev, epwrite->bEndpointAddress),
+		buffer_cmd, sizeof(cmd),
+		&actual_len, USB_CTRL_SET_TIMEOUT);
+	kfree(buffer_cmd);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_device_reset);
+
+int vpu_write_host (u32 id, const char *buf, size_t *size, unsigned int timeout_ms)
+{
+	int len = *size;
+	int ret = 0;
+	struct acm *xdev = usb_get_device_by_id(id);
+	struct acm *acm;
+	int index = 0;
+	long jiffies_passed = 0;
+	long jiffies_timeout = (long)msecs_to_jiffies(timeout_ms);
+	int retval = -ENODEV;
+	int i;
+	int val = ACM_CTRL_DTR | ACM_CTRL_RTS;
+	int count = len;
+	int stat;
+	unsigned long flags;
+	int wbn;
+	struct acm_wb *wb;
+
+	if (!xdev)
+		return -EINVAL;
+
+	acm = vpu_acm_get_by_minor(index);
+	if (!acm)
+		return -EINVAL;
+
+	ret = wait_event_interruptible_timeout(acm->wioctl,
+					acm, jiffies_timeout - jiffies_passed);
+	if (ret == 0)
+		return -ETIME;
+
+	*size = 0;
+	if (len == 0)
+		return -EINVAL;
+
+	mutex_lock(&acm->mutex);
+	if (acm->disconnected)
+		goto disconnected;
+
+	retval = usb_autopm_get_interface(acm->control);
+	if (retval)
+		goto error_get_interface;
+	/*
+	 * FIXME: Why do we need this? Allocating 64K of physically contiguous
+	 * memory is really nasty...
+	 */
+	acm->control->needs_remote_wakeup = 1;
+
+	acm->ctrlurb->dev = acm->dev;
+	retval = usb_submit_urb(acm->ctrlurb, GFP_KERNEL);
+	if (retval) {
+		dev_err(&acm->control->dev,
+			"%s - usb_submit_urb(ctrl irq) failed\n", __func__);
+		goto error_submit_urb;
+	}
+
+	/*
+	 * Unthrottle device in case the TTY was closed while throttled.
+	 */
+	clear_bit(ACM_THROTTLED, &acm->flags);
+
+	retval = vpu_acm_submit_read_urbs(acm, GFP_KERNEL);
+	if (retval)
+		goto error_submit_read_urbs;
+
+	usb_autopm_put_interface(acm->control);
+
+	mutex_unlock(&acm->mutex);
+
+	vpu_acm_submit_read_urbs(acm, GFP_KERNEL);
+
+	acm->ctrlout = val;
+	vpu_acm_set_control(acm, val);
+
+	if (!count)
+		return -EINVAL;
+
+	dev_vdbg(&acm->data->dev, "%d bytes from tty layer\n", count);
+
+	spin_lock_irqsave(&acm->write_lock, flags);
+	wbn = vpu_acm_wb_alloc(acm);
+	if (wbn < 0) {
+		spin_unlock_irqrestore(&acm->write_lock, flags);
+		return -EINVAL;
+	}
+	wb = &acm->wb[wbn];
+
+	if (!acm->dev) {
+		wb->use = 0;
+		spin_unlock_irqrestore(&acm->write_lock, flags);
+		return -EINVAL;
+	}
+
+	count = (count > acm->writesize) ? acm->writesize : count;
+	dev_vdbg(&acm->data->dev, "writing %d bytes\n", count);
+	memcpy(wb->buf, buf, count);
+	wb->len = count;
+	len = count;
+	stat = usb_autopm_get_interface_async(acm->control);
+	if (stat) {
+		wb->use = 0;
+		spin_unlock_irqrestore(&acm->write_lock, flags);
+		return -EINVAL;
+	}
+
+	if (acm->susp_count) {
+		usb_anchor_urb(wb->urb, &acm->delayed);
+		spin_unlock_irqrestore(&acm->write_lock, flags);
+		return -EINVAL;
+	}
+	stat = vpu_acm_start_wb(acm, wb);
+	spin_unlock_irqrestore(&acm->write_lock, flags);
+
+	if (stat < 0)
+		return -EINVAL;
+
+error_submit_read_urbs:
+	for (i = 0; i < acm->rx_buflimit; i++)
+		usb_kill_urb(acm->read_urbs[i]);
+	usb_kill_urb(acm->ctrlurb);
+error_submit_urb:
+	usb_autopm_put_interface(acm->control);
+error_get_interface:
+disconnected:
+	mutex_unlock(&acm->mutex);
+	*size = len;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(vpu_write_host);
+
+int vpu_write_reset_host (u32 id)
+{
+	struct acm *xdev = usb_get_device_by_id(id);
+	struct acm *acm;
+	int index = 0;
+	int count = 8;
+	int stat;
+	int i;
+	unsigned long flags;
+	int wbn;
+	struct acm_wb *wb;
+	const char *buf = 0;
+
+	if (!xdev)
+		return -EINVAL;
+
+	acm = vpu_acm_get_by_minor(index);
+
+	if (!count)
+		return  -EINVAL;
+	dev_vdbg(&acm->data->dev, "%d bytes from tty layer\n", count);
+
+	spin_lock_irqsave(&acm->write_lock, flags);
+	wbn = vpu_acm_wb_alloc(acm);
+	if (wbn < 0) {
+		spin_unlock_irqrestore(&acm->write_lock, flags);
+		return -EINVAL;
+	}
+	wb = &acm->wb[wbn];
+
+	if (!acm->dev) {
+		wb->use = 0;
+		spin_unlock_irqrestore(&acm->write_lock, flags);
+		return -EINVAL;
+	}
+
+	count = (count > acm->writesize) ? acm->writesize : count;
+	dev_vdbg(&acm->data->dev, "writing %d bytes\n", count);
+	memcpy(wb->buf, &buf, count);
+	wb->len = count;
+
+	stat = usb_autopm_get_interface_async(acm->control);
+	if (stat) {
+		wb->use = 0;
+		spin_unlock_irqrestore(&acm->write_lock, flags);
+		return -EINVAL;
+	}
+
+	if (acm->susp_count) {
+		usb_anchor_urb(wb->urb, &acm->delayed);
+		spin_unlock_irqrestore(&acm->write_lock, flags);
+		return -EINVAL;
+	}
+	stat = vpu_acm_start_wb(acm, wb);
+	spin_unlock_irqrestore(&acm->write_lock, flags);
+	if (stat < 0)
+		return -EINVAL;
+
+	for (i = 0; i < acm->rx_buflimit; i++)
+		usb_kill_urb(acm->read_urbs[i]);
+	usb_kill_urb(acm->ctrlurb);
+
+	usb_autopm_put_interface(acm->control);
+
+	mutex_unlock(&acm->mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(vpu_write_reset_host);
+
+void vpu_write_swid (struct acm *acm, int buf, int len)
+{
+	int count = len;
+	int stat;
+	int i;
+	unsigned long flags;
+	int wbn;
+	struct acm_wb *wb;
+	if (!count)
+		return;
+	dev_vdbg(&acm->data->dev, "%d bytes from tty layer\n", count);
+
+	spin_lock_irqsave(&acm->write_lock, flags);
+	wbn = vpu_acm_wb_alloc(acm);
+	if (wbn < 0) {
+		spin_unlock_irqrestore(&acm->write_lock, flags);
+		return;
+	}
+	wb = &acm->wb[wbn];
+
+	if (!acm->dev) {
+		wb->use = 0;
+		spin_unlock_irqrestore(&acm->write_lock, flags);
+		return;
+	}
+
+	count = (count > acm->writesize) ? acm->writesize : count;
+	dev_vdbg(&acm->data->dev, "writing %d bytes\n", count);
+	memcpy(wb->buf, &buf, count);
+	wb->len = count;
+
+	stat = usb_autopm_get_interface_async(acm->control);
+	if (stat) {
+		wb->use = 0;
+		spin_unlock_irqrestore(&acm->write_lock, flags);
+		return;
+	}
+
+	if (acm->susp_count) {
+		usb_anchor_urb(wb->urb, &acm->delayed);
+		spin_unlock_irqrestore(&acm->write_lock, flags);
+		return;
+	}
+	stat = vpu_acm_start_wb(acm, wb);
+	spin_unlock_irqrestore(&acm->write_lock, flags);
+	if (stat < 0)
+		return;
+
+	for (i = 0; i < acm->rx_buflimit; i++)
+		usb_kill_urb(acm->read_urbs[i]);
+	usb_kill_urb(acm->ctrlurb);
+
+	usb_autopm_put_interface(acm->control);
+
+	mutex_unlock(&acm->mutex);
+
+	return;
+}
+
+int vpu_close_host (u32 id)
+{
+	struct acm *xdev = usb_get_device_by_id(id);
+	struct urb *urb;
+	struct acm *acm;
+	int index = 0;
+	int wbn;
+	struct acm_wb *wb;
+
+	if (!xdev)
+		return -ENODEV;
+	acm = vpu_acm_get_by_minor(index);
+	wbn = vpu_acm_wb_alloc(acm);
+	if (wbn < 0) {
+		return -EINVAL;
+	}
+	wb = &acm->wb[wbn];
+	spin_lock_irq(&acm->write_lock);
+	spin_unlock_irq(&acm->write_lock);
+
+	usb_autopm_get_interface_no_resume(acm->control);
+	acm->control->needs_remote_wakeup = 0;
+	usb_autopm_put_interface(acm->control);
+
+	for (;;) {
+		urb = usb_get_from_anchor(&acm->delayed);
+		if (!urb)
+			break;
+		wb = urb->context;
+		wb->use = 0;
+		usb_autopm_put_interface_async(acm->control);
+	}
+
+//	vpu_acm_kill_urbs(acm);
+	return 0;
+
+}
+EXPORT_SYMBOL_GPL(vpu_close_host);
+
+int vpu_close_reset_host (u32 id)
+{
+	struct acm *xdev = usb_get_device_by_id(id);
+	struct acm *acm;
+	int index = 0;
+	struct urb *urb;
+	int wbn;
+	struct acm_wb *wb;
+	if (!xdev)
+		return -EINVAL;
+	acm = vpu_acm_get_by_minor(index);
+	wbn = vpu_acm_wb_alloc(acm);
+	if (wbn < 0) {
+		return -EINVAL;
+	}
+	wb = &acm->wb[wbn];
+	spin_lock_irq(&acm->write_lock);
+	spin_unlock_irq(&acm->write_lock);
+
+	usb_autopm_get_interface_no_resume(acm->control);
+	acm->control->needs_remote_wakeup = 0;
+	usb_autopm_put_interface(acm->control);
+
+	for (;;) {
+		urb = usb_get_from_anchor(&acm->delayed);
+		if (!urb)
+			break;
+		wb = urb->context;
+		wb->use = 0;
+		usb_autopm_put_interface_async(acm->control);
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(vpu_close_reset_host);
+
+void vpu_close_swid (struct acm *acm, int len)
+{
+	struct urb *urb;
+	int wbn;
+	struct acm_wb *wb;
+	wbn = vpu_acm_wb_alloc(acm);
+	if (wbn < 0) {
+		return;
+	}
+	wb = &acm->wb[wbn];
+	spin_lock_irq(&acm->write_lock);
+	spin_unlock_irq(&acm->write_lock);
+
+	usb_autopm_get_interface_no_resume(acm->control);
+	acm->control->needs_remote_wakeup = 0;
+	usb_autopm_put_interface(acm->control);
+
+	for (;;) {
+		urb = usb_get_from_anchor(&acm->delayed);
+		if (!urb)
+			break;
+		wb = urb->context;
+		wb->use = 0;
+		usb_autopm_put_interface_async(acm->control);
+	}
+}
+
+int vpu_read_host (u32 id, void *data, size_t *size, unsigned int timeout_ms)
+{
+	size_t len = *size;
+	size_t remaining = len;
+	struct acm *xdev = usb_get_device_by_id(id);
+	struct acm *acm;
+	int index = 0;
+	long jiffies_passed = 0;
+	long jiffies_timeout = (long)msecs_to_jiffies(timeout_ms);
+	int ret = 0;
+	struct urb *urb;
+	int retval = -ENODEV;
+	int i;
+	int val = ACM_CTRL_DTR | ACM_CTRL_RTS;
+
+	if (!xdev)
+		return -ENODEV;
+
+	acm = vpu_acm_get_by_minor(index);
+	if (!acm)
+		return -ENODEV;
+
+	ret = wait_event_interruptible_timeout(acm->wioctl,
+					acm, jiffies_timeout - jiffies_passed);
+	if (ret == 0)
+		return -ETIME;
+
+	*size = 0;
+	if (len == 0)
+		return -EINVAL;
+
+	mutex_lock(&acm->mutex);
+
+	retval = usb_autopm_get_interface(acm->control);
+	if (retval)
+		goto error_get_interface;
+
+	/*
+	 * FIXME: Why do we need this? Allocating 64K of physically contiguous
+	 * memory is really nasty...
+	 */
+
+	acm->control->needs_remote_wakeup = 1;
+	acm->ctrlurb->dev = acm->dev;
+
+	/*
+	 * Unthrottle device in case the TTY was closed while throttled.
+	 */
+	clear_bit(ACM_THROTTLED, &acm->flags);
+
+	retval = vpu_acm_submit_read_urbs(acm, GFP_KERNEL);
+	if (retval)
+		goto error_submit_read_urbs;
+
+	usb_autopm_put_interface(acm->control);
+
+	mutex_unlock(&acm->mutex);
+
+	acm->ctrlout = val;
+	vpu_acm_set_control(acm, val);
+	urb = acm->read_urbs[0];
+	while (remaining > 0 && urb) {
+		size_t bcopy;
+		bcopy = min(remaining, (size_t)urb->transfer_buffer_length);
+		memcpy(data, urb->transfer_buffer, bcopy);
+		data += bcopy;
+		remaining -= bcopy;
+//		urb->transfer_buffer += bcopy;
+		*size = len - remaining;
+	}
+	vpu_acm_kill_urbs(acm);
+
+//	for (i = 0; i < acm->rx_buflimit; i++)
+//		usb_free_coherent(acm->dev, acm->readsize,
+//			  acm->read_buffers[i].base, acm->read_buffers[i].dma);
+	return 0;
+
+error_submit_read_urbs:
+	for (i = 0; i < acm->rx_buflimit; i++)
+		usb_kill_urb(acm->read_urbs[i]);
+	usb_kill_urb(acm->ctrlurb);
+error_get_interface:
+
+	mutex_unlock(&acm->mutex);
+
+	return usb_translate_errors(retval);
+}
+EXPORT_SYMBOL_GPL(vpu_read_host);
+
+/* Little helpers: write/read buffers free */
+static void vpu_acm_write_buffers_free(struct acm *acm)
+{
+	int i;
+	struct acm_wb *wb;
+	for (wb = &acm->wb[0], i = 0; i < ACM_NW; i++, wb++)
+		usb_free_coherent(acm->dev, acm->writesize, wb->buf, wb->dmah);
+}
+
+static void vpu_acm_read_buffers_free(struct acm *acm)
+{
+	int i;
+
+	for (i = 0; i < acm->rx_buflimit; i++)
+		usb_free_coherent(acm->dev, acm->readsize,
+			  acm->read_buffers[i].base, acm->read_buffers[i].dma);
+}
+
+/* Little helper: write buffers allocate */
+static int vpu_acm_write_buffers_alloc(struct acm *acm)
+{
+	int i;
+	struct acm_wb *wb;
+	for (wb = &acm->wb[0], i = 0; i < ACM_NW; i++, wb++) {
+		wb->buf = usb_alloc_coherent(acm->dev, acm->writesize, GFP_KERNEL,
+		    &wb->dmah);
+		if (!wb->buf) {
+			while (i != 0) {
+				--i;
+				--wb;
+				usb_free_coherent(acm->dev, acm->writesize,
+				    wb->buf, wb->dmah);
+			}
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+static void mxlk_usb_add_device(struct acm *acm, int devnum, int busnum)
+{
+	mutex_lock(&dev_list_mutex);
+
+	acm->devid = (XLINK_DEV_INF_USB << XLINK_DEV_INF_TYPE_SHIFT) |
+		      ((busnum << 8 | devnum) << XLINK_DEV_PHYS_ID_SHIFT) |
+		      (XLINK_DEV_TYPE_KMB << XLINK_DEV_TYPE_SHIFT) |
+		      (XLINK_DEV_SLICE_0 << XLINK_DEV_SLICE_ID_SHIFT) |
+		      (XLINK_DEV_FUNC_VPU << XLINK_DEV_FUNC_SHIFT);
+
+	acm->status = 4;
+
+	list_add_tail(&acm->list, &dev_list);
+	mutex_unlock(&dev_list_mutex);
+}
+
+static int vpu_acm_probe(struct usb_interface *intf,
+		     const struct usb_device_id *id)
+{
+	struct usb_cdc_union_desc *union_header = NULL;
+	struct usb_cdc_call_mgmt_descriptor *cmgmd = NULL;
+	unsigned char *buffer = intf->altsetting->extra;
+	int buflen = intf->altsetting->extralen;
+	struct usb_interface *control_interface;
+	struct usb_interface *data_interface;
+	struct usb_endpoint_descriptor *epctrl = NULL;
+	struct usb_endpoint_descriptor *epread = NULL;
+	struct usb_endpoint_descriptor *epwrite = NULL;
+	struct usb_device *usb_dev = interface_to_usbdev(intf);
+	struct usb_cdc_parsed_header h;
+	struct acm *acm;
+	int minor;
+	int ctrlsize, readsize;
+	u8 *buf;
+	int call_intf_num = -1;
+	int data_intf_num = -1;
+	unsigned long quirks;
+	int num_rx_buf;
+	int i;
+	int combined_interfaces = 0;
+	int rv = -ENOMEM;
+	int res;
+	size_t size = 8;
+	struct usb_device *udev = interface_to_usbdev(intf);
+	int devnum = udev->devnum;
+	int busnum = udev->bus->busnum;
+	/* normal quirks */
+	quirks = (unsigned long)id->driver_info;
+
+	if (quirks == IGNORE_DEVICE)
+		return -ENODEV;
+
+	memset(&h, 0x00, sizeof(struct usb_cdc_parsed_header));
+
+	num_rx_buf = (quirks == SINGLE_RX_URB) ? 1 : ACM_NR;
+
+	/* handle quirks deadly to normal probing*/
+	if (quirks == NO_UNION_NORMAL) {
+		data_interface = usb_ifnum_to_if(usb_dev, 1);
+		control_interface = usb_ifnum_to_if(usb_dev, 0);
+		/* we would crash */
+		if (!data_interface || !control_interface)
+			return -ENODEV;
+		goto skip_normal_probe;
+	}
+
+	/* normal probing*/
+	if (!buffer) {
+		dev_err(&intf->dev, "Weird descriptor references\n");
+		return -EINVAL;
+	}
+
+	if (!intf->cur_altsetting)
+		return -EINVAL;
+
+	if (!buflen) {
+		if (intf->cur_altsetting->endpoint &&
+				intf->cur_altsetting->endpoint->extralen &&
+				intf->cur_altsetting->endpoint->extra) {
+			dev_dbg(&intf->dev,
+				"Seeking extra descriptors on endpoint\n");
+			buflen = intf->cur_altsetting->endpoint->extralen;
+			buffer = intf->cur_altsetting->endpoint->extra;
+		} else {
+			dev_err(&intf->dev,
+				"Zero length descriptor references\n");
+			return -EINVAL;
+		}
+	}
+
+	cdc_parse_cdc_header(&h, intf, buffer, buflen);
+	union_header = h.usb_cdc_union_desc;
+	cmgmd = h.usb_cdc_call_mgmt_descriptor;
+	if (cmgmd)
+		call_intf_num = cmgmd->bDataInterface;
+
+	if (!union_header) {
+		if (call_intf_num > 0) {
+			dev_dbg(&intf->dev, "No union descriptor, using call management descriptor\n");
+			/* quirks for Droids MuIn LCD */
+			if (quirks & NO_DATA_INTERFACE) {
+				data_interface = usb_ifnum_to_if(usb_dev, 0);
+			} else {
+				data_intf_num = call_intf_num;
+				data_interface = usb_ifnum_to_if(usb_dev, data_intf_num);
+			}
+			control_interface = intf;
+		} else {
+			if (intf->cur_altsetting->desc.bNumEndpoints != 3) {
+				dev_dbg(&intf->dev, "No union descriptor, giving up\n");
+				return -ENODEV;
+			} else {
+				dev_warn(&intf->dev, "No union descriptor, testing for castrated device\n");
+				combined_interfaces = 1;
+				control_interface = data_interface = intf;
+				goto look_for_collapsed_interface;
+			}
+		}
+	} else {
+		data_intf_num = union_header->bSlaveInterface0;
+		control_interface = usb_ifnum_to_if(usb_dev, union_header->bMasterInterface0);
+		data_interface = usb_ifnum_to_if(usb_dev, data_intf_num);
+	}
+
+	if (!control_interface || !data_interface) {
+		dev_dbg(&intf->dev, "no interfaces\n");
+		return -ENODEV;
+	}
+	if (!data_interface->cur_altsetting || !control_interface->cur_altsetting)
+		return -ENODEV;
+
+	if (data_intf_num != call_intf_num)
+		dev_dbg(&intf->dev, "Separate call control interface. That is not fully supported.\n");
+
+	if (control_interface == data_interface) {
+		/* some broken devices designed for windows work this way */
+		dev_warn(&intf->dev, "Control and data interfaces are not separated!\n");
+		combined_interfaces = 1;
+		/* a popular other OS doesn't use it */
+		quirks |= NO_CAP_LINE;
+		if (data_interface->cur_altsetting->desc.bNumEndpoints != 3) {
+			dev_err(&intf->dev, "This needs exactly 3 endpoints\n");
+			return -EINVAL;
+		}
+look_for_collapsed_interface:
+		res = usb_find_common_endpoints(data_interface->cur_altsetting,
+				&epread, &epwrite, &epctrl, NULL);
+		if (res)
+			return res;
+
+		goto made_compressed_probe;
+	}
+
+skip_normal_probe:
+	/*workaround for switched interfaces */
+	if (data_interface->cur_altsetting->desc.bInterfaceClass
+						!= CDC_DATA_INTERFACE_TYPE) {
+		if (control_interface->cur_altsetting->desc.bInterfaceClass
+						== CDC_DATA_INTERFACE_TYPE) {
+			dev_dbg(&intf->dev,
+				"Your device has switched interfaces.\n");
+			swap(control_interface, data_interface);
+		} else {
+			return -EINVAL;
+		}
+	}
+
+	/* Accept probe requests only for the control interface */
+	if (!combined_interfaces && intf != control_interface)
+		return -ENODEV;
+
+	if (!combined_interfaces && usb_interface_claimed(data_interface)) {
+		/* valid in this context */
+		dev_dbg(&intf->dev, "The data interface isn't available\n");
+		return -EBUSY;
+	}
+
+
+	if (data_interface->cur_altsetting->desc.bNumEndpoints < 2 ||
+	    control_interface->cur_altsetting->desc.bNumEndpoints == 0)
+		return -EINVAL;
+
+	epctrl = &control_interface->cur_altsetting->endpoint[0].desc;
+	epread = &data_interface->cur_altsetting->endpoint[0].desc;
+	epwrite = &data_interface->cur_altsetting->endpoint[1].desc;
+
+
+	/* workaround for switched endpoints */
+	if (!usb_endpoint_dir_in(epread)) {
+		/* descriptors are swapped */
+		dev_dbg(&intf->dev,
+			"The data interface has switched endpoints\n");
+		swap(epread, epwrite);
+	}
+made_compressed_probe:
+	dev_dbg(&intf->dev, "interfaces are valid\n");
+	acm = kzalloc(sizeof(struct acm), GFP_KERNEL);
+	if (acm == NULL)
+		goto alloc_fail;
+
+	mxlk_usb_add_device(acm, devnum, busnum);
+
+	minor = vpu_acm_alloc_minor(acm);
+	if (minor < 0)
+		goto alloc_fail1;
+
+	ctrlsize = usb_endpoint_maxp(epctrl);
+	readsize = usb_endpoint_maxp(epread) *
+				(quirks == SINGLE_RX_URB ? 1 : 2);
+	acm->combined_interfaces = combined_interfaces;
+	acm->writesize = usb_endpoint_maxp(epwrite) * 20;
+	acm->control = control_interface;
+	acm->data = data_interface;
+	acm->minor = minor;
+	acm->dev = usb_dev;
+	if (h.usb_cdc_acm_descriptor)
+		acm->ctrl_caps = h.usb_cdc_acm_descriptor->bmCapabilities;
+	if (quirks & NO_CAP_LINE)
+		acm->ctrl_caps &= ~USB_CDC_CAP_LINE;
+	acm->ctrlsize = ctrlsize;
+	acm->readsize = readsize;
+	acm->rx_buflimit = num_rx_buf;
+	INIT_WORK(&acm->work, vpu_acm_softint);
+	init_waitqueue_head(&acm->wioctl);
+	spin_lock_init(&acm->write_lock);
+	spin_lock_init(&acm->read_lock);
+	mutex_init(&acm->mutex);
+	if (usb_endpoint_xfer_int(epread)) {
+		acm->bInterval = epread->bInterval;
+		acm->in = usb_rcvintpipe(usb_dev, epread->bEndpointAddress);
+	} else {
+		acm->in = usb_rcvbulkpipe(usb_dev, epread->bEndpointAddress);
+	}
+	if (usb_endpoint_xfer_int(epwrite))
+		acm->out = usb_sndintpipe(usb_dev, epwrite->bEndpointAddress);
+	else
+		acm->out = usb_sndbulkpipe(usb_dev, epwrite->bEndpointAddress);
+	init_usb_anchor(&acm->delayed);
+	acm->quirks = quirks;
+
+	buf = usb_alloc_coherent(usb_dev, ctrlsize, GFP_KERNEL, &acm->ctrl_dma);
+	if (!buf)
+		goto alloc_fail1;
+	acm->ctrl_buffer = buf;
+
+	if (vpu_acm_write_buffers_alloc(acm) < 0)
+		goto alloc_fail2;
+
+	acm->ctrlurb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!acm->ctrlurb)
+		goto alloc_fail3;
+	for (i = 0; i < num_rx_buf; i++) {
+		struct acm_rb *rb = &(acm->read_buffers[i]);
+		struct urb *urb;
+
+		rb->base = usb_alloc_coherent(acm->dev, readsize, GFP_KERNEL,
+								&rb->dma);
+		if (!rb->base)
+			goto alloc_fail4;
+		rb->index = i;
+		rb->instance = acm;
+
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb)
+			goto alloc_fail4;
+
+		urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+		urb->transfer_dma = rb->dma;
+		if (usb_endpoint_xfer_int(epread))
+			usb_fill_int_urb(urb, acm->dev, acm->in, rb->base,
+					 acm->readsize,
+					 vpu_acm_read_bulk_callback, rb,
+					 acm->bInterval);
+		else
+			usb_fill_bulk_urb(urb, acm->dev, acm->in, rb->base,
+					  acm->readsize,
+					  vpu_acm_read_bulk_callback, rb);
+
+		acm->read_urbs[i] = urb;
+		__set_bit(i, &acm->read_urbs_free);
+	}
+	for (i = 0; i < ACM_NW; i++) {
+		struct acm_wb *snd = &(acm->wb[i]);
+
+		snd->urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (snd->urb == NULL)
+			goto alloc_fail5;
+
+		if (usb_endpoint_xfer_int(epwrite))
+			usb_fill_int_urb(snd->urb, usb_dev, acm->out,
+				NULL, acm->writesize, vpu_acm_write_bulk, snd, epwrite->bInterval);
+		else
+			usb_fill_bulk_urb(snd->urb, usb_dev, acm->out,
+				NULL, acm->writesize, vpu_acm_write_bulk, snd);
+		snd->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+		if (quirks & SEND_ZERO_PACKET)
+			snd->urb->transfer_flags |= URB_ZERO_PACKET;
+		snd->instance = acm;
+	}
+	usb_set_intfdata(intf, acm);
+
+	i = device_create_file(&intf->dev, &dev_attr_bmCapabilities);
+	if (i < 0)
+		goto alloc_fail5;
+
+	if (h.usb_cdc_country_functional_desc) { /* export the country data */
+		struct usb_cdc_country_functional_desc *cfd =
+					h.usb_cdc_country_functional_desc;
+
+		acm->country_codes = kmalloc(cfd->bLength - 4, GFP_KERNEL);
+		if (!acm->country_codes)
+			goto skip_countries;
+		acm->country_code_size = cfd->bLength - 4;
+		memcpy(acm->country_codes, (u8 *)&cfd->wCountyCode0,
+							cfd->bLength - 4);
+		acm->country_rel_date = cfd->iCountryCodeRelDate;
+
+		i = device_create_file(&intf->dev, &dev_attr_wCountryCodes);
+		if (i < 0) {
+			kfree(acm->country_codes);
+			acm->country_codes = NULL;
+			acm->country_code_size = 0;
+			goto skip_countries;
+		}
+
+		i = device_create_file(&intf->dev,
+						&dev_attr_iCountryCodeRelDate);
+		if (i < 0) {
+			device_remove_file(&intf->dev, &dev_attr_wCountryCodes);
+			kfree(acm->country_codes);
+			acm->country_codes = NULL;
+			acm->country_code_size = 0;
+			goto skip_countries;
+		}
+	}
+
+skip_countries:
+	usb_fill_int_urb(acm->ctrlurb, usb_dev,
+			 usb_rcvintpipe(usb_dev, epctrl->bEndpointAddress),
+			 acm->ctrl_buffer, ctrlsize, vpu_acm_ctrl_irq, acm,
+			 /* works around buggy devices */
+			 epctrl->bInterval ? epctrl->bInterval : 16);
+	acm->ctrlurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+	acm->ctrlurb->transfer_dma = acm->ctrl_dma;
+	acm->notification_buffer = NULL;
+	acm->nb_index = 0;
+	acm->nb_size = 0;
+
+	acm->line.dwDTERate = cpu_to_le32(9600);
+	acm->line.bDataBits = 8;
+	vpu_acm_set_line(acm, &acm->line);
+
+	usb_driver_claim_interface(&vpu_acm_driver, data_interface, acm);
+	usb_set_intfdata(data_interface, acm);
+
+	usb_get_intf(control_interface);
+
+
+	if (quirks & CLEAR_HALT_CONDITIONS) {
+		usb_clear_halt(usb_dev, acm->in);
+		usb_clear_halt(usb_dev, acm->out);
+	}
+
+	vpu_write_swid(acm, devnum, size);
+	vpu_close_swid(acm, size);
+	vpu_write_swid(acm, busnum, size);
+	vpu_close_swid(acm, size);
+
+	return 0;
+
+alloc_fail5:
+	usb_set_intfdata(intf, NULL);
+	for (i = 0; i < ACM_NW; i++)
+		usb_free_urb(acm->wb[i].urb);
+alloc_fail4:
+	for (i = 0; i < num_rx_buf; i++)
+		usb_free_urb(acm->read_urbs[i]);
+	vpu_acm_read_buffers_free(acm);
+	usb_free_urb(acm->ctrlurb);
+alloc_fail3:
+	vpu_acm_write_buffers_free(acm);
+alloc_fail2:
+	usb_free_coherent(usb_dev, ctrlsize, acm->ctrl_buffer, acm->ctrl_dma);
+alloc_fail1:
+	kfree(acm);
+alloc_fail:
+	return rv;
+}
+
+static void vpu_acm_disconnect(struct usb_interface *intf)
+{
+	struct acm *acm = usb_get_intfdata(intf);
+	int i;
+	/* sibling interface is already cleaning up */
+	if (!acm)
+		return;
+
+	mutex_lock(&acm->mutex);
+	acm->disconnected = true;
+	acm->status = 0;
+	__list_del_entry(&acm->list);
+	if (acm->country_codes) {
+		device_remove_file(&acm->control->dev,
+				&dev_attr_wCountryCodes);
+		device_remove_file(&acm->control->dev,
+				&dev_attr_iCountryCodeRelDate);
+	}
+	wake_up_all(&acm->wioctl);
+	device_remove_file(&acm->control->dev, &dev_attr_bmCapabilities);
+	usb_set_intfdata(acm->control, NULL);
+	usb_set_intfdata(acm->data, NULL);
+	mutex_unlock(&acm->mutex);
+
+	vpu_acm_kill_urbs(acm);
+	cancel_work_sync(&acm->work);
+
+
+	usb_free_urb(acm->ctrlurb);
+	for (i = 0; i < ACM_NW; i++)
+		usb_free_urb(acm->wb[i].urb);
+	for (i = 0; i < acm->rx_buflimit; i++)
+		usb_free_urb(acm->read_urbs[i]);
+	vpu_acm_write_buffers_free(acm);
+	usb_free_coherent(acm->dev, acm->ctrlsize, acm->ctrl_buffer, acm->ctrl_dma);
+	vpu_acm_read_buffers_free(acm);
+
+	kfree(acm->notification_buffer);
+
+	if (!acm->combined_interfaces)
+		usb_driver_release_interface(&vpu_acm_driver, intf == acm->control ?
+					acm->data : acm->control);
+
+
+}
+
+#ifdef CONFIG_PM
+static int vpu_acm_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct acm *acm = usb_get_intfdata(intf);
+	int cnt;
+	spin_lock_irq(&acm->write_lock);
+	if (PMSG_IS_AUTO(message)) {
+		if (acm->transmitting) {
+			spin_unlock_irq(&acm->write_lock);
+			return -EBUSY;
+		}
+	}
+	cnt = acm->susp_count++;
+	spin_unlock_irq(&acm->write_lock);
+
+	if (cnt)
+		return 0;
+
+	vpu_acm_kill_urbs(acm);
+	cancel_work_sync(&acm->work);
+
+	return 0;
+}
+
+static int vpu_acm_resume(struct usb_interface *intf)
+{
+	struct acm *acm = usb_get_intfdata(intf);
+	int rv = 0;
+	spin_lock_irq(&acm->write_lock);
+
+	if (--acm->susp_count)
+		goto out;
+
+out:
+	spin_unlock_irq(&acm->write_lock);
+
+	return rv;
+}
+
+static int vpu_acm_reset_resume(struct usb_interface *intf)
+{
+	return vpu_acm_resume(intf);
+}
+
+#endif /* CONFIG_PM */
+
+static int vpu_acm_pre_reset(struct usb_interface *intf)
+{
+	struct acm *acm = usb_get_intfdata(intf);
+	clear_bit(EVENT_RX_STALL, &acm->flags);
+	acm->nb_index = 0; /* pending control transfers are lost */
+
+	return 0;
+}
+
+#define NOKIA_PCSUITE_ACM_INFO(x) \
+		USB_DEVICE_AND_INTERFACE_INFO(0x0421, x, \
+		USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM, \
+		USB_CDC_ACM_PROTO_VENDOR)
+
+#define SAMSUNG_PCSUITE_ACM_INFO(x) \
+		USB_DEVICE_AND_INTERFACE_INFO(0x04e7, x, \
+		USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM, \
+		USB_CDC_ACM_PROTO_VENDOR)
+
+/*
+ * USB driver structure.
+ */
+
+static const struct usb_device_id vpu_acm_ids[] = {
+	/* quirky and broken devices */
+	{ USB_DEVICE(0x076d, 0x0006), /* Denso Cradle CU-321 */
+	.driver_info = NO_UNION_NORMAL, },/* has no union descriptor */
+	{ USB_DEVICE(0x17ef, 0x7000), /* Lenovo USB modem */
+	.driver_info = NO_UNION_NORMAL, },/* has no union descriptor */
+	{ USB_DEVICE(0x0870, 0x0001), /* Metricom GS Modem */
+	.driver_info = NO_UNION_NORMAL, /* has no union descriptor */
+	},
+	{ USB_DEVICE(0x0e8d, 0x0003), /* FIREFLY, MediaTek Inc; andrey.arapov@gmail.com */
+	.driver_info = NO_UNION_NORMAL, /* has no union descriptor */
+	},
+	{ USB_DEVICE(0x0e8d, 0x2000), /* MediaTek Inc Preloader */
+	.driver_info = DISABLE_ECHO, /* DISABLE ECHO in termios flag */
+	},
+	{ USB_DEVICE(0x0e8d, 0x3329), /* MediaTek Inc GPS */
+	.driver_info = NO_UNION_NORMAL, /* has no union descriptor */
+	},
+	{ USB_DEVICE(0x0482, 0x0203), /* KYOCERA AH-K3001V */
+	.driver_info = NO_UNION_NORMAL, /* has no union descriptor */
+	},
+	{ USB_DEVICE(0x079b, 0x000f), /* BT On-Air USB MODEM */
+	.driver_info = NO_UNION_NORMAL, /* has no union descriptor */
+	},
+	{ USB_DEVICE(0x0ace, 0x1602), /* ZyDAS 56K USB MODEM */
+	.driver_info = SINGLE_RX_URB,
+	},
+	{ USB_DEVICE(0x0ace, 0x1608), /* ZyDAS 56K USB MODEM */
+	.driver_info = SINGLE_RX_URB, /* firmware bug */
+	},
+	{ USB_DEVICE(0x0ace, 0x1611), /* ZyDAS 56K USB MODEM - new version */
+	.driver_info = SINGLE_RX_URB, /* firmware bug */
+	},
+	{ USB_DEVICE(0x11ca, 0x0201), /* VeriFone Mx870 Gadget Serial */
+	.driver_info = SINGLE_RX_URB,
+	},
+	{ USB_DEVICE(0x1965, 0x0018), /* Uniden UBC125XLT */
+	.driver_info = NO_UNION_NORMAL, /* has no union descriptor */
+	},
+	{ USB_DEVICE(0x22b8, 0x7000), /* Motorola Q Phone */
+	.driver_info = NO_UNION_NORMAL, /* has no union descriptor */
+	},
+	{ USB_DEVICE(0x0803, 0x3095), /* Zoom Telephonics Model 3095F USB MODEM */
+	.driver_info = NO_UNION_NORMAL, /* has no union descriptor */
+	},
+	{ USB_DEVICE(0x0572, 0x1321), /* Conexant USB MODEM CX93010 */
+	.driver_info = NO_UNION_NORMAL, /* has no union descriptor */
+	},
+	{ USB_DEVICE(0x0572, 0x1324), /* Conexant USB MODEM RD02-D400 */
+	.driver_info = NO_UNION_NORMAL, /* has no union descriptor */
+	},
+	{ USB_DEVICE(0x0572, 0x1328), /* Shiro / Aztech USB MODEM UM-3100 */
+	.driver_info = NO_UNION_NORMAL, /* has no union descriptor */
+	},
+	{ USB_DEVICE(0x0572, 0x1349), /* Hiro (Conexant) USB MODEM H50228 */
+	.driver_info = NO_UNION_NORMAL, /* has no union descriptor */
+	},
+	{ USB_DEVICE(0x20df, 0x0001), /* Simtec Electronics Entropy Key */
+	.driver_info = QUIRK_CONTROL_LINE_STATE, },
+	{ USB_DEVICE(0x2184, 0x001c) },	/* GW Instek AFG-2225 */
+	{ USB_DEVICE(0x2184, 0x0036) },	/* GW Instek AFG-125 */
+	{ USB_DEVICE(0x22b8, 0x6425), /* Motorola MOTOMAGX phones */
+	},
+	/* Motorola H24 HSPA module: */
+	{ USB_DEVICE(0x22b8, 0x2d91) }, /* modem                                */
+	{ USB_DEVICE(0x22b8, 0x2d92),   /* modem           + diagnostics        */
+	.driver_info = NO_UNION_NORMAL, /* handle only modem interface          */
+	},
+	{ USB_DEVICE(0x22b8, 0x2d93),   /* modem + AT port                      */
+	.driver_info = NO_UNION_NORMAL, /* handle only modem interface          */
+	},
+	{ USB_DEVICE(0x22b8, 0x2d95),   /* modem + AT port + diagnostics        */
+	.driver_info = NO_UNION_NORMAL, /* handle only modem interface          */
+	},
+	{ USB_DEVICE(0x22b8, 0x2d96),   /* modem                         + NMEA */
+	.driver_info = NO_UNION_NORMAL, /* handle only modem interface          */
+	},
+	{ USB_DEVICE(0x22b8, 0x2d97),   /* modem           + diagnostics + NMEA */
+	.driver_info = NO_UNION_NORMAL, /* handle only modem interface          */
+	},
+	{ USB_DEVICE(0x22b8, 0x2d99),   /* modem + AT port               + NMEA */
+	.driver_info = NO_UNION_NORMAL, /* handle only modem interface          */
+	},
+	{ USB_DEVICE(0x22b8, 0x2d9a),   /* modem + AT port + diagnostics + NMEA */
+	.driver_info = NO_UNION_NORMAL, /* handle only modem interface          */
+	},
+
+	{ USB_DEVICE(0x0572, 0x1329), /* Hummingbird huc56s (Conexant) */
+	.driver_info = NO_UNION_NORMAL, /* union descriptor misplaced on
+					   data interface instead of
+					   communications interface.
+					   Maybe we should define a new
+					   quirk for this. */
+	},
+	{ USB_DEVICE(0x0572, 0x1340), /* Conexant CX93010-2x UCMxx */
+	.driver_info = NO_UNION_NORMAL,
+	},
+	{ USB_DEVICE(0x05f9, 0x4002), /* PSC Scanning, Magellan 800i */
+	.driver_info = NO_UNION_NORMAL,
+	},
+	{ USB_DEVICE(0x1bbb, 0x0003), /* Alcatel OT-I650 */
+	.driver_info = NO_UNION_NORMAL, /* reports zero length descriptor */
+	},
+	{ USB_DEVICE(0x1576, 0x03b1), /* Maretron USB100 */
+	.driver_info = NO_UNION_NORMAL, /* reports zero length descriptor */
+	},
+	{ USB_DEVICE(0xfff0, 0x0100), /* DATECS FP-2000 */
+	.driver_info = NO_UNION_NORMAL, /* reports zero length descriptor */
+	},
+	{ USB_DEVICE(0x09d8, 0x0320), /* Elatec GmbH TWN3 */
+	.driver_info = NO_UNION_NORMAL, /* has misplaced union descriptor */
+	},
+	{ USB_DEVICE(0x0ca6, 0xa050), /* Castles VEGA3000 */
+	.driver_info = NO_UNION_NORMAL, /* reports zero length descriptor */
+	},
+
+	{ USB_DEVICE(0x2912, 0x0001), /* ATOL FPrint */
+	.driver_info = CLEAR_HALT_CONDITIONS,
+	},
+
+	/* Nokia S60 phones expose two ACM channels. The first is
+	 * a modem and is picked up by the standard AT-command
+	 * information below. The second is 'vendor-specific' but
+	 * is treated as a serial device at the S60 end, so we want
+	 * to expose it on Linux too. */
+	{ NOKIA_PCSUITE_ACM_INFO(0x042D), }, /* Nokia 3250 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x04D8), }, /* Nokia 5500 Sport */
+	{ NOKIA_PCSUITE_ACM_INFO(0x04C9), }, /* Nokia E50 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0419), }, /* Nokia E60 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x044D), }, /* Nokia E61 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0001), }, /* Nokia E61i */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0475), }, /* Nokia E62 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0508), }, /* Nokia E65 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0418), }, /* Nokia E70 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0425), }, /* Nokia N71 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0486), }, /* Nokia N73 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x04DF), }, /* Nokia N75 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x000e), }, /* Nokia N77 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0445), }, /* Nokia N80 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x042F), }, /* Nokia N91 & N91 8GB */
+	{ NOKIA_PCSUITE_ACM_INFO(0x048E), }, /* Nokia N92 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0420), }, /* Nokia N93 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x04E6), }, /* Nokia N93i  */
+	{ NOKIA_PCSUITE_ACM_INFO(0x04B2), }, /* Nokia 5700 XpressMusic */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0134), }, /* Nokia 6110 Navigator (China) */
+	{ NOKIA_PCSUITE_ACM_INFO(0x046E), }, /* Nokia 6110 Navigator */
+	{ NOKIA_PCSUITE_ACM_INFO(0x002f), }, /* Nokia 6120 classic &  */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0088), }, /* Nokia 6121 classic */
+	{ NOKIA_PCSUITE_ACM_INFO(0x00fc), }, /* Nokia 6124 classic */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0042), }, /* Nokia E51 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x00b0), }, /* Nokia E66 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x00ab), }, /* Nokia E71 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0481), }, /* Nokia N76 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0007), }, /* Nokia N81 & N81 8GB */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0071), }, /* Nokia N82 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x04F0), }, /* Nokia N95 & N95-3 NAM */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0070), }, /* Nokia N95 8GB  */
+	{ NOKIA_PCSUITE_ACM_INFO(0x00e9), }, /* Nokia 5320 XpressMusic */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0099), }, /* Nokia 6210 Navigator, RM-367 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0128), }, /* Nokia 6210 Navigator, RM-419 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x008f), }, /* Nokia 6220 Classic */
+	{ NOKIA_PCSUITE_ACM_INFO(0x00a0), }, /* Nokia 6650 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x007b), }, /* Nokia N78 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0094), }, /* Nokia N85 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x003a), }, /* Nokia N96 & N96-3  */
+	{ NOKIA_PCSUITE_ACM_INFO(0x00e9), }, /* Nokia 5320 XpressMusic */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0108), }, /* Nokia 5320 XpressMusic 2G */
+	{ NOKIA_PCSUITE_ACM_INFO(0x01f5), }, /* Nokia N97, RM-505 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x02e3), }, /* Nokia 5230, RM-588 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0178), }, /* Nokia E63 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x010e), }, /* Nokia E75 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x02d9), }, /* Nokia 6760 Slide */
+	{ NOKIA_PCSUITE_ACM_INFO(0x01d0), }, /* Nokia E52 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0223), }, /* Nokia E72 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0275), }, /* Nokia X6 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x026c), }, /* Nokia N97 Mini */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0154), }, /* Nokia 5800 XpressMusic */
+	{ NOKIA_PCSUITE_ACM_INFO(0x04ce), }, /* Nokia E90 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x01d4), }, /* Nokia E55 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0302), }, /* Nokia N8 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x0335), }, /* Nokia E7 */
+	{ NOKIA_PCSUITE_ACM_INFO(0x03cd), }, /* Nokia C7 */
+	{ SAMSUNG_PCSUITE_ACM_INFO(0x6651), }, /* Samsung GTi8510 (INNOV8) */
+
+	/* Support for Owen devices */
+	{ USB_DEVICE(0x03eb, 0x0030), }, /* Owen SI30 */
+
+	/* NOTE: non-Nokia COMM/ACM/0xff is likely MSFT RNDIS... NOT a modem! */
+
+	/* Support for Droids MuIn LCD */
+	{ USB_DEVICE(0x04d8, 0x000b),
+	.driver_info = NO_DATA_INTERFACE,
+	},
+
+#if IS_ENABLED(CONFIG_INPUT_IMS_PCU)
+	{ USB_DEVICE(0x04d8, 0x0082),	/* Application mode */
+	.driver_info = IGNORE_DEVICE,
+	},
+	{ USB_DEVICE(0x04d8, 0x0083),	/* Bootloader mode */
+	.driver_info = IGNORE_DEVICE,
+	},
+#endif
+
+	/*Samsung phone in firmware update mode */
+	{ USB_DEVICE(0x04e8, 0x685d),
+	.driver_info = IGNORE_DEVICE,
+	},
+
+	/* Exclude Infineon Flash Loader utility */
+	{ USB_DEVICE(0x058b, 0x0041),
+	.driver_info = IGNORE_DEVICE,
+	},
+
+	{ USB_DEVICE(0x1bc7, 0x0021), /* Telit 3G ACM only composition */
+	.driver_info = SEND_ZERO_PACKET,
+	},
+	{ USB_DEVICE(0x1bc7, 0x0023), /* Telit 3G ACM + ECM composition */
+	.driver_info = SEND_ZERO_PACKET,
+	},
+
+	/* control interfaces without any protocol set */
+	{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,
+		USB_CDC_PROTO_NONE) },
+
+	/* control interfaces with various AT-command sets */
+	{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,
+		USB_CDC_ACM_PROTO_AT_V25TER) },
+	{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,
+		USB_CDC_ACM_PROTO_AT_PCCA101) },
+	{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,
+		USB_CDC_ACM_PROTO_AT_PCCA101_WAKE) },
+	{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,
+		USB_CDC_ACM_PROTO_AT_GSM) },
+	{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,
+		USB_CDC_ACM_PROTO_AT_3G) },
+	{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,
+		USB_CDC_ACM_PROTO_AT_CDMA) },
+
+	{ USB_DEVICE(0x1519, 0x0452), /* Intel 7260 modem */
+	.driver_info = SEND_ZERO_PACKET,
+	},
+
+	{ }
+};
+
+MODULE_DEVICE_TABLE(usb, vpu_acm_ids);
+
+static struct usb_driver vpu_acm_driver = {
+	.name =		"vpu_cdc_acm",
+	.probe =	vpu_acm_probe,
+	.disconnect =	vpu_acm_disconnect,
+#ifdef CONFIG_PM
+	.suspend =	vpu_acm_suspend,
+	.resume =	vpu_acm_resume,
+	.reset_resume =	vpu_acm_reset_resume,
+#endif
+	.pre_reset =	vpu_acm_pre_reset,
+	.id_table =	vpu_acm_ids,
+#ifdef CONFIG_PM
+	.supports_autosuspend = 1,
+#endif
+	.disable_hub_initiated_lpm = 1,
+};
+
+/*
+ * Init / exit.
+ */
+
+static int __init vpu_acm_init(void)
+{
+	int retval;
+	retval = usb_register(&vpu_acm_driver);
+
+	return 0;
+}
+
+static void __exit vpu_acm_exit(void)
+{
+	usb_deregister(&vpu_acm_driver);
+	idr_destroy(&vpu_acm_minors);
+}
+
+module_init(vpu_acm_init);
+module_exit(vpu_acm_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_CHARDEV_MAJOR(ACM_TTY_MAJOR);
diff --git a/drivers/misc/xlink-usb/remote_host/vpu-cdc-acm.h b/drivers/misc/xlink-usb/remote_host/vpu-cdc-acm.h
new file mode 100644
index 000000000000..f6da65417858
--- /dev/null
+++ b/drivers/misc/xlink-usb/remote_host/vpu-cdc-acm.h
@@ -0,0 +1,112 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * vpu-cdc-acm.h - XLink USB Remote Host driver
+ *
+ * Copyright (C) 2019 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2, as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef CMSPAR
+#define CMSPAR			0
+#endif
+
+/*
+ * Major and minor numbers.
+ */
+
+#define ACM_TTY_MAJOR		166
+#define ACM_TTY_MINORS		256
+
+/*
+ * Requests.
+ */
+
+#define USB_RT_ACM		(USB_TYPE_CLASS | USB_RECIP_INTERFACE)
+
+/*
+ * Output control lines.
+ */
+
+#define ACM_CTRL_DTR		0x01
+#define ACM_CTRL_RTS		0x02
+
+/*
+ * Input control lines and line errors.
+ */
+
+#define ACM_CTRL_DCD		0x01
+#define ACM_CTRL_DSR		0x02
+#define ACM_CTRL_BRK		0x04
+#define ACM_CTRL_RI		0x08
+
+#define ACM_CTRL_FRAMING	0x10
+#define ACM_CTRL_PARITY		0x20
+#define ACM_CTRL_OVERRUN	0x40
+
+int vpu_write_host (u32 id, const char *buf, size_t *size, unsigned int timeout_ms);
+int vpu_close_host (u32 id);
+int vpu_read_host (u32 id, void *data, size_t *size, unsigned int timeout_ms);
+int usb_get_device_num(uint32_t *id_list);
+int usb_get_device_name_by_id(u32 id, char *device_name, size_t name_size);
+int usb_get_device_status_by_id(u32 id, uint32_t *status);
+int usb_device_reset(u8 cmd);
+int vpu_write_reset_host (u32 id);
+int vpu_close_reset_host (u32 id);
+int usb_connect_device(uint32_t sw_device_id);
+/*
+ * Internal driver structures.
+ */
+
+/*
+ * The only reason to have several buffers is to accommodate assumptions
+ * in line disciplines. They ask for empty space amount, receive our URB size,
+ * and proceed to issue several 1-character writes, assuming they will fit.
+ * The very first write takes a complete URB. Fortunately, this only happens
+ * when processing onlcr, so we only need 2 buffers. These values must be
+ * powers of 2.
+ */
+#define ACM_NW  16
+#define ACM_NR  16
+
+struct acm_wb {
+	unsigned char *buf;
+	dma_addr_t dmah;
+	int len;
+	int use;
+	struct urb		*urb;
+	struct acm		*instance;
+};
+
+struct acm_rb {
+	int			size;
+	unsigned char		*base;
+	dma_addr_t		dma;
+	int			index;
+	struct acm		*instance;
+};
+
+
+
+#define CDC_DATA_INTERFACE_TYPE	0x0a
+
+/* constants describing various quirks and errors */
+#define NO_UNION_NORMAL			BIT(0)
+#define SINGLE_RX_URB			BIT(1)
+#define NO_CAP_LINE			BIT(2)
+#define NO_DATA_INTERFACE		BIT(4)
+#define IGNORE_DEVICE			BIT(5)
+#define QUIRK_CONTROL_LINE_STATE	BIT(6)
+#define CLEAR_HALT_CONDITIONS		BIT(7)
+#define SEND_ZERO_PACKET		BIT(8)
+#define DISABLE_ECHO			BIT(9)
diff --git a/include/linux/xlink_drv_inf.h b/include/linux/xlink_drv_inf.h
new file mode 100644
index 000000000000..e70e51b7a83e
--- /dev/null
+++ b/include/linux/xlink_drv_inf.h
@@ -0,0 +1,91 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Intel Keem Bay XLink PCIe Driver
+ *
+ * Copyright (C) 2021 Intel Corporation
+ */
+
+#ifndef _XLINK_DRV_INF_H_
+#define _XLINK_DRV_INF_H_
+
+#include <linux/bitfield.h>
+#include <linux/bits.h>
+#include <linux/types.h>
+
+#define XLINK_DEV_INF_TYPE_MASK		GENMASK(27, 24)
+#define XLINK_DEV_PCIE_SLICE_ID_MASK	GENMASK(3, 1)
+
+#define XLINK_DEV_INF_TYPE_SHIFT        (24)
+#define XLINK_DEV_INT_TYPE_MASK         (0x7)
+#define XLINK_DEV_PHYS_ID_SHIFT         (8)
+#define XLINK_DEV_PHYS_ID_MASK          (0xFFFF)
+#define XLINK_DEV_TYPE_SHIFT            (4)
+#define XLINK_DEV_TYPE_MASK             (0xF)
+#define XLINK_DEV_SLICE_ID_SHIFT        (1)
+#define XLINK_DEV_SLICE_ID_MASK         (0x7)
+#define XLINK_DEV_FUNC_SHIFT            (0)
+#define XLINK_DEV_FUNC_MASK             (0x1)
+
+#define XLINK_DEV_FUNC_SHIFT		(0)
+#define XLINK_DEV_SLICE_ID_SHIFT	(1)
+#define XLINK_DEV_TYPE_SHIFT		(4)
+#define XLINK_DEV_PHYS_ID_SHIFT		(8)
+#define XLINK_DEV_INF_TYPE_SHIFT	(24)
+
+enum xlink_device_inf_type {
+	XLINK_DEV_INF_PCIE = 1,
+	XLINK_DEV_INF_USB = 2,
+};
+
+enum xlink_device_type {
+	XLINK_DEV_TYPE_KMB = 0,
+	XLINK_DEV_TYPE_THB_PRIME,
+	XLINK_DEV_TYPE_THB_STANDARD
+};
+
+enum xlink_device_pcie_slice {
+	XLINK_DEV_SLICE_0 = 0,
+	XLINK_DEV_SLICE_1,
+	XLINK_DEV_SLICE_2,
+	XLINK_DEV_SLICE_3
+};
+
+enum xlink_device_func {
+	XLINK_DEV_FUNC_VPU = 0,
+	XLINK_DEV_FUNC_MEDIA = 1
+};
+
+enum _xlink_device_status {
+	_XLINK_DEV_OFF,
+	_XLINK_DEV_ERROR,
+	_XLINK_DEV_BUSY,
+	_XLINK_DEV_RECOVERY,
+	_XLINK_DEV_READY
+};
+
+enum xlink_device_event_type {
+	NOTIFY_DEVICE_DISCONNECTED,
+	NOTIFY_DEVICE_CONNECTED,
+	NUM_EVENT_TYPE
+};
+
+typedef int (*xlink_device_event)(u32 sw_device_id,
+				  enum xlink_device_event_type event_type);
+
+int xlink_pcie_get_device_list(u32 *sw_device_id_list,
+			       u32 *num_devices);
+int xlink_pcie_get_device_name(u32 sw_device_id, char *device_name,
+			       size_t name_size);
+int xlink_pcie_get_device_status(u32 sw_device_id,
+				 u32 *device_status);
+int xlink_pcie_boot_device(u32 sw_device_id, const char *binary_name);
+int xlink_pcie_connect(u32 sw_device_id);
+int xlink_pcie_read(u32 sw_device_id, void *data, size_t *const size,
+		    u32 timeout);
+int xlink_pcie_write(u32 sw_device_id, void *data, size_t *const size,
+		     u32 timeout);
+int xlink_pcie_reset_device(u32 sw_device_id);
+int xlink_pcie_register_device_event(u32 sw_device_id,
+				     xlink_device_event event_notif_fn);
+int xlink_pcie_unregister_device_event(u32 sw_device_id);
+#endif
-- 
2.25.1

