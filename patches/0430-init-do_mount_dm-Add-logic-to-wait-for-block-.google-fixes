From af260ce985c9f6ed2f58b13cef1f5ec547a9d102 Mon Sep 17 00:00:00 2001
From: Sathyanarayanan Kuppuswamy <sathyanarayanan.kuppuswamy@intel.com>
Date: Tue, 12 Sep 2017 12:12:17 -0700
Subject: [PATCH 430/434] init: do_mount_dm: Add logic to wait for block device
 enumeration

Calling dm_setup_drives() before the completion of raw block
device enumeration leads to "device lookup failed" error in
dm_table_add_target() function, which in turn leads to incomplete device
mapper configuration for the given block device. Without proper DM
setup, if we try to mount the DM device, it leads to following kernel
panic in mount_root() function due to invalid DM queue setup. This patch
fixes this issue by adding a logic to wait for block device enumeration
to complete before performing the verity checks.

[    0.875069] device-mapper: table: 253:0: verity: Data device lookup failed
[    0.883103] BUG: unable to handle kernel NULL pointer dereference at (null)
[    0.891854] IP:           (null)
[    0.895453] PGD 0
[    0.895454] P4D 0
[    0.897686]
[    0.901574] Oops: 0010 [#1] PREEMPT SMP
[    0.905856] Modules linked in:
[    0.909266] CPU: 1 PID: 1 Comm: swapper/0 Tainted: G     U  W 4.13.0-rc4-quilt-2e5dc0ac #2
[    0.919083] task: ffff968eb6a06040 task.stack: ffff9b9f40010000
[    0.925698] RIP: 0010:          (null)
[    0.929880] RSP: 0000:ffff9b9f40013a30 EFLAGS: 00010246
[    0.935714] RAX: 0000000000000000 RBX: ffff968eb63620c0 RCX: 0000000000000000
[    0.943674] RDX: 0000000000000000 RSI: ffff968eb63620c0 RDI: ffff968eb4a55370
[    0.951649] RBP: ffff9b9f40013a88 R08: 0000000000000001 R09: ffff968eb6362130
[    0.959623] R10: fffff5b2c9d28d00 R11: ffff968eb51fbec0 R12: ffff968eb4a55370
[    0.967586] R13: 00000000ffffffff R14: 0000000000000000 R15: 0000000000000000
[    0.975557] FS:  0000000000000000(0000) GS:ffff968ebfc80000(0000) knlGS:0000000000000000
[    0.984588] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    0.990997] CR2: 0000000000000000 CR3: 0000000185212000 CR4: 00000000003406e0
[    0.998958] Call Trace:
[    1.001692]  ? generic_make_request+0x122/0x320
[    1.006753]  submit_bio+0x73/0x160
[    1.010550]  submit_bh_wbc.isra.44+0x113/0x140
[    1.015518]  __bread_gfp+0x67/0x120
[    1.019414]  ext4_fill_super+0x184/0x3880
[    1.023891]  ? vsnprintf+0x201/0x490
[    1.027885]  ? set_bdev_super+0x30/0x30
[    1.032170]  ? snprintf+0x43/0x60
[    1.035869]  mount_bdev+0x17d/0x1b0
[    1.039762]  ? ext4_calculate_overhead+0x430/0x430
[    1.045113]  ext4_mount+0x15/0x20
[    1.048813]  mount_fs+0x153/0x180
[    1.052513]  vfs_kern_mount+0x90/0x180
[    1.056699]  do_mount+0x1e0/0xd00
[    1.060397]  ? _copy_from_user+0x60/0xb0
[    1.064780]  ? memdup_user+0x53/0x80
[    1.068770]  SyS_mount+0x94/0xd0
[    1.072378]  mount_block_root+0x105/0x2c4
[    1.076857]  mount_root+0x6d/0x71
[    1.080555]  prepare_namespace+0x172/0x19f
[    1.085127]  kernel_init_freeable+0x21f/0x243
[    1.089990]  ? rest_init+0xd0/0xd0
[    1.093777]  kernel_init+0xe/0x100
[    1.097575]  ret_from_fork+0x27/0x40
[    1.101563] Code:  Bad RIP value.
[    1.105266] RIP:           (null) RSP: ffff9b9f40013a30
[    1.111089] CR2: 0000000000000000
[    1.114789] ---[ end trace 7a237ef06917bfe3 ]---
[    1.123581] Kernel panic - not syncing: Fatal exception
[    1.129510] reboot: panic mode set: p,w
[    1.133784] Kernel Offset: 0x25000000 from 0xffffffff81000000
(relocation range: 0xffffffff80000000-0xffffffffbfffffff)

Fixes: e97f06fcd04b ("CHROMIUM: dm: boot time specification of dm=")
Change-Id: I48ac7fc8ac752b4ebac25b8b21267f9ff9ba07bd
Signed-off-by: Sathyanarayanan Kuppuswamy <sathyanarayanan.kuppuswamy@intel.com>
---
 include/linux/device-mapper.h |  5 ++++
 init/do_mounts_dm.c           | 45 +++++++++++++++++++++++++++++++++++
 2 files changed, 50 insertions(+)

diff --git a/include/linux/device-mapper.h b/include/linux/device-mapper.h
index b7b047709918..63974da8c1ba 100644
--- a/include/linux/device-mapper.h
+++ b/include/linux/device-mapper.h
@@ -526,6 +526,11 @@ struct dm_table *dm_swap_table(struct mapped_device *md,
  */
 void *dm_vcalloc(unsigned long nmemb, unsigned long elem_size);
 
+/*
+ * Helper function to parse DM arguments
+ */
+int dm_split_args(int *argc, char ***argvp, char *input);
+
 /*-----------------------------------------------------------------
  * Macros.
  *---------------------------------------------------------------*/
diff --git a/init/do_mounts_dm.c b/init/do_mounts_dm.c
index af84b01ccfbc..cb63c625fd0a 100644
--- a/init/do_mounts_dm.c
+++ b/init/do_mounts_dm.c
@@ -343,6 +343,47 @@ static int __init dm_setup(char *str)
 	return 0;
 }
 
+/* Number of milliseconds to wait before checking for drive status */
+#define DM_DRIVE_WAIT			20
+/* Number of tries allowed to wait for DM drive, before timeout */
+#define DM_DRIVE_RETRY_COUNT		100
+
+static int __init dm_wait_for_drive(char *params)
+{
+	char *dm_params;
+	int ret, argc = 0, try = 0;
+	char **argv;
+	dev_t dm_dev;
+
+	dm_params = kstrndup(params, strlen(params), GFP_KERNEL);
+	if (!dm_params)
+		return -ENOMEM;
+
+	ret = dm_split_args(&argc, &argv, dm_params);
+	if (ret || argc < 2) {
+		DMDEBUG("failed to get dm params");
+		goto free_dm_params;
+	}
+
+	dm_dev = dm_get_dev_t(argv[1]);
+	while (!dm_dev && try++ < DM_DRIVE_RETRY_COUNT) {
+		DMDEBUG("Waiting for device %s\n", argv[1]);
+		msleep(DM_DRIVE_WAIT);
+		dm_dev = dm_get_dev_t(argv[1]);
+	}
+
+	if (!dm_dev) {
+		ret = -ENODEV;
+		goto free_dm_params;
+	}
+
+	DMDEBUG("Device %s found\n", argv[1]);
+
+free_dm_params:
+	kfree(dm_params);
+	return ret;
+}
+
 static void __init dm_setup_drives(void)
 {
 	struct mapped_device *md = NULL;
@@ -382,6 +423,10 @@ static void __init dm_setup_drives(void)
 			       (unsigned long long) target->begin,
 			       (unsigned long long) target->length,
 			       target->type, target->params);
+
+			if (dm_wait_for_drive(target->params))
+				goto add_target_fail;
+
 			if (dm_table_add_target(table, target->type,
 						target->begin,
 						target->length,
-- 
2.19.1

