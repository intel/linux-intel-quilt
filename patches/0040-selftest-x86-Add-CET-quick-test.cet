From d409d737774089ba05e509ed068197c6b51540b2 Mon Sep 17 00:00:00 2001
From: Yu-cheng Yu <yu-cheng.yu@intel.com>
Date: Wed, 20 May 2020 15:38:29 -0700
Subject: [PATCH 40/43] selftest/x86: Add CET quick test

Introduce a quick test to verify shadow stack and IBT are working.

Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>

v2:
- Rewrite assembly code and remove compiler conditionals.
- Update return code to include 'not_tested'.
- Verify in segv_handler the fault is a control-protection fault, otherwise
  exit the test.
- Use only one user signal SIGUSR1.
---
 tools/testing/selftests/x86/Makefile         |   5 +
 tools/testing/selftests/x86/cet_quick_test.c | 148 +++++++++++++++++++
 2 files changed, 153 insertions(+)
 create mode 100644 tools/testing/selftests/x86/cet_quick_test.c

diff --git a/tools/testing/selftests/x86/Makefile b/tools/testing/selftests/x86/Makefile
index 88c5f723039d..74105beb41eb 100644
--- a/tools/testing/selftests/x86/Makefile
+++ b/tools/testing/selftests/x86/Makefile
@@ -19,6 +19,11 @@ TARGETS_C_32BIT_ONLY := entry_from_vm86 test_syscall_vdso unwind_vdso \
 			test_FCMOV test_FCOMI test_FISTTP \
 			vdso_restorer
 TARGETS_C_64BIT_ONLY := fsgsbase sysret_rip syscall_numbering
+
+ifeq ($(CAN_BUILD_CET),1)
+TARGETS_C_BOTHBITS += cet_quick_test
+endif
+
 # Some selftests require 32bit support enabled also on 64bit systems
 TARGETS_C_32BIT_NEEDED := ldt_gdt ptrace_syscall
 
diff --git a/tools/testing/selftests/x86/cet_quick_test.c b/tools/testing/selftests/x86/cet_quick_test.c
new file mode 100644
index 000000000000..8480cf303a3b
--- /dev/null
+++ b/tools/testing/selftests/x86/cet_quick_test.c
@@ -0,0 +1,148 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/* Quick tests to verify Shadow Stack and IBT are working */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <string.h>
+#include <ucontext.h>
+
+ucontext_t ucp;
+
+enum {
+	r_not_tested = -1,
+	r_fail = 0,
+	r_ok = 1,
+};
+
+int result[4] = {r_not_tested, r_not_tested, r_not_tested, r_not_tested};
+int test_id;
+
+/* Defined in include/uapi/asm-generic/siginfo.h */
+#define SEGV_CPERR 8
+
+/*
+ * Do an indirect jmp to a location without endbr to trigger a control
+ * protection fault.  Verify in segv_handler that ibt is working.
+ */
+void ibt_violation(void)
+{
+	void *ptr;
+
+	asm volatile("lea 1f, %0\n\t"
+		     "jmp *%0\n\t"
+		     "1:" : "=r"(ptr));
+
+	result[test_id] = r_fail;
+	test_id++;
+	setcontext(&ucp);
+}
+
+/*
+ * Do a push and ret to cause shadow stack mismatch and trigger a control
+ * protection fault.  Verify in segv_handler that shadow stack is working.
+ */
+void shstk_violation(void)
+{
+	void *ptr;
+
+	asm volatile("lea 1f, %0\n\t"
+		     "push %0\n\t"
+		     "ret\n\t"
+		     "1:" : "=r"(ptr));
+
+	result[test_id] = r_fail;
+	test_id++;
+	setcontext(&ucp);
+}
+
+void segv_handler(int signum, siginfo_t *si, void *uc)
+{
+	if (si->si_code == SEGV_CPERR) {
+		result[test_id] = r_ok;
+		test_id++;
+	} else {
+		printf("Unexpected seg fault\n");
+		exit(1);
+	}
+
+	setcontext(&ucp);
+}
+
+/*
+ * Verify shadow stack and ibt are working in a signal handler.
+ */
+void user1_handler(int signum, siginfo_t *si, void *uc)
+{
+	if (test_id == 2)
+		shstk_violation();
+
+	if (test_id == 3)
+		ibt_violation();
+}
+
+int main(int argc, char *argv[])
+{
+	struct sigaction sa;
+	int r;
+
+	r = sigemptyset(&sa.sa_mask);
+	if (r)
+		return -1;
+
+	sa.sa_flags = SA_SIGINFO;
+
+	/*
+	 * Control protection fault handler
+	 */
+	sa.sa_sigaction = segv_handler;
+	r = sigaction(SIGSEGV, &sa, NULL);
+	if (r)
+		return -1;
+
+	/*
+	 * Test shadow stack/ibt in signal handler
+	 */
+	sa.sa_sigaction = user1_handler;
+	r = sigaction(SIGUSR1, &sa, NULL);
+	if (r)
+		return -1;
+
+	test_id = 0;
+
+	/*
+	 * Pass or fail, each test returns here with test_id incremented to
+	 * the next test.
+	 */
+	r = getcontext(&ucp);
+	if (r)
+		return -1;
+
+	if (test_id == 0)
+		shstk_violation();
+	else if (test_id == 1)
+		ibt_violation();
+	else if (test_id == 2)
+		raise(SIGUSR1);
+	else if (test_id == 3)
+		raise(SIGUSR1);
+
+	r = 0;
+	printf("[%s]\tShadow stack\n", result[0] == -1 ? "untested" :
+	       (result[0] ? "OK" : "FAIL"));
+	r += result[0];
+
+	printf("[%s]\tIBT\n", result[1] == -1 ? "untested" :
+	       (result[1] ? "OK" : "FAIL"));
+	r += result[1];
+
+	printf("[%s]\tShadow stack in signal\n", result[2] == -1 ? "untested" :
+	       (result[2] ? "OK" : "FAIL"));
+	r += result[2];
+
+	printf("[%s]\tIBT in signal\n", result[3] == -1 ? "untested" :
+	       (result[3] ? "OK" : "FAIL"));
+	r += result[3];
+
+	return r;
+}
-- 
2.27.0

