From 6507bc70a4ef5b7c85e0f660874a4791f34c8d95 Mon Sep 17 00:00:00 2001
From: "Dutta, Ranjan" <ranjan.dutta@intel.com>
Date: Mon, 23 Mar 2020 16:26:25 +0530
Subject: [PATCH 1225/1225] Fix merge issues for rt45

Signed-off-by: Dutta, Ranjan <ranjan.dutta@intel.com>
---
 include/linux/kthread.h           |   2 +-
 net/netlabel/netlabel_kapi.c      |   2 +-
 net/netlabel/netlabel_unlabeled.c |  13 +-
 net/netlabel/netlabel_user.h      |   2 +-
 net/xfrm/xfrm_policy.c            |   2 +-
 security/security.c               | 730 +++++++++++++++++++-------------------
 security/selinux/hooks.c          |   8 -
 security/selinux/include/objsec.h |  11 -
 8 files changed, 368 insertions(+), 402 deletions(-)

Index: b/include/linux/kthread.h
===================================================================
--- a/include/linux/kthread.h
+++ b/include/linux/kthread.h
@@ -208,7 +208,7 @@ struct cgroup_subsys_state *kthread_blkc
 static inline void kthread_associate_blkcg(struct cgroup_subsys_state *css) { }
 static inline struct cgroup_subsys_state *kthread_blkcg(void)
 {
-	return NULL;
+        return NULL;
 }
 #endif
 #endif /* _LINUX_KTHREAD_H */
Index: b/net/netlabel/netlabel_kapi.c
===================================================================
--- a/net/netlabel/netlabel_kapi.c
+++ b/net/netlabel/netlabel_kapi.c
@@ -244,7 +244,7 @@ int netlbl_cfg_unlbl_static_add(struct n
 
 	return netlbl_unlhsh_add(net,
 				 dev_name, addr, mask, addr_len,
-				 secid->common, audit_info);
+				 secid, audit_info);
 }
 
 /**
Index: b/net/netlabel/netlabel_unlabeled.c
===================================================================
--- a/net/netlabel/netlabel_unlabeled.c
+++ b/net/netlabel/netlabel_unlabeled.c
@@ -389,7 +389,6 @@ int netlbl_unlhsh_add(struct net *net,
 	struct audit_buffer *audit_buf = NULL;
 	char *secctx = NULL;
 	u32 secctx_len;
-	struct secids ids;
 
 	if (addr_len != sizeof(struct in_addr) &&
 	    addr_len != sizeof(struct in6_addr))
@@ -422,8 +421,7 @@ int netlbl_unlhsh_add(struct net *net,
 		const struct in_addr *addr4 = addr;
 		const struct in_addr *mask4 = mask;
 
-		ids.common = secid;
-		ret_val = netlbl_unlhsh_add_addr4(iface, addr4, mask4, &ids);
+		ret_val = netlbl_unlhsh_add_addr4(iface, addr4, mask4, secid);
 		if (audit_buf != NULL)
 			netlbl_af4list_audit_addr(audit_buf, 1,
 						  dev_name,
@@ -436,8 +434,7 @@ int netlbl_unlhsh_add(struct net *net,
 		const struct in6_addr *addr6 = addr;
 		const struct in6_addr *mask6 = mask;
 
-		ids.common = secid;
-		ret_val = netlbl_unlhsh_add_addr6(iface, addr6, mask6, &ids);
+		ret_val = netlbl_unlhsh_add_addr6(iface, addr6, mask6, secid);
 		if (audit_buf != NULL)
 			netlbl_af6list_audit_addr(audit_buf, 1,
 						  dev_name,
@@ -1128,7 +1125,7 @@ static int netlbl_unlabel_staticlist_gen
 		if (ret_val != 0)
 			goto list_cb_failure;
 
-		secid = addr4->secid.common;
+		secid = addr4->secid;
 	} else {
 		ret_val = nla_put_in6_addr(cb_arg->skb,
 					   NLBL_UNLABEL_A_IPV6ADDR,
@@ -1142,7 +1139,7 @@ static int netlbl_unlabel_staticlist_gen
 		if (ret_val != 0)
 			goto list_cb_failure;
 
-		secid = addr6->secid.common;
+		secid = addr6->secid;
 	}
 
 	ret_val = security_secid_to_secctx(&secid, &secctx, &secctx_len);
@@ -1554,7 +1551,7 @@ int __init netlbl_unlabel_defconf(void)
 	/* Only the kernel is allowed to call this function and the only time
 	 * it is called is at bootup before the audit subsystem is reporting
 	 * messages so don't worry to much about these values. */
-	security_task_getsecid(current, &audit_info.secid.common);
+	security_task_getsecid(current, &audit_info.secid);
 	audit_info.loginuid = GLOBAL_ROOT_UID;
 	audit_info.sessionid = 0;
 
Index: b/net/netlabel/netlabel_user.h
===================================================================
--- a/net/netlabel/netlabel_user.h
+++ b/net/netlabel/netlabel_user.h
@@ -48,7 +48,7 @@
 static inline void netlbl_netlink_auditinfo(struct sk_buff *skb,
 					    struct netlbl_audit *audit_info)
 {
-	security_task_getsecid(current, &audit_info->secid.common);
+	security_task_getsecid(current, &audit_info->secid);
 	audit_info->loginuid = audit_get_loginuid(current);
 	audit_info->sessionid = audit_get_sessionid(current);
 }
Index: b/net/xfrm/xfrm_policy.c
===================================================================
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@ -2299,7 +2299,7 @@ int __xfrm_decode_session(struct sk_buff
 
 	afinfo->decode_session(skb, fl, reverse);
 
-	err = security_xfrm_decode_session(skb, &fl->flowi_secid.common);
+	err = security_xfrm_decode_session(skb, &fl->flowi_secid);
 	rcu_read_unlock();
 	return err;
 }
Index: b/security/security.c
===================================================================
--- a/security/security.c
+++ b/security/security.c
@@ -1540,10 +1540,7 @@ EXPORT_SYMBOL(security_cred_getsecid);
 
 int security_kernel_act_as(struct cred *new, struct secids *secid)
 {
-	struct secids ids;
-
-	ids.common = secid;
-	return call_int_hook(kernel_act_as, 0, new, &ids);
+	return call_int_hook(kernel_act_as, 0, new, secid);
 }
 
 int security_kernel_create_files_as(struct cred *new, struct inode *inode)
@@ -2487,10 +2484,7 @@ int security_xfrm_state_alloc_acquire(st
 				      struct xfrm_sec_ctx *polsec,
 				      struct secids *secid)
 {
-	struct secids ids;
-
-	ids.common = secid;
-	return call_int_hook(xfrm_state_alloc_acquire, 0, x, polsec, &ids);
+	return call_int_hook(xfrm_state_alloc_acquire, 0, x, polsec, secid);
 }
 
 int security_xfrm_state_delete(struct xfrm_state *x)
@@ -2507,10 +2501,7 @@ void security_xfrm_state_free(struct xfr
 int security_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx,
 					struct secids *fl_secid, u8 dir)
 {
-	struct secids ids;
-
-	ids.common = fl_secid;
-	return call_int_hook(xfrm_policy_lookup, 0, ctx, &ids, dir);
+	return call_int_hook(xfrm_policy_lookup, 0, ctx, fl_secid, dir);
 }
 
 int security_xfrm_state_pol_flow_match(struct xfrm_state *x,
@@ -2612,10 +2603,7 @@ void security_audit_rule_free(void *lsmr
 int security_audit_rule_match(struct secids *secid, u32 field, u32 op,
 			      void *lsmrule, struct audit_context *actx)
 {
-	struct secids ids;
-
-	ids.common = secid;
-	return call_int_hook(audit_rule_match, 0, &ids, field, op, lsmrule,
+	return call_int_hook(audit_rule_match, 0, secid, field, op, lsmrule,
 				actx);
 }
 #endif /* CONFIG_AUDIT */
Index: b/security/selinux/hooks.c
===================================================================
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -331,14 +331,6 @@ static struct inode_security_struct *bac
 	return selinux_inode(inode);
 }
 
-static void inode_free_rcu(struct rcu_head *head)
-{
-	struct inode_security_struct *isec;
-
-	isec = container_of(head, struct inode_security_struct, rcu);
-	kmem_cache_free(sel_inode_cache, isec);
-}
-
 static void inode_free_security(struct inode *inode)
 {
 	struct inode_security_struct *isec = selinux_inode(inode);
Index: b/security/selinux/include/objsec.h
===================================================================
--- a/security/selinux/include/objsec.h
+++ b/security/selinux/include/objsec.h
@@ -237,15 +237,4 @@ static inline struct sk_security_struct
 #endif
 }
 
-static inline struct inode_security_struct *selinux_inode(
-						const struct inode *inode)
-{
-	return inode->i_security;
-}
-
-static inline struct sk_security_struct *selinux_sock(const struct sock *sock)
-{
-	return sock->sk_security;
-}
-
 #endif /* _SELINUX_OBJSEC_H_ */
