From e4c93d1dc0818fa97e3ff7905e1170a8049380f3 Mon Sep 17 00:00:00 2001
From: "Wong, Vee Khee" <vee.khee.wong@intel.com>
Date: Tue, 18 Feb 2020 21:16:04 +0800
Subject: [PATCH 44/44] net: stmmac: Adjust PSE ART value to match PMC ART

For PSE GbE interface, it has a Always Running Timer(ART) that runs at
a different frequency compared to the PMC ART. This eventually will
cause a wrong ART value being passed to the kernel to perform TSC
calculation for crosstimestamping.

An adjustment to the PSE ART is introduced based on the ratio of PMC
ART frequency obtained from CPU LEAF 15H:[ECX].

Signed-off-by: Wong, Vee Khee <vee.khee.wong@intel.com>
Signed-off-by: Voon Weifeng <weifeng.voon@intel.com>
---
 .../net/ethernet/stmicro/stmmac/stmmac_pci.c  | 22 +++++++++++++++++++
 .../net/ethernet/stmicro/stmmac/stmmac_ptp.c  |  7 ++++++
 include/linux/stmmac.h                        |  2 ++
 3 files changed, 31 insertions(+)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
index 7e3a7edccc66..4018f8e18d3e 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -393,7 +393,18 @@ static void ehl_pse_work_around(struct pci_dev *pdev,
 static int ehl_pse0_common_data(struct pci_dev *pdev,
 				struct plat_stmmacenet_data *plat)
 {
+	if (boot_cpu_has(X86_FEATURE_ART)) {
+		unsigned int unused[3], ecx_pmc_art_freq;
+		/* Elkhart Lake PSE ART is 19.2MHz */
+		int pse_art_freq = 19200000;
+
+		cpuid(0x15, unused, unused + 1, &ecx_pmc_art_freq, unused + 2);
+		plat->pmc_art_to_pse_art_ratio = ecx_pmc_art_freq /
+						 pse_art_freq;
+	}
+
 	plat->phy_addr = 1;
+	plat->is_pse = 1;
 	ehl_pse_work_around(pdev, plat);
 
 	if (plat->is_hfpga)
@@ -442,7 +453,18 @@ static struct stmmac_pci_info ehl_pse0_sgmii1g_pci_info = {
 static int ehl_pse1_common_data(struct pci_dev *pdev,
 				struct plat_stmmacenet_data *plat)
 {
+	if (boot_cpu_has(X86_FEATURE_ART)) {
+		unsigned int unused[3], ecx_pmc_art_freq;
+		/* Elkhart Lake PSE ART is 19.2MHz */
+		int pse_art_freq = 19200000;
+
+		cpuid(0x15, unused, unused + 1, &ecx_pmc_art_freq, unused + 2);
+		plat->pmc_art_to_pse_art_ratio = ecx_pmc_art_freq /
+						 pse_art_freq;
+	}
+
 	plat->phy_addr = 1;
+	plat->is_pse = 1;
 	ehl_pse_work_around(pdev, plat);
 
 	if (plat->is_hfpga)
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c
index 433a171bf264..d38d58b7ad9a 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c
@@ -284,6 +284,13 @@ static int stmmac_get_syncdevicetime(ktime_t *device,
 		*system = convert_art_to_tsc(art_time);
 	}
 
+	/* In the case of PSE Local ART, it might be running different frequency
+	 * compared to the PMC ART, so we will need to perform a multiplication
+	 * to match the PMC ART frequency.
+	 */
+	if (priv->plat->is_pse)
+		system->cycles *= priv->plat->pmc_art_to_pse_art_ratio;
+
 	return 0;
 }
 
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
index cb5a9aa2321e..8f0830713839 100644
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -230,11 +230,13 @@ struct plat_stmmacenet_data {
 	u32 ftos;
 	u32 fgos;
 	bool has_art;
+	int pmc_art_to_pse_art_ratio;
 	int int_snapshot_num;
 	int ext_snapshot_num;
 	int ext_snapshot_en;
 	bool has_safety_feat;
 	bool is_hfpga;
+	bool is_pse;
 	bool ehl_ao_wa;
 	bool serdes_pse_sgmii_wa;
 	/* TX and RX PHY latency (ns) */
-- 
2.17.1

