From 2dfea8867d61be3e47bf7944c7742938fd3d26b1 Mon Sep 17 00:00:00 2001
From: Ong Boon Leong <boon.leong.ong@intel.com>
Date: Tue, 19 May 2020 22:57:09 +0800
Subject: [PATCH 03/78] net: stmmac: add TX HW Time-stamping error fallback
 mode

It is possible that the returned T/S is not valid due to descriptor error.
So, we add check for detecting descriptor error in write-back Tx
descriptor.

If HW TX TS is not valid, it is still better to get the current PTP clock
to approximate the TX frame TS instead of not updating the TS which may
be used by caller as stale and old TS from the past descriptor and cause
issue to application.

Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
---
 drivers/net/ethernet/stmicro/stmmac/dwmac4_descs.c |  6 ++++++
 drivers/net/ethernet/stmicro/stmmac/dwmac4_descs.h |  1 +
 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c  | 10 +++++++++-
 3 files changed, 16 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4_descs.c b/drivers/net/ethernet/stmicro/stmmac/dwmac4_descs.c
index f289b06b47e6..e596610bee77 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_descs.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_descs.c
@@ -227,6 +227,12 @@ static int dwmac4_wrback_get_tx_timestamp_status(struct dma_desc *p)
 	if (le32_to_cpu(p->des3) & TDES3_CONTEXT_TYPE)
 		return 0;
 
+	/* Check for descriptor error
+	 * TODO: See if need to check against other descriptor error bits.
+	 */
+	if (le32_to_cpu(p->des3) & TDES3_DESC_ERR)
+		return 0;
+
 	/* Tx Timestamp Status is 1 so des0 and des1'll have valid values */
 	if (le32_to_cpu(p->des3) & TDES3_TIMESTAMP_STATUS)
 		return 1;
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4_descs.h b/drivers/net/ethernet/stmicro/stmmac/dwmac4_descs.h
index f504b522a891..bc115cac4ced 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_descs.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_descs.h
@@ -60,6 +60,7 @@
 #define TDES3_ERROR_SUMMARY		BIT(15)
 #define TDES3_TIMESTAMP_STATUS		BIT(17)
 #define TDES3_TIMESTAMP_STATUS_SHIFT	17
+#define TDES3_DESC_ERR			BIT(23)
 
 /* TDES3 context */
 #define TDES3_CTXT_TCMSSV		BIT(26)
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 6c9eadc32b80..47d359d5a44b 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -458,6 +458,7 @@ bool stmmac_eee_init(struct stmmac_priv *priv)
 void stmmac_get_tx_hwtstamp(struct stmmac_priv *priv,
 			    struct dma_desc *p, ktime_t *hwtstamp)
 {
+	void __iomem *ptpaddr = priv->ptpaddr;
 	bool found = false;
 	u64 adjust = 0;
 	u64 ns = 0;
@@ -497,9 +498,16 @@ void stmmac_get_tx_hwtstamp(struct stmmac_priv *priv,
 		adjust += -(2 * (NSEC_PER_SEC / priv->plat->clk_ptp_rate));
 
 		ns += adjust;
-		*hwtstamp = ns_to_ktime(ns);
 		netdev_dbg(priv->dev, "get valid TX hw timestamp %llu\n", ns);
+	} else {
+		netdev_dbg(priv->dev, "cannot get TX hw timestamp\n");
+		/* TX HW T/S invalid, fallback to current PTP time instead
+		 * of not updating hwtstamp (which can be valid stale data
+		 * from past)
+		 */
+		stmmac_get_systime(priv, ptpaddr, &ns);
 	}
+	*hwtstamp = ns_to_ktime(ns);
 }
 
 /* stmmac_get_rx_hwtstamp - get HW RX timestamps
-- 
2.17.1

