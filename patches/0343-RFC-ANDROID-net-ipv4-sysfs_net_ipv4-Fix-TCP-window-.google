From 60c1e5cb8fad4bd5ec5d01cef1587c2d310dc5b7 Mon Sep 17 00:00:00 2001
From: Amit Pundir <amit.pundir@linaro.org>
Date: Mon, 8 Jan 2018 22:55:09 +0530
Subject: [PATCH 343/431] RFC: ANDROID: net: ipv4: sysfs_net_ipv4: Fix TCP
 window size controlling knobs

Refactor /sys/kernel/ipv4/tcp_* send/receive window size controlling
knobs to align with the changes of upstream commit 356d1833b638
("tcp: Namespace-ify sysctl_tcp_rmem and sysctl_tcp_wmem").

Fixes: ("ANDROID: net: ipv4: sysfs_net_ipv4: Add sysfs-based knobs for controlling TCP window size")
Signed-off-by: Amit Pundir <amit.pundir@linaro.org>
---
 include/net/tcp.h         |  2 +-
 net/ipv4/sysfs_net_ipv4.c | 12 ++++++------
 net/ipv4/tcp_input.c      |  2 +-
 net/ipv4/tcp_output.c     |  6 +++---
 4 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/include/net/tcp.h b/include/net/tcp.h
index cd3ecda9..26d9d5d 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -1275,7 +1275,7 @@ static inline void tcp_sack_reset(struct tcp_options_received *rx_opt)
 	rx_opt->num_sacks = 0;
 }
 
-u32 tcp_default_init_rwnd(u32 mss);
+u32 tcp_default_init_rwnd(const struct sock *sk, u32 mss);
 void tcp_cwnd_restart(struct sock *sk, s32 delta);
 
 static inline void tcp_slow_start_after_idle_check(struct sock *sk)
diff --git a/net/ipv4/sysfs_net_ipv4.c b/net/ipv4/sysfs_net_ipv4.c
index 0cbbf10..35a651aa 100644
--- a/net/ipv4/sysfs_net_ipv4.c
+++ b/net/ipv4/sysfs_net_ipv4.c
@@ -45,13 +45,13 @@ static ssize_t _name##_store(struct kobject *kobj, \
 static struct kobj_attribute _name##_attr = \
 	__ATTR(_name, 0644, _name##_show, _name##_store)
 
-CREATE_IPV4_FILE(tcp_wmem_min, sysctl_tcp_wmem[0]);
-CREATE_IPV4_FILE(tcp_wmem_def, sysctl_tcp_wmem[1]);
-CREATE_IPV4_FILE(tcp_wmem_max, sysctl_tcp_wmem[2]);
+CREATE_IPV4_FILE(tcp_wmem_min, init_net.ipv4.sysctl_tcp_wmem[0]);
+CREATE_IPV4_FILE(tcp_wmem_def, init_net.ipv4.sysctl_tcp_wmem[1]);
+CREATE_IPV4_FILE(tcp_wmem_max, init_net.ipv4.sysctl_tcp_wmem[2]);
 
-CREATE_IPV4_FILE(tcp_rmem_min, sysctl_tcp_rmem[0]);
-CREATE_IPV4_FILE(tcp_rmem_def, sysctl_tcp_rmem[1]);
-CREATE_IPV4_FILE(tcp_rmem_max, sysctl_tcp_rmem[2]);
+CREATE_IPV4_FILE(tcp_rmem_min, init_net.ipv4.sysctl_tcp_rmem[0]);
+CREATE_IPV4_FILE(tcp_rmem_def, init_net.ipv4.sysctl_tcp_rmem[1]);
+CREATE_IPV4_FILE(tcp_rmem_max, init_net.ipv4.sysctl_tcp_rmem[2]);
 
 static struct attribute *ipv4_attrs[] = {
 	&tcp_wmem_min_attr.attr,
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index f9dcb29..0d6d8f8 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -432,7 +432,7 @@ static void tcp_fixup_rcvbuf(struct sock *sk)
 	int rcvmem;
 
 	rcvmem = 2 * SKB_TRUESIZE(mss + MAX_TCP_HEADER) *
-		 tcp_default_init_rwnd(mss);
+		 tcp_default_init_rwnd(sk, mss);
 
 	/* Dynamic Right Sizing (DRS) has 2 to 3 RTT latency
 	 * Allow enough cushion so that sender is not limited by our window
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index d1db053..89401d3 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -180,14 +180,14 @@ static inline void tcp_event_ack_sent(struct sock *sk, unsigned int pkts,
 }
 
 
-u32 tcp_default_init_rwnd(u32 mss)
+u32 tcp_default_init_rwnd(const struct sock *sk, u32 mss)
 {
 	/* Initial receive window should be twice of TCP_INIT_CWND to
 	 * enable proper sending of new unsent data during fast recovery
 	 * (RFC 3517, Section 4, NextSeg() rule (2)). Further place a
 	 * limit when mss is larger than 1460.
 	 */
-	u32 init_rwnd = sysctl_tcp_default_init_rwnd;
+	u32 init_rwnd = sock_net(sk)->ipv4.sysctl_tcp_default_init_rwnd;
 
 	if (mss > 1460)
 		init_rwnd = max((1460 * init_rwnd) / mss, 2U);
@@ -243,7 +243,7 @@ void tcp_select_initial_window(const struct sock *sk, int __space, __u32 mss,
 	}
 
 	if (!init_rcv_wnd) /* Use default unless specified otherwise */
-		init_rcv_wnd = tcp_default_init_rwnd(mss);
+		init_rcv_wnd = tcp_default_init_rwnd(sk, mss);
 	*rcv_wnd = min(*rcv_wnd, init_rcv_wnd * mss);
 
 	/* Set the clamp no higher than max representable value */
-- 
2.7.4

