From ad413707f1f7536a7f85786dd0331cbe0d46e2ba Mon Sep 17 00:00:00 2001
From: Amit Pundir <amit.pundir@linaro.org>
Date: Wed, 1 Jun 2016 21:53:20 +0530
Subject: [PATCH 211/351] ANDROID: sdcardfs: use wrappers to access i_mutex
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Use inode_{lock,unlock,lock_nested} wrappers as suggested by upstream
commit 5955102c9984 (wrappers for ->i_mutex access) for access to
->i_mutex, otherwise we run into following build error:

  CC [M]  fs/sdcardfs/dentry.o
In file included from fs/sdcardfs/dentry.c:21:0:
fs/sdcardfs/sdcardfs.h: In function ‘lock_parent’:
fs/sdcardfs/sdcardfs.h:422:33: error: ‘struct inode’ has no member named ‘i_mutex’
  mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_PARENT);
                                 ^
fs/sdcardfs/sdcardfs.h: In function ‘unlock_dir’:
fs/sdcardfs/sdcardfs.h:428:28: error: ‘struct inode’ has no member named ‘i_mutex’
  mutex_unlock(&d_inode(dir)->i_mutex);
                            ^
In file included from ./include/linux/fs.h:19:0,
                 from fs/sdcardfs/sdcardfs.h:31,
                 from fs/sdcardfs/dentry.c:21:
fs/sdcardfs/sdcardfs.h: In function ‘prepare_dir’:
fs/sdcardfs/sdcardfs.h:457:27: error: ‘struct inode’ has no member named ‘i_mutex’
  mutex_lock(&d_inode(dent)->i_mutex);
                           ^
./include/linux/mutex.h:146:44: note: in definition of macro ‘mutex_lock’
 #define mutex_lock(lock) mutex_lock_nested(lock, 0)
                                            ^
In file included from fs/sdcardfs/dentry.c:21:0:
fs/sdcardfs/sdcardfs.h:459:29: error: ‘struct inode’ has no member named‘i_mutex’
  mutex_unlock(&d_inode(dent)->i_mutex);
                             ^
fs/sdcardfs/sdcardfs.h:466:38: error: ‘struct inode’ has no member named ‘i_mutex’
  mutex_unlock(&d_inode(parent.dentry)->i_mutex);
                                      ^

Change-Id: I4c8298045ac511aba5542d9ca967331f550376a5
Signed-off-by: Amit Pundir <amit.pundir@linaro.org>
---
 fs/sdcardfs/inode.c    |  4 ++--
 fs/sdcardfs/lookup.c   |  6 +++---
 fs/sdcardfs/sdcardfs.h | 10 +++++-----
 3 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/fs/sdcardfs/inode.c b/fs/sdcardfs/inode.c
index 1b8f068987c7..bd8a70185147 100644
--- a/fs/sdcardfs/inode.c
+++ b/fs/sdcardfs/inode.c
@@ -807,10 +807,10 @@ static int sdcardfs_setattr(struct vfsmount *mnt, struct dentry *dentry, struct
 	 * unlinked (no inode->i_sb and i_ino==0.  This happens if someone
 	 * tries to open(), unlink(), then ftruncate() a file.
 	 */
-	mutex_lock(&d_inode(lower_dentry)->i_mutex);
+	inode_lock(d_inode(lower_dentry));
 	err = notify_change2(lower_mnt, lower_dentry, &lower_ia, /* note: lower_ia */
 			NULL);
-	mutex_unlock(&d_inode(lower_dentry)->i_mutex);
+	inode_unlock(d_inode(lower_dentry));
 	if (current->mm)
 		up_write(&current->mm->mmap_sem);
 	if (err)
diff --git a/fs/sdcardfs/lookup.c b/fs/sdcardfs/lookup.c
index e94a65c8bbbd..d9d46308ef94 100644
--- a/fs/sdcardfs/lookup.c
+++ b/fs/sdcardfs/lookup.c
@@ -244,7 +244,7 @@ static struct dentry *__sdcardfs_lookup(struct dentry *dentry,
 	if (err == -ENOENT) {
 		struct dentry *child;
 		struct dentry *match = NULL;
-		mutex_lock(&d_inode(lower_dir_dentry)->i_mutex);
+		inode_lock(d_inode(lower_dir_dentry));
 		spin_lock(&lower_dir_dentry->d_lock);
 		list_for_each_entry(child, &lower_dir_dentry->d_subdirs, d_child) {
 			if (child && d_inode(child)) {
@@ -255,7 +255,7 @@ static struct dentry *__sdcardfs_lookup(struct dentry *dentry,
 			}
 		}
 		spin_unlock(&lower_dir_dentry->d_lock);
-		mutex_unlock(&d_inode(lower_dir_dentry)->i_mutex);
+		inode_unlock(d_inode(lower_dir_dentry));
 		if (match) {
 			err = vfs_path_lookup(lower_dir_dentry,
 						lower_dir_mnt,
@@ -344,7 +344,7 @@ static struct dentry *__sdcardfs_lookup(struct dentry *dentry,
  * On fail (== error)
  * 	returns error ptr
  *
- * @dir : Parent inode. It is locked (dir->i_mutex)
+ * @dir : Parent inode.
  * @dentry : Target dentry to lookup. we should set each of fields.
  *	     (dentry->d_name is initialized already)
  * @nd : nameidata of parent inode
diff --git a/fs/sdcardfs/sdcardfs.h b/fs/sdcardfs/sdcardfs.h
index b03130329014..66a97ef8d261 100644
--- a/fs/sdcardfs/sdcardfs.h
+++ b/fs/sdcardfs/sdcardfs.h
@@ -465,13 +465,13 @@ extern int setup_obb_dentry(struct dentry *dentry, struct path *lower_path);
 static inline struct dentry *lock_parent(struct dentry *dentry)
 {
 	struct dentry *dir = dget_parent(dentry);
-	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_PARENT);
+	inode_lock_nested(d_inode(dir), I_MUTEX_PARENT);
 	return dir;
 }
 
 static inline void unlock_dir(struct dentry *dir)
 {
-	mutex_unlock(&d_inode(dir)->i_mutex);
+	inode_unlock(d_inode(dir));
 	dput(dir);
 }
 
@@ -500,16 +500,16 @@ static inline int prepare_dir(const char *path_s, uid_t uid, gid_t gid, mode_t m
 	attrs.ia_uid = make_kuid(&init_user_ns, uid);
 	attrs.ia_gid = make_kgid(&init_user_ns, gid);
 	attrs.ia_valid = ATTR_UID | ATTR_GID;
-	mutex_lock(&d_inode(dent)->i_mutex);
+	inode_lock(d_inode(dent));
 	notify_change2(parent.mnt, dent, &attrs, NULL);
-	mutex_unlock(&d_inode(dent)->i_mutex);
+	inode_unlock(d_inode(dent));
 
 out_dput:
 	dput(dent);
 
 out_unlock:
 	/* parent dentry locked by lookup_create */
-	mutex_unlock(&d_inode(parent.dentry)->i_mutex);
+	inode_unlock(d_inode(parent.dentry));
 	path_put(&parent);
 	return err;
 }
-- 
2.17.1

