From 28b171d4c2069ff07e894e05ca8d28a8dde8ffee Mon Sep 17 00:00:00 2001
From: Cezary Rojewski <cezary.rojewski@intel.com>
Date: Wed, 8 May 2019 19:08:44 +0200
Subject: [PATCH 010/154] ASoC: Intel: Save reply header when processing IRQ

Reply header may contain some vital information including, but not
limited to, received payload size. Content is context dependent and may
vary between firmware versions and target platform. Rather than
specifying some returned values explicitly e.g. said size, return entire
reply and let caller decide.

Change-Id: Idb49753340ca412b83abe49bb092a355e7c40362
Signed-off-by: Cezary Rojewski <cezary.rojewski@intel.com>
---
 sound/soc/intel/baytrail/sst-baytrail-ipc.c |  8 ++--
 sound/soc/intel/common/sst-ipc.c            | 23 ++++++-----
 sound/soc/intel/common/sst-ipc.h            |  7 +++-
 sound/soc/intel/haswell/sst-haswell-ipc.c   | 26 ++++++------
 sound/soc/intel/skylake/skl-sst-ipc.c       | 44 ++++++++++++---------
 5 files changed, 64 insertions(+), 44 deletions(-)

diff --git a/sound/soc/intel/baytrail/sst-baytrail-ipc.c b/sound/soc/intel/baytrail/sst-baytrail-ipc.c
index 8bd1eddcc091..26c319bae09c 100644
--- a/sound/soc/intel/baytrail/sst-baytrail-ipc.c
+++ b/sound/soc/intel/baytrail/sst-baytrail-ipc.c
@@ -241,6 +241,7 @@ static int sst_byt_process_reply(struct sst_byt *byt, u64 header)
 		return 1;
 
 	if (header & IPC_HEADER_LARGE(true)) {
+		msg->reply = header;
 		msg->rx_size = sst_byt_header_data(header);
 		sst_dsp_inbox_read(byt->dsp, msg->rx_data, msg->rx_size);
 	}
@@ -416,7 +417,7 @@ int sst_byt_stream_commit(struct sst_byt *byt, struct sst_byt_stream *stream)
 				sizeof(*str_req) + sizeof(u32),
 				true, stream->str_id);
 	ret = sst_ipc_tx_message_wait(&byt->ipc, header, str_req,
-				      sizeof(*str_req),
+				      sizeof(*str_req), NULL,
 				      reply, sizeof(*reply));
 	if (ret < 0) {
 		dev_err(byt->dev, "ipc: error stream commit failed\n");
@@ -439,7 +440,8 @@ int sst_byt_stream_free(struct sst_byt *byt, struct sst_byt_stream *stream)
 		goto out;
 
 	header = sst_byt_header(IPC_IA_FREE_STREAM, 0, false, stream->str_id);
-	ret = sst_ipc_tx_message_wait(&byt->ipc, header, NULL, 0, NULL, 0);
+	ret = sst_ipc_tx_message_wait(&byt->ipc, header, NULL, 0,
+			NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(byt->dev, "ipc: free stream %d failed\n",
 			stream->str_id);
@@ -464,7 +466,7 @@ static int sst_byt_stream_operations(struct sst_byt *byt, int type,
 	header = sst_byt_header(type, 0, false, stream_id);
 	if (wait)
 		return sst_ipc_tx_message_wait(&byt->ipc, header, NULL,
-						0, NULL, 0);
+						0, NULL, NULL, 0);
 	else
 		return sst_ipc_tx_message_nowait(&byt->ipc, header,
 						NULL, 0);
diff --git a/sound/soc/intel/common/sst-ipc.c b/sound/soc/intel/common/sst-ipc.c
index ef5b66af1cd2..e928734fefa0 100644
--- a/sound/soc/intel/common/sst-ipc.c
+++ b/sound/soc/intel/common/sst-ipc.c
@@ -43,7 +43,7 @@ static struct ipc_message *msg_get_empty(struct sst_generic_ipc *ipc)
 }
 
 static int tx_wait_done(struct sst_generic_ipc *ipc,
-	struct ipc_message *msg, void *rx_data)
+	struct ipc_message *msg, u64 *reply, void *rx_data)
 {
 	unsigned long flags;
 	int ret;
@@ -62,6 +62,8 @@ static int tx_wait_done(struct sst_generic_ipc *ipc,
 	} else {
 
 		/* copy the data returned from DSP */
+		if (reply)
+			*reply = msg->reply;
 		if (rx_data)
 			memcpy(rx_data, msg->rx_data, msg->rx_size);
 		ret = msg->errno;
@@ -73,8 +75,8 @@ static int tx_wait_done(struct sst_generic_ipc *ipc,
 }
 
 static int ipc_tx_message(struct sst_generic_ipc *ipc, u64 header,
-	void *tx_data, size_t tx_bytes, void *rx_data,
-	size_t rx_bytes, int wait)
+	void *tx_data, size_t tx_bytes, u64 *reply,
+	void *rx_data, size_t rx_bytes, int wait)
 {
 	struct ipc_message *msg;
 	unsigned long flags;
@@ -88,6 +90,7 @@ static int ipc_tx_message(struct sst_generic_ipc *ipc, u64 header,
 	}
 
 	msg->header = header;
+	msg->reply = 0;
 	msg->tx_size = tx_bytes;
 	msg->rx_size = rx_bytes;
 	msg->wait = wait;
@@ -103,7 +106,7 @@ static int ipc_tx_message(struct sst_generic_ipc *ipc, u64 header,
 	spin_unlock_irqrestore(&ipc->dsp->spinlock, flags);
 
 	if (wait)
-		return tx_wait_done(ipc, msg, rx_data);
+		return tx_wait_done(ipc, msg, reply, rx_data);
 	else
 		return 0;
 }
@@ -174,7 +177,8 @@ static void ipc_tx_msgs(struct work_struct *work)
 }
 
 int sst_ipc_tx_message_wait(struct sst_generic_ipc *ipc, u64 header,
-	void *tx_data, size_t tx_bytes, void *rx_data, size_t rx_bytes)
+	void *tx_data, size_t tx_bytes, u64 *reply,
+	void *rx_data, size_t rx_bytes)
 {
 	int ret;
 
@@ -188,7 +192,7 @@ int sst_ipc_tx_message_wait(struct sst_generic_ipc *ipc, u64 header,
 			return -EIO;
 
 	ret = ipc_tx_message(ipc, header, tx_data, tx_bytes,
-		rx_data, rx_bytes, 1);
+		reply, rx_data, rx_bytes, 1);
 
 	if (ipc->ops.check_dsp_lp_on)
 		if (ipc->ops.check_dsp_lp_on(ipc->dsp, false))
@@ -202,15 +206,16 @@ int sst_ipc_tx_message_nowait(struct sst_generic_ipc *ipc, u64 header,
 	void *tx_data, size_t tx_bytes)
 {
 	return ipc_tx_message(ipc, header, tx_data, tx_bytes,
-		NULL, 0, 0);
+		NULL, NULL, 0, 0);
 }
 EXPORT_SYMBOL_GPL(sst_ipc_tx_message_nowait);
 
 int sst_ipc_tx_message_nopm(struct sst_generic_ipc *ipc, u64 header,
-	void *tx_data, size_t tx_bytes, void *rx_data, size_t rx_bytes)
+	void *tx_data, size_t tx_bytes, u64 *reply,
+	void *rx_data, size_t rx_bytes)
 {
 	return ipc_tx_message(ipc, header, tx_data, tx_bytes,
-		rx_data, rx_bytes, 1);
+		reply, rx_data, rx_bytes, 1);
 }
 EXPORT_SYMBOL_GPL(sst_ipc_tx_message_nopm);
 
diff --git a/sound/soc/intel/common/sst-ipc.h b/sound/soc/intel/common/sst-ipc.h
index ef38600e88f7..6c592658b344 100644
--- a/sound/soc/intel/common/sst-ipc.h
+++ b/sound/soc/intel/common/sst-ipc.h
@@ -20,6 +20,7 @@
 struct ipc_message {
 	struct list_head list;
 	u64 header;
+	u64 reply;
 
 	/* direction wrt host CPU */
 	char *tx_data;
@@ -67,13 +68,15 @@ struct sst_generic_ipc {
 };
 
 int sst_ipc_tx_message_wait(struct sst_generic_ipc *ipc, u64 header,
-	void *tx_data, size_t tx_bytes, void *rx_data, size_t rx_bytes);
+	void *tx_data, size_t tx_bytes, u64 *reply,
+	void *rx_data, size_t rx_bytes);
 
 int sst_ipc_tx_message_nowait(struct sst_generic_ipc *ipc, u64 header,
 	void *tx_data, size_t tx_bytes);
 
 int sst_ipc_tx_message_nopm(struct sst_generic_ipc *ipc, u64 header,
-	void *tx_data, size_t tx_bytes, void *rx_data, size_t rx_bytes);
+	void *tx_data, size_t tx_bytes, u64 *reply,
+	void *rx_data, size_t rx_bytes);
 
 struct ipc_message *sst_ipc_reply_find_msg(struct sst_generic_ipc *ipc,
 	u64 header);
diff --git a/sound/soc/intel/haswell/sst-haswell-ipc.c b/sound/soc/intel/haswell/sst-haswell-ipc.c
index a83b92d6bea8..dd632bdc22ea 100644
--- a/sound/soc/intel/haswell/sst-haswell-ipc.c
+++ b/sound/soc/intel/haswell/sst-haswell-ipc.c
@@ -562,6 +562,7 @@ static int hsw_process_reply(struct sst_hsw *hsw, u32 header)
 	case IPC_GLB_REPLY_SUCCESS:
 		if (msg->pending) {
 			trace_ipc_pending_reply("completed", header);
+			msg->reply = header;
 			sst_dsp_inbox_read(hsw->dsp, msg->rx_data,
 				msg->rx_size);
 			hsw->ipc.pending = false;
@@ -814,7 +815,7 @@ int sst_hsw_fw_get_version(struct sst_hsw *hsw,
 
 	ret = sst_ipc_tx_message_wait(&hsw->ipc,
 		IPC_GLB_TYPE(IPC_GLB_GET_FW_VERSION),
-		NULL, 0, version, sizeof(*version));
+		NULL, 0, NULL, version, sizeof(*version));
 	if (ret < 0)
 		dev_err(hsw->dev, "error: get version failed\n");
 
@@ -878,7 +879,7 @@ int sst_hsw_stream_set_volume(struct sst_hsw *hsw,
 	}
 
 	ret = sst_ipc_tx_message_wait(&hsw->ipc, header, req,
-		sizeof(*req), NULL, 0);
+		sizeof(*req), NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(hsw->dev, "error: set stream volume failed\n");
 		return ret;
@@ -944,7 +945,7 @@ int sst_hsw_mixer_set_volume(struct sst_hsw *hsw, u32 stage_id, u32 channel,
 	req.target_volume = volume;
 
 	ret = sst_ipc_tx_message_wait(&hsw->ipc, header, &req,
-		sizeof(req), NULL, 0);
+		sizeof(req), NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(hsw->dev, "error: set mixer volume failed\n");
 		return ret;
@@ -1003,7 +1004,7 @@ int sst_hsw_stream_free(struct sst_hsw *hsw, struct sst_hsw_stream *stream)
 	header = IPC_GLB_TYPE(IPC_GLB_FREE_STREAM);
 
 	ret = sst_ipc_tx_message_wait(&hsw->ipc, header, &stream->free_req,
-		sizeof(stream->free_req), NULL, 0);
+		sizeof(stream->free_req), NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(hsw->dev, "error: free stream %d failed\n",
 			stream->free_req.stream_id);
@@ -1195,7 +1196,7 @@ int sst_hsw_stream_commit(struct sst_hsw *hsw, struct sst_hsw_stream *stream)
 	header = IPC_GLB_TYPE(IPC_GLB_ALLOCATE_STREAM);
 
 	ret = sst_ipc_tx_message_wait(&hsw->ipc, header, str_req,
-		sizeof(*str_req), reply, sizeof(*reply));
+		sizeof(*str_req), NULL, reply, sizeof(*reply));
 	if (ret < 0) {
 		dev_err(hsw->dev, "error: stream commit failed\n");
 		return ret;
@@ -1245,7 +1246,7 @@ int sst_hsw_mixer_get_info(struct sst_hsw *hsw)
 	trace_ipc_request("get global mixer info", 0);
 
 	ret = sst_ipc_tx_message_wait(&hsw->ipc, header, NULL, 0,
-		reply, sizeof(*reply));
+		NULL, reply, sizeof(*reply));
 	if (ret < 0) {
 		dev_err(hsw->dev, "error: get stream info failed\n");
 		return ret;
@@ -1267,7 +1268,7 @@ static int sst_hsw_stream_operations(struct sst_hsw *hsw, int type,
 
 	if (wait)
 		return sst_ipc_tx_message_wait(&hsw->ipc, header,
-			NULL, 0, NULL, 0);
+			NULL, 0, NULL, NULL, 0);
 	else
 		return sst_ipc_tx_message_nowait(&hsw->ipc, header, NULL, 0);
 }
@@ -1397,7 +1398,7 @@ int sst_hsw_device_set_config(struct sst_hsw *hsw,
 	header = IPC_GLB_TYPE(IPC_GLB_SET_DEVICE_FORMATS);
 
 	ret = sst_ipc_tx_message_wait(&hsw->ipc, header, &config,
-		sizeof(config), NULL, 0);
+		sizeof(config), NULL, NULL, 0);
 	if (ret < 0)
 		dev_err(hsw->dev, "error: set device formats failed\n");
 
@@ -1418,7 +1419,7 @@ int sst_hsw_dx_set_state(struct sst_hsw *hsw,
 	trace_ipc_request("PM enter Dx state", state);
 
 	ret = sst_ipc_tx_message_wait(&hsw->ipc, header, &state_,
-		sizeof(state_), dx, sizeof(*dx));
+		sizeof(state_), NULL, dx, sizeof(*dx));
 	if (ret < 0) {
 		dev_err(hsw->dev, "ipc: error set dx state %d failed\n", state);
 		return ret;
@@ -1933,7 +1934,7 @@ int sst_hsw_module_enable(struct sst_hsw *hsw,
 		config.map.module_entries[0].entry_point);
 
 	ret = sst_ipc_tx_message_wait(&hsw->ipc, header,
-			&config, sizeof(config), NULL, 0);
+			&config, sizeof(config), NULL, NULL, 0);
 	if (ret < 0)
 		dev_err(dev, "ipc: module enable failed - %d\n", ret);
 	else
@@ -1971,7 +1972,8 @@ int sst_hsw_module_disable(struct sst_hsw *hsw,
 			IPC_MODULE_OPERATION(IPC_MODULE_DISABLE) |
 			IPC_MODULE_ID(module_id);
 
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, header,  NULL, 0, NULL, 0);
+	ret = sst_ipc_tx_message_wait(&hsw->ipc, header,  NULL, 0,
+			NULL, NULL, 0);
 	if (ret < 0)
 		dev_err(dev, "module disable failed - %d\n", ret);
 	else
@@ -2024,7 +2026,7 @@ int sst_hsw_module_set_param(struct sst_hsw *hsw,
 	parameter->data_size = param_size;
 
 	ret = sst_ipc_tx_message_wait(&hsw->ipc, header,
-		parameter, transfer_parameter_size , NULL, 0);
+		parameter, transfer_parameter_size, NULL, NULL, 0);
 	if (ret < 0)
 		dev_err(dev, "ipc: module set parameter failed - %d\n", ret);
 
diff --git a/sound/soc/intel/skylake/skl-sst-ipc.c b/sound/soc/intel/skylake/skl-sst-ipc.c
index fd32840a101c..b72e6fd97c99 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.c
+++ b/sound/soc/intel/skylake/skl-sst-ipc.c
@@ -459,6 +459,7 @@ void skl_ipc_process_reply(struct sst_generic_ipc *ipc,
 	if (reply == IPC_GLB_REPLY_SUCCESS) {
 		dev_dbg(ipc->dev, "ipc FW reply %x: success\n", header.primary);
 		/* copy the rx data from the mailbox */
+		msg->reply = *ipc_header;
 		sst_dsp_inbox_read(ipc->dsp, msg->rx_data, msg->rx_size);
 		switch (IPC_GLB_NOTIFY_MSG_TYPE(header.primary)) {
 		case IPC_GLB_LOAD_MULTIPLE_MODS:
@@ -655,7 +656,8 @@ int skl_ipc_create_pipeline(struct sst_generic_ipc *ipc,
 	header.extension = IPC_PPL_LP_MODE(lp_mode);
 
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0, NULL, 0);
+	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
+			NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: create pipeline fail, err: %d\n", ret);
 		return ret;
@@ -677,7 +679,8 @@ int skl_ipc_delete_pipeline(struct sst_generic_ipc *ipc, u8 instance_id)
 	header.primary |= IPC_INSTANCE_ID(instance_id);
 
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0, NULL, 0);
+	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
+			NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: delete pipeline failed, err %d\n", ret);
 		return ret;
@@ -701,7 +704,8 @@ int skl_ipc_set_pipeline_state(struct sst_generic_ipc *ipc,
 	header.primary |= IPC_PPL_STATE(state);
 
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0, NULL, 0);
+	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
+			NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: set pipeline state failed, err: %d\n", ret);
 		return ret;
@@ -724,7 +728,8 @@ skl_ipc_save_pipeline(struct sst_generic_ipc *ipc, u8 instance_id, int dma_id)
 
 	header.extension = IPC_DMA_ID(dma_id);
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0, NULL, 0);
+	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
+			NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: save pipeline failed, err: %d\n", ret);
 		return ret;
@@ -746,7 +751,8 @@ int skl_ipc_restore_pipeline(struct sst_generic_ipc *ipc, u8 instance_id)
 	header.primary |= IPC_INSTANCE_ID(instance_id);
 
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0, NULL, 0);
+	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
+			NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: restore  pipeline failed, err: %d\n", ret);
 		return ret;
@@ -772,7 +778,7 @@ int skl_ipc_set_dx(struct sst_generic_ipc *ipc, u8 instance_id,
 	dev_dbg(ipc->dev, "In %s primary =%x ext=%x\n", __func__,
 			 header.primary, header.extension);
 	ret = sst_ipc_tx_message_wait(ipc, *ipc_header,
-				dx, sizeof(*dx), NULL, 0);
+				dx, sizeof(*dx), NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: set dx failed, err %d\n", ret);
 		return ret;
@@ -809,7 +815,7 @@ int skl_ipc_init_instance(struct sst_generic_ipc *ipc,
 	dev_dbg(ipc->dev, "In %s primary =%x ext=%x\n", __func__,
 			 header.primary, header.extension);
 	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, param_data,
-			msg->param_data_size, NULL, 0);
+			msg->param_data_size, NULL, NULL, 0);
 
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: init instance failed\n");
@@ -841,7 +847,8 @@ int skl_ipc_bind_unbind(struct sst_generic_ipc *ipc,
 
 	dev_dbg(ipc->dev, "In %s hdr=%x ext=%x\n", __func__, header.primary,
 			 header.extension);
-	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0, NULL, 0);
+	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
+			NULL, NULL, 0);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: bind/unbind failed\n");
 		return ret;
@@ -869,8 +876,8 @@ int skl_ipc_load_modules(struct sst_generic_ipc *ipc,
 	header.primary |= IPC_GLB_TYPE(IPC_GLB_LOAD_MULTIPLE_MODS);
 	header.primary |= IPC_LOAD_MODULE_CNT(module_cnt);
 
-	ret = sst_ipc_tx_message_nowait(ipc, *ipc_header, data,
-				(sizeof(u16) * module_cnt));
+	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, data,
+				(sizeof(u16) * module_cnt), NULL, NULL, 0);
 	if (ret < 0)
 		dev_err(ipc->dev, "ipc: load modules failed :%d\n", ret);
 
@@ -891,7 +898,7 @@ int skl_ipc_unload_modules(struct sst_generic_ipc *ipc, u8 module_cnt,
 	header.primary |= IPC_LOAD_MODULE_CNT(module_cnt);
 
 	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, data,
-				(sizeof(u16) * module_cnt), NULL, 0);
+				(sizeof(u16) * module_cnt), NULL, NULL, 0);
 	if (ret < 0)
 		dev_err(ipc->dev, "ipc: unload modules failed :%d\n", ret);
 
@@ -932,7 +939,7 @@ int skl_ipc_set_large_config(struct sst_generic_ipc *ipc,
 			(unsigned)data_offset, (unsigned)tx_size);
 		ret = sst_ipc_tx_message_wait(ipc, *ipc_header,
 					  ((char *)param) + data_offset,
-					  tx_size, NULL, 0);
+					  tx_size, NULL, NULL, 0);
 		if (ret < 0) {
 			dev_err(ipc->dev,
 				"ipc: set large config fail, err: %d\n", ret);
@@ -957,7 +964,7 @@ int skl_ipc_get_large_config(struct sst_generic_ipc *ipc,
 		struct skl_ipc_large_config_msg *msg, u32 *param)
 {
 	struct skl_ipc_header header = {0};
-	u64 *ipc_header = (u64 *)(&header);
+	u64 *reply, *ipc_header = (u64 *)(&header);
 	int ret = 0;
 	size_t sz_remaining, rx_size, data_offset;
 
@@ -982,8 +989,8 @@ int skl_ipc_get_large_config(struct sst_generic_ipc *ipc,
 			header.extension |= IPC_FINAL_BLOCK(1);
 
 		ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
-					      ((char *)param) + data_offset,
-					      msg->param_data_size);
+				NULL, ((char *)param) + data_offset,
+				msg->param_data_size);
 		if (ret < 0) {
 			dev_err(ipc->dev,
 				"ipc: get large config fail, err: %d\n", ret);
@@ -1018,8 +1025,8 @@ int skl_sst_ipc_load_library(struct sst_generic_ipc *ipc,
 	header.primary |= IPC_MOD_ID(dma_id);
 
 	if (wait)
-		ret = sst_ipc_tx_message_wait(ipc, *ipc_header,
-					NULL, 0, NULL, 0);
+		ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,
+					NULL, NULL, 0);
 	else
 		ret = sst_ipc_tx_message_nowait(ipc, *ipc_header, NULL, 0);
 
@@ -1051,7 +1058,8 @@ int skl_ipc_set_d0ix(struct sst_generic_ipc *ipc, struct skl_ipc_d0ix_msg *msg)
 	/*
 	 * Use the nopm IPC here as we dont want it checking for D0iX
 	 */
-	ret = sst_ipc_tx_message_nopm(ipc, *ipc_header, NULL, 0, NULL, 0);
+	ret = sst_ipc_tx_message_nopm(ipc, *ipc_header, NULL, 0,
+			NULL, NULL, 0);
 	if (ret < 0)
 		dev_err(ipc->dev, "ipc: set d0ix failed, err %d\n", ret);
 
-- 
2.17.1

