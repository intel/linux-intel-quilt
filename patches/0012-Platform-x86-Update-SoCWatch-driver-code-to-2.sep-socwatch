From 5531dd5c0d2ae86f7e17b8403d6fb35332532765 Mon Sep 17 00:00:00 2001
From: Faycal Benmlih <faycal.benmlih@intel.com>
Date: Tue, 23 Apr 2019 14:23:37 -0500
Subject: [PATCH 12/30] Platform/x86: Update SoCWatch driver code to 2.10

Signed-off-by: Faycal Benmlih <faycal.benmlih@intel.com>
---
 drivers/platform/x86/socwatch/Makefile        |    2 +-
 .../platform/x86/socwatch/inc/sw_collector.h  |  140 +-
 .../platform/x86/socwatch/inc/sw_defines.h    |  135 +-
 .../platform/x86/socwatch/inc/sw_file_ops.h   |  109 +-
 .../x86/socwatch/inc/sw_hardware_io.h         |  143 +-
 .../platform/x86/socwatch/inc/sw_internal.h   |  146 ++-
 drivers/platform/x86/socwatch/inc/sw_ioctl.h  |  404 +++---
 .../x86/socwatch/inc/sw_kernel_defines.h      |  194 +--
 drivers/platform/x86/socwatch/inc/sw_list.h   |  134 +-
 .../platform/x86/socwatch/inc/sw_lock_defs.h  |  166 +--
 drivers/platform/x86/socwatch/inc/sw_mem.h    |  115 +-
 .../x86/socwatch/inc/sw_ops_provider.h        |  109 +-
 .../x86/socwatch/inc/sw_output_buffer.h       |  120 +-
 .../socwatch/inc/sw_overhead_measurements.h   |  219 ++--
 .../platform/x86/socwatch/inc/sw_structs.h    |  358 ++---
 drivers/platform/x86/socwatch/inc/sw_telem.h  |  120 +-
 .../socwatch/inc/sw_trace_notifier_provider.h |  109 +-
 .../x86/socwatch/inc/sw_tracepoint_handlers.h |  194 ++-
 drivers/platform/x86/socwatch/inc/sw_types.h  |  117 +-
 .../platform/x86/socwatch/inc/sw_version.h    |  117 +-
 drivers/platform/x86/socwatch/sw_collector.c  |  528 ++++----
 drivers/platform/x86/socwatch/sw_driver.c     |  477 ++++---
 drivers/platform/x86/socwatch/sw_file_ops.c   |  275 ++--
 .../platform/x86/socwatch/sw_hardware_io.c    |  150 +--
 drivers/platform/x86/socwatch/sw_internal.c   |  165 +--
 drivers/platform/x86/socwatch/sw_mem.c        |  197 ++-
 .../platform/x86/socwatch/sw_ops_provider.c   | 1160 ++++++++---------
 .../platform/x86/socwatch/sw_output_buffer.c  |  602 ++++++---
 drivers/platform/x86/socwatch/sw_reader.c     |  162 ++-
 drivers/platform/x86/socwatch/sw_telem.c      | 1026 ++++++++++-----
 .../x86/socwatch/sw_trace_notifier_provider.c |  490 ++++---
 .../x86/socwatch/sw_tracepoint_handlers.c     |  250 ++--
 .../platform/x86/socwatchhv/inc/asm_helper.h  |  324 +++--
 drivers/platform/x86/socwatchhv/inc/control.h |  211 ++-
 .../platform/x86/socwatchhv/inc/pw_types.h    |  111 +-
 .../platform/x86/socwatchhv/inc/pw_version.h  |  109 +-
 .../platform/x86/socwatchhv/inc/sw_defines.h  |  141 +-
 .../platform/x86/socwatchhv/inc/sw_ioctl.h    |  404 +++---
 .../platform/x86/socwatchhv/inc/sw_structs.h  |  359 ++---
 .../platform/x86/socwatchhv/inc/sw_types.h    |  117 +-
 .../platform/x86/socwatchhv/inc/sw_version.h  |  117 +-
 .../platform/x86/socwatchhv/inc/swhv_acrn.h   |  161 ++-
 .../x86/socwatchhv/inc/swhv_acrn_sbuf.h       |  107 +-
 .../x86/socwatchhv/inc/swhv_defines.h         |  128 +-
 .../platform/x86/socwatchhv/inc/swhv_driver.h |  119 +-
 .../platform/x86/socwatchhv/inc/swhv_ioctl.h  |  205 ++-
 .../x86/socwatchhv/inc/swhv_structs.h         |  183 +--
 drivers/platform/x86/socwatchhv/swhv_acrn.c   |  332 ++---
 drivers/platform/x86/socwatchhv/swhv_driver.c |  192 ++-
 49 files changed, 6341 insertions(+), 5612 deletions(-)

diff --git a/drivers/platform/x86/socwatch/Makefile b/drivers/platform/x86/socwatch/Makefile
index 15ac18fcfdc0..073397d5aec0 100644
--- a/drivers/platform/x86/socwatch/Makefile
+++ b/drivers/platform/x86/socwatch/Makefile
@@ -4,7 +4,7 @@
 
 DRIVER_BASE=socwatch
 DRIVER_MAJOR=2
-DRIVER_MINOR=6
+DRIVER_MINOR=10
 # basic name of driver
 DRIVER_NAME=${DRIVER_BASE}${DRIVER_MAJOR}_${DRIVER_MINOR}
 
diff --git a/drivers/platform/x86/socwatch/inc/sw_collector.h b/drivers/platform/x86/socwatch/inc/sw_collector.h
index 41430cbeddef..69a7a4833b1d 100644
--- a/drivers/platform/x86/socwatch/inc/sw_collector.h
+++ b/drivers/platform/x86/socwatch/inc/sw_collector.h
@@ -1,58 +1,58 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
-*/
 #ifndef __SW_COLLECTOR_H__
 
 #include "sw_internal.h"
@@ -80,19 +80,18 @@ struct sw_hw_ops;
  * @per_msg_payload_size:   Data size
  * @msg:                    Ptr to collected data
  */
-typedef struct sw_collector_data {
+struct sw_collector_data {
 	SW_LIST_ENTRY(list, sw_collector_data);
-	struct cpumask cpumask;
+	struct cpumask                  cpumask;
 	struct sw_driver_interface_info *info;
-	const struct sw_hw_ops **ops;
-	size_t per_msg_payload_size;
-	u64 last_update_jiffies;
+	const struct sw_hw_ops          **ops;
+	size_t                          per_msg_payload_size;
+	u64                             last_update_jiffies;
 	struct sw_driver_msg *msg;
-} sw_collector_data_t;
-#define GET_MSG_SLOT_FOR_CPU(msgs, cpu, size)                                  \
-	((struct sw_driver_msg *)&(                                            \
-		((char *)(msgs))[(cpu) *                                       \
-				 (sizeof(struct sw_driver_msg) + (size))]))
+};
+
+#define GET_MSG_SLOT_FOR_CPU(msgs, cpu, size) ((struct sw_driver_msg *) & \
+	(((char *)(msgs))[(cpu) * (sizeof(struct sw_driver_msg) + (size))]))
 
 struct sw_collector_data *sw_alloc_collector_node(void);
 void sw_free_collector_node(struct sw_collector_data *node);
@@ -103,21 +102,20 @@ int sw_write_collector_node(struct sw_collector_data *data);
 void sw_init_collector_list(void *list_head);
 void sw_destroy_collector_list(void *list_head);
 int sw_handle_collector_list(void *list_head,
-			     int (*func)(struct sw_collector_data *data));
+	int (*func)(struct sw_collector_data *data));
 int sw_handle_collector_list_on_cpu(void *list_head,
-				    int (*func)(struct sw_collector_data *data,
-						int cpu),
-				    int cpu);
+	int (*func)(struct sw_collector_data *data, int cpu),
+	int cpu);
 
-int sw_handle_driver_io_descriptor(
-	char *dst_vals, int cpu,
+int sw_handle_driver_io_descriptor(char *dst_vals,
+	int cpu,
 	const struct sw_driver_io_descriptor *descriptor,
 	const struct sw_hw_ops *hw_ops);
 int sw_init_driver_io_descriptor(struct sw_driver_io_descriptor *descriptor);
 int sw_reset_driver_io_descriptor(struct sw_driver_io_descriptor *descriptor);
 
 int sw_add_driver_info(void *list_head,
-		       const struct sw_driver_interface_info *info);
+	const struct sw_driver_interface_info *info);
 
 void sw_handle_per_cpu_msg(void *info);
 void sw_handle_per_cpu_msg_no_sched(void *info);
diff --git a/drivers/platform/x86/socwatch/inc/sw_defines.h b/drivers/platform/x86/socwatch/inc/sw_defines.h
index ab0f4911332d..a670904e4e39 100644
--- a/drivers/platform/x86/socwatch/inc/sw_defines.h
+++ b/drivers/platform/x86/socwatch/inc/sw_defines.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef _PW_DEFINES_H_
 #define _PW_DEFINES_H_ 1
@@ -63,9 +62,9 @@
  * Common to kernel and userspace.
  * ***************************************************
  */
-#define PW_SUCCESS 0
-#define PW_ERROR 1
-#define PW_SUCCESS_NO_COLLECT 2
+#define PW_SUCCESS              0
+#define PW_ERROR                1
+#define PW_SUCCESS_NO_COLLECT   2
 
 /*
  * Helper macro to convert 'u64' to 'unsigned long long' to avoid gcc warnings.
@@ -94,13 +93,10 @@
 /*
  * Circularly decrement 'i'.
  */
-#define CIRCULAR_DEC(i, m)                                                     \
-	({                                                                     \
-		int __tmp1 = (i);                                              \
-		if (--__tmp1 < 0)                                              \
-			__tmp1 = (m);                                          \
-		__tmp1;                                                        \
-	})
+#define CIRCULAR_DEC(i, m) ({			\
+	int __tmp1 = (i);			\
+	if (--__tmp1 < 0)			\
+		__tmp1 = (m); __tmp1; })
 /*
  * Retrieve size of an array.
  */
@@ -114,7 +110,7 @@
  * Assumes version numbers are 8b unsigned ints.
  */
 #define SW_GET_SCU_FW_VERSION_MAJOR(ver) (((ver) >> 8) & 0xff)
-#define SW_GET_SCU_FW_VERSION_MINOR(ver) ((ver)&0xff)
+#define SW_GET_SCU_FW_VERSION_MINOR(ver) ((ver) & 0xff)
 /*
  * Max size of process name retrieved from kernel.
  */
@@ -152,5 +148,12 @@ typedef enum {
 #define MAX_UNSIGNED_24_BIT_VALUE 0xFFFFFF
 #define MAX_UNSIGNED_32_BIT_VALUE 0xFFFFFFFF
 #define MAX_UNSIGNED_64_BIT_VALUE 0xFFFFFFFFFFFFFFFF
+/*
+ * TELEM BAR CONFIG
+ */
+#define MAX_TELEM_BAR_CFG	3
+#define TELEM_MCHBAR_CFG	0
+#define TELEM_IPC1BAR_CFG	1
+#define TELEM_SSRAMBAR_CFG	2
 
 #endif /* _PW_DEFINES_H_ */
diff --git a/drivers/platform/x86/socwatch/inc/sw_file_ops.h b/drivers/platform/x86/socwatch/inc/sw_file_ops.h
index c3a30a17a7b0..bba7e5ddbb87 100644
--- a/drivers/platform/x86/socwatch/inc/sw_file_ops.h
+++ b/drivers/platform/x86/socwatch/inc/sw_file_ops.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 #ifndef __SW_FILE_OPS_H__
 #define __SW_FILE_OPS_H__
 
diff --git a/drivers/platform/x86/socwatch/inc/sw_hardware_io.h b/drivers/platform/x86/socwatch/inc/sw_hardware_io.h
index 5cc9ebe18cf1..9e207f2a473a 100644
--- a/drivers/platform/x86/socwatch/inc/sw_hardware_io.h
+++ b/drivers/platform/x86/socwatch/inc/sw_hardware_io.h
@@ -1,73 +1,72 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 #ifndef __SW_HARDWARE_IO_H__
 #define __SW_HARDWARE_IO_H__
 
 #include "sw_structs.h"
 
-typedef int (*sw_io_desc_init_func_t)(
-	struct sw_driver_io_descriptor *descriptor);
-typedef void (*sw_hardware_op_func_t)(
-	char *dst_vals, int cpu,
-	const struct sw_driver_io_descriptor *descriptor,
+typedef int (*sw_io_desc_init_func_t)
+	(struct sw_driver_io_descriptor *descriptor);
+typedef void (*sw_hardware_op_func_t)
+	(char *dst_vals,
+	int cpu, const struct sw_driver_io_descriptor *descriptor,
 	u16 counter_size_in_bytes);
-typedef int (*sw_io_desc_print_func_t)(
-	const struct sw_driver_io_descriptor *descriptor);
-typedef int (*sw_io_desc_reset_func_t)(
-	const struct sw_driver_io_descriptor *descriptor);
+typedef int (*sw_io_desc_print_func_t)
+	(const struct sw_driver_io_descriptor *descriptor);
+typedef int (*sw_io_desc_reset_func_t)
+	(const struct sw_driver_io_descriptor *descriptor);
 typedef bool (*sw_io_desc_available_func_t)(void);
 typedef bool (*sw_hw_op_post_config_func_t)(void);
 
@@ -87,13 +86,13 @@ typedef bool (*sw_hw_op_post_config_func_t)(void);
  */
 struct sw_hw_ops {
 	const char *name;
-	sw_io_desc_init_func_t init;
-	sw_hardware_op_func_t read;
-	sw_hardware_op_func_t write;
-	sw_io_desc_print_func_t print;
-	sw_io_desc_reset_func_t reset;
-	sw_io_desc_available_func_t available;
-	sw_hw_op_post_config_func_t post_config;
+	sw_io_desc_init_func_t       init;
+	sw_hardware_op_func_t        read;
+	sw_hardware_op_func_t        write;
+	sw_io_desc_print_func_t      print;
+	sw_io_desc_reset_func_t      reset;
+	sw_io_desc_available_func_t  available;
+	sw_hw_op_post_config_func_t  post_config;
 };
 
 bool sw_is_valid_hw_op_id(int id);
@@ -102,7 +101,7 @@ const struct sw_hw_ops *sw_get_hw_ops_for(int id);
 const char *sw_get_hw_op_abstract_name(const struct sw_hw_ops *op);
 
 int sw_for_each_hw_op(int (*func)(const struct sw_hw_ops *op, void *priv),
-		      void *priv, bool return_on_error);
+			void *priv, bool return_on_error);
 
 /**
  * Add an operation to the list of providers.
diff --git a/drivers/platform/x86/socwatch/inc/sw_internal.h b/drivers/platform/x86/socwatch/inc/sw_internal.h
index c8d9da330756..3e027e4f63fc 100644
--- a/drivers/platform/x86/socwatch/inc/sw_internal.h
+++ b/drivers/platform/x86/socwatch/inc/sw_internal.h
@@ -1,58 +1,58 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
-*/
 #ifndef __SW_DATA_STRUCTS_H__
 #define __SW_DATA_STRUCTS_H__
 
@@ -66,27 +66,27 @@
 #include <linux/slab.h>
 #include <linux/cpumask.h>
 #include <linux/hrtimer.h>
-#include <linux/fs.h> /* inode */
-#include <linux/device.h> /* class_create */
-#include <linux/cdev.h> /* cdev_alloc */
+#include <linux/fs.h>      /* inode */
+#include <linux/device.h>  /* class_create */
+#include <linux/cdev.h>    /* cdev_alloc */
 #include <linux/vmalloc.h> /* vmalloc */
-#include <linux/sched.h> /* TASK_INTERRUPTIBLE */
-#include <linux/wait.h> /* wait_event_interruptible */
-#include <linux/pci.h> /* pci_get_bus_and_slot */
+#include <linux/sched.h>   /* TASK_INTERRUPTIBLE */
+#include <linux/wait.h>    /* wait_event_interruptible */
+#include <linux/pci.h>     /* pci_get_bus_and_slot */
 #include <linux/version.h> /* LINUX_VERSION_CODE */
-#include <linux/sfi.h> /* For SFI F/W version */
+#include <linux/sfi.h>     /* For SFI F/W version */
 #include <asm/hardirq.h>
 #include <linux/cpufreq.h>
-#include <asm/local.h> /* local_t */
+#include <asm/local.h>     /* local_t */
 #include <linux/hardirq.h> /* "in_atomic" */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0)
-#include <asm/uaccess.h> /* copy_to_user */
+    #include <asm/uaccess.h>   /* copy_to_user */
 #else
-#include <linux/uaccess.h> /* copy_to_user */
+    #include <linux/uaccess.h>   /* copy_to_user */
 #endif /* LINUX_VERSION_CODE */
 
 #ifdef CONFIG_X86_WANT_INTEL_MID
-#include <asm/intel-mid.h>
+    #include <asm/intel-mid.h>
 #endif /* CONFIG_X86_WANT_INTEL_MID */
 /*
  * End taken from sw_driver
@@ -101,6 +101,7 @@
  * ******************************************
  */
 #define GET_POLLED_CPU() (sw_max_num_cpus)
+#define CAS32(p, o, n) (cmpxchg((p), (o), (n)) == (o))
 
 /* ******************************************
  * Function declarations.
@@ -109,15 +110,14 @@
 /*
  * Output to user.
  */
-unsigned long sw_copy_to_user(char __user *dst,
-			      char *src, size_t bytes_to_copy);
+unsigned long sw_copy_to_user(char __user *dst, char *src, size_t bytes_to_copy);
 bool sw_check_output_buffer_params(void __user *buffer, size_t bytes_to_read,
-				   size_t buff_size);
+	size_t buff_size);
 /*
  * smp call function.
  */
 void sw_schedule_work(const struct cpumask *mask, void (*work)(void *),
-		      void *data);
+	void *data);
 /*
  * Save IRQ flags and retrieve cpu number.
  */
@@ -134,5 +134,13 @@ int sw_set_module_scope_for_cpus(void);
  * reset module scope for cpu frequencies.
  */
 int sw_reset_module_scope_for_cpus(void);
+/*
+ * Setup p-unit/pmc telemetry
+ */
+int sw_setup_telem(u64 addrs[3]);
+/*
+ * Tear down p-unit/pmc telemetry
+ */
+void sw_destroy_telem(void);
 
 #endif /* __SW_DATA_STRUCTS_H__ */
diff --git a/drivers/platform/x86/socwatch/inc/sw_ioctl.h b/drivers/platform/x86/socwatch/inc/sw_ioctl.h
index 1f8e903a0e1c..43a1f69af9ab 100644
--- a/drivers/platform/x86/socwatch/inc/sw_ioctl.h
+++ b/drivers/platform/x86/socwatch/inc/sw_ioctl.h
@@ -1,71 +1,71 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
-*/
 #ifndef __SW_IOCTL_H__
 #define __SW_IOCTL_H__ 1
 
 #if defined(__linux__) || defined(__QNX__)
-#if __KERNEL__
-#include <linux/ioctl.h>
-#if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)
-#include <asm/compat.h>
-#include <linux/compat.h>
-#endif /* COMPAT && x64 */
-#else /* !__KERNEL__ */
-#include <sys/ioctl.h>
-#endif /* __KERNEL__ */
+	#if __KERNEL__
+		#include <linux/ioctl.h>
+		#if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)
+			#include <asm/compat.h>
+			#include <linux/compat.h>
+		#endif /* COMPAT && x64 */
+	#else /* !__KERNEL__ */
+		#include <sys/ioctl.h>
+	#endif /* __KERNEL__ */
 #endif /* __linux__ */
 /*
  * Ensure we pull in definition of 'DO_COUNT_DROPPED_SAMPLES'!
@@ -107,6 +107,9 @@ enum sw_ioctl_cmd {
 	sw_ioctl_cmd_avail_notify,
 	sw_ioctl_cmd_avail_collect,
 	sw_ioctl_cmd_topology_changes,
+	sw_ioctl_cmd_config_continuous,
+	sw_ioctl_cmd_read_continuous,
+	sw_ioctl_cmd_telem_bar,
 };
 /*
  * The actual IOCTL commands.
@@ -120,150 +123,136 @@ enum sw_ioctl_cmd {
  * (similar to the file "read" and "write" calls).
  */
 #ifdef SWW_MERGE /* Windows */
-/*
- * Device type           -- in the "User Defined" range."
- */
-#define POWER_I_CONF_TYPE 40000
+	 /*
+	  * Device type		   -- in the "User Defined" range."
+	  */
+	#define POWER_I_CONF_TYPE 40000
 
-/* List assigned tracepoint id */
-#define CSIR_TRACEPOINT_ID_MASK 1
-#define DEVICE_STATE_TRACEPOINT_ID_MASK 2
-#define CSIR_SEPARATE_TRACEPOINT_ID_MASK 3
-#define RESET_TRACEPOINT_ID_MASK 4
-#define DISPLAY_ON_TRACEPOINT_ID_MASK 5
+	/* List assigned tracepoint id */
+	#define CSIR_TRACEPOINT_ID_MASK			1
+	#define DEVICE_STATE_TRACEPOINT_ID_MASK		2
+	#define CSIR_SEPARATE_TRACEPOINT_ID_MASK	3
+	#define RESET_TRACEPOINT_ID_MASK		4
+	#define DISPLAY_ON_TRACEPOINT_ID_MASK		5
 
-#ifdef SWW_MERGE
-/*
- * TELEM BAR CONFIG
- */
-#define MAX_TELEM_BAR_CFG 3
-#define TELEM_MCHBAR_CFG 0
-#define TELEM_IPC1BAR_CFG 1
-#define TELEM_SSRAMBAR_CFG 2
-#endif
-
-/*
- * The IOCTL function codes from 0x800 to 0xFFF are for customer use.
- */
-#define PW_IOCTL_CONFIG                                                        \
+	/*
+	 * The IOCTL function codes from 0x800 to 0xFFF are for customer use.
+	 */
+	#define PW_IOCTL_CONFIG \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_START_COLLECTION                                              \
+	#define PW_IOCTL_START_COLLECTION \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x901, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_STOP_COLLECTION                                               \
+	#define PW_IOCTL_STOP_COLLECTION \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS)
 
-/* TODO: pause, resume, cancel not supported yet */
-#define PW_IOCTL_PAUSE_COLLECTION                                              \
+	/* TODO: pause, resume, cancel not supported yet */
+	#define PW_IOCTL_PAUSE_COLLECTION \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x903, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_RESUME_COLLECTION                                             \
+	#define PW_IOCTL_RESUME_COLLECTION \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x904, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_CANCEL_COLLECTION                                             \
+	#define PW_IOCTL_CANCEL_COLLECTION \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x905, METHOD_BUFFERED, FILE_ANY_ACCESS)
 
-#define PW_IOCTL_GET_PROCESSOR_GROUP_TOPOLOGY                                  \
+	#define PW_IOCTL_GET_PROCESSOR_GROUP_TOPOLOGY \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x906, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_TOPOLOGY                                                      \
+	#define PW_IOCTL_TOPOLOGY \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x907, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_GET_AVAILABLE_COLLECTORS                                      \
+	#define PW_IOCTL_GET_AVAILABLE_COLLECTORS \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x908, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_IMMEDIATE_IO                                                  \
+	#define PW_IOCTL_IMMEDIATE_IO \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x909, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_DRV_CLEANUP                                                   \
+	#define PW_IOCTL_DRV_CLEANUP \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x90A, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_SET_COLLECTION_EVENT                                          \
+	#define PW_IOCTL_SET_COLLECTION_EVENT \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x90B, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_TRY_STOP_EVENT                                                \
+	#define PW_IOCTL_TRY_STOP_EVENT \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x90C, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_SET_PCH_ACTIVE_INTERVAL                                       \
+	#define PW_IOCTL_SET_PCH_ACTIVE_INTERVAL \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x90D, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_SET_TELEM_BAR                                                 \
+	#define PW_IOCTL_SET_TELEM_BAR \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x90E, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_METADATA                                                      \
+	#define PW_IOCTL_METADATA \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x90F, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_SET_GBE_INTERVAL                                              \
+	#define PW_IOCTL_SET_GBE_INTERVAL \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x910, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_ENABLE_COLLECTION                                             \
+	#define PW_IOCTL_ENABLE_COLLECTION \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x911, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_DISABLE_COLLECTION                                            \
+	#define PW_IOCTL_DISABLE_COLLECTION \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x912, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_DRIVER_BUILD_DATE                                             \
-	CTL_CODE(POWER_I_CONF_TYPE, 0x913, METHOD_BUFFERED, FILE_ANY_ACCESS)
+	#define PW_IOCTL_DRIVER_BUILD_DATE \
+		CTL_CODE(POWER_I_CONF_TYPE, 0x913, METHOD_BUFFERED, FILE_ANY_ACCESS)
+	#define PW_IOCTL_CONFIG_CONTINUOUS \
+		CTL_CODE(POWER_I_CONF_TYPE, 0x914, METHOD_BUFFERED, FILE_ANY_ACCESS)
+	#define PW_IOCTL_READ_CONTINUOUS \
+		CTL_CODE(POWER_I_CONF_TYPE, 0x915, METHOD_BUFFERED, FILE_ANY_ACCESS)
 
 #elif !defined(__APPLE__)
-#define PW_IOCTL_CONFIG                                                        \
-	_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config,                        \
-	     struct sw_driver_ioctl_arg *)
-#if DO_COUNT_DROPPED_SAMPLES
-#define PW_IOCTL_CMD                                                           \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd,                          \
-	      struct sw_driver_ioctl_arg *)
-#else
-#define PW_IOCTL_CMD                                                           \
-	_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd,                           \
-	     struct sw_driver_ioctl_arg *)
-#endif /* DO_COUNT_DROPPED_SAMPLES */
-#define PW_IOCTL_POLL _IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
-#define PW_IOCTL_IMMEDIATE_IO                                                  \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io,                 \
-	      struct sw_driver_ioctl_arg *)
-#define PW_IOCTL_GET_SCU_FW_VERSION                                            \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version,                   \
-	     struct sw_driver_ioctl_arg *)
-#define PW_IOCTL_READ_IMMEDIATE                                                \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate,               \
-	      struct sw_driver_ioctl_arg *)
-#define PW_IOCTL_GET_DRIVER_VERSION                                            \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version,                \
-	     struct sw_driver_ioctl_arg *)
-#define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS                                     \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace,                   \
-	     struct sw_driver_ioctl_arg *)
-#define PW_IOCTL_GET_AVAILABLE_NOTIFIERS                                       \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify,                  \
-	     struct sw_driver_ioctl_arg *)
-#define PW_IOCTL_GET_AVAILABLE_COLLECTORS                                      \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect,                 \
-	     struct sw_driver_ioctl_arg *)
-#define PW_IOCTL_GET_TOPOLOGY_CHANGES                                          \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes,              \
-	     struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_CONFIG	\
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config, struct sw_driver_ioctl_arg *)
+	#if DO_COUNT_DROPPED_SAMPLES
+		#define PW_IOCTL_CMD \
+			_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, struct sw_driver_ioctl_arg *)
+	#else
+		#define PW_IOCTL_CMD \
+			_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, struct sw_driver_ioctl_arg *)
+	#endif /* DO_COUNT_DROPPED_SAMPLES */
+	#define PW_IOCTL_POLL _IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
+	#define PW_IOCTL_IMMEDIATE_IO	\
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_GET_SCU_FW_VERSION \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_READ_IMMEDIATE \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_GET_DRIVER_VERSION \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_GET_AVAILABLE_NOTIFIERS \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_GET_AVAILABLE_COLLECTORS \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_GET_TOPOLOGY_CHANGES \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_CONFIG_CONTINUOUS \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config_continuous, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_READ_CONTINUOUS \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_continuous, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_SET_TELEM_BAR \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_telem_bar, struct sw_driver_ioctl_arg *)
 #else /* __APPLE__ */
-#define PW_IOCTL_CONFIG                                                        \
-	_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config,                        \
-	     struct sw_driver_ioctl_arg)
-#if DO_COUNT_DROPPED_SAMPLES
-#define PW_IOCTL_CMD                                                           \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd,                          \
-	      struct sw_driver_ioctl_arg)
-#else
-#define PW_IOCTL_CMD                                                           \
-	_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, struct sw_driver_ioctl_arg)
-#endif /* DO_COUNT_DROPPED_SAMPLES */
-#define PW_IOCTL_POLL _IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
-#define PW_IOCTL_IMMEDIATE_IO                                                  \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io,                 \
-	      struct sw_driver_ioctl_arg)
-#define PW_IOCTL_GET_SCU_FW_VERSION                                            \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version,                  \
-	      struct sw_driver_ioctl_arg)
-#define PW_IOCTL_READ_IMMEDIATE                                                \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate,               \
-	      struct sw_driver_ioctl_arg)
-#define PW_IOCTL_GET_DRIVER_VERSION                                            \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version,               \
-	      struct sw_driver_ioctl_arg)
-#define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS                                     \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace,                  \
-	      struct sw_driver_ioctl_arg)
-#define PW_IOCTL_GET_AVAILABLE_NOTIFIERS                                       \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify,                 \
-	      struct sw_driver_ioctl_arg)
-#define PW_IOCTL_GET_AVAILABLE_COLLECTORS                                      \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect,                \
-	      struct sw_driver_ioctl_arg)
-#define PW_IOCTL_GET_TOPOLOGY_CHANGES                                          \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes,             \
-	      struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_CONFIG \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config, struct sw_driver_ioctl_arg)
+	#if DO_COUNT_DROPPED_SAMPLES
+		#define PW_IOCTL_CMD \
+			_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, struct sw_driver_ioctl_arg)
+	#else
+		#define PW_IOCTL_CMD \
+			_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, struct sw_driver_ioctl_arg)
+	#endif /* DO_COUNT_DROPPED_SAMPLES */
+	#define PW_IOCTL_POLL \
+		_IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
+	#define PW_IOCTL_IMMEDIATE_IO \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_GET_SCU_FW_VERSION \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_READ_IMMEDIATE \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_GET_DRIVER_VERSION \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_GET_AVAILABLE_NOTIFIERS \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_GET_AVAILABLE_COLLECTORS \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_GET_TOPOLOGY_CHANGES \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_CONFIG_CONTINUOUS \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config_continuous, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_READ_CONTINUOUS \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_continuous, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_SET_TELEM_BAR \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_telem_bar, struct sw_driver_ioctl_arg *)
 #endif /* __APPLE__ */
 
 /*
@@ -273,31 +262,38 @@ enum sw_ioctl_cmd {
  * and ONLY by the driver.
  */
 #if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)
-#define PW_IOCTL_CONFIG32                                                      \
-	_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config, compat_uptr_t)
+	#define PW_IOCTL_CONFIG32 \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config, compat_uptr_t)
 #if DO_COUNT_DROPPED_SAMPLES
-#define PW_IOCTL_CMD32                                                         \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, compat_uptr_t)
+	#define PW_IOCTL_CMD32 \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, compat_uptr_t)
 #else
-#define PW_IOCTL_CMD32                                                         \
-	_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, compat_uptr_t)
+	#define PW_IOCTL_CMD32 \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, compat_uptr_t)
 #endif /* DO_COUNT_DROPPED_SAMPLES */
-#define PW_IOCTL_POLL32 _IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
-#define PW_IOCTL_IMMEDIATE_IO32                                                \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io, compat_uptr_t)
-#define PW_IOCTL_GET_SCU_FW_VERSION32                                          \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version, compat_uptr_t)
-#define PW_IOCTL_READ_IMMEDIATE32                                              \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate, compat_uptr_t)
-#define PW_IOCTL_GET_DRIVER_VERSION32                                          \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version, compat_uptr_t)
-#define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS32                                   \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace, compat_uptr_t)
-#define PW_IOCTL_GET_AVAILABLE_NOTIFIERS32                                     \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify, compat_uptr_t)
-#define PW_IOCTL_GET_AVAILABLE_COLLECTORS32                                    \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect, compat_uptr_t)
-#define PW_IOCTL_GET_TOPOLOGY_CHANGES32                                        \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes, compat_uptr_t)
+	#define PW_IOCTL_POLL32 \
+		_IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
+	#define PW_IOCTL_IMMEDIATE_IO32 \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io, compat_uptr_t)
+	#define PW_IOCTL_GET_SCU_FW_VERSION32 \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version, compat_uptr_t)
+	#define PW_IOCTL_READ_IMMEDIATE32 \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate, compat_uptr_t)
+	#define PW_IOCTL_GET_DRIVER_VERSION32 \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version, compat_uptr_t)
+	#define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS32 \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace, compat_uptr_t)
+	#define PW_IOCTL_GET_AVAILABLE_NOTIFIERS32 \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify, compat_uptr_t)
+	#define PW_IOCTL_GET_AVAILABLE_COLLECTORS32 \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect, compat_uptr_t)
+	#define PW_IOCTL_GET_TOPOLOGY_CHANGES32 \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes, compat_uptr_t)
+	#define PW_IOCTL_CONFIG_CONTINUOUS32 \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config_continuous, compat_uptr_t)
+	#define PW_IOCTL_READ_CONTINUOUS32 \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_continuous, compat_uptr_t)
+	#define PW_IOCTL_SET_TELEM_BAR32 \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_telem_bar, compat_uptr_t)
 #endif /* defined(CONFIG_COMPAT) && defined(CONFIG_X86_64) */
 #endif /* __SW_IOCTL_H__ */
diff --git a/drivers/platform/x86/socwatch/inc/sw_kernel_defines.h b/drivers/platform/x86/socwatch/inc/sw_kernel_defines.h
index 26328645b232..eaa730491a6e 100644
--- a/drivers/platform/x86/socwatch/inc/sw_kernel_defines.h
+++ b/drivers/platform/x86/socwatch/inc/sw_kernel_defines.h
@@ -1,74 +1,74 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
-*/
 #ifndef _SW_KERNEL_DEFINES_H_
 #define _SW_KERNEL_DEFINES_H_ 1
 
 #include "sw_defines.h"
 
 #if defined(__APPLE__)
-#define likely(x) (x)
-#define unlikely(x) (x)
+	#define likely(x)   (x)
+	#define unlikely(x) (x)
 #endif /* __APPLE__ */
 
 #if !defined(__APPLE__)
-#define CPU() (raw_smp_processor_id())
-#define RAW_CPU() (raw_smp_processor_id())
+	#define CPU() (raw_smp_processor_id())
+	#define RAW_CPU() (raw_smp_processor_id())
 #else
-#define CPU() (cpu_number())
-#define RAW_CPU() (cpu_number())
+	#define CPU() (cpu_number())
+	#define RAW_CPU() (cpu_number())
 #endif /* __APPLE__ */
 
 #define TID() (current->pid)
@@ -77,7 +77,7 @@
 #define PKG(c) (cpu_data(c).phys_proc_id)
 #define IT_REAL_INCR() (current->signal->it_real_incr.tv64)
 
-#define ATOMIC_CAS(ptr, old_val, new_val)                                      \
+#define ATOMIC_CAS(ptr, old_val, new_val)							  \
 	(cmpxchg((ptr), (old_val), (new_val)) == (old_val))
 
 /*
@@ -98,19 +98,19 @@
  * and 'DO_TRACK_MEMORY_USAGE' to be TRUE.
  */
 #if DO_DRIVER_PROFILING
-#if !DO_OVERHEAD_MEASUREMENTS
-#undef DO_OVERHEAD_MEASUREMENTS
-#define DO_OVERHEAD_MEASUREMENTS 1
-#endif /* DO_OVERHEAD_MEASUREMENTS */
-#if !DO_TRACK_MEMORY_USAGE
-#undef DO_TRACK_MEMORY_USAGE
-#define DO_TRACK_MEMORY_USAGE 1
-#endif /* DO_TRACK_MEMORY_USAGE */
+	#if !DO_OVERHEAD_MEASUREMENTS
+		#undef DO_OVERHEAD_MEASUREMENTS
+		#define DO_OVERHEAD_MEASUREMENTS 1
+	#endif /* DO_OVERHEAD_MEASUREMENTS */
+	#if !DO_TRACK_MEMORY_USAGE
+		#undef DO_TRACK_MEMORY_USAGE
+		#define DO_TRACK_MEMORY_USAGE 1
+	#endif /* DO_TRACK_MEMORY_USAGE */
 #endif /* DO_DRIVER_PROFILING */
 /*
  * Should we allow debug output.
  * Set to: "1" ==> 'OUTPUT' is enabled.
- *         "0" ==> 'OUTPUT' is disabled.
+ *		 "0" ==> 'OUTPUT' is disabled.
  */
 #define DO_DEBUG_OUTPUT 0
 /*
@@ -118,47 +118,47 @@
  * These are independent of the 'OUTPUT' macro
  * (which controls debug messages).
  * Set to '1' ==> Print driver error messages (to '/var/log/messages')
- *        '0' ==> Do NOT print driver error messages
+ *		'0' ==> Do NOT print driver error messages
  */
 #define DO_PRINT_DRIVER_ERROR_MESSAGES 1
 /*
  * Macros to control output printing.
  */
 #if !defined(__APPLE__)
-#if DO_DEBUG_OUTPUT
-#define pw_pr_debug(...) printk(KERN_INFO __VA_ARGS__)
-#define pw_pr_warn(...) printk(KERN_WARNING __VA_ARGS__)
+	#if DO_DEBUG_OUTPUT
+		#define pw_pr_debug(...) pr_info(__VA_ARGS__)
+		#define pw_pr_warn(...) pr_warn(__VA_ARGS__)
+	#else
+		#define pw_pr_debug(...)
+		#define pw_pr_warn(...)
+	#endif
+	#define pw_pr_force(...) pr_info(__VA_ARGS__)
 #else
-#define pw_pr_debug(...)
-#define pw_pr_warn(...)
-#endif
-#define pw_pr_force(...) printk(KERN_INFO __VA_ARGS__)
-#else
-#if DO_DEBUG_OUTPUT
-#define pw_pr_debug(...) IOLog(__VA_ARGS__)
-#define pw_pr_warn(...) IOLog(__VA_ARGS__)
-#else
-#define pw_pr_debug(...)
-#define pw_pr_warn(...)
-#endif
-#define pw_pr_force(...) IOLog(__VA_ARGS__)
+	#if DO_DEBUG_OUTPUT
+		#define pw_pr_debug(...) IOLog(__VA_ARGS__)
+		#define pw_pr_warn(...) IOLog(__VA_ARGS__)
+	#else
+		#define pw_pr_debug(...)
+		#define pw_pr_warn(...)
+	#endif
+	#define pw_pr_force(...) IOLog(__VA_ARGS__)
 #endif /* __APPLE__ */
 
 /*
  * Macro for driver error messages.
  */
 #if !defined(__APPLE__)
-#if (DO_PRINT_DRIVER_ERROR_MESSAGES || DO_DEBUG_OUTPUT)
-#define pw_pr_error(...) printk(KERN_ERR __VA_ARGS__)
-#else
-#define pw_pr_error(...)
-#endif
-#else
-#if (DO_PRINT_DRIVER_ERROR_MESSAGES || DO_DEBUG_OUTPUT)
-#define pw_pr_error(...) IOLog(__VA_ARGS__)
+	#if (DO_PRINT_DRIVER_ERROR_MESSAGES || DO_DEBUG_OUTPUT)
+		#define pw_pr_error(...) pr_err(__VA_ARGS__)
+	#else
+		#define pw_pr_error(...)
+	#endif
 #else
-#define pw_pr_error(...)
-#endif
+	#if (DO_PRINT_DRIVER_ERROR_MESSAGES || DO_DEBUG_OUTPUT)
+		#define pw_pr_error(...) IOLog(__VA_ARGS__)
+	#else
+		#define pw_pr_error(...)
+	#endif
 #endif /* __APPLE__ */
 
 #endif /* _SW_KERNEL_DEFINES_H_ */
diff --git a/drivers/platform/x86/socwatch/inc/sw_list.h b/drivers/platform/x86/socwatch/inc/sw_list.h
index 9c17e50ac5bf..9b632beefa84 100644
--- a/drivers/platform/x86/socwatch/inc/sw_list.h
+++ b/drivers/platform/x86/socwatch/inc/sw_list.h
@@ -1,76 +1,76 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 #ifndef __SW_LIST_H__
 #define __SW_LIST_H__
 
 #include <linux/list.h>
 
-#define SW_DEFINE_LIST_HEAD(name, dummy) struct list_head name
-#define SW_DECLARE_LIST_HEAD(name, dummy) extern struct list_head name
-#define SW_LIST_ENTRY(name, dummy) struct list_head name
-#define SW_LIST_HEAD_VAR(dummy) struct list_head
-#define SW_LIST_HEAD_INIT(head) INIT_LIST_HEAD(head)
-#define SW_LIST_ENTRY_INIT(node, field) INIT_LIST_HEAD(&node->field)
-#define SW_LIST_ADD(head, node, field) list_add_tail(&node->field, head)
-#define SW_LIST_GET_HEAD_ENTRY(head, type, field)                              \
+#define SW_DEFINE_LIST_HEAD(name, dummy)            struct list_head name
+#define SW_DECLARE_LIST_HEAD(name, dummy)           extern struct list_head name
+#define SW_LIST_ENTRY(name, dummy)                  struct list_head name
+#define SW_LIST_HEAD_VAR(dummy)                     struct list_head
+#define SW_LIST_HEAD_INIT(head)                     INIT_LIST_HEAD(head)
+#define SW_LIST_ENTRY_INIT(node, field)             INIT_LIST_HEAD(&node->field)
+#define SW_LIST_ADD(head, node, field)              \
+	list_add_tail(&node->field, head)
+#define SW_LIST_GET_HEAD_ENTRY(head, type, field)   \
 	list_first_entry(head, struct type, field)
-#define SW_LIST_UNLINK(node, field) list_del(&node->field)
-#define SW_LIST_FOR_EACH_ENTRY(node, head, field)                              \
+#define SW_LIST_UNLINK(node, field)                 list_del(&node->field)
+#define SW_LIST_FOR_EACH_ENTRY(node, head, field)   \
 	list_for_each_entry(node, head, field)
-#define SW_LIST_EMPTY(head) list_empty(head)
-#define SW_LIST_HEAD_INITIALIZER(head) LIST_HEAD_INIT(head)
+#define SW_LIST_EMPTY(head)                         list_empty(head)
+#define SW_LIST_HEAD_INITIALIZER(head)              LIST_HEAD_INIT(head)
 
 #endif /* __SW_LIST_H__ */
diff --git a/drivers/platform/x86/socwatch/inc/sw_lock_defs.h b/drivers/platform/x86/socwatch/inc/sw_lock_defs.h
index be44bfab01a7..42914f8998f7 100644
--- a/drivers/platform/x86/socwatch/inc/sw_lock_defs.h
+++ b/drivers/platform/x86/socwatch/inc/sw_lock_defs.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 /*
  * Description: file containing locking routines
@@ -62,37 +61,44 @@
 #ifndef __SW_LOCK_DEFS_H__
 #define __SW_LOCK_DEFS_H__
 
-#define SW_DEFINE_SPINLOCK(s) DEFINE_SPINLOCK(s)
-#define SW_DECLARE_SPINLOCK(s) static spinlock_t s
+/*
+ * Spinlocks
+ */
+#define SW_DEFINE_SPINLOCK(s)   DEFINE_SPINLOCK(s)
+#define SW_DECLARE_SPINLOCK(s)  static spinlock_t s
+
+#define SW_INIT_SPINLOCK(s)     spin_lock_init(&s)
+#define SW_DESTROY_SPINLOCK(s)  /* NOP */
 
-#define SW_INIT_SPINLOCK(s) spin_lock_init(&s)
-#define SW_DESTROY_SPINLOCK(s) /* NOP */
+#define LOCK(l) { \
+	unsigned long l##_flags; \
+	spin_lock_irqsave(&(l), l##_flags);
 
-#define LOCK(l)                                                                \
-	{                                                                      \
-		unsigned long _tmp_l_flags;                                    \
-		spin_lock_irqsave(&(l), _tmp_l_flags);
+#define UNLOCK(l) \
+	spin_unlock_irqrestore(&(l), l##_flags); \
+}
 
-#define UNLOCK(l)                                                              \
-	spin_unlock_irqrestore(&(l), _tmp_l_flags);                            \
-	}
+/*
+ * R/W locks
+ */
+#define SW_DECLARE_RWLOCK(l) static rwlock_t l
+#define SW_INIT_RWLOCK(l) rwlock_init(&(l))
+#define SW_DESTROY_RWLOCK(l) /* NOP */
 
-#define READ_LOCK(l)                                                           \
-	{                                                                      \
-		unsigned long _tmp_l_flags;                                    \
-		read_lock_irqsave(&(l), _tmp_l_flags);
+#define READ_LOCK(l) { \
+	unsigned long l##_flags; \
+	read_lock_irqsave(&(l), l##_flags);
 
-#define READ_UNLOCK(l)                                                         \
-	read_unlock_irqrestore(&(l), _tmp_l_flags);                            \
-	}
+#define READ_UNLOCK(l) \
+	read_unlock_irqrestore(&(l), l##_flags); \
+}
 
-#define WRITE_LOCK(l)                                                          \
-	{                                                                      \
-		unsigned long _tmp_l_flags;                                    \
-		write_lock_irqsave(&(l), _tmp_l_flags);
+#define WRITE_LOCK(l) { \
+	unsigned long l##_flags; \
+	write_lock_irqsave(&(l), l##_flags);
 
-#define WRITE_UNLOCK(l)                                                        \
-	write_unlock_irqrestore(&(l), _tmp_l_flags);                           \
-	}
+#define WRITE_UNLOCK(l) \
+	write_unlock_irqrestore(&(l), l##_flags); \
+}
 
 #endif /* __SW_LOCK_DEFS_H__ */
diff --git a/drivers/platform/x86/socwatch/inc/sw_mem.h b/drivers/platform/x86/socwatch/inc/sw_mem.h
index 0d6de7f3a21b..b8797fd1dab1 100644
--- a/drivers/platform/x86/socwatch/inc/sw_mem.h
+++ b/drivers/platform/x86/socwatch/inc/sw_mem.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 /*
  * Description: file containing memory management routines
@@ -64,13 +63,13 @@
 
 #include "sw_types.h"
 
-void *sw_kmalloc(size_t size, gfp_t flags);
+void *sw_kmalloc(size_t size, unsigned int flags);
 void sw_kfree(const void *obj);
 /*
  * Allocate free pages.
  */
-unsigned long sw_allocate_pages(gfp_t flags,
-				unsigned int alloc_size_in_bytes);
+unsigned long sw_allocate_pages(unsigned int flags,
+	unsigned int alloc_size_in_bytes);
 /*
  * Free up previously allocated pages.
  */
diff --git a/drivers/platform/x86/socwatch/inc/sw_ops_provider.h b/drivers/platform/x86/socwatch/inc/sw_ops_provider.h
index bb841bf65cb6..69b1b70a3fdc 100644
--- a/drivers/platform/x86/socwatch/inc/sw_ops_provider.h
+++ b/drivers/platform/x86/socwatch/inc/sw_ops_provider.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 #ifndef __SW_OPS_PROVIDER_H__
 #define __SW_OPS_PROVIDER_H__
 
diff --git a/drivers/platform/x86/socwatch/inc/sw_output_buffer.h b/drivers/platform/x86/socwatch/inc/sw_output_buffer.h
index 8d6518222ce3..d7138a7aa866 100644
--- a/drivers/platform/x86/socwatch/inc/sw_output_buffer.h
+++ b/drivers/platform/x86/socwatch/inc/sw_output_buffer.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef _SW_OUTPUT_BUFFER_H_
 #define _SW_OUTPUT_BUFFER_H_ 1
@@ -97,11 +96,10 @@ void sw_reset_per_cpu_buffers(void);
 
 void sw_count_samples_produced_dropped(void);
 
-int sw_produce_polled_msg(struct sw_driver_msg *, enum sw_wakeup_action);
 int sw_produce_generic_msg(struct sw_driver_msg *, enum sw_wakeup_action);
 
 bool sw_any_seg_full(u32 *val, bool is_flush_mode);
-size_t sw_consume_data(u32 mask, void __user *buffer, size_t bytes_to_read);
+ssize_t sw_consume_data(u32 mask, void __user *buffer, size_t bytes_to_read);
 
 unsigned int sw_get_output_buffer_size(void);
 
@@ -133,4 +131,12 @@ void sw_cancel_reader(void);
  */
 void sw_print_reader_stats(void);
 
+/* *************************************************
+ * For circular buffer (continuous profiling)
+ * *************************************************
+ */
+long initialize_circular_buffer(size_t size);
+void reset_circular_buffer(void);
+void destroy_circular_buffer(void);
+
 #endif /* _SW_OUTPUT_BUFFER_H_ */
diff --git a/drivers/platform/x86/socwatch/inc/sw_overhead_measurements.h b/drivers/platform/x86/socwatch/inc/sw_overhead_measurements.h
index 4052555419a8..b665f5438a3f 100644
--- a/drivers/platform/x86/socwatch/inc/sw_overhead_measurements.h
+++ b/drivers/platform/x86/socwatch/inc/sw_overhead_measurements.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 /*
  * Description: file containing overhead measurement
@@ -81,26 +80,26 @@
 #if DO_OVERHEAD_MEASUREMENTS
 
 #ifndef __get_cpu_var
-/*
- * Kernels >= 3.19 don't include a definition
- * of '__get_cpu_var'. Create one now.
- */
-#define __get_cpu_var(var) (*this_cpu_ptr(&var))
+	/*
+	 * Kernels >= 3.19 don't include a definition
+	 * of '__get_cpu_var'. Create one now.
+	 */
+	#define __get_cpu_var(var) (*this_cpu_ptr(&var))
 #endif /* __get_cpu_var */
 #ifndef __raw_get_cpu_var
-/*
- * Kernels >= 3.19 don't include a definition
- * of '__raw_get_cpu_var'. Create one now.
- */
-#define __raw_get_cpu_var(var) (*raw_cpu_ptr(&var))
+	/*
+	 * Kernels >= 3.19 don't include a definition
+	 * of '__raw_get_cpu_var'. Create one now.
+	 */
+	#define __raw_get_cpu_var(var) (*raw_cpu_ptr(&var))
 #endif /* __get_cpu_var */
 
 extern u64 sw_timestamp(void);
 
 #define DECLARE_OVERHEAD_VARS(name)					\
 	static DEFINE_PER_CPU(u64, name##_elapsed_time);		\
-	static DEFINE_PER_CPU(local_t, name##_num_iters) = LOCAL_INIT(0); \
-									\
+	static DEFINE_PER_CPU(local_t, name##_num_iters) =		\
+							 LOCAL_INIT(0);	\
 	static inline u64 get_my_cumulative_elapsed_time_##name(void)	\
 	{								\
 		return *(&__get_cpu_var(name##_elapsed_time));		\
@@ -109,81 +108,77 @@ extern u64 sw_timestamp(void);
 	{								\
 		return local_read(&__get_cpu_var(name##_num_iters));	\
 	}								\
-									\
-	static inline u64 name##_get_cumulative_elapsed_time_for(int cpu) \
+	static inline u64 name##_get_cumulative_elapsed_time_for(	\
+							int cpu)	\
 	{								\
 		return *(&per_cpu(name##_elapsed_time, cpu));		\
 	}								\
-									\
 	static inline int name##_get_cumulative_num_iters_for(int cpu)	\
 	{								\
 		return local_read(&per_cpu(name##_num_iters, cpu));	\
 	}								\
-									\
-	static inline void name##_get_cumulative_overhead_params(u64 *time, \
-								 int *iters) \
+	static inline void name##_get_cumulative_overhead_params(	\
+							u64 *time,	\
+							int *iters)	\
 	{								\
 		int cpu = 0;						\
-		*time = 0;						\
-		*iters = 0;						\
+		*time = 0; *iters = 0;					\
 		for_each_online_cpu(cpu) {				\
-			*iters += name##_get_cumulative_num_iters_for(cpu); \
-			*time += name##_get_cumulative_elapsed_time_for(cpu); \
+			*iters += name##_get_cumulative_num_iters_for(	\
+								cpu);	\
+			*time += name##_get_cumulative_elapsed_time_for(\
+								cpu);	\
 		}							\
 		return;							\
 	}								\
-									\
 	static inline void name##_print_cumulative_overhead_params(	\
-		const char *str)					\
+							const char *str)\
 	{								\
 		int num = 0;						\
 		u64 time = 0;						\
 		name##_get_cumulative_overhead_params(&time, &num);	\
-		printk(KERN_INFO "%s: %d iters took %llu nano seconds!\n", \
-		       str, num, time);					\
+		pw_pr_error("%s: %d iters took %llu nano seconds!\n",	\
+			str, num, time);				\
 	}
 
-#define DO_PER_CPU_OVERHEAD_FUNC(func, ...)				\
-	do {								\
-		u64 *__v = &__raw_get_cpu_var(func##_elapsed_time);	\
-		u64 tmp_1 = 0, tmp_2 = 0;				\
-		local_inc(&__raw_get_cpu_var(func##_num_iters));	\
-		tmp_1 = sw_timestamp();					\
-		{							\
-			func(__VA_ARGS__);				\
-		}							\
-		tmp_2 = sw_timestamp();					\
-		*(__v) += (tmp_2 - tmp_1);				\
-	} while (0)
-
-#define DO_PER_CPU_OVERHEAD_FUNC_RET(type, func, ...)			\
-	({								\
-		type __ret;						\
-		u64 *__v = &__raw_get_cpu_var(func##_elapsed_time);	\
-		u64 tmp_1 = 0, tmp_2 = 0;				\
-		local_inc(&__raw_get_cpu_var(func##_num_iters));	\
-		tmp_1 = sw_timestamp();					\
-		{							\
-			__ret = func(__VA_ARGS__);			\
-		}							\
-		tmp_2 = sw_timestamp();					\
-		*(__v) += (tmp_2 - tmp_1);				\
-		__ret;							\
-	})
+#define DO_PER_CPU_OVERHEAD_FUNC(func, ...) do {			\
+	u64 *__v = &__raw_get_cpu_var(func##_elapsed_time);		\
+	u64 tmp_1 = 0, tmp_2 = 0;					\
+	local_inc(&__raw_get_cpu_var(func##_num_iters));		\
+	tmp_1 = sw_timestamp();						\
+	{								\
+		func(__VA_ARGS__);						\
+	}								\
+	tmp_2 = sw_timestamp();						\
+	*(__v) += (tmp_2 - tmp_1);					\
+} while (0)
+
+#define DO_PER_CPU_OVERHEAD_FUNC_RET(type, func, ...) ({		\
+	type __ret;							\
+	u64 *__v = &__raw_get_cpu_var(func##_elapsed_time);		\
+	u64 tmp_1 = 0, tmp_2 = 0;					\
+	local_inc(&__raw_get_cpu_var(func##_num_iters));		\
+	tmp_1 = sw_timestamp();						\
+	{								\
+		__ret = func(__VA_ARGS__);					\
+	}								\
+	tmp_2 = sw_timestamp();						\
+	*(__v) += (tmp_2 - tmp_1);					\
+	__ret;								\
+})
 
 #else /* !DO_OVERHEAD_MEASUREMENTS */
 #define DECLARE_OVERHEAD_VARS(name)					\
 	static inline void name##_print_cumulative_overhead_params(	\
-		const char *str)					\
-	{ /* NOP */							\
-	}
+							const char *str)\
+		{ /* NOP */ }
 
 #define DO_PER_CPU_OVERHEAD_FUNC(func, ...) func(__VA_ARGS__)
 #define DO_PER_CPU_OVERHEAD_FUNC_RET(type, func, ...) func(__VA_ARGS__)
 
 #endif /* DO_OVERHEAD_MEASUREMENTS */
 
-#define PRINT_CUMULATIVE_OVERHEAD_PARAMS(name, str)	\
+#define PRINT_CUMULATIVE_OVERHEAD_PARAMS(name, str)			\
 	name##_print_cumulative_overhead_params(str)
 
 #endif /* _PW_OVERHEAD_MEASUREMENTS_H_ */
diff --git a/drivers/platform/x86/socwatch/inc/sw_structs.h b/drivers/platform/x86/socwatch/inc/sw_structs.h
index de5ad2b6eb70..738edd35de24 100644
--- a/drivers/platform/x86/socwatch/inc/sw_structs.h
+++ b/drivers/platform/x86/socwatch/inc/sw_structs.h
@@ -1,58 +1,58 @@
-/*
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
 #ifndef __SW_STRUCTS_H__
 #define __SW_STRUCTS_H__ 1
 
@@ -82,7 +82,7 @@ typedef struct sw_string_type {
 	char data[1];
 } sw_string_type_t;
 #pragma pack(pop)
-#define SW_STRING_TYPE_HEADER_SIZE()                                           \
+#define SW_STRING_TYPE_HEADER_SIZE()			\
 	(sizeof(struct sw_string_type) - sizeof(char[1]))
 
 #pragma pack(push, 1)
@@ -91,21 +91,22 @@ struct sw_key_value_payload {
 	char data[1];
 };
 #pragma pack(pop)
-#define SW_KEY_VALUE_PAYLOAD_HEADER_SIZE()                                     \
+#define SW_KEY_VALUE_PAYLOAD_HEADER_SIZE()		\
 	(sizeof(struct sw_key_value_payload) - sizeof(char[1]))
 
 typedef enum sw_kernel_wakelock_type {
-	SW_WAKE_LOCK = 0, /* A kernel wakelock was acquired */
-	SW_WAKE_UNLOCK = 1, /* A kernel wakelock was released */
-	SW_WAKE_LOCK_TIMEOUT =
-		2, /* A kernel wakelock was acquired with a timeout */
-	SW_WAKE_LOCK_INITIAL = 3, /* A kernel wakelock was acquired
-				   * before the
-				   * collection started
-				   */
-	SW_WAKE_UNLOCK_ALL = 4, /* All previously held kernel wakelocks were
-				 * released -- used in ACPI S3 notifications
-				 */
+	/* A kernel wakelock was acquired */
+	SW_WAKE_LOCK = 0,
+	/* A kernel wakelock was released */
+	SW_WAKE_UNLOCK = 1,
+	/* A kernel wakelock was acquired with a timeout */
+	SW_WAKE_LOCK_TIMEOUT = 2,
+	/* A kernel wakelock was acquired before the collection started*/
+	SW_WAKE_LOCK_INITIAL = 3,
+	/* All previously held kernel wakelocks were
+	 * released -- used in ACPI S3 notifications
+	 */
+	SW_WAKE_UNLOCK_ALL = 4,
 } sw_kernel_wakelock_type_t;
 
 typedef enum sw_when_type {
@@ -118,18 +119,23 @@ typedef enum sw_when_type {
 } sw_when_type_t;
 
 /**
- * trigger_bits is defined to use type pw_u8_t
- * that makes only upto 8 types possible
+ * trigger_bits is defined to use type pw_u8_t that makes only
+ * upto 8 types possible
  */
-#define SW_TRIGGER_BEGIN_MASK() (1U << SW_WHEN_TYPE_BEGIN)
-#define SW_TRIGGER_END_MASK() (1U << SW_WHEN_TYPE_END)
-#define SW_TRIGGER_POLL_MASK() (1U << SW_WHEN_TYPE_POLL)
-#define SW_TRIGGER_TRACEPOINT_MASK() (1U << SW_WHEN_TYPE_TRACEPOINT)
-#define SW_TRIGGER_NOTIFIER_MASK() (1U << SW_WHEN_TYPE_NOTIFIER)
-#define SW_GET_TRIGGER_MASK_VALUE(m) (1U << (m))
-#define SW_TRIGGER_MASK_ALL() (0xFF)
+#define SW_TRIGGER_BEGIN_MASK()		(1U << SW_WHEN_TYPE_BEGIN)
+#define SW_TRIGGER_END_MASK()		(1U << SW_WHEN_TYPE_END)
+#define SW_TRIGGER_POLL_MASK()		(1U << SW_WHEN_TYPE_POLL)
+#define SW_TRIGGER_TRACEPOINT_MASK()	(1U << SW_WHEN_TYPE_TRACEPOINT)
+#define SW_TRIGGER_NOTIFIER_MASK()	(1U << SW_WHEN_TYPE_NOTIFIER)
+#define SW_GET_TRIGGER_MASK_VALUE(m)	(1U << (m))
+#define SW_TRIGGER_MASK_ALL()		(0xFF)
+
+enum sw_io_cmd {
+	SW_IO_CMD_READ = 0,
+	SW_IO_CMD_WRITE,
+	SW_IO_CMD_MAX
+};
 
-enum sw_io_cmd { SW_IO_CMD_READ = 0, SW_IO_CMD_WRITE, SW_IO_CMD_MAX };
 
 #pragma pack(push, 1)
 struct sw_driver_msr_io_descriptor {
@@ -143,10 +149,8 @@ struct sw_driver_ipc_mmio_io_descriptor {
 	union {
 #ifdef SWW_MERGE
 #pragma warning(push)
-#pragma warning(                                                               \
-	disable : 4201) /* disable C4201: nonstandard extension used:
-			 * nameless struct/union
-			 */
+/* disable C4201: nonstandard extension used: nameless struct/union */
+#pragma warning(disable:4201)
 #endif
 		struct {
 			pw_u16_t command;
@@ -156,13 +160,14 @@ struct sw_driver_ipc_mmio_io_descriptor {
 #pragma warning(pop) /* enable C4201 */
 #endif
 		union {
-			pw_u32_t ipc_command; /* (sub_command << 12)
-					       * | (command)
-					       */
+			/* (sub_command << 12) | (command) */
+			pw_u32_t ipc_command;
 			pw_u8_t is_gbe; /* Used only for GBE MMIO */
 		};
 	};
-	/* TODO: add a section for 'ctrl_address' and 'ctrl_remapped_address' */
+	/* TODO: add a section for 'ctrl_address' and
+	 * 'ctrl_remapped_address'
+	 */
 	union {
 		pw_u64_t data_address; /* Will be "io_remapped" */
 		pw_u64_t data_remapped_address;
@@ -196,10 +201,12 @@ struct sw_driver_configdb_io_descriptor {
 
 #pragma pack(push, 1)
 struct sw_driver_trace_args_io_descriptor {
-	pw_u8_t num_args; /* Number of valid entries in the 'args' array,
-			   * below; 1 <= num_args <= 7
-			   */
-	pw_u8_t args[7]; /* Max of 7 args can be recorded */
+	/* Number of valid entries in the 'args' array, below;
+	 * 1 <= num_args <= 7
+	 */
+	pw_u8_t num_args;
+	/* Max of 7 args can be recorded */
+	pw_u8_t args[7];
 };
 #pragma pack(pop)
 
@@ -207,14 +214,14 @@ struct sw_driver_trace_args_io_descriptor {
 /**
  * struct - sw_driver_telem_io_descriptor - Telemetry Metric descriptor
  *
- * @id:    (Client & Driver) Telemetry ID of the counter to read.
+ * @id:	(Client & Driver) Telemetry ID of the counter to read.
  * @idx:   (Driver only) index into telem array to read, or the row
- *            of the telem_indirect table to lookup the telem array index.
+ *		of the telem_indirect table to lookup the telem array index.
  * @unit:  Unit from which to collect:  0 = PMC, 1 = PUNIT
- *              Values come from the telemetry_unit enum.
+ *		Values come from the telemetry_unit enum.
  * @scale_op:  When there are multiple instances of a telem value (e.g.
- *              module C-states) the operation to use when scaling the CPU ID
- *              and adding it to the telemetry data ID.
+ *		module C-states) the operation to use when scaling the CPU ID
+ *		and adding it to the telemetry data ID.
  * @scale_val: Amount to scale an ID (when scaling one.)
  *
  * Like all hardware mechanism descriptors, the client uses this to pass
@@ -225,13 +232,13 @@ struct sw_driver_trace_args_io_descriptor {
  * the equation: ID = ID_value + (cpuid <scaling_op> <scaling_val>)
  * where <scaling_op> is one of +, *, /, or %, and scaling_val is an integer
  * value.  This gives you:
- *            Operation             scale_op     scale_val
- *       Single instance of an ID       *            0
- *       Sequentially increasing
- *          CPU-specific values         *            1
- *       Per module cpu-specific
- *          values (2 cores/module)     /            2
- *       Round Robin assignment         %         cpu_count
+ *	Operation			scale_op	 	scale_val
+ *	Single instance of an ID	*			0
+ *	sequentially increasing
+ *	CPU-specific values		*			1
+ *	Per module cpu-specific
+ *	values (2 cores/module)		/			2
+ *	Round Robin assignment		%			cpu_count
  *
  * Note that scaling_value of 0 implies that no scaling should be
  * applied.  While (*, 1) is equivalent to (+, 0), the scaling value of 0
@@ -243,21 +250,21 @@ struct sw_driver_trace_args_io_descriptor {
 struct sw_driver_telem_io_descriptor {
 	union {
 		pw_u16_t id;
-		pw_u8_t idx;
+		pw_u8_t  idx;
 	};
-	pw_u8_t unit;
-	pw_u8_t scale_op;
-	pw_u16_t scale_val;
+	pw_u8_t   unit;
+	pw_u8_t   scale_op;
+	pw_u16_t  scale_val;
 };
 #pragma pack(pop)
 enum telemetry_unit { TELEM_PUNIT = 0, TELEM_PMC, TELEM_UNIT_NONE };
-#define TELEM_MAX_ID 0xFFFF /* Maximum value of a Telemtry event ID. */
-#define TELEM_MAX_SCALE 0xFFFF /* Maximum ID scaling value. */
-#define TELEM_OP_ADD '+' /* Addition operator */
-#define TELEM_OP_MULT '*' /* Multiplication operator */
-#define TELEM_OP_DIV '/' /* Division operator */
-#define TELEM_OP_MOD '%' /* Modulus operator */
-#define TELEM_OP_NONE 'X' /* No operator--Not a scaled ID */
+#define TELEM_MAX_ID	0xFFFF  /* Maximum value of a Telemtry event ID. */
+#define TELEM_MAX_SCALE 0xFFFF  /* Maximum ID scaling value. */
+#define TELEM_OP_ADD	'+'	 /* Addition operator */
+#define TELEM_OP_MULT	'*'	 /* Multiplication operator */
+#define TELEM_OP_DIV	'/'	 /* Division operator */
+#define TELEM_OP_MOD	'%'	 /* Modulus operator */
+#define TELEM_OP_NONE	'X'	 /* No operator--Not a scaled ID */
 
 #pragma pack(push, 1)
 struct sw_driver_mailbox_io_descriptor {
@@ -293,8 +300,8 @@ struct sw_driver_pch_mailbox_io_descriptor {
 	};
 	union {
 		/*
-		 * Will be "io_remapped"
-		 */
+	 	* Will be "io_remapped"
+		*/
 		pw_u64_t msg_full_sts_address;
 		pw_u64_t msg_full_sts_remapped_address;
 	};
@@ -314,20 +321,17 @@ typedef struct sw_driver_io_descriptor {
 	pw_u16_t collection_type;
 	/* TODO: specify READ/WRITE */
 	pw_s16_t collection_command; /* One of 'enum sw_io_cmd' */
-	pw_u16_t counter_size_in_bytes; /* The number of bytes to
-					 * READ or WRITE
-					 */
+	pw_u16_t counter_size_in_bytes; /* The number of bytes to READ or WRITE */
 	union {
-		struct sw_driver_msr_io_descriptor msr_descriptor;
-		struct sw_driver_ipc_mmio_io_descriptor ipc_descriptor;
-		struct sw_driver_ipc_mmio_io_descriptor mmio_descriptor;
-		struct sw_driver_pci_io_descriptor pci_descriptor;
-		struct sw_driver_configdb_io_descriptor configdb_descriptor;
-		struct sw_driver_trace_args_io_descriptor trace_args_descriptor;
-		struct sw_driver_telem_io_descriptor telem_descriptor;
-		struct sw_driver_pch_mailbox_io_descriptor
-			pch_mailbox_descriptor;
-		struct sw_driver_mailbox_io_descriptor mailbox_descriptor;
+		struct sw_driver_msr_io_descriptor 		msr_descriptor;
+		struct sw_driver_ipc_mmio_io_descriptor 	ipc_descriptor;
+		struct sw_driver_ipc_mmio_io_descriptor 	mmio_descriptor;
+		struct sw_driver_pci_io_descriptor		pci_descriptor;
+		struct sw_driver_configdb_io_descriptor		configdb_descriptor;
+		struct sw_driver_trace_args_io_descriptor 	trace_args_descriptor;
+		struct sw_driver_telem_io_descriptor		telem_descriptor;
+		struct sw_driver_pch_mailbox_io_descriptor 	pch_mailbox_descriptor;
+		struct sw_driver_mailbox_io_descriptor		mailbox_descriptor;
 	};
 	pw_u64_t write_value; /* The value to WRITE */
 } sw_driver_io_descriptor_t;
@@ -345,48 +349,38 @@ typedef struct sw_driver_io_descriptor {
 struct sw_driver_interface_info {
 	pw_u64_t tracepoint_id_mask;
 	pw_u64_t notifier_id_mask;
-	pw_s16_t cpu_mask; /* On which CPU(s) should the driver
-			    * read the data?
-			    * Currently:  -2 ==> read on ALL CPUs,
-			    *             -1 ==> read on ANY CPU,
-			    *           >= 0 ==> the specific CPU to read on
-			    */
+	pw_s16_t cpu_mask;  /* On which CPU(s) should the driver read the data? */
+			/* Currently:  -2 ==> read on ALL CPUs, */
+			/* -1 ==> read on ANY CPU, */
+			/* >= 0 ==> the specific CPU to read on */
 	pw_s16_t plugin_id; /* Metric Plugin SID */
-	pw_s16_t metric_id; /* Domain-specific ID assigned by
-			     * each Metric Plugin
-			     */
+	pw_s16_t metric_id; /* Domain-specific ID assigned by each Metric Plugin */
 	pw_s16_t msg_id; /* Msg ID retrieved from the SoC Watch config file */
-	pw_u16_t num_io_descriptors; /* Number of descriptors in the array,
-				      * below.
-				      */
-	pw_u8_t trigger_bits; /* Mask of 'when bits' to fire this collector. */
+	pw_u16_t num_io_descriptors; /* Number of descriptors in the array, below. */
+	pw_u8_t  trigger_bits;  /* Mask of 'when bits' to fire this collector. */
 	pw_u16_t sampling_interval_msec; /* Sampling interval, in msecs */
-	pw_u8_t descriptors[1]; /* Array of sw_driver_io_descriptor structs. */
+	pw_u8_t  descriptors[1];	 /* Array of sw_driver_io_descriptor structs. */
 };
 #pragma pack(pop)
 
-#define SW_DRIVER_INTERFACE_INFO_HEADER_SIZE()                                 \
+#define SW_DRIVER_INTERFACE_INFO_HEADER_SIZE()	\
 	(sizeof(struct sw_driver_interface_info) - sizeof(pw_u8_t[1]))
 
 #pragma pack(push, 1)
 struct sw_driver_interface_msg {
-	pw_u16_t num_infos; /* Number of 'sw_driver_interface_info'
-			     * structs contained within the 'infos' variable,
-			     * below
-			     */
-	pw_u16_t min_polling_interval_msecs; /* Min time to wait before
-					      * polling; used exclusively
-					      * with the low overhead,
-					      * context-switch based
-					      * polling mode
-					      */
-	/* pw_u16_t infos_size_bytes; Size of data inlined
-	 * within the 'infos' variable, below
+	/* Number of 'sw_driver_interface_info' structs contained within
+	 * the 'infos' variable, below
+	 */
+	pw_u16_t num_infos;
+	/* Min time to wait before polling; used exclusively
+	 * with the low overhead, context-switch based
+	 * polling mode
 	 */
+	pw_u16_t min_polling_interval_msecs;
 	pw_u8_t infos[1];
 };
 #pragma pack(pop)
-#define SW_DRIVER_INTERFACE_MSG_HEADER_SIZE()                                  \
+#define SW_DRIVER_INTERFACE_MSG_HEADER_SIZE()	\
 	(sizeof(struct sw_driver_interface_msg) - sizeof(pw_u8_t[1]))
 
 typedef enum sw_name_id_type {
@@ -403,7 +397,7 @@ struct sw_name_id_pair {
 	struct sw_string_type name;
 };
 #pragma pack(pop)
-#define SW_NAME_ID_HEADER_SIZE()                                               \
+#define SW_NAME_ID_HEADER_SIZE() 		\
 	(sizeof(struct sw_name_id_pair) - sizeof(struct sw_string_type))
 
 #pragma pack(push, 1)
@@ -424,20 +418,23 @@ struct sw_name_info_msg {
 typedef struct sw_driver_msg {
 	pw_u64_t tsc;
 	pw_u16_t cpuidx;
-	pw_u8_t plugin_id; /* Cannot have more than 256 plugins */
-	pw_u8_t metric_id; /* Each plugin cannot handle more than 256 metrics */
-	pw_u8_t msg_id; /* Each metric cannot have more than 256 components */
+	/* Cannot have more than 256 plugins */
+	pw_u8_t  plugin_id;
+	/* Each plugin cannot handle more than 256 metrics */
+	pw_u8_t  metric_id;
+	/* Each metric cannot have more than 256 components */
+	pw_u8_t  msg_id;
 	pw_u16_t payload_len;
-	/* pw_u64_t p_payload; Ptr to payload */
+	/* pw_u64_t p_payload;  // Ptr to payload */
 	union {
-		pw_u64_t __dummy; /* Ensure size of struct is consistent
-				   * on x86, x64
-				   */
-		char *p_payload; /* Ptr to payload (collected data values). */
+		/* Ensure size of struct is consistent on x86, x64 */
+		pw_u64_t __dummy;
+		/* Ptr to payload (collected data values). */
+		char	*p_payload;
 	};
 } sw_driver_msg_t;
 #pragma pack(pop)
-#define SW_DRIVER_MSG_HEADER_SIZE()                                            \
+#define SW_DRIVER_MSG_HEADER_SIZE() 		\
 	(sizeof(struct sw_driver_msg) - sizeof(pw_u64_t))
 
 typedef enum sw_driver_collection_cmd {
@@ -501,6 +498,21 @@ enum sw_pm_mode {
 
 #define SW_PM_VALUE(mode, action) ((mode) << 16 | (action))
 
+#pragma pack(push, 1)
+/*
+ * Structure for continuous collection
+ */
+struct sw_driver_continuous_collect {
+	/* Size of data that needs to be collected every second */
+	pw_u32_t collection_size;
+	/* struct sw_driver_interface_msg for this collection */
+	pw_u8_t payload[1];
+};
+#define SW_DRIVER_CONTINUOUS_COLLECT_HEADER_SIZE() 		\
+		(sizeof(struct sw_driver_continuous_collect) -	\
+			sizeof(pw_u8_t[1]))
+#pragma pack(pop)
+
 /*
  * Wrapper for ioctl arguments.
  * EVERY ioctl MUST use this struct!
@@ -509,8 +521,8 @@ enum sw_pm_mode {
 struct sw_driver_ioctl_arg {
 	pw_s32_t in_len;
 	pw_s32_t out_len;
-	/* pw_u64_t p_in_arg; Pointer to input arg */
-	/* pw_u64_t p_out_arg; Pointer to output arg */
+	/* pw_u64_t p_in_arg; // Pointer to input arg */
+	/* pw_u64_t p_out_arg; // Pointer to output arg */
 	char *in_arg;
 	char *out_arg;
 };
@@ -518,10 +530,14 @@ struct sw_driver_ioctl_arg {
 
 #pragma pack(push, 1)
 typedef struct sw_driver_msg_interval {
-	pw_u8_t plugin_id; /* Cannot have more than 256 plugins */
-	pw_u8_t metric_id; /* Each plugin cannot handle more than 256 metrics */
-	pw_u8_t msg_id; /* Each metric cannot have more than 256 components */
-	pw_u16_t interval; /* collection interval */
+	/* Cannot have more than 256 plugins */
+	pw_u8_t  plugin_id;
+	/* Each plugin cannot handle more than 256 metrics */
+	pw_u8_t  metric_id;
+	/* Each metric cannot have more than 256 components */
+	pw_u8_t  msg_id;
+	/* collection interval */
+	pw_u16_t interval;
 } sw_driver_msg_interval_t;
 #pragma pack(pop)
 
diff --git a/drivers/platform/x86/socwatch/inc/sw_telem.h b/drivers/platform/x86/socwatch/inc/sw_telem.h
index e324ff681b2e..3cfbb4ec515d 100644
--- a/drivers/platform/x86/socwatch/inc/sw_telem.h
+++ b/drivers/platform/x86/socwatch/inc/sw_telem.h
@@ -1,74 +1,76 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef _SW_TELEM_H_
 #define _SW_TELEM_H_ 1
 
-#include "sw_structs.h" /* sw_driver_io_descriptor */
-#include "sw_types.h" /* u8 and other types */
+#include "sw_structs.h"      /* sw_driver_io_descriptor */
+#include "sw_types.h"        /* u8 and other types */
 
 int sw_telem_init_func(struct sw_driver_io_descriptor *descriptor);
 void sw_read_telem_info(char *dst_vals, int cpu,
 			const struct sw_driver_io_descriptor *descriptor,
 			u16 counter_size_in_bytes);
 void sw_write_telem_info(char *dst_vals, int cpu,
-			 const struct sw_driver_io_descriptor *descriptor,
-			 u16 counter_size_in_bytes);
+			const struct sw_driver_io_descriptor *descriptor,
+			u16 counter_size_in_bytes);
 int sw_reset_telem(const struct sw_driver_io_descriptor *descriptor);
 bool sw_telem_available(void);
 bool sw_telem_post_config(void);
 
+int setup_telem(u64 addrs[3]);
+void destroy_telem(void);
+
 #endif /* SW_TELEM_H */
diff --git a/drivers/platform/x86/socwatch/inc/sw_trace_notifier_provider.h b/drivers/platform/x86/socwatch/inc/sw_trace_notifier_provider.h
index 3ec4930c9010..470f962858a8 100644
--- a/drivers/platform/x86/socwatch/inc/sw_trace_notifier_provider.h
+++ b/drivers/platform/x86/socwatch/inc/sw_trace_notifier_provider.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 #ifndef __SW_TRACE_NOTIFIER_PROVIDER_H__
 #define __SW_TRACE_NOTIFIER_PROVIDER_H__
 
diff --git a/drivers/platform/x86/socwatch/inc/sw_tracepoint_handlers.h b/drivers/platform/x86/socwatch/inc/sw_tracepoint_handlers.h
index d8a54c099d36..70e5b83a72ca 100644
--- a/drivers/platform/x86/socwatch/inc/sw_tracepoint_handlers.h
+++ b/drivers/platform/x86/socwatch/inc/sw_tracepoint_handlers.h
@@ -1,58 +1,58 @@
-/*
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
 #ifndef __SW_TRACEPOINT_HANDLERS_H__
 #define __SW_TRACEPOINT_HANDLERS_H__
 
@@ -66,45 +66,41 @@ enum sw_trace_data_type {
 };
 
 struct sw_trace_notifier_name {
-	const char *
-		kernel_name; /* The tracepoint name; used by the kernel
-			      * to identify tracepoints
-			      */
-	const char *
-		abstract_name; /* An abstract name used by plugins to
-				* specify tracepoints-of-interest;
-				* shared with Ring-3
-				*/
+	const char *kernel_name;   /* The tracepoint name; used by the kernel
+				    * to identify tracepoints
+				    */
+	const char *abstract_name; /* An abstract name used by plugins
+				    * tospecify tracepoints-of-interest;
+				    * shared with Ring-3
+				    */
 };
 
 typedef struct sw_trace_notifier_data sw_trace_notifier_data_t;
+
 typedef int (*sw_trace_notifier_register_func)(
-	struct sw_trace_notifier_data *node);
+			struct sw_trace_notifier_data *node);
 typedef int (*sw_trace_notifier_unregister_func)(
-	struct sw_trace_notifier_data *node);
+			struct sw_trace_notifier_data *node);
 
 struct sw_trace_notifier_data {
-	enum sw_trace_data_type type; /* Tracepoint or Notifier */
-	const struct sw_trace_notifier_name *name; /* Tracepoint name(s) */
-	sw_trace_notifier_register_func probe_register; /* probe register
-							 * function
-							 */
-	sw_trace_notifier_unregister_func probe_unregister; /* probe unregister
-							     * function
-							     */
+	/* Tracepoint or Notifier */
+	enum sw_trace_data_type type;
+	/* Tracepoint name(s) */
+	const struct sw_trace_notifier_name *name;
+	/* probe register function */
+	sw_trace_notifier_register_func probe_register;
+	/* probe unregister function */
+	sw_trace_notifier_unregister_func probe_unregister;
 	struct tracepoint *tp;
-	bool always_register; /* Set to TRUE if this tracepoint/notifier
-			       * must ALWAYS be registered, regardless
-			       * of whether the user has specified
-			       * anything to collect
-			       */
+	bool always_register;	/* Set to TRUE if this tracepoint/notifier must
+				 * ALWAYS be registered, regardless of whether
+				 * the user has specified anything to collect
+				 */
 	bool was_registered;
-	SW_DEFINE_LIST_HEAD(
-		list,
-		sw_collector_data); /* List of 'sw_collector_data'
-				     * instances for this tracepoint
-				     * or notifier
-				     */
+	/* List of 'sw_collector_data' instances for this
+	 * tracepoint or notifier
+	 */
+	SW_DEFINE_LIST_HEAD(list, sw_collector_data);
 };
 
 struct sw_topology_node {
@@ -112,11 +108,9 @@ struct sw_topology_node {
 
 	SW_LIST_ENTRY(list, sw_topology_node);
 };
-SW_DECLARE_LIST_HEAD(
-	sw_topology_list,
-	sw_topology_node); /* List of entries tracking
-			    * changes in CPU topology
-			    */
+
+/* List of entries tracking changes in CPU topology */
+SW_DECLARE_LIST_HEAD(sw_topology_list, sw_topology_node);
 extern size_t sw_num_topology_entries; /* Size of the 'sw_topology_list' */
 
 int sw_extract_tracepoints(void);
@@ -137,19 +131,21 @@ void sw_reset_trace_notifier_lists(void);
 
 void sw_print_trace_notifier_overheads(void);
 
-int sw_for_each_tracepoint_node(int (*func)(struct sw_trace_notifier_data *node,
-					    void *priv),
-				void *priv, bool return_on_error);
-int sw_for_each_notifier_node(int (*func)(struct sw_trace_notifier_data *node,
-					  void *priv),
-			      void *priv, bool return_on_error);
+int sw_for_each_tracepoint_node(
+	int (*func)(struct sw_trace_notifier_data *node, void *priv),
+	void *priv,
+	bool return_on_error);
+int sw_for_each_notifier_node(
+	int (*func)(struct sw_trace_notifier_data *node, void *priv),
+	void *priv,
+	bool return_on_error);
 
 int sw_get_trace_notifier_id(struct sw_trace_notifier_data *node);
 
-const char *
-sw_get_trace_notifier_kernel_name(struct sw_trace_notifier_data *node);
-const char *
-sw_get_trace_notifier_abstract_name(struct sw_trace_notifier_data *node);
+const char *sw_get_trace_notifier_kernel_name(
+	struct sw_trace_notifier_data *node);
+const char *sw_get_trace_notifier_abstract_name(
+	struct sw_trace_notifier_data *node);
 
 /*
  * Clear out the topology list.
diff --git a/drivers/platform/x86/socwatch/inc/sw_types.h b/drivers/platform/x86/socwatch/inc/sw_types.h
index 156c92c8349a..e9af829c31c8 100644
--- a/drivers/platform/x86/socwatch/inc/sw_types.h
+++ b/drivers/platform/x86/socwatch/inc/sw_types.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef _PW_TYPES_H_
 #define _PW_TYPES_H_
@@ -68,7 +67,7 @@
 /*
  * UNSIGNED types...
  */
-typedef uint8_t u8;
+typedef uint8_t  u8;
 typedef uint16_t u16;
 typedef uint32_t u32;
 typedef uint64_t u64;
@@ -87,13 +86,13 @@ typedef int64_t s64;
 #include <sys/types.h>
 #include <stdint.h> /* Grab 'uint64_t' etc. */
 
-typedef uint8_t u8;
+typedef uint8_t  u8;
 typedef uint16_t u16;
 typedef uint32_t u32;
 typedef uint64_t u64;
 /*
- * SIGNED types...
- */
+* SIGNED types...
+*/
 typedef int8_t s8;
 typedef int16_t s16;
 typedef int32_t s32;
diff --git a/drivers/platform/x86/socwatch/inc/sw_version.h b/drivers/platform/x86/socwatch/inc/sw_version.h
index 5476b0d79ac5..b6fe1eecdd0e 100644
--- a/drivers/platform/x86/socwatch/inc/sw_version.h
+++ b/drivers/platform/x86/socwatch/inc/sw_version.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef __SW_VERSION_H__
 #define __SW_VERSION_H__ 1
@@ -61,14 +60,14 @@
  * SOCWatch driver version
  */
 #define SW_DRIVER_VERSION_MAJOR 2
-#define SW_DRIVER_VERSION_MINOR 6
-#define SW_DRIVER_VERSION_OTHER 2
+#define SW_DRIVER_VERSION_MINOR 10
+#define SW_DRIVER_VERSION_OTHER 0
 
 /*
  * Every SOC Watch userspace component shares the same version number.
  */
 #define SOCWATCH_VERSION_MAJOR 2
-#define SOCWATCH_VERSION_MINOR 8
-#define SOCWATCH_VERSION_OTHER 0
+#define SOCWATCH_VERSION_MINOR 10
+#define SOCWATCH_VERSION_OTHER 1
 
 #endif /* __SW_VERSION_H__ */
diff --git a/drivers/platform/x86/socwatch/sw_collector.c b/drivers/platform/x86/socwatch/sw_collector.c
index db855bab4fd8..ebc65666caf6 100644
--- a/drivers/platform/x86/socwatch/sw_collector.c
+++ b/drivers/platform/x86/socwatch/sw_collector.c
@@ -1,86 +1,66 @@
-/*
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
-  This file is provided under a dual BSD/GPLv2 license.	 When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-  * Redistributions of source code must retain the above copyright
-  notice, this list of condiions and the following disclaimer.
-  * Redistributions in binary form must reproduce the above copyright
-  notice, this list of conditions and the following disclaimer in
-  the documentation and/or other materials provided with the
-  distribution.
-  * Neither the name of Intel Corporation nor the names of its
-  contributors may be used to endorse or promote products derived
-  from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
-#include "sw_internal.h"
-#include "sw_structs.h"
 #include "sw_collector.h"
+#include "sw_hardware_io.h"
+#include "sw_internal.h"
 #include "sw_kernel_defines.h"
 #include "sw_mem.h"
-#include "sw_types.h"
-#include "sw_hardware_io.h"
 #include "sw_output_buffer.h"
+#include "sw_structs.h"
+#include "sw_types.h"
 
-/* -------------------------------------------------
- * Local function declarations.
- * -------------------------------------------------
- */
-void sw_free_driver_interface_info_i(struct sw_driver_interface_info *info);
-const struct sw_hw_ops **sw_alloc_ops_i(pw_u16_t num_io_descriptors);
-void sw_free_ops_i(const struct sw_hw_ops **ops);
-struct sw_driver_interface_info *
-sw_copy_driver_interface_info_i(const struct sw_driver_interface_info *info);
-int sw_init_driver_interface_info_i(struct sw_driver_interface_info *info);
-int sw_reset_driver_interface_info_i(struct sw_driver_interface_info *info);
-int sw_init_ops_i(const struct sw_hw_ops **ops,
-		  const struct sw_driver_interface_info *info);
-sw_driver_msg_t *
-sw_alloc_collector_msg_i(const struct sw_driver_interface_info *info,
-			 size_t per_msg_payload_size);
-void sw_free_collector_msg_i(sw_driver_msg_t *msg);
-size_t sw_get_payload_size_i(const struct sw_driver_interface_info *info);
-void sw_handle_per_cpu_msg_i(void *info, enum sw_wakeup_action action);
 /* -------------------------------------------------
  * Variables.
  * -------------------------------------------------
@@ -94,9 +74,154 @@ const static struct sw_hw_ops *s_hw_ops;
  * Driver interface info functions.
  */
 
+/**
+ * sw_copy_driver_interface_info_i - Allocate and copy the passed-in "info".
+ *
+ * @info: Information about the metric and collection properties
+ *
+ * Returns: a pointer to the newly allocated sw_driver_interface_info,
+ *          which is a copy of the version passed in via the info pointer.
+ */
+struct sw_driver_interface_info *
+sw_copy_driver_interface_info_i(const struct sw_driver_interface_info *info)
+{
+	size_t size;
+	struct sw_driver_interface_info *node = NULL;
+
+	if (!info) {
+		pw_pr_error("ERROR: NULL sw_driver_interface_info in alloc!\n");
+		return node;
+	}
+
+	size = SW_DRIVER_INTERFACE_INFO_HEADER_SIZE() +
+	       (info->num_io_descriptors *
+		sizeof(struct sw_driver_io_descriptor));
+	node = (struct sw_driver_interface_info *)sw_kmalloc(size, GFP_KERNEL);
+	if (!node) {
+		pw_pr_error("ERROR allocating driver interface info!\n");
+		return node;
+	}
+	memcpy((char *)node, (const char *)info, size);
+
+	/*
+	 * Do debug dump.
+	 */
+	pw_pr_debug(
+		"DRIVER info has plugin_ID = %d, metric_ID = %d, msg_ID = %d\n",
+		node->plugin_id, node->metric_id, node->msg_id);
+
+	return node;
+}
+
+int sw_init_driver_interface_info_i(struct sw_driver_interface_info *info)
+{
+	/*
+	 * Do any initialization here.
+	 * For now, only IPC/MMIO descriptors need to be initialized.
+	 */
+	int i = 0;
+	struct sw_driver_io_descriptor *descriptor = NULL;
+
+	if (!info) {
+		pw_pr_error("ERROR: no info!\n");
+		return -PW_ERROR;
+	}
+	for (i = 0,
+	    descriptor = (struct sw_driver_io_descriptor *)info->descriptors;
+	     i < info->num_io_descriptors; ++i, ++descriptor) {
+		if (sw_init_driver_io_descriptor(descriptor))
+			return -PW_ERROR;
+	}
+	return PW_SUCCESS;
+}
+
+int sw_init_ops_i(const struct sw_hw_ops **ops,
+		const struct sw_driver_interface_info *info)
+{
+	int i = 0;
+	struct sw_driver_io_descriptor *descriptor = NULL;
+
+	if (!ops || !info)
+		return -PW_ERROR;
+
+	for (i = 0,
+	descriptor = (struct sw_driver_io_descriptor *)info->descriptors;
+	i < info->num_io_descriptors; ++i, ++descriptor) {
+		ops[i] = sw_get_hw_ops_for(descriptor->collection_type);
+		if (ops[i] == NULL)
+			return -PW_ERROR;
+	}
+	return PW_SUCCESS;
+}
+
+size_t sw_get_payload_size_i(const struct sw_driver_interface_info *info)
+{
+	size_t size = 0;
+	int i = 0;
+
+	if (info) {
+		for (i = 0;
+			i < info->num_io_descriptors;
+			size += ((struct sw_driver_io_descriptor *)
+				info->descriptors)[i].counter_size_in_bytes,
+			++i
+		)
+			;
+	}
+	return size;
+}
+
+sw_driver_msg_t *
+sw_alloc_collector_msg_i(const struct sw_driver_interface_info *info,
+			 size_t per_msg_payload_size)
+{
+	size_t per_msg_size = 0, total_size = 0;
+	sw_driver_msg_t *msg = NULL;
+
+	if (!info)
+		return NULL;
+
+	per_msg_size = sizeof(struct sw_driver_msg) + per_msg_payload_size;
+	total_size = per_msg_size * num_possible_cpus();
+	msg = (sw_driver_msg_t *)sw_kmalloc(total_size, GFP_KERNEL);
+	if (msg) {
+		int cpu = -1;
+
+		memset(msg, 0, total_size);
+		for_each_possible_cpu(cpu) {
+			sw_driver_msg_t *__msg = GET_MSG_SLOT_FOR_CPU(
+				msg, cpu, per_msg_payload_size);
+			char *__payload =
+				(char *)__msg + sizeof(struct sw_driver_msg);
+
+			__msg->cpuidx = (pw_u16_t)cpu;
+			__msg->plugin_id = (pw_u8_t)info->plugin_id;
+			__msg->metric_id = (pw_u8_t)info->metric_id;
+			__msg->msg_id = (pw_u8_t)info->msg_id;
+			__msg->payload_len = per_msg_payload_size;
+			__msg->p_payload = __payload;
+			pw_pr_debug(
+				"[%d]: per_msg_payload_size = %zx, msg = %p, payload = %p\n",
+				cpu, per_msg_payload_size, __msg, __payload);
+		}
+	}
+	return msg;
+}
+
+const struct sw_hw_ops **sw_alloc_ops_i(pw_u16_t num_io_descriptors)
+{
+	size_t size = num_io_descriptors * sizeof(struct sw_hw_ops *);
+	const struct sw_hw_ops **ops = sw_kmalloc(size, GFP_KERNEL);
+
+	if (ops)
+		memset(ops, 0, size);
+
+	return ops;
+}
+
 /**
  * sw_add_driver_info() - Add a collector node to the list called at this
- *			"when type".
+ *                      "when type".
  * @head:   The collector node list to add the new node to.
  * @info:   Driver information to add to the list.
  *
@@ -179,8 +304,8 @@ int sw_add_driver_info(void *list_head,
 			pw_pr_debug("OK: set CPU = %d\n", node->info->cpu_mask);
 		} else if (node->info->cpu_mask == -1) {
 			/*
-			 * Collect data on ANY CPU. Leave empty as a flag
-			 * to signify user wishes to collect data on 'ANY' cpu.
+			 * Collect data on ANY CPU.  Leave empty as a flag to
+			 * signify user wishes to collect data on 'ANY' cpu.
 			 */
 			pw_pr_debug("OK: set ANY CPU\n");
 		} else {
@@ -195,90 +320,16 @@ int sw_add_driver_info(void *list_head,
 	return PW_SUCCESS;
 }
 
-const struct sw_hw_ops **sw_alloc_ops_i(pw_u16_t num_io_descriptors)
-{
-	size_t size = num_io_descriptors * sizeof(struct sw_hw_ops *);
-	const struct sw_hw_ops **ops = sw_kmalloc(size, GFP_KERNEL);
-
-	if (ops) {
-		memset(ops, 0, size);
-	}
-	return ops;
-}
-
 void sw_free_driver_interface_info_i(struct sw_driver_interface_info *info)
 {
-	if (info) {
+	if (info)
 		sw_kfree(info);
-	}
 }
 
 void sw_free_ops_i(const struct sw_hw_ops **ops)
 {
-	if (ops) {
+	if (ops)
 		sw_kfree(ops);
-	}
-}
-
-/**
- * sw_copy_driver_interface_info_i - Allocate and copy the passed-in "info".
- *
- * @info: Information about the metric and collection properties
- *
- * Returns: a pointer to the newly allocated sw_driver_interface_info,
- *	    which is a copy of the version passed in via the info pointer.
- */
-struct sw_driver_interface_info *
-sw_copy_driver_interface_info_i(const struct sw_driver_interface_info *info)
-{
-	size_t size;
-	struct sw_driver_interface_info *node = NULL;
-
-	if (!info) {
-		pw_pr_error("ERROR: NULL sw_driver_interface_info in alloc!\n");
-		return node;
-	}
-
-	size = SW_DRIVER_INTERFACE_INFO_HEADER_SIZE() +
-	       (info->num_io_descriptors *
-		sizeof(struct sw_driver_io_descriptor));
-	node = (struct sw_driver_interface_info *)sw_kmalloc(size, GFP_KERNEL);
-	if (!node) {
-		pw_pr_error("ERROR allocating driver interface info!\n");
-		return node;
-	}
-	memcpy((char *)node, (const char *)info, size);
-
-	/*
-	 * Do debug dump.
-	 */
-	pw_pr_debug("DRIVER info has plugin_ID = %d, metric_ID = %d, "
-		    "msg_ID = %d\n",
-		    node->plugin_id, node->metric_id, node->msg_id);
-
-	return node;
-}
-int sw_init_driver_interface_info_i(struct sw_driver_interface_info *info)
-{
-	/*
-	 * Do any initialization here.
-	 * For now, only IPC/MMIO descriptors need to be initialized.
-	 */
-	int i = 0;
-	struct sw_driver_io_descriptor *descriptor = NULL;
-
-	if (!info) {
-		pw_pr_error("ERROR: no info!\n");
-		return -PW_ERROR;
-	}
-	for (i = 0,
-	    descriptor = (struct sw_driver_io_descriptor *)info->descriptors;
-	     i < info->num_io_descriptors; ++i, ++descriptor) {
-		if (sw_init_driver_io_descriptor(descriptor)) {
-			return -PW_ERROR;
-		}
-	}
-	return PW_SUCCESS;
 }
 
 int sw_reset_driver_interface_info_i(struct sw_driver_interface_info *info)
@@ -297,42 +348,21 @@ int sw_reset_driver_interface_info_i(struct sw_driver_interface_info *info)
 	for (i = 0,
 	    descriptor = (struct sw_driver_io_descriptor *)info->descriptors;
 	     i < info->num_io_descriptors; ++i, ++descriptor) {
-		if (sw_reset_driver_io_descriptor(descriptor)) {
-			return -PW_ERROR;
-		}
-	}
-	return PW_SUCCESS;
-}
-int sw_init_ops_i(const struct sw_hw_ops **ops,
-		  const struct sw_driver_interface_info *info)
-{
-	int i = 0;
-	struct sw_driver_io_descriptor *descriptor = NULL;
-
-	if (!ops || !info) {
-		return -PW_ERROR;
-	}
-	for (i = 0,
-	    descriptor = (struct sw_driver_io_descriptor *)info->descriptors;
-	     i < info->num_io_descriptors; ++i, ++descriptor) {
-		ops[i] = sw_get_hw_ops_for(descriptor->collection_type);
-		if (ops[i] == NULL) {
+		if (sw_reset_driver_io_descriptor(descriptor))
 			return -PW_ERROR;
-		}
 	}
 	return PW_SUCCESS;
 }
 
-/*
- * If this descriptor's collector has an init function, call it passing in
- * this descriptor.  That allows the collector to perform any initialization
- * or registration specific to this metric.
- */
+/* If this descriptor's collector has an init function, call it passing in */
+/* this descriptor.  That allows the collector to perform any initialization */
+/* or registration specific to this metric. */
 int sw_init_driver_io_descriptor(struct sw_driver_io_descriptor *descriptor)
 {
 	sw_io_desc_init_func_t init_func = NULL;
 	const struct sw_hw_ops *ops =
 		sw_get_hw_ops_for(descriptor->collection_type);
+
 	if (ops == NULL) {
 		pw_pr_error("NULL ops found in init_driver_io_desc: type %d\n",
 			    descriptor->collection_type);
@@ -343,10 +373,10 @@ int sw_init_driver_io_descriptor(struct sw_driver_io_descriptor *descriptor)
 	if (init_func) {
 		int retval = (*init_func)(descriptor);
 
-		if (retval) {
+		if (retval)
 			pw_pr_error("(*init) return value for type %d: %d\n",
 				    descriptor->collection_type, retval);
-		}
+
 		return retval;
 	}
 	return PW_SUCCESS;
@@ -354,14 +384,16 @@ int sw_init_driver_io_descriptor(struct sw_driver_io_descriptor *descriptor)
 
 /*
  * If this descriptor's collector has a finalize function, call it passing in
- * this descriptor. This allows the collector to perform any finalization
- * specific to this metric.
+ * this
+ * descriptor. This allows the collector to perform any finalization specific to
+ * this metric.
  */
 int sw_reset_driver_io_descriptor(struct sw_driver_io_descriptor *descriptor)
 {
 	sw_io_desc_reset_func_t reset_func = NULL;
 	const struct sw_hw_ops *ops =
 		sw_get_hw_ops_for(descriptor->collection_type);
+
 	if (ops == NULL) {
 		pw_pr_error("NULL ops found in reset_driver_io_desc: type %d\n",
 			    descriptor->collection_type);
@@ -374,10 +406,10 @@ int sw_reset_driver_io_descriptor(struct sw_driver_io_descriptor *descriptor)
 	if (reset_func) {
 		int retval = (*reset_func)(descriptor);
 
-		if (retval) {
+		if (retval)
 			pw_pr_error("(*reset) return value for type %d: %d\n",
 				    descriptor->collection_type, retval);
-		}
+
 		return retval;
 	}
 	return PW_SUCCESS;
@@ -418,63 +450,10 @@ int sw_handle_driver_io_descriptor(
 	return PW_SUCCESS;
 }
 
-sw_driver_msg_t *
-sw_alloc_collector_msg_i(const struct sw_driver_interface_info *info,
-			 size_t per_msg_payload_size)
-{
-	size_t per_msg_size = 0, total_size = 0;
-	sw_driver_msg_t *msg = NULL;
-
-	if (!info) {
-		return NULL;
-	}
-	per_msg_size = sizeof(struct sw_driver_msg) + per_msg_payload_size;
-	total_size = per_msg_size * num_possible_cpus();
-	msg = (sw_driver_msg_t *)sw_kmalloc(total_size, GFP_KERNEL);
-	if (msg) {
-		int cpu = -1;
-
-		memset(msg, 0, total_size);
-		for_each_possible_cpu(cpu) {
-			sw_driver_msg_t *__msg = GET_MSG_SLOT_FOR_CPU(
-				msg, cpu, per_msg_payload_size);
-			char *__payload =
-				(char *)__msg + sizeof(struct sw_driver_msg);
-			__msg->cpuidx = (pw_u16_t)cpu;
-			__msg->plugin_id = (pw_u8_t)info->plugin_id;
-			__msg->metric_id = (pw_u8_t)info->metric_id;
-			__msg->msg_id = (pw_u8_t)info->msg_id;
-			__msg->payload_len = per_msg_payload_size;
-			__msg->p_payload = __payload;
-			pw_pr_debug(
-				"[%d]: per_msg_payload_size = %zx, msg = %p, payload = %p\n",
-				cpu, per_msg_payload_size, __msg, __payload);
-		}
-	}
-	return msg;
-}
-
 void sw_free_collector_msg_i(sw_driver_msg_t *msg)
 {
-	if (msg) {
+	if (msg)
 		sw_kfree(msg);
-	}
-}
-
-size_t sw_get_payload_size_i(const struct sw_driver_interface_info *info)
-{
-	size_t size = 0;
-	int i = 0;
-
-	if (info) {
-		for (i = 0; i < info->num_io_descriptors;
-		     size +=
-		     ((struct sw_driver_io_descriptor *)info->descriptors)[i]
-			     .counter_size_in_bytes,
-		    ++i)
-			;
-	}
-	return size;
 }
 
 void sw_handle_per_cpu_msg_i(void *info, enum sw_wakeup_action action)
@@ -482,8 +461,8 @@ void sw_handle_per_cpu_msg_i(void *info, enum sw_wakeup_action action)
 	/*
 	 * Basic algo:
 	 * For each descriptor in 'node->info->descriptors'; do:
-	 * 1. Perform H/W read; use 'descriptor->collection_type'
-	 * to determine type of read; use 'descriptor->counter_size_in_bytes'
+	 * 1. Perform H/W read; use 'descriptor->collection_type' to
+	 * determine type of read; use 'descriptor->counter_size_in_bytes'
 	 * for read size. Use msg->p_payload[dst_idx] as dst address
 	 * 2. Increment dst idx by 'descriptor->counter_size_in_bytes'
 	 */
@@ -507,14 +486,13 @@ void sw_handle_per_cpu_msg_i(void *info, enum sw_wakeup_action action)
 			pw_pr_debug("NULL OPS!\n");
 			continue;
 		}
-		if (descriptors->collection_command == SW_IO_CMD_WRITE) {
+		if (descriptors->collection_command == SW_IO_CMD_WRITE)
 			wasAnyWrite = true;
-		}
+
 		if (sw_handle_driver_io_descriptor(dst_vals, cpu, descriptors,
-						   ops[i])) {
+						   ops[i]))
 			pw_pr_error("ERROR reading descriptor with type %d\n",
 				    descriptors->collection_type);
-		}
 	}
 
 	/*
@@ -524,12 +502,9 @@ void sw_handle_per_cpu_msg_i(void *info, enum sw_wakeup_action action)
 	 * message.
 	 */
 	if (likely(wasAnyWrite == false)) {
-		if (sw_produce_generic_msg(msg, action)) {
+		if (sw_produce_generic_msg(msg, action))
 			pw_pr_warn("WARNING: could NOT produce message!\n");
-		}
 	}
-
-	return;
 }
 
 /*
@@ -539,6 +514,7 @@ struct sw_collector_data *sw_alloc_collector_node(void)
 {
 	struct sw_collector_data *node = (struct sw_collector_data *)sw_kmalloc(
 		sizeof(struct sw_collector_data), GFP_KERNEL);
+
 	if (node) {
 		node->per_msg_payload_size = 0x0;
 		node->last_update_jiffies = 0x0;
@@ -552,9 +528,9 @@ struct sw_collector_data *sw_alloc_collector_node(void)
 
 void sw_free_collector_node(struct sw_collector_data *node)
 {
-	if (!node) {
+	if (node)
 		return;
-	}
+
 	if (node->info) {
 		sw_reset_driver_interface_info_i(node->info);
 		sw_free_driver_interface_info_i(node->info);
@@ -569,14 +545,13 @@ void sw_free_collector_node(struct sw_collector_data *node)
 		node->msg = NULL;
 	}
 	sw_kfree(node);
-	return;
 }
 
 int sw_handle_collector_node(struct sw_collector_data *node)
 {
-	if (!node || !node->info || !node->ops || !node->msg) {
+	if (!node || !node->info || !node->ops || !node->msg)
 		return -PW_ERROR;
-	}
+
 	pw_pr_debug("Calling SMP_CALL_FUNCTION_MANY!\n");
 	sw_schedule_work(&node->cpumask, &sw_handle_per_cpu_msg, node);
 	return PW_SUCCESS;
@@ -584,9 +559,9 @@ int sw_handle_collector_node(struct sw_collector_data *node)
 
 int sw_handle_collector_node_on_cpu(struct sw_collector_data *node, int cpu)
 {
-	if (!node || !node->info || !node->ops || !node->msg) {
+	if (!node || !node->info || !node->ops || !node->msg)
 		return -PW_ERROR;
-	}
+
 	/*
 	 * Check if this node indicates it should be scheduled
 	 * on the given cpu. If so, clear all other CPUs from the
@@ -614,7 +589,10 @@ void sw_destroy_collector_list(void *list_head)
 	SW_LIST_HEAD_VAR(sw_collector_data) * head = list_head;
 	while (!SW_LIST_EMPTY(head)) {
 		struct sw_collector_data *curr =
-			SW_LIST_GET_HEAD_ENTRY(head, sw_collector_data, list);
+			SW_LIST_GET_HEAD_ENTRY(head,
+				sw_collector_data,
+				list);
+
 		BUG_ON(!curr->info);
 		SW_LIST_UNLINK(curr, list);
 		sw_free_collector_node(curr);
@@ -623,8 +601,8 @@ void sw_destroy_collector_list(void *list_head)
 
 /**
  * sw_handle_collector_list - Iterate through the collector list, calling
- *			      func() upon each element.
- * @list_head:	The collector list head.
+ *                            func() upon each element.
+ * @list_head:  The collector list head.
  * @func:  The function to call for each collector.
  *
  * This function is called when one of the "when types" fires, since the
@@ -639,15 +617,15 @@ int sw_handle_collector_list(void *list_head,
 	int retVal = PW_SUCCESS;
 	struct sw_collector_data *curr = NULL;
 
-	if (!head || !func) {
+	if (!head || !func)
 		return -PW_ERROR;
-	}
+
 	SW_LIST_FOR_EACH_ENTRY(curr, head, list)
 	{
 		pw_pr_debug("HANDLING\n");
-		if ((*func)(curr)) {
+		if ((*func)(curr))
 			retVal = -PW_ERROR;
-		}
+
 	}
 	return retVal;
 }
@@ -660,15 +638,16 @@ int sw_handle_collector_list_on_cpu(void *list_head,
 	SW_LIST_HEAD_VAR(sw_collector_data) * head = list_head;
 	int retVal = PW_SUCCESS;
 	struct sw_collector_data *curr = NULL;
-	if (!head || !func) {
+
+	if (!head || !func)
 		return -PW_ERROR;
-	}
+
 	SW_LIST_FOR_EACH_ENTRY(curr, head, list)
 	{
 		pw_pr_debug("HANDLING\n");
-		if ((*func)(curr, cpu)) {
+		if ((*func)(curr, cpu))
 			retVal = -PW_ERROR;
-		}
+
 	}
 	return retVal;
 }
@@ -685,9 +664,9 @@ void sw_handle_per_cpu_msg_no_sched(void *info)
 
 void sw_handle_per_cpu_msg_on_cpu(int cpu, void *info)
 {
-	if (unlikely(cpu == RAW_CPU())) {
+	if (unlikely(cpu == RAW_CPU()))
 		sw_handle_per_cpu_msg_no_sched(info);
-	} else {
+	else {
 		pw_pr_debug("[%d] is handling for %d\n", RAW_CPU(), cpu);
 		/*
 		 * No need to disable preemption -- 'smp_call_function_single'
@@ -695,9 +674,8 @@ void sw_handle_per_cpu_msg_on_cpu(int cpu, void *info)
 		 */
 		smp_call_function_single(
 			cpu, &sw_handle_per_cpu_msg_no_sched, info,
-			false /* false ==> do NOT wait for function
-			       * completion
-			       */);
+			false
+			/* false ==> do NOT wait for function completion */);
 	}
 }
 
diff --git a/drivers/platform/x86/socwatch/sw_driver.c b/drivers/platform/x86/socwatch/sw_driver.c
index 661a42555baa..0a8ad70b800b 100644
--- a/drivers/platform/x86/socwatch/sw_driver.c
+++ b/drivers/platform/x86/socwatch/sw_driver.c
@@ -1,58 +1,58 @@
-/*
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
 #define MOD_AUTHOR "Gautam Upadhyaya <gautam.upadhyaya@intel.com>"
 #define MOD_DESC "SoC Watch kernel module"
 
@@ -103,21 +103,20 @@ int sw_collection_start_i(void);
 int sw_collection_stop_i(void);
 int sw_collection_poll_i(void);
 size_t sw_get_payload_size_i(const struct sw_driver_interface_info *info);
-sw_driver_msg_t *
-sw_alloc_collector_msg_i(const struct sw_driver_interface_info *info,
-			 size_t per_msg_payload_size);
+sw_driver_msg_t *sw_alloc_collector_msg_i(
+	const struct sw_driver_interface_info *info,
+	size_t per_msg_payload_size);
 static long sw_unlocked_handle_ioctl_i(unsigned int ioctl_num,
-				       void *p_local_args);
-static long
-sw_set_driver_infos_i(struct sw_driver_interface_msg __user *remote_msg,
-		      int local_len);
-static long sw_handle_cmd_i(sw_driver_collection_cmd_t cmd,
-			    u64 __user *remote_out_args);
+                                       void *p_local_args);
+static long sw_set_driver_infos_i(
+	struct sw_driver_interface_msg __user *remote_msg, int local_len);
+static long sw_handle_cmd_i(
+	sw_driver_collection_cmd_t cmd, u64 __user* remote_out_args);
 static void sw_do_extract_scu_fw_version(void);
-static long
-sw_get_available_name_id_mappings_i(enum sw_name_id_type type,
-				    struct sw_name_info_msg __user *remote_info,
-				    size_t local_len);
+static long sw_get_available_name_id_mappings_i(
+	enum sw_name_id_type type,
+	struct sw_name_info_msg __user* remote_info,
+	size_t local_len);
 static enum sw_driver_collection_cmd sw_get_collection_cmd_i(void);
 static bool sw_should_flush_buffer_i(void);
 
@@ -132,9 +131,11 @@ static bool sw_should_flush_buffer_i(void);
  * and is NOT exported.
  */
 struct swa_internal_state {
-	sw_driver_collection_cmd_t
-		cmd; /* indicates which command was specified */
-		     /* last e.g. START, STOP etc. */
+	/*
+	 * Indicates which command was specified
+	 * last e.g. START, STOP etc.
+	 */
+	sw_driver_collection_cmd_t cmd;
 	/*
 	 * Should we write to our per-cpu output buffers?
 	 * YES if we're actively collecting.
@@ -154,13 +155,13 @@ struct swa_internal_state {
  * -------------------------------------------------
  */
 static bool do_force_module_scope_for_cpu_frequencies;
-module_param(do_force_module_scope_for_cpu_frequencies, bool, S_IRUSR);
+module_param(do_force_module_scope_for_cpu_frequencies, bool, 0400);
 MODULE_PARM_DESC(
 	do_force_module_scope_for_cpu_frequencies,
 	"Toggle module scope for cpu frequencies. Sets \"affected_cpus\" and \"related_cpus\" of cpufreq_policy.");
 
 static unsigned short sw_buffer_num_pages = 16;
-module_param(sw_buffer_num_pages, ushort, S_IRUSR);
+module_param(sw_buffer_num_pages, ushort, 0400);
 MODULE_PARM_DESC(
 	sw_buffer_num_pages,
 	"Specify number of 4kB pages to use for each per-cpu buffer. MUST be a power of 2! Default value = 16 (64 kB)");
@@ -204,7 +205,7 @@ DECLARE_OVERHEAD_VARS(sw_any_seg_full);
  * Debugging ONLY!
  */
 #if DO_DEBUG_OUTPUT
-static const char *s_when_type_names[] = { "BEGIN", "POLL", "NOTIFIER",
+static const char * const s_when_type_names[] = { "BEGIN", "POLL", "NOTIFIER",
 					   "TRACEPOINT", "END" };
 #endif /* DO_DEBUG_OUTPUT */
 
@@ -256,9 +257,9 @@ int sw_print_collector_node_i(struct sw_collector_data *curr)
 	struct sw_driver_io_descriptor *descriptor = NULL;
 	struct sw_driver_interface_info *info = NULL;
 
-	if (!curr) {
+	if (!curr)
 		return -PW_ERROR;
-	}
+
 	info = curr->info;
 	descriptor = (struct sw_driver_io_descriptor *)info->descriptors;
 	pw_pr_debug(
@@ -268,13 +269,13 @@ int sw_print_collector_node_i(struct sw_collector_data *curr)
 	     --num_descriptors, ++descriptor) {
 		const struct sw_hw_ops *ops =
 			sw_get_hw_ops_for(descriptor->collection_type);
-		if (ops == NULL) {
+		if (ops == NULL)
 			return -PW_ERROR;
-		}
+
 		print_func = ops->print;
-		if (print_func && (*print_func)(descriptor)) {
+		if (print_func && (*print_func)(descriptor))
 			return -PW_ERROR;
-		}
+
 	}
 	return PW_SUCCESS;
 }
@@ -297,9 +298,9 @@ static int sw_reset_collector_node_i(struct sw_collector_data *coll)
 	int num_descriptors;
 	int retcode = PW_SUCCESS;
 
-	if (!coll) {
+	if (!coll)
 		return -PW_ERROR;
-	}
+
 	info = coll->info;
 
 	descriptor = (struct sw_driver_io_descriptor *)info->descriptors;
@@ -310,9 +311,9 @@ static int sw_reset_collector_node_i(struct sw_collector_data *coll)
 	     --num_descriptors, ++descriptor) {
 		const struct sw_hw_ops *ops =
 			sw_get_hw_ops_for(descriptor->collection_type);
-		if (ops && ops->reset && (*ops->reset)(descriptor)) {
+		if (ops && ops->reset && (*ops->reset)(descriptor))
 			retcode = -PW_ERROR;
-		}
+
 	}
 	return retcode;
 }
@@ -330,25 +331,25 @@ void sw_iterate_driver_info_lists_i(void)
 
 	for (which = SW_WHEN_TYPE_BEGIN; which <= SW_WHEN_TYPE_END; ++which) {
 		pw_pr_debug("ITERATING list %s\n", s_when_type_names[which]);
+		/* Should NEVER happen! */
 		if (sw_handle_collector_list(
 			    &sw_collector_lists[which],
-			    &sw_print_collector_node_i)) {
-			/* Should NEVER happen! */
+			    &sw_print_collector_node_i))
 			pw_pr_error(
 				"WARNING: error occurred while printing values!\n");
-		}
+
 	}
 
 	if (sw_for_each_tracepoint_node(&sw_iterate_trace_notifier_list_i, NULL,
-					false /*return-on-error*/)) {
+					false /*return-on-error*/))
 		pw_pr_error(
 			"WARNING: error occurred while printing tracepoint values!\n");
-	}
+
 	if (sw_for_each_notifier_node(&sw_iterate_trace_notifier_list_i, NULL,
-				      false /*return-on-error*/)) {
+				      false /*return-on-error*/))
 		pw_pr_error(
 			"WARNING: error occurred while printing notifier values!\n");
-	}
+
 }
 
 static void sw_reset_collectors_i(void)
@@ -358,10 +359,10 @@ static void sw_reset_collectors_i(void)
 	for (which = SW_WHEN_TYPE_BEGIN; which <= SW_WHEN_TYPE_END; ++which) {
 		pw_pr_debug("ITERATING list %s\n", s_when_type_names[which]);
 		if (sw_handle_collector_list(&sw_collector_lists[which],
-					     &sw_reset_collector_node_i)) {
+					     &sw_reset_collector_node_i))
 			pw_pr_error(
 				"WARNING: error occurred while resetting a collector!\n");
-		}
+
 	}
 }
 
@@ -403,6 +404,9 @@ void sw_destroy_data_structures_i(void)
 	sw_destroy_per_cpu_buffers();
 	sw_destroy_collector_lists_i();
 	sw_remove_trace_notify();
+
+	/* Should already have been called from 'collection_stop' */
+	sw_destroy_telem();
 }
 
 int sw_get_arch_details_i(void)
@@ -421,11 +425,11 @@ static int
 sw_init_destroy_trace_notifier_lists_i(struct sw_trace_notifier_data *node,
 				       void *is_init)
 {
-	if (is_init == INIT_FLAG) {
+	if (is_init == INIT_FLAG)
 		sw_init_collector_list(&node->list);
-	} else {
+	else
 		sw_destroy_collector_list(&node->list);
-	}
+
 	node->was_registered = false;
 
 	return PW_SUCCESS;
@@ -435,9 +439,9 @@ int sw_init_collector_lists_i(void)
 {
 	int i = 0;
 
-	for (i = 0; i < NUM_COLLECTOR_MODES; ++i) {
+	for (i = 0; i < NUM_COLLECTOR_MODES; ++i)
 		sw_init_collector_list(&sw_collector_lists[i]);
-	}
+
 	sw_for_each_tracepoint_node(&sw_init_destroy_trace_notifier_lists_i,
 				    INIT_FLAG, false /*return-on-error*/);
 	sw_for_each_notifier_node(&sw_init_destroy_trace_notifier_lists_i,
@@ -450,9 +454,9 @@ void sw_destroy_collector_lists_i(void)
 {
 	int i = 0;
 
-	for (i = 0; i < NUM_COLLECTOR_MODES; ++i) {
+	for (i = 0; i < NUM_COLLECTOR_MODES; ++i)
 		sw_destroy_collector_list(&sw_collector_lists[i]);
-	}
+
 	sw_for_each_tracepoint_node(&sw_init_destroy_trace_notifier_lists_i,
 				    DESTROY_FLAG, false /*return-on-error*/);
 	sw_for_each_notifier_node(&sw_init_destroy_trace_notifier_lists_i,
@@ -462,7 +466,6 @@ void sw_destroy_collector_lists_i(void)
 /*
  * Used for {READ,WRITE}_IMMEDIATE requests.
  */
-typedef struct sw_immediate_request_info sw_immediate_request_info_t;
 struct sw_immediate_request_info {
 	struct sw_driver_io_descriptor *local_descriptor;
 	char *dst_vals;
@@ -476,15 +479,13 @@ void sw_handle_immediate_request_i(void *request)
 	char *dst_vals = info->dst_vals;
 	const struct sw_hw_ops *ops =
 		sw_get_hw_ops_for(descriptor->collection_type);
-	if (likely(ops != NULL)) {
+	if (likely(ops != NULL))
 		*(info->retVal) = sw_handle_driver_io_descriptor(
 			dst_vals, RAW_CPU(), descriptor, ops);
-	} else {
+	else
 		pw_pr_error(
 			"No operations found to satisfy collection type %u!\n",
 			descriptor->collection_type);
-	}
-	return;
 }
 
 static int num_times_polled;
@@ -542,10 +543,10 @@ int sw_collection_stop_i(void)
 	/*
 	 * Unregister any registered tracepoints and notifiers.
 	 */
-	if (sw_unregister_trace_notifiers()) {
+	if (sw_unregister_trace_notifiers())
 		pw_pr_warn(
 			"Warning: some trace_notifier probe functions could NOT be unregistered!\n");
-	}
+
 	/*
 	 * Handle 'STOP' snapshots, if any.
 	 */
@@ -564,7 +565,7 @@ int sw_collection_stop_i(void)
 	 * close to the 'wake_up_interruptible', below.
 	 */
 	s_internal_state.drain_buffers = true;
-	smp_mb();
+	smp_mb(); /* order memory access */
 	/*
 	 * Wakeup any sleeping readers, and cleanup any
 	 * timers in the reader subsys.
@@ -576,10 +577,10 @@ int sw_collection_stop_i(void)
 	 */
 	sw_count_samples_produced_dropped();
 #if DO_OVERHEAD_MEASUREMENTS
-	pw_pr_force(
-		"DEBUG: there were %llu samples produced and %llu samples dropped in buffer v5!\n",
-		sw_num_samples_produced, sw_num_samples_dropped);
-#endif /* DO_OVERHEAD_MEASUREMENTS */
+	pw_pr_force("DEBUG: there were %llu samples produced and %llu samples \
+		dropped in buffer v5!\n", sw_num_samples_produced,
+		sw_num_samples_dropped);
+#endif // DO_OVERHEAD_MEASUREMENTS
 	/*
 	 * DEBUG: iterate over collection lists.
 	 */
@@ -592,6 +593,14 @@ int sw_collection_stop_i(void)
 	 * Clear out the collector lists.
 	 */
 	sw_destroy_collector_lists_i();
+	/*
+	 * Free up circular buffer
+	 */
+	destroy_circular_buffer();
+	/*
+	 * Remove telemetry mappings
+	 */
+	sw_destroy_telem();
 	pw_pr_debug("OK, STOPPED collection!\n");
 #if DO_OVERHEAD_MEASUREMENTS
 	pw_pr_force("There were %d poll ticks!\n", num_times_polled);
@@ -604,9 +613,9 @@ int sw_collection_poll_i(void)
 	/*
 	 * Handle 'POLL' timer expirations.
 	 */
-	if (SW_LIST_EMPTY(&sw_collector_lists[SW_WHEN_TYPE_POLL])) {
+	if (SW_LIST_EMPTY(&sw_collector_lists[SW_WHEN_TYPE_POLL]))
 		pw_pr_debug("DEBUG: EMPTY POLL LIST\n");
-	}
+
 	++num_times_polled;
 	return sw_handle_collector_list(&sw_collector_lists[SW_WHEN_TYPE_POLL],
 					&sw_handle_collector_node);
@@ -642,13 +651,13 @@ sw_add_trace_notifier_driver_info_i(struct sw_trace_notifier_data *node,
 
 static int sw_post_config_i(const struct sw_hw_ops *op, void *priv)
 {
-	if (!op->available || !(*op->available)()) {
-		/* op not available */
+	/* op not available */
+	if (!op->available || !(*op->available)())
 		return 0;
-	}
-	if (!op->post_config || (*op->post_config)()) {
+
+	if (!op->post_config || (*op->post_config)())
 		return 0;
-	}
+
 	return -EIO;
 }
 
@@ -753,19 +762,18 @@ sw_set_driver_infos_i(struct sw_driver_interface_msg __user *remote_msg,
 				} else {
 					if (sw_add_driver_info(
 						    &sw_collector_lists[i],
-						    local_info)) {
+						    local_info))
 						pw_pr_error(
 							"WARNING: could NOT add driver info to list for 'when type' %d!\n",
 							i);
-					}
 				}
 			}
 		}
 	}
 	if (sw_for_each_hw_op(&sw_post_config_i, NULL,
-			      false /*return-on-error*/)) {
+			      false /*return-on-error*/))
 		pw_pr_error("POST-CONFIG error!\n");
-	}
+
 	vfree(local_msg);
 	memset(&s_internal_state, 0, sizeof(s_internal_state));
 	/*
@@ -788,14 +796,14 @@ static long sw_handle_cmd_i(sw_driver_collection_cmd_t cmd,
 	}
 	switch (cmd) {
 	case SW_DRIVER_START_COLLECTION:
-		if (sw_collection_start_i()) {
+		if (sw_collection_start_i())
 			return -PW_ERROR;
-		}
+
 		break;
 	case SW_DRIVER_STOP_COLLECTION:
-		if (sw_collection_stop_i()) {
+		if (sw_collection_stop_i())
 			return -PW_ERROR;
-		}
+
 		break;
 	default:
 		pw_pr_error("WARNING: unsupported command %d\n", cmd);
@@ -844,9 +852,9 @@ static void sw_do_extract_scu_fw_version(void)
 	sw_scu_fw_major_minor = 0x0;
 #ifdef SFI_SIG_OEMB
 	if (sfi_table_parse(SFI_SIG_OEMB, NULL, NULL,
-			    &sw_do_parse_sfi_oemb_table)) {
+			    &sw_do_parse_sfi_oemb_table))
 		pw_pr_force("WARNING: NO SFI information!\n");
-	}
+
 #endif /* SFI_SIG_OEMB */
 }
 
@@ -899,18 +907,19 @@ sw_get_available_trace_notifiers_i(enum sw_name_id_type type,
 {
 	long retVal = PW_SUCCESS;
 
-	if (type == SW_NAME_TYPE_TRACEPOINT) {
+	if (type == SW_NAME_TYPE_TRACEPOINT)
 		retVal = sw_for_each_tracepoint_node(&sw_gather_tracepoint_i,
 						     local_info,
 						     false /*return-on-error*/);
-	} else {
+	else
 		retVal = sw_for_each_notifier_node(&sw_gather_notifier_i,
 						   local_info,
 						   false /*return-on-error*/);
-	}
+
 	pw_pr_debug(
 		"There are %u extracted traces/notifiers for a total of %u bytes!\n",
 		local_info->num_name_id_pairs, local_info->payload_len);
+
 	return retVal;
 }
 
@@ -972,17 +981,17 @@ sw_get_available_name_id_mappings_i(enum sw_name_id_type type,
 	memset(buffer, 0, local_len);
 	local_info = (struct sw_name_info_msg *)buffer;
 
-	if (type == SW_NAME_TYPE_COLLECTOR) {
+	if (type == SW_NAME_TYPE_COLLECTOR)
 		retVal = sw_get_available_collectors_i(local_info);
-	} else {
+	else
 		retVal = sw_get_available_trace_notifiers_i(type, local_info);
-	}
+
 	if (retVal == PW_SUCCESS) {
 		retVal = copy_to_user(remote_info, local_info, local_len);
-		if (retVal) {
+		if (retVal)
 			pw_pr_error(
 				"ERROR: couldn't copy tracepoint info to user space!\n");
-		}
+
 	}
 	vfree(buffer);
 	return retVal;
@@ -1001,7 +1010,7 @@ sw_get_topology_changes_i(struct sw_driver_topology_msg __user *remote_msg,
 	struct sw_driver_topology_change *dst = NULL;
 	size_t dst_idx = 0;
 
-	SW_LIST_HEAD_VAR(sw_topology_node) *head = (void *)&sw_topology_list;
+	SW_LIST_HEAD_VAR(sw_topology_node) * head = (void *)&sw_topology_list;
 	struct sw_topology_node *tnode = NULL;
 
 	if (local_len < buffer_len) {
@@ -1030,14 +1039,74 @@ sw_get_topology_changes_i(struct sw_driver_topology_msg __user *remote_msg,
 		memcpy(&dst[dst_idx++], change, sizeof(*change));
 	}
 	retVal = copy_to_user(remote_msg, local_msg, buffer_len);
-	if (retVal) {
+	if (retVal)
 		pw_pr_error(
 			"ERROR: couldn't copy topology changes to user space!\n");
-	}
+
 	vfree(buffer);
 	return retVal;
 }
 
+static long sw_read_continuous_i(char *remote_buffer, size_t local_len)
+{
+	/* TODO: call 'consume_buffer' directly? */
+	ssize_t val = sw_consume_data(0 /*mask, dummy*/, remote_buffer,
+					local_len);
+	if (val <= 0)
+		return val;
+
+	return 0;
+}
+
+static long sw_set_telem_cfgs_i(char *remote_cfg, size_t local_len)
+{
+	u64 *local_cfg = vmalloc(local_len);
+	int retval = 0;
+
+	if (!local_cfg) {
+		pw_pr_error("ERROR allocating space for local telem cfgs!\n");
+		return -EFAULT;
+	}
+	if (copy_from_user(local_cfg, remote_cfg, local_len)) {
+		pw_pr_error("ERROR copying message from user space!\n");
+		retval = -EFAULT;
+		goto done_set_telem_cfgs;
+	}
+	if (sw_setup_telem(local_cfg)) {
+		pw_pr_error("Couldn't setup telemetry\n");
+		retval = -1;
+	}
+done_set_telem_cfgs:
+	vfree(local_cfg);
+	return retval;
+}
+
+static long sw_set_continuous_i(
+	struct sw_driver_continuous_collect __user *remote_msg,
+	int local_len)
+{
+    pw_u32_t buffer_size = 0;
+	long ret = get_user(buffer_size, &remote_msg->collection_size);
+	if (ret)
+		return ret;
+
+	if (buffer_size == 0) {
+		pw_pr_error("Cannot allocate a zero length buffer!\n");
+		return -EINVAL;
+	}
+	ret = initialize_circular_buffer(buffer_size);
+	if (ret)
+		return ret;
+
+	ret = sw_set_driver_infos_i((struct sw_driver_interface_msg __user *)
+		remote_msg->payload, local_len);
+	if (ret) {
+		destroy_circular_buffer();
+		return ret;
+	}
+	return 0;
+}
+
 #if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)
 #define MATCH_IOCTL(num, pred) ((num) == (pred) || (num) == (pred##32))
 #else
@@ -1045,7 +1114,7 @@ sw_get_topology_changes_i(struct sw_driver_topology_msg __user *remote_msg,
 #endif
 
 static long sw_unlocked_handle_ioctl_i(unsigned int ioctl_num,
-				       void *p_local_args)
+					   void *p_local_args)
 {
 	struct sw_driver_ioctl_arg local_args;
 	int local_in_len, local_out_len;
@@ -1063,7 +1132,8 @@ static long sw_unlocked_handle_ioctl_i(unsigned int ioctl_num,
 	 */
 	if (_IOC_TYPE(ioctl_num) != APWR_IOCTL_MAGIC_NUM) {
 		pw_pr_error(
-			"ERROR: requested IOCTL TYPE (%d) != APWR_IOCTL_MAGIC_NUM (%d)\n",
+			"ERROR: requested IOCTL TYPE (%d) != \
+				APWR_IOCTL_MAGIC_NUM (%d)\n",
 			_IOC_TYPE(ioctl_num), APWR_IOCTL_MAGIC_NUM);
 		return -PW_ERROR;
 	}
@@ -1075,7 +1145,7 @@ static long sw_unlocked_handle_ioctl_i(unsigned int ioctl_num,
 	local_in_len = local_args.in_len;
 	local_out_len = local_args.out_len;
 	pw_pr_debug("GU: local_in_len = %d, local_out_len = %d\n", local_in_len,
-		    local_out_len);
+		local_out_len);
 	/*
 	 * (3) Service individual IOCTL requests.
 	 */
@@ -1085,17 +1155,22 @@ static long sw_unlocked_handle_ioctl_i(unsigned int ioctl_num,
 			(struct sw_driver_interface_msg __user *)
 				local_args.in_arg,
 			local_in_len);
+	} else if (MATCH_IOCTL(ioctl_num, PW_IOCTL_CONFIG_CONTINUOUS)) {
+		pw_pr_debug("DEBUG: PW_IOCTL_CONFIG_CONTINUOUS\n");
+		return sw_set_continuous_i(
+			(struct sw_driver_continuous_collect __user *)
+				local_args.in_arg,
+			local_in_len);
 	} else if (MATCH_IOCTL(ioctl_num, PW_IOCTL_CMD)) {
 		sw_driver_collection_cmd_t local_cmd;
 
 		pw_pr_debug("PW_IOCTL_CMD\n");
-		if (get_user(local_cmd, (sw_driver_collection_cmd_t __user *)
-						local_args.in_arg)) {
-			pw_pr_error("ERROR: could NOT extract cmd value!\n");
-			return -PW_ERROR;
-		}
-		return sw_handle_cmd_i(local_cmd,
-				       (u64 __user *)local_args.out_arg);
+	if (get_user(local_cmd,
+		(sw_driver_collection_cmd_t __user *)local_args.in_arg)) {
+		pw_pr_error("ERROR: could NOT extract cmd value!\n");
+		return -PW_ERROR;
+	}
+	return sw_handle_cmd_i(local_cmd, (u64 __user *)local_args.out_arg);
 	} else if (MATCH_IOCTL(ioctl_num, PW_IOCTL_POLL)) {
 		pw_pr_debug("PW_IOCTL_POLL\n");
 		return DO_PER_CPU_OVERHEAD_FUNC_RET(int, sw_collection_poll_i);
@@ -1146,15 +1221,15 @@ static long sw_unlocked_handle_ioctl_i(unsigned int ioctl_num,
 			goto ret_immediate_io;
 		}
 		local_descriptor = ((struct sw_driver_io_descriptor *)
-					    local_info->descriptors);
+						local_info->descriptors);
 		pw_pr_debug("Collection type after %d\n",
-			    local_descriptor->collection_type);
+				local_descriptor->collection_type);
 		/*
 		 * Check cpu mask for correctness here. For now, we do NOT allow
 		 * reading on ALL cpus.
 		 */
 		if ((int)local_info->cpu_mask < -1 ||
-		    (int)local_info->cpu_mask >= (int)sw_max_num_cpus) {
+			(int)local_info->cpu_mask >= (int)sw_max_num_cpus) {
 			pw_pr_error(
 				"ERROR: invalid cpu mask %d specified in immediate IO; valid values are: -1, [0 -- %d]!\n",
 				local_info->cpu_mask, sw_max_num_cpus - 1);
@@ -1169,7 +1244,7 @@ static long sw_unlocked_handle_ioctl_i(unsigned int ioctl_num,
 			local_descriptor->collection_type,
 			local_info->cpu_mask);
 		if (sw_is_valid_hw_op_id(local_descriptor->collection_type) ==
-		    false) {
+			false) {
 			pw_pr_error(
 				"ERROR: invalid collection type %d specified for immediate IO\n",
 				(int)local_descriptor->collection_type);
@@ -1180,7 +1255,7 @@ static long sw_unlocked_handle_ioctl_i(unsigned int ioctl_num,
 		 * Check collection cmd for correctness here
 		 */
 		if (local_descriptor->collection_command < SW_IO_CMD_READ ||
-		    local_descriptor->collection_command > SW_IO_CMD_WRITE) {
+			local_descriptor->collection_command > SW_IO_CMD_WRITE) {
 			pw_pr_error(
 				"ERROR: invalid collection command %d specified for immediate IO\n",
 				local_descriptor->collection_command);
@@ -1215,7 +1290,7 @@ static long sw_unlocked_handle_ioctl_i(unsigned int ioctl_num,
 			default: /* IO on a particular CPU */
 				cpumask_set_cpu(local_info->cpu_mask, &cpumask);
 				pw_pr_debug("[%d] setting for %d\n", RAW_CPU(),
-					    local_info->cpu_mask);
+						local_info->cpu_mask);
 				break;
 			}
 			sw_schedule_work(&cpumask,
@@ -1257,16 +1332,17 @@ static long sw_unlocked_handle_ioctl_i(unsigned int ioctl_num,
 		}
 ret_immediate_io:
 		vfree(src_vals);
-		if (dst_vals) {
+		if (dst_vals)
 			vfree(dst_vals);
-		}
+
 		return retVal;
 	} else if (MATCH_IOCTL(ioctl_num, PW_IOCTL_GET_SCU_FW_VERSION)) {
 		u32 local_data = (u32)sw_scu_fw_major_minor;
 
 		if (put_user(local_data, (u32 __user *)local_args.out_arg)) {
 			pw_pr_error(
-				"ERROR copying scu fw version to userspace!\n");
+				"ERROR copying scu fw version to userspace!\n"
+				);
 			return -PW_ERROR;
 		}
 		return PW_SUCCESS;
@@ -1275,44 +1351,51 @@ static long sw_unlocked_handle_ioctl_i(unsigned int ioctl_num,
 			(pw_u64_t)SW_DRIVER_VERSION_MAJOR << 32 |
 			(pw_u64_t)SW_DRIVER_VERSION_MINOR << 16 |
 			(pw_u64_t)SW_DRIVER_VERSION_OTHER;
-		if (put_user(local_version, (u64 __user *)local_args.out_arg)) {
+		if (put_user(local_version,
+			(u64 __user *)local_args.out_arg)) {
 			pw_pr_error(
-				"ERROR copying driver version to userspace!\n");
+				"ERROR copying driver version to userspace!\n"
+				);
 			return -PW_ERROR;
 		}
 		return PW_SUCCESS;
-	} else if (MATCH_IOCTL(ioctl_num, PW_IOCTL_GET_AVAILABLE_TRACEPOINTS)) {
+	} else if (MATCH_IOCTL(ioctl_num,
+			PW_IOCTL_GET_AVAILABLE_TRACEPOINTS)) {
 		pw_pr_debug("DEBUG: AVAIL tracepoints! local_out_len = %u\n",
-			    local_out_len);
+			local_out_len);
 		return sw_get_available_name_id_mappings_i(
 			SW_NAME_TYPE_TRACEPOINT,
 			(struct sw_name_info_msg __user *)local_args.out_arg,
 			local_out_len);
 	} else if (MATCH_IOCTL(ioctl_num, PW_IOCTL_GET_AVAILABLE_NOTIFIERS)) {
-		pw_pr_debug("DEBUG: AVAIL tracepoints! local_out_len = %u\n",
-			    local_out_len);
+		pw_pr_debug("DEBUG: AVAIL notifiers! local_out_len = %u\n",
+			local_out_len);
 		return sw_get_available_name_id_mappings_i(
 			SW_NAME_TYPE_NOTIFIER,
 			(struct sw_name_info_msg __user *)local_args.out_arg,
 			local_out_len);
 	} else if (MATCH_IOCTL(ioctl_num, PW_IOCTL_GET_AVAILABLE_COLLECTORS)) {
-		pw_pr_debug("DEBUG: AVAIL tracepoints! local_out_len = %u\n",
-			    local_out_len);
+		pw_pr_debug("DEBUG: AVAIL collectors! local_out_len = %u\n",
+			local_out_len);
 		return sw_get_available_name_id_mappings_i(
 			SW_NAME_TYPE_COLLECTOR,
 			(struct sw_name_info_msg __user *)local_args.out_arg,
 			local_out_len);
 	} else if (MATCH_IOCTL(ioctl_num, PW_IOCTL_GET_TOPOLOGY_CHANGES)) {
 		pw_pr_debug("DEBUG: TOPOLOGY changes! local_out_len = %u\n",
-			    local_out_len);
+			local_out_len);
 		return sw_get_topology_changes_i(
 			(struct sw_driver_topology_msg __user *)
-				local_args.out_arg,
-			local_out_len);
-	} else {
-		pw_pr_error("ERROR: invalid ioctl num: %u\n",
-			    _IOC_NR(ioctl_num));
+				local_args.out_arg, local_out_len);
+	} else if (MATCH_IOCTL(ioctl_num, PW_IOCTL_READ_CONTINUOUS)) {
+		pw_pr_debug("DEBUG: READ_CONTINUOUS!\n");
+		return sw_read_continuous_i(local_args.out_arg, local_out_len);
+	} else if (MATCH_IOCTL(ioctl_num, PW_IOCTL_SET_TELEM_BAR)) {
+		pw_pr_debug("DEBUG: got a request to set telem bar!\n");
+		return sw_set_telem_cfgs_i(local_args.in_arg, local_in_len);
 	}
+
+	pw_pr_error("ERROR: invalid ioctl num: %u\n", _IOC_NR(ioctl_num));
 	return -PW_ERROR;
 }
 
@@ -1373,17 +1456,15 @@ int sw_load_driver_i(void)
 		if (sw_set_module_scope_for_cpus()) {
 			pw_pr_force("ERROR setting affected cpus\n");
 			return -PW_ERROR;
-		} else {
-			pw_pr_debug("OK, setting worked\n");
 		}
+		pw_pr_debug("OK, setting worked\n");
 	}
 	if (sw_init_data_structures_i()) {
 		pw_pr_error("ERROR initializing data structures!\n");
 		goto err_ret_init_data;
 	}
-	if (sw_register_dev(&s_ops)) {
+	if (sw_register_dev(&s_ops))
 		goto err_ret_register_dev;
-	}
 	/*
 	 * Retrieve a list of tracepoint structs to use when
 	 * registering probe functions.
@@ -1399,7 +1480,7 @@ int sw_load_driver_i(void)
 	pw_pr_force("OK: LOADED SoC Watch Driver\n");
 #ifdef CONFIG_X86_WANT_INTEL_MID
 	pw_pr_force("SOC Identifier = %u, Stepping = %u\n",
-		    intel_mid_identify_cpu(), intel_mid_soc_stepping());
+			intel_mid_identify_cpu(), intel_mid_soc_stepping());
 #endif /* CONFIG_X86_WANT_INTEL_MID */
 	pw_pr_force("-----------------------------------------\n");
 	return PW_SUCCESS;
@@ -1410,11 +1491,10 @@ int sw_load_driver_i(void)
 	sw_destroy_data_structures_i();
 err_ret_init_data:
 	if (do_force_module_scope_for_cpu_frequencies) {
-		if (sw_reset_module_scope_for_cpus()) {
+		if (sw_reset_module_scope_for_cpus())
 			pw_pr_force("ERROR resetting affected cpus\n");
-		} else {
+		else
 			pw_pr_debug("OK, resetting worked\n");
-		}
 	}
 	return -PW_ERROR;
 }
@@ -1428,11 +1508,10 @@ void sw_unload_driver_i(void)
 	sw_destroy_data_structures_i();
 
 	if (do_force_module_scope_for_cpu_frequencies) {
-		if (sw_reset_module_scope_for_cpus()) {
+		if (sw_reset_module_scope_for_cpus())
 			pw_pr_force("ERROR resetting affected cpus\n");
-		} else {
+		else
 			pw_pr_debug("OK, resetting worked\n");
-		}
 	}
 
 	pw_pr_force("-----------------------------------------\n");
@@ -1443,24 +1522,22 @@ void sw_unload_driver_i(void)
 	PRINT_CUMULATIVE_OVERHEAD_PARAMS(sw_collection_poll_i, "POLL");
 	PRINT_CUMULATIVE_OVERHEAD_PARAMS(sw_any_seg_full, "ANY_SEG_FULL");
 #if DO_TRACK_MEMORY_USAGE
-	{
-		/*
-		 * Dump memory stats.
-		 */
+	/*
+	 * Dump memory stats.
+	 */
+	pw_pr_force(
+		"TOTAL # BYTES ALLOCED = %llu, CURR # BYTES ALLOCED = %llu, MAX # BYTES ALLOCED = %llu\n",
+		sw_get_total_bytes_alloced(),
+		sw_get_curr_bytes_alloced(),
+		sw_get_max_bytes_alloced());
+	if (unlikely(sw_get_curr_bytes_alloced())) {
 		pw_pr_force(
-			"TOTAL # BYTES ALLOCED = %llu, CURR # BYTES ALLOCED = %llu, MAX # BYTES ALLOCED = %llu\n",
-			sw_get_total_bytes_alloced(),
-			sw_get_curr_bytes_alloced(),
-			sw_get_max_bytes_alloced());
-		if (unlikely(sw_get_curr_bytes_alloced())) {
-			pw_pr_force(
-				"***********************************************************************\n");
-			pw_pr_force(
-				"WARNING: possible memory leak: there are %llu bytes still allocated!\n",
-				sw_get_curr_bytes_alloced());
-			pw_pr_force(
-				"***********************************************************************\n");
-		}
+			"***********************************************************************\n");
+		pw_pr_force(
+			"WARNING: possible memory leak: there are %llu bytes still allocated!\n",
+			sw_get_curr_bytes_alloced());
+		pw_pr_force(
+			"***********************************************************************\n");
 	}
 #endif /* DO_TRACK_MEMORY_USAGE */
 	pw_pr_force("-----------------------------------------\n");
diff --git a/drivers/platform/x86/socwatch/sw_file_ops.c b/drivers/platform/x86/socwatch/sw_file_ops.c
index ea84d252a4d3..199ae560801e 100644
--- a/drivers/platform/x86/socwatch/sw_file_ops.c
+++ b/drivers/platform/x86/socwatch/sw_file_ops.c
@@ -1,70 +1,70 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
-*/
-#include <linux/module.h> /* try_module_get */
-#include <linux/fs.h> /* inode */
-#include <linux/device.h> /* class_create */
-#include <linux/cdev.h> /* cdev_alloc */
+#include <linux/module.h>  /* try_module_get */
+#include <linux/fs.h>      /* inode */
+#include <linux/device.h>  /* class_create */
+#include <linux/cdev.h>    /* cdev_alloc */
 #include <linux/version.h> /* LINUX_VERSION_CODE */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0)
-#include <asm/uaccess.h> /* copy_to_user */
+#if KERNEL_VERSION(4, 12, 0) > LINUX_VERSION_CODE
+    #include <asm/uaccess.h>   /* copy_to_user */
 #else
-#include <linux/uaccess.h> /* copy_to_user */
+    #include <linux/uaccess.h>   /* copy_to_user */
 #endif /* LINUX_VERSION_CODE */
-#include <linux/wait.h> /* wait_event_interruptible */
-#include <linux/sched.h> /* TASK_INTERRUPTIBLE */
+#include <linux/wait.h>    /* wait_event_interruptible */
+#include <linux/sched.h>   /* TASK_INTERRUPTIBLE */
 
 #include "sw_kernel_defines.h"
 #include "sw_types.h"
@@ -84,56 +84,20 @@
 /*
  * Check if we're currently collecting data.
  */
-#define IS_COLLECTING()                                                        \
-	({                                                                     \
-		sw_driver_collection_cmd_t __cmd = GET_CMD();                  \
-		bool __val = (__cmd == SW_DRIVER_START_COLLECTION ||           \
-			      __cmd == SW_DRIVER_RESUME_COLLECTION);           \
-		__val;                                                         \
-	})
+#define IS_COLLECTING() ({					\
+	sw_driver_collection_cmd_t __cmd = GET_CMD();		\
+	bool __val = (__cmd == SW_DRIVER_START_COLLECTION ||	\
+			__cmd == SW_DRIVER_RESUME_COLLECTION);	\
+	__val; })
+
 /*
  * Check if we're currently paused.
  */
-#define IS_SLEEPING()                                                          \
-	({                                                                     \
-		sw_driver_collection_cmd_t __cmd = GET_CMD();                  \
-		bool __val = __cmd == SW_DRIVER_PAUSE_COLLECTION;              \
-		__val;                                                         \
-	})
-/* -------------------------------------------------
- * Typedefs
- * -------------------------------------------------
- */
-typedef unsigned long sw_bits_t;
-
-/* -------------------------------------------------
- *  Local function declarations.
- * -------------------------------------------------
- */
-static int sw_device_open_i(struct inode *inode, struct file *file);
-static int sw_device_release_i(struct inode *inode, struct file *file);
-static ssize_t sw_device_read_i(struct file *file, char __user *buffer,
-				size_t length, loff_t *offset);
-static long sw_device_unlocked_ioctl_i(struct file *filp,
-				       unsigned int ioctl_num,
-				       unsigned long ioctl_param);
-#if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)
-static long sw_device_compat_ioctl_i(struct file *file, unsigned int ioctl_num,
-				     unsigned long ioctl_param);
-#endif
+#define IS_SLEEPING() ({					\
+	sw_driver_collection_cmd_t __cmd = GET_CMD();		\
+	bool __val = __cmd == SW_DRIVER_PAUSE_COLLECTION;	\
+	__val; })
 
-/*
- * File operations exported by the driver.
- */
-static struct file_operations s_fops = {
-	.open = &sw_device_open_i,
-	.read = &sw_device_read_i,
-	.unlocked_ioctl = &sw_device_unlocked_ioctl_i,
-#if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)
-	.compat_ioctl = &sw_device_compat_ioctl_i,
-#endif /* COMPAT && x64 */
-	.release = &sw_device_release_i,
-};
 /*
  * Character device file MAJOR
  * number -- we're now obtaining
@@ -155,7 +119,7 @@ static struct sw_file_ops *s_file_ops;
  * concurent access into the same device.
  */
 #define DEV_IS_OPEN 0 /* see if device is in use */
-static volatile sw_bits_t dev_status;
+static volatile unsigned long dev_status;
 
 /*
  * File operations.
@@ -168,14 +132,13 @@ static int sw_device_open_i(struct inode *inode, struct file *file)
 	/*
 	 * We don't want to talk to two processes at the same time
 	 */
-	if (test_and_set_bit(DEV_IS_OPEN, &dev_status)) {
-		/* Device is busy */
-		return -EBUSY;
-	}
+	if (test_and_set_bit(DEV_IS_OPEN, &dev_status))
+		return -EBUSY; /* Device is busy */
+
 
 	if (!try_module_get(THIS_MODULE)) {
-		/* No such device */
-		return -ENODEV;
+		pw_pr_error("ERROR: Device not found!\n");
+		return -ENODEV;/* No such device */
 	}
 	pw_pr_debug("OK, allowed client open!\n");
 	return PW_SUCCESS;
@@ -205,9 +168,9 @@ static int sw_device_release_i(struct inode *inode, struct file *file)
 }
 
 static ssize_t sw_device_read_i(struct file *file, char __user *user_buffer,
-				size_t length, loff_t *offset)
+	size_t length, loff_t *offset)
 {
-	size_t bytes_read = 0;
+	ssize_t bytes_read = 0;
 	u32 val = 0;
 
 	if (!user_buffer) {
@@ -217,29 +180,26 @@ static ssize_t sw_device_read_i(struct file *file, char __user *user_buffer,
 	}
 	do {
 		val = SW_ALL_WRITES_DONE_MASK;
-		if (wait_event_interruptible(
-			    sw_reader_queue,
-			    (sw_any_seg_full(&val,
-					     (*s_file_ops->should_flush)()) ||
-			     (!IS_COLLECTING() && !IS_SLEEPING())))) {
+		if (wait_event_interruptible(sw_reader_queue,
+			(sw_any_seg_full(&val, (*s_file_ops->should_flush)()) ||
+				 (!IS_COLLECTING() && !IS_SLEEPING())))) {
 			pw_pr_error("wait_event_interruptible error\n");
 			return -ERESTARTSYS;
 		}
-		pw_pr_debug(KERN_INFO "After wait: val = %u\n", val);
+		pw_pr_debug("After wait: val = %u\n", val);
 	} while (val == SW_NO_DATA_AVAIL_MASK);
 	/*
 	 * Are we done producing/consuming?
 	 */
-	if (val == SW_ALL_WRITES_DONE_MASK) {
+	if (val == SW_ALL_WRITES_DONE_MASK)
 		return 0; /* "0" ==> EOF */
-	}
+
 	/*
 	 * Copy the buffer contents into userspace.
 	 */
-	bytes_read = sw_consume_data(
-		val, user_buffer,
-		length); /* 'read' returns # of bytes actually read */
-	if (unlikely(bytes_read == 0)) {
+	/* 'read' returns # of bytes actually read */
+	bytes_read = sw_consume_data(val, user_buffer, length);
+	if (unlikely(bytes_read <= 0)) {
 		/* Cannot be EOF since that has already been checked above */
 		return -EIO;
 	}
@@ -250,12 +210,11 @@ static ssize_t sw_device_read_i(struct file *file, char __user *user_buffer,
  * (1) Handle 32b IOCTLs in 32b kernel-space.
  * (2) Handle 64b IOCTLs in 64b kernel-space.
  */
-static long sw_device_unlocked_ioctl_i(struct file *filp,
-				       unsigned int ioctl_num,
-				       unsigned long ioctl_param)
+static long sw_device_unlocked_ioctl_i(
+	struct file *filp, unsigned int ioctl_num, unsigned long ioctl_param)
 {
 	struct sw_driver_ioctl_arg __user *remote_args =
-		(struct sw_driver_ioctl_arg __user *)ioctl_param;
+			(struct sw_driver_ioctl_arg __user *)ioctl_param;
 	struct sw_driver_ioctl_arg local_args;
 
 	if (copy_from_user(&local_args, remote_args, sizeof(local_args))) {
@@ -284,32 +243,46 @@ struct sw_driver_ioctl_arg32 {
 /*
  * Handle 32b IOCTLs in 64b kernel-space.
  */
-static long sw_device_compat_ioctl_i(struct file *file, unsigned int ioctl_num,
-				     unsigned long ioctl_param)
+static long sw_device_compat_ioctl_i(
+	struct file *file, unsigned int ioctl_num, unsigned long ioctl_param)
 {
 	struct sw_driver_ioctl_arg32 __user *remote_args32 =
-		compat_ptr(ioctl_param);
+						compat_ptr(ioctl_param);
 	struct sw_driver_ioctl_arg local_args;
 	u32 data;
 
-	if (get_user(local_args.in_len, &remote_args32->in_len)) {
+	if (get_user(local_args.in_len, &remote_args32->in_len))
 		return -PW_ERROR;
-	}
-	if (get_user(local_args.out_len, &remote_args32->out_len)) {
+
+	if (get_user(local_args.out_len, &remote_args32->out_len))
 		return -PW_ERROR;
-	}
-	if (get_user(data, &remote_args32->in_arg)) {
+
+	if (get_user(data, &remote_args32->in_arg))
 		return -PW_ERROR;
-	}
+
 	local_args.in_arg = (char *)(unsigned long)data;
-	if (get_user(data, &remote_args32->out_arg)) {
+	if (get_user(data, &remote_args32->out_arg))
 		return -PW_ERROR;
-	}
+
 	local_args.out_arg = (char *)(unsigned long)data;
 	return (*s_file_ops->ioctl_handler)(ioctl_num, &local_args);
 }
 #endif
 
+/*
+ * File operations exported by the driver.
+ */
+static const struct file_operations s_fops = {
+	.open = &sw_device_open_i,
+	.read = &sw_device_read_i,
+	.unlocked_ioctl = &sw_device_unlocked_ioctl_i,
+#if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)
+	.compat_ioctl = &sw_device_compat_ioctl_i,
+#endif /* COMPAT && x64 */
+	.release = &sw_device_release_i,
+};
+
+
 /*
  * Device creation, deletion operations.
  */
@@ -330,20 +303,20 @@ int sw_register_dev(struct sw_file_ops *ops)
 	ret = alloc_chrdev_region(&apwr_dev, 0, 1, PW_DEVICE_NAME);
 	apwr_dev_major_num = MAJOR(apwr_dev);
 	apwr_class = class_create(THIS_MODULE, "apwr");
-	if (IS_ERR(apwr_class)) {
-		printk(KERN_ERR "Error registering apwr class\n");
-	}
+	if (IS_ERR(apwr_class))
+		pw_pr_error("Error registering apwr class\n");
+
 
 	device_create(apwr_class, NULL, apwr_dev, NULL, PW_DEVICE_NAME);
 	apwr_cdev = cdev_alloc();
 	if (apwr_cdev == NULL) {
-		printk("Error allocating character device\n");
+		pw_pr_error("Error allocating character device\n");
 		return ret;
 	}
 	apwr_cdev->owner = THIS_MODULE;
 	apwr_cdev->ops = &s_fops;
-	if (cdev_add(apwr_cdev, apwr_dev, 1) < 0) {
-		printk("Error registering device driver\n");
+	if (cdev_add(apwr_cdev, apwr_dev, 1) < 0)  {
+		pw_pr_error("Error registering device driver\n");
 		return ret;
 	}
 	s_file_ops = ops;
diff --git a/drivers/platform/x86/socwatch/sw_hardware_io.c b/drivers/platform/x86/socwatch/sw_hardware_io.c
index 759288ac546e..ce5d05692165 100644
--- a/drivers/platform/x86/socwatch/sw_hardware_io.c
+++ b/drivers/platform/x86/socwatch/sw_hardware_io.c
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #include "sw_types.h"
 #include "sw_kernel_defines.h"
@@ -61,6 +60,7 @@
 #include "sw_internal.h"
 #include "sw_hardware_io.h"
 
+
 struct sw_ops_node {
 	const struct sw_hw_ops *op;
 	int id;
@@ -68,8 +68,8 @@ struct sw_ops_node {
 	SW_LIST_ENTRY(list, sw_ops_node);
 };
 
-static SW_DEFINE_LIST_HEAD(s_ops,
-sw_in			   sw_ops_node) = SW_LIST_HEAD_INITIALIZER(s_ops);
+static SW_DEFINE_LIST_HEAD(s_ops, sw_ops_node) =
+			SW_LIST_HEAD_INITIALIZER(s_ops);
 
 static int s_op_idx = -1;
 
@@ -81,12 +81,10 @@ int sw_get_hw_op_id(const struct sw_hw_ops *ops)
 	if (ops && ops->name) {
 		struct sw_ops_node *node = NULL;
 
-		SW_LIST_FOR_EACH_ENTRY(node, &s_ops, list)
-		{
+		SW_LIST_FOR_EACH_ENTRY(node, &s_ops, list) {
 			if (node->op->name &&
-			    !strcmp(node->op->name, ops->name)) {
+				!strcmp(node->op->name, ops->name))
 				return node->id;
-			}
 		}
 	}
 	return -1;
@@ -96,11 +94,9 @@ const struct sw_hw_ops *sw_get_hw_ops_for(int id)
 {
 	struct sw_ops_node *node = NULL;
 
-	SW_LIST_FOR_EACH_ENTRY(node, &s_ops, list)
-	{
-		if (node->id == id) {
+	SW_LIST_FOR_EACH_ENTRY(node, &s_ops, list) {
+		if (node->id == id)
 			return node->op;
-		}
 	}
 	return NULL;
 }
@@ -109,36 +105,33 @@ bool sw_is_valid_hw_op_id(int id)
 {
 	struct sw_ops_node *node = NULL;
 
-	SW_LIST_FOR_EACH_ENTRY(node, &s_ops, list)
-	{
-		if (node->id == id) {
+	SW_LIST_FOR_EACH_ENTRY(node, &s_ops, list) {
+		if (node->id == id)
 			return true;
-		}
 	}
 	return false;
 }
 
 const char *sw_get_hw_op_abstract_name(const struct sw_hw_ops *op)
 {
-	if (op) {
+	if (op)
 		return op->name;
-	}
+
 	return NULL;
 }
 
 int sw_for_each_hw_op(int (*func)(const struct sw_hw_ops *op, void *priv),
-		      void *priv, bool return_on_error) {
+	void *priv, bool return_on_error)
+{
 	int retval = PW_SUCCESS;
 	struct sw_ops_node *node = NULL;
 
 	if (func) {
-		SW_LIST_FOR_EACH_ENTRY(node, &s_ops, list)
-		{
+		SW_LIST_FOR_EACH_ENTRY(node, &s_ops, list) {
 			if ((*func)(node->op, priv)) {
 				retval = -EIO;
-				if (return_on_error) {
+				if (return_on_error)
 					break;
-				}
 			}
 		}
 	}
@@ -150,12 +143,12 @@ int sw_register_hw_op(const struct sw_hw_ops *op)
 	struct sw_ops_node *node = NULL;
 
 	if (!op) {
-		pw_pr_error("NULL input node in \"sw_register_hw_op\"");
+		pw_pr_error("NULL input node in \"%s\"", __func__);
 		return -EIO;
 	}
 	node = sw_kmalloc(sizeof(struct sw_ops_node), GFP_KERNEL);
 	if (!node) {
-		pw_pr_error("sw_kmalloc error in \"sw_register_hw_op\"");
+		pw_pr_error("sw_kmalloc error in \"%s\"", __func__);
 		return -ENOMEM;
 	}
 	node->op = op;
@@ -178,6 +171,7 @@ void sw_free_hw_ops(void)
 	while (!SW_LIST_EMPTY(&s_ops)) {
 		struct sw_ops_node *node =
 			SW_LIST_GET_HEAD_ENTRY(&s_ops, sw_ops_node, list);
+
 		SW_LIST_UNLINK(node, list);
 		sw_kfree(node);
 	}
diff --git a/drivers/platform/x86/socwatch/sw_internal.c b/drivers/platform/x86/socwatch/sw_internal.c
index 04544b8fecb3..8ad36a989fd2 100644
--- a/drivers/platform/x86/socwatch/sw_internal.c
+++ b/drivers/platform/x86/socwatch/sw_internal.c
@@ -1,65 +1,66 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 #include "sw_hardware_io.h"
 #include "sw_mem.h"
 #include "sw_kernel_defines.h"
+#include "sw_telem.h"
 #include "sw_internal.h"
 
-bool sw_check_output_buffer_params(void __user *buffer, size_t bytes_to_read,
-				   size_t buff_size)
+bool sw_check_output_buffer_params(
+	void __user *buffer, size_t bytes_to_read, size_t buff_size)
 {
 	if (!buffer) {
 		pw_pr_error("ERROR: NULL ptr in sw_consume_data!\n");
@@ -67,7 +68,7 @@ bool sw_check_output_buffer_params(void __user *buffer, size_t bytes_to_read,
 	}
 	if (bytes_to_read != buff_size) {
 		pw_pr_error("Error: bytes_to_read = %zu, required to be %zu\n",
-			    bytes_to_read, buff_size);
+			bytes_to_read, buff_size);
 		return false;
 	}
 	return true;
@@ -78,29 +79,27 @@ unsigned long sw_copy_to_user(char __user *dst, char *src, size_t bytes_to_copy)
 	return copy_to_user(dst, src, bytes_to_copy);
 }
 
-void sw_schedule_work(const struct cpumask *mask, void (*work)(void *),
-		      void *data)
+void sw_schedule_work(
+	const struct cpumask *mask, void (*work)(void *), void *data)
 {
 	/*
 	 * Did the user ask us to run on 'ANY' CPU?
 	 */
-	if (cpumask_empty(mask)) {
+	if (cpumask_empty(mask))
 		(*work)(data); /* Call on current CPU */
-	} else {
+	else {
 		preempt_disable();
 		{
 			/*
 			 * Did the user ask to run on this CPU?
 			 */
-			if (cpumask_test_cpu(RAW_CPU(), mask)) {
+			if (cpumask_test_cpu(RAW_CPU(), mask))
 				(*work)(data); /* Call on current CPU */
-			}
+
 			/*
 			 * OK, now check other CPUs.
 			 */
-			smp_call_function_many(
-				mask, work, data,
-				true /* Wait for all funcs to complete */);
+			smp_call_function_many(mask, work, data, true);
 		}
 		preempt_enable();
 	}
@@ -119,19 +118,19 @@ void sw_put_cpu(unsigned long flags)
 }
 
 #ifndef CONFIG_NR_CPUS_PER_MODULE
-#define CONFIG_NR_CPUS_PER_MODULE 2
+	#define CONFIG_NR_CPUS_PER_MODULE 2
 #endif /* CONFIG_NR_CPUS_PER_MODULE */
 
 static void sw_get_cpu_sibling_mask(int cpu, struct cpumask *sibling_mask)
 {
 	unsigned int base =
-		(cpu / CONFIG_NR_CPUS_PER_MODULE) * CONFIG_NR_CPUS_PER_MODULE;
+		(cpu/CONFIG_NR_CPUS_PER_MODULE) * CONFIG_NR_CPUS_PER_MODULE;
 	unsigned int i;
 
 	cpumask_clear(sibling_mask);
-	for (i = base; i < (base + CONFIG_NR_CPUS_PER_MODULE); ++i) {
+	for (i = base; i < (base+CONFIG_NR_CPUS_PER_MODULE); ++i)
 		cpumask_set_cpu(i, sibling_mask);
-	}
+
 }
 
 struct pw_cpufreq_node {
@@ -150,15 +149,14 @@ int sw_set_module_scope_for_cpus(void)
 	int cpu = 0;
 
 	INIT_LIST_HEAD(&pw_cpufreq_policy_lists);
-
 	for_each_online_cpu(cpu) {
 		struct cpumask sibling_mask;
 		struct pw_cpufreq_node *node = NULL;
 		struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
 
-		if (!policy) {
+		if (!policy)
 			continue;
-		}
+
 		/*
 		 * Get siblings for this cpu.
 		 */
@@ -195,8 +193,8 @@ int sw_set_module_scope_for_cpus(void)
 		/*
 		 * Ensure 'related_cpus' is a superset of 'cpus'
 		 */
-		cpumask_or(policy->related_cpus, policy->related_cpus,
-			   policy->cpus);
+		cpumask_or(policy->related_cpus,
+			policy->related_cpus, policy->cpus);
 		/*
 		 * Ensure 'cpus' only contains online cpus.
 		 */
@@ -221,9 +219,10 @@ int sw_reset_module_scope_for_cpus(void)
 			list_first_entry(head, struct pw_cpufreq_node, list);
 		int cpu = node->cpu;
 		struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
-		if (!policy) {
+
+		if (!policy)
 			continue;
-		}
+
 		policy->shared_type = node->shared_type;
 		cpumask_copy(policy->related_cpus, &node->related_cpus);
 		cpumask_copy(policy->cpus, &node->cpus);
@@ -236,3 +235,13 @@ int sw_reset_module_scope_for_cpus(void)
 	}
 	return PW_SUCCESS;
 }
+
+int sw_setup_telem(u64 addrs[3])
+{
+	return setup_telem(addrs);
+}
+
+void sw_destroy_telem(void)
+{
+	destroy_telem();
+}
diff --git a/drivers/platform/x86/socwatch/sw_mem.c b/drivers/platform/x86/socwatch/sw_mem.c
index ac7725387c78..c1e22611ba67 100644
--- a/drivers/platform/x86/socwatch/sw_mem.c
+++ b/drivers/platform/x86/socwatch/sw_mem.c
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 #include <linux/slab.h>
 
 #include "sw_kernel_defines.h"
@@ -79,18 +78,16 @@ static atomic_t pw_mem_should_panic = ATOMIC_INIT(0);
 /*
  * Macro to check if PANIC is on.
  */
-#define MEM_PANIC()                                                            \
-	do {                                                                   \
-		atomic_set(&pw_mem_should_panic, 1);                           \
-		smp_mb();                                                      \
+#define MEM_PANIC() do {						\
+		atomic_set(&pw_mem_should_panic, 1);			\
+		smp_mb(); /* memory access ordering */			\
 	} while (0)
-#define SHOULD_TRACE()                                                         \
-	({                                                                     \
-		bool __tmp = false;                                            \
-		smp_mb();                                                      \
-		__tmp = (atomic_read(&pw_mem_should_panic) == 0);              \
-		__tmp;                                                         \
-	})
+
+#define SHOULD_TRACE() ({						\
+	bool __tmp = false;						\
+	smp_mb(); /* memory access ordering */				\
+	__tmp = (atomic_read(&pw_mem_should_panic) == 0);		\
+	__tmp; })
 
 #else /* if !DO_MEM_PANIC_ON_ALLOC_ERROR */
 
@@ -137,16 +134,18 @@ u64 sw_get_curr_bytes_alloced(void)
  * Allocate free pages.
  * TODO: add memory tracker?
  */
-unsigned long sw_allocate_pages(gfp_t flags,
-				unsigned int alloc_size_in_bytes)
+unsigned long sw_allocate_pages(
+	unsigned int flags, unsigned int alloc_size_in_bytes)
 {
-	return __get_free_pages(flags, get_order(alloc_size_in_bytes));
+	return __get_free_pages(
+		(gfp_t)flags, get_order(alloc_size_in_bytes));
 }
 /*
  * Free up previously allocated pages.
  * TODO: add memory tracker?
  */
-void sw_release_pages(unsigned long addr, unsigned int alloc_size_in_bytes)
+void sw_release_pages(
+	unsigned long addr, unsigned int alloc_size_in_bytes)
 {
 	free_pages(addr, get_order(alloc_size_in_bytes));
 }
@@ -195,36 +194,28 @@ static SW_DEFINE_SPINLOCK(sw_kmalloc_lock);
  */
 #define PW_MEM_MAGIC 0xdeadbeef
 
-#define PW_ADD_MAGIC(x)                                                        \
-	({                                                                     \
-		char *__tmp1 = (char *)(x);                                    \
-		*((int *)__tmp1) = PW_MEM_MAGIC;                               \
-		__tmp1 += sizeof(int);                                         \
-		__tmp1;                                                        \
-	})
-#define PW_ADD_SIZE(x, s)                                                      \
-	({                                                                     \
-		char *__tmp1 = (char *)(x);                                    \
-		*((int *)__tmp1) = (s);                                        \
-		__tmp1 += sizeof(int);                                         \
-		__tmp1;                                                        \
-	})
+#define PW_ADD_MAGIC(x) ({					\
+	char *__tmp1 = (char *)(x);				\
+	*((int *)__tmp1) = PW_MEM_MAGIC;			\
+	__tmp1 += sizeof(int); __tmp1; })
+
+#define PW_ADD_SIZE(x, s) ({					\
+	char *__tmp1 = (char *)(x);				\
+	*((int *)__tmp1) = (s);					\
+	__tmp1 += sizeof(int); __tmp1; })
+
 #define PW_ADD_STAMP(x, s) PW_ADD_MAGIC(PW_ADD_SIZE((x), (s)))
 
-#define PW_IS_MAGIC(x)                                                         \
-	({                                                                     \
-		int *__tmp1 = (int *)((char *)(x) - sizeof(int));              \
-		*__tmp1 == PW_MEM_MAGIC;                                       \
-	})
-#define PW_REMOVE_STAMP(x)                                                     \
-	({                                                                     \
-		char *__tmp1 = (char *)(x);                                    \
-		__tmp1 -= sizeof(int) * 2;                                     \
-		__tmp1;                                                        \
-	})
+#define PW_IS_MAGIC(x) ({					\
+	int *__tmp1 = (int *)((char *)(x) - sizeof(int));	\
+	*__tmp1 == PW_MEM_MAGIC; })
+#define PW_REMOVE_STAMP(x) ({					\
+	char *__tmp1 = (char *)(x);				\
+	__tmp1 -= sizeof(int) * 2; __tmp1; })
+
 #define PW_GET_SIZE(x) (*((int *)(x)))
 
-void *sw_kmalloc(size_t size, gfp_t flags)
+void *sw_kmalloc(size_t size, unsigned int flags)
 {
 	size_t act_size = 0;
 	void *retVal = NULL;
@@ -234,21 +225,20 @@ void *sw_kmalloc(size_t size, gfp_t flags)
 	 * previously!
 	 */
 	{
-		if (!SHOULD_TRACE()) {
+		if (!SHOULD_TRACE())
 			return NULL;
-		}
 	}
 	/*
 	 * (1) Allocate requested block.
 	 */
 	act_size = size + sizeof(int) * 2;
-	retVal = kmalloc(act_size, flags);
+	retVal = kmalloc(act_size, (gfp_t)flags);
 	if (!retVal) {
 		/*
 		 * Panic if we couldn't allocate
 		 * requested memory.
 		 */
-		printk(KERN_INFO "ERROR: could NOT allocate memory!\n");
+		pw_pr_debug("ERROR: could NOT allocate memory!\n");
 		MEM_PANIC();
 		return NULL;
 	}
@@ -280,7 +270,7 @@ void sw_kfree(const void *obj)
 	 * by us.
 	 */
 	if (!PW_IS_MAGIC(obj)) {
-		printk(KERN_INFO "ERROR: %p is NOT a PW_MAGIC ptr!\n", obj);
+		pw_pr_debug("ERROR: %p is NOT a PW_MAGIC ptr!\n", obj);
 		return;
 	}
 	/*
@@ -307,12 +297,13 @@ void sw_kfree(const void *obj)
 
 #else /* !DO_TRACK_MEMORY_USAGE */
 
-void *sw_kmalloc(size_t size, gfp_t flags)
+void *sw_kmalloc(size_t size, unsigned int flags)
 {
 	void *ret = NULL;
 
 	if (SHOULD_TRACE()) {
-		if (!(ret = kmalloc(size, flags))) {
+		ret = kmalloc(size, (gfp_t)flags);
+		if (!ret) {
 			/*
 			 * Panic if we couldn't allocate
 			 * requested memory.
diff --git a/drivers/platform/x86/socwatch/sw_ops_provider.c b/drivers/platform/x86/socwatch/sw_ops_provider.c
index 6e0c77204657..6277d7d550ca 100644
--- a/drivers/platform/x86/socwatch/sw_ops_provider.c
+++ b/drivers/platform/x86/socwatch/sw_ops_provider.c
@@ -1,65 +1,65 @@
-/*
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/pci.h> /* "pci_get_domain_bus_and_slot" */
 #include <linux/delay.h> /* "udelay" */
 #include <asm/msr.h>
 #ifdef CONFIG_RPMSG_IPC
-#include <asm/intel_mid_rpmsg.h>
+	#include <asm/intel_mid_rpmsg.h>
 #endif /* CONFIG_RPMSG_IPC */
 
 #include "sw_types.h"
@@ -74,20 +74,20 @@
 /*
  * Should we be doing 'direct' PCI reads and writes?
  * '1' ==> YES, call "pci_{read,write}_config_dword()" directly
- * '0' ==> NO, Use the "intel_mid_msgbus_{read32,write32}_raw()"
- *         API (defined in 'intel_mid_pcihelpers.c')
+ * '0' ==> NO, Use the "intel_mid_msgbus_{read32,write32}_raw()" API
+ *		(defined in 'intel_mid_pcihelpers.c')
  */
 #define DO_DIRECT_PCI_READ_WRITE 0
 #if !IS_ENABLED(CONFIG_ANDROID) || !defined(CONFIG_X86_WANT_INTEL_MID)
-/*
- * 'intel_mid_pcihelpers.h' is probably not present -- force
- * direct PCI calls in this case.
- */
-#undef DO_DIRECT_PCI_READ_WRITE
-#define DO_DIRECT_PCI_READ_WRITE 1
+    /*
+     * 'intel_mid_pcihelpers.h' is probably not present -- force
+     * direct PCI calls in this case.
+     */
+	#undef DO_DIRECT_PCI_READ_WRITE
+	#define DO_DIRECT_PCI_READ_WRITE  1
 #endif
 #if !DO_DIRECT_PCI_READ_WRITE
-#include <asm/intel_mid_pcihelpers.h>
+	#include <asm/intel_mid_pcihelpers.h>
 #endif
 
 #define SW_PCI_MSG_CTRL_REG 0x000000D0
@@ -97,7 +97,7 @@
  *  NUM_RETRY & USEC_DELAY are used in PCH Mailbox (sw_read_pch_mailbox_info_i).
  *  Tested on KBL + SPT-LP. May need to revisit.
  */
-#define NUM_RETRY 100
+#define NUM_RETRY  100
 #define USEC_DELAY 100
 
 #define EXTCNF_CTRL 0xF00 /* offset for hw semaphore. */
@@ -117,23 +117,23 @@
 /*
  * TODO: separate into H/W and S/W IO?
  */
-typedef enum sw_io_type {
-	SW_IO_MSR = 0,
-	SW_IO_IPC = 1,
-	SW_IO_MMIO = 2,
-	SW_IO_PCI = 3,
-	SW_IO_CONFIGDB = 4,
-	SW_IO_TRACE_ARGS = 5,
-	SW_IO_WAKEUP = 6,
-	SW_IO_SOCPERF = 7,
-	SW_IO_PROC_NAME = 8,
-	SW_IO_IRQ_NAME = 9,
-	SW_IO_WAKELOCK = 10,
-	SW_IO_TELEM = 11,
-	SW_IO_PCH_MAILBOX = 12,
-	SW_IO_MAILBOX = 13,
-	SW_IO_MAX = 14,
-} sw_io_type_t;
+enum sw_io_type {
+	SW_IO_MSR		= 0,
+	SW_IO_IPC		= 1,
+	SW_IO_MMIO		= 2,
+	SW_IO_PCI		= 3,
+	SW_IO_CONFIGDB		= 4,
+	SW_IO_TRACE_ARGS	= 5,
+	SW_IO_WAKEUP		= 6,
+	SW_IO_SOCPERF		= 7,
+	SW_IO_PROC_NAME		= 8,
+	SW_IO_IRQ_NAME		= 9,
+	SW_IO_WAKELOCK		= 10,
+	SW_IO_TELEM		= 11,
+	SW_IO_PCH_MAILBOX	= 12,
+	SW_IO_MAILBOX		= 13,
+	SW_IO_MAX		= 14,
+};
 
 /*
  * "io_remapped" values for HW and FW semaphores
@@ -141,7 +141,7 @@ typedef enum sw_io_type {
 static struct {
 	volatile void __iomem *hw_semaphore;
 	volatile void __iomem *fw_semaphore;
-} s_gbe_semaphore = { NULL, NULL };
+} s_gbe_semaphore = {NULL, NULL};
 
 /*
  * Function declarations.
@@ -149,92 +149,51 @@ static struct {
 /*
  * Exported by the SOCPERF driver.
  */
-extern void SOCPERF_Read_Data2(void *data_buffer);
+extern void __weak SOCPERF_Read_Data3(void *data_buffer);
 
 /*
  * Init functions.
  */
-int sw_ipc_mmio_descriptor_init_func_i(
-	struct sw_driver_io_descriptor *descriptor);
-int sw_pch_mailbox_descriptor_init_func_i(
-	struct sw_driver_io_descriptor *descriptor);
-int sw_mailbox_descriptor_init_func_i(
-	struct sw_driver_io_descriptor *descriptor);
+int sw_ipc_mmio_descriptor_init_func_i(struct sw_driver_io_descriptor *descriptor);
+int sw_pch_mailbox_descriptor_init_func_i(struct sw_driver_io_descriptor *descriptor);
+int sw_mailbox_descriptor_init_func_i(struct sw_driver_io_descriptor *descriptor);
 
 /*
  * Read functions.
  */
-void sw_read_msr_info_i(char *dst_vals, int cpu,
-			const struct sw_driver_io_descriptor *descriptor,
-			u16 counter_size_in_bytes);
-void sw_read_ipc_info_i(char *dst_vals, int cpu,
-			const struct sw_driver_io_descriptor *descriptor,
-			u16 counter_size_in_bytes);
-void sw_read_mmio_info_i(char *dst_vals, int cpu,
-			 const struct sw_driver_io_descriptor *descriptor,
-			 u16 counter_size_in_bytes);
-void sw_read_pch_mailbox_info_i(char *dst_vals, int cpu,
-			const struct sw_driver_io_descriptor *descriptor,
-				u16 counter_size_in_bytes);
-void sw_read_mailbox_info_i(char *dst_vals, int cpu,
-			    const struct sw_driver_io_descriptor *descriptor,
-			    u16 counter_size_in_bytes);
-void sw_read_pci_info_i(char *dst_vals, int cpu,
-			const struct sw_driver_io_descriptor *descriptor,
-			u16 counter_size_in_bytes);
-void sw_read_configdb_info_i(char *dst_vals, int cpu,
-			     const struct sw_driver_io_descriptor *descriptor,
-			     u16 counter_size_in_bytes);
-void sw_read_socperf_info_i(char *dst_vals, int cpu,
-			    const struct sw_driver_io_descriptor *descriptor,
-			    u16 counter_size_in_bytes);
+void sw_read_msr_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_read_ipc_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_read_mmio_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_read_pch_mailbox_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_read_mailbox_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_read_pci_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_read_configdb_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_read_socperf_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
 
 /*
  * Write functions.
  */
-void sw_write_msr_info_i(char *dst_vals, int cpu,
-			 const struct sw_driver_io_descriptor *descriptor,
-			 u16 counter_size_in_bytes);
-void sw_write_ipc_info_i(char *dst_vals, int cpu,
-			 const struct sw_driver_io_descriptor *descriptor,
-			 u16 counter_size_in_bytes);
-void sw_write_mmio_info_i(char *dst_vals, int cpu,
-			  const struct sw_driver_io_descriptor *descriptor,
-			  u16 counter_size_in_bytes);
-void sw_write_mailbox_info_i(char *dst_vals, int cpu,
-			     const struct sw_driver_io_descriptor *descriptor,
-			     u16 counter_size_in_bytes);
-void sw_write_pci_info_i(char *dst_vals, int cpu,
-			 const struct sw_driver_io_descriptor *descriptor,
-			 u16 counter_size_in_bytes);
-void sw_write_configdb_info_i(char *dst_vals, int cpu,
-			      const struct sw_driver_io_descriptor *descriptor,
-			      u16 counter_size_in_bytes);
-void sw_write_trace_args_info_i(char *dst_vals, int cpu,
-			const struct sw_driver_io_descriptor *descriptor,
-				u16 counter_size_in_bytes);
-void sw_write_wakeup_info_i(char *dst_vals, int cpu,
-			    const struct sw_driver_io_descriptor *descriptor,
-			    u16 counter_size_in_bytes);
-void sw_write_socperf_info_i(char *dst_vals, int cpu,
-			     const struct sw_driver_io_descriptor *descriptor,
-			     u16 counter_size_in_bytes);
+void sw_write_msr_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_write_ipc_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_write_mmio_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_write_mailbox_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_write_pci_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_write_configdb_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_write_trace_args_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_write_wakeup_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
+void sw_write_socperf_info_i(char *dst_vals, int cpu, const struct sw_driver_io_descriptor *descriptor, u16 counter_size_in_bytes);
 
 /*
  * Print functions.
  */
-int sw_print_msr_io_descriptor(const struct sw_driver_io_descriptor
-			       *descriptor);
+int sw_print_msr_io_descriptor(const struct sw_driver_io_descriptor *descriptor);
 
 /*
  * Reset functions -- equal but opposite of init.
  */
-int sw_ipc_mmio_descriptor_reset_func_i(
-	const struct sw_driver_io_descriptor *descriptor);
-int sw_pch_mailbox_descriptor_reset_func_i(
-	const struct sw_driver_io_descriptor *descriptor);
-int sw_mailbox_descriptor_reset_func_i(
-	const struct sw_driver_io_descriptor *descriptor);
+int sw_ipc_mmio_descriptor_reset_func_i(const struct sw_driver_io_descriptor *descriptor);
+int sw_pch_mailbox_descriptor_reset_func_i(const struct sw_driver_io_descriptor *descriptor);
+int sw_mailbox_descriptor_reset_func_i(const struct sw_driver_io_descriptor *descriptor);
 
 /*
  * Available functions.
@@ -245,100 +204,99 @@ bool sw_socperf_available_i(void);
  * Helper functions.
  */
 u32 sw_platform_configdb_read32(u32 address);
-u32 sw_platform_pci_read32(u32 bus, u32 device, u32 function, u32 ctrl_offset,
-			   u32 ctrl_value, u32 data_offset);
-u64 sw_platform_pci_read64(u32 bus, u32 device, u32 function, u32 ctrl_offset,
-			   u32 ctrl_value, u32 data_offset);
-bool sw_platform_pci_write32(u32 bus, u32 device, u32 function,
-			     u32 write_offset, u32 data_value);
+u32 sw_platform_pci_read32(u32 bus, u32 device, u32 function, u32 ctrl_offset, u32 ctrl_value, u32 data_offset);
+u64 sw_platform_pci_read64(u32 bus, u32 device, u32 function, u32 ctrl_offset, u32 ctrl_value, u32 data_offset);
+bool sw_platform_pci_write32(u32 bus, u32 device, u32 function, u32 write_offset, u32 data_value);
 
 /*
  * Table of collector operations.
  */
 static const struct sw_hw_ops s_hw_ops[] = {
-	[SW_IO_MSR] = { .name = "MSR",
-			.init = NULL,
-			.read = &sw_read_msr_info_i,
-			.write = &sw_write_msr_info_i,
-			.print = &sw_print_msr_io_descriptor,
-			.reset = NULL,
-			.available = NULL },
+	[SW_IO_MSR] = {
+		.name = "MSR",
+		.init = NULL,
+		.read = &sw_read_msr_info_i,
+		.write = &sw_write_msr_info_i,
+		.print = &sw_print_msr_io_descriptor,
+		.reset = NULL,
+		.available = NULL
+	},
 	[SW_IO_IPC] = {
-			.name = "IPC",
-			.init = &sw_ipc_mmio_descriptor_init_func_i,
-			.read = &sw_read_ipc_info_i,
-			.reset = &sw_ipc_mmio_descriptor_reset_func_i,
-			/* Other fields are don't care (will be set to NULL) */
-		},
+		.name = "IPC",
+		.init = &sw_ipc_mmio_descriptor_init_func_i,
+		.read = &sw_read_ipc_info_i,
+		.reset = &sw_ipc_mmio_descriptor_reset_func_i,
+		/* Other fields are don't care (will be set to NULL) */
+	},
 	[SW_IO_MMIO] = {
-			.name = "MMIO",
-			.init = &sw_ipc_mmio_descriptor_init_func_i,
-			.read = &sw_read_mmio_info_i,
-			.write = &sw_write_mmio_info_i,
-			.reset = &sw_ipc_mmio_descriptor_reset_func_i,
-			/* Other fields are don't care (will be set to NULL) */
-		},
+		.name = "MMIO",
+		.init = &sw_ipc_mmio_descriptor_init_func_i,
+		.read = &sw_read_mmio_info_i,
+		.write = &sw_write_mmio_info_i,
+		.reset = &sw_ipc_mmio_descriptor_reset_func_i,
+		/* Other fields are don't care (will be set to NULL) */
+	},
 	[SW_IO_PCI] = {
-			.name = "PCI",
-			.read = &sw_read_pci_info_i,
-			.write = &sw_write_pci_info_i,
-			/* Other fields are don't care (will be set to NULL) */
-		},
+		.name = "PCI",
+		.read = &sw_read_pci_info_i,
+		.write = &sw_write_pci_info_i,
+		/* Other fields are don't care (will be set to NULL) */
+	},
 	[SW_IO_CONFIGDB] = {
-			.name = "CONFIGDB",
-			.read = &sw_read_configdb_info_i,
-			/* Other fields are don't care (will be set to NULL) */
-		},
+		.name = "CONFIGDB",
+		.read = &sw_read_configdb_info_i,
+		/* Other fields are don't care (will be set to NULL) */
+	},
 	[SW_IO_WAKEUP] = {
-			.name = "WAKEUP",
-			/* Other fields are don't care (will be set to NULL) */
-		},
+		.name = "WAKEUP",
+		/* Other fields are don't care (will be set to NULL) */
+	},
 	[SW_IO_SOCPERF] = {
-			.name = "SOCPERF",
-			.read = &sw_read_socperf_info_i,
-			.available = &sw_socperf_available_i,
-			/* Other fields are don't care (will be set to NULL) */
-		},
+		.name = "SOCPERF",
+		.read = &sw_read_socperf_info_i,
+		.available = &sw_socperf_available_i,
+		/* Other fields are don't care (will be set to NULL) */
+	},
 	[SW_IO_PROC_NAME] = {
-			.name = "PROC-NAME",
-			/* Other fields are don't care (will be set to NULL) */
-		},
+		.name = "PROC-NAME",
+		/* Other fields are don't care (will be set to NULL) */
+	},
 	[SW_IO_IRQ_NAME] = {
-			.name = "IRQ-NAME",
-			/* Other fields are don't care (will be set to NULL) */
-		},
+		.name = "IRQ-NAME",
+		/* Other fields are don't care (will be set to NULL) */
+	},
 	[SW_IO_WAKELOCK] = {
-			.name = "WAKELOCK",
-			/* Other fields are don't care (will be set to NULL) */
-		},
+		.name = "WAKELOCK",
+		/* Other fields are don't care (will be set to NULL) */
+	},
 	[SW_IO_TELEM] = {
-			.name = "TELEM",
-			.init = &sw_telem_init_func,
-			.read = &sw_read_telem_info,
-			.reset = &sw_reset_telem,
-			.available = &sw_telem_available,
-			.post_config = &sw_telem_post_config,
-			/* Other fields are don't care (will be set to NULL) */
-		},
+		.name = "TELEM",
+		.init = &sw_telem_init_func,
+		.read = &sw_read_telem_info,
+		.reset = &sw_reset_telem,
+		.available = &sw_telem_available,
+		.post_config = &sw_telem_post_config,
+		/* Other fields are don't care (will be set to NULL) */
+	},
 	[SW_IO_PCH_MAILBOX] = {
-			.name = "PCH-MAILBOX",
-			.init = &sw_pch_mailbox_descriptor_init_func_i,
-			.read = &sw_read_pch_mailbox_info_i,
-			.reset = &sw_pch_mailbox_descriptor_reset_func_i,
-			/* Other fields are don't care (will be set to NULL) */
-		},
+		.name = "PCH-MAILBOX",
+		.init = &sw_pch_mailbox_descriptor_init_func_i,
+		.read = &sw_read_pch_mailbox_info_i,
+		.reset = &sw_pch_mailbox_descriptor_reset_func_i,
+		/* Other fields are don't care (will be set to NULL) */
+	},
 	[SW_IO_MAILBOX] = {
-			.name = "MAILBOX",
-			.init = &sw_mailbox_descriptor_init_func_i,
-			.read = &sw_read_mailbox_info_i,
-			.write = &sw_write_mailbox_info_i,
-			.reset = &sw_mailbox_descriptor_reset_func_i,
-			/* Other fields are don't care (will be set to NULL) */
-		},
+		.name = "MAILBOX",
+		.init = &sw_mailbox_descriptor_init_func_i,
+		.read = &sw_read_mailbox_info_i,
+		.write = &sw_write_mailbox_info_i,
+		.reset = &sw_mailbox_descriptor_reset_func_i,
+		/* Other fields are don't care (will be set to NULL) */
+	},
 	[SW_IO_MAX] = {
-			.name = NULL,
-			/* Other fields are don't care (will be set to NULL) */
-		}
+		.name = NULL,
+		/* Other fields are don't care (will be set to NULL) */
+	}
 };
 
 /*
@@ -351,79 +309,60 @@ int sw_ipc_mmio_descriptor_init_func_i(
 	struct sw_driver_ipc_mmio_io_descriptor *__ipc_mmio = NULL;
 	u64 data_address = 0;
 
-	if (!descriptor) { /* Should NEVER happen */
+	if (!descriptor) /* Should NEVER happen */
 		return -PW_ERROR;
-	}
-	if (descriptor->collection_type == SW_IO_IPC) {
+
+	if (descriptor->collection_type == SW_IO_IPC)
 		__ipc_mmio = &descriptor->ipc_descriptor;
-	} else {
+	else
 		__ipc_mmio = &descriptor->mmio_descriptor;
-	}
-	pw_pr_debug("cmd = %u, sub-cmd = %u, data_addr = 0x%llx\n",
-		    __ipc_mmio->command, __ipc_mmio->sub_command,
-		    __ipc_mmio->data_address);
+
+	pw_pr_debug("cmd = %u, sub-cmd = %u, data_addr = 0x%llx\n"
+		__ipc_mmio->command, __ipc_mmio->sub_command,
+		__ipc_mmio->data_address);
 	data_address = __ipc_mmio->data_address;
-	/*
-	 * if (__ipc_mmio->command || __ipc_mmio->sub_command) {
-	 * __ipc_mmio->ipc_command =
-	 * ((pw_u32_t)__ipc_mmio->sub_command << 12)
-	 * | (pw_u32_t)__ipc_mmio->command;
-	 * }
-	 */
-	if (data_address) {
-		__ipc_mmio->data_remapped_address =
-			(pw_u64_t)(unsigned long)ioremap_nocache(
-				(unsigned long)data_address,
+
+	if (!data_address)
+		return PW_SUCCESS;
+
+	__ipc_mmio->data_remapped_address =
+		(pw_u64_t)(unsigned long)ioremap_nocache(
+			(unsigned long)data_address,
+			descriptor->counter_size_in_bytes);
+	if ((void *)(unsigned long)__ipc_mmio->data_remapped_address == NULL)
+		return -EIO;
+
+	pw_pr_debug("mapped addr 0x%llx\n", __ipc_mmio->data_remapped_address);
+	if ((__ipc_mmio->is_gbe) &&
+		(!s_gbe_semaphore.hw_semaphore ||
+			!s_gbe_semaphore.fw_semaphore) &&
+				(data_address >= GBE_CTRL_OFFSET)) {
+
+		u64 hw_addr = (data_address - GBE_CTRL_OFFSET) + EXTCNF_CTRL;
+		u64 fw_addr = (data_address - GBE_CTRL_OFFSET) + FWSM_CTRL;
+		pw_pr_debug("Initializing GBE semaphore\n");
+
+		s_gbe_semaphore.hw_semaphore =
+			ioremap_nocache(
+				(unsigned long)hw_addr,
+				descriptor->counter_size_in_bytes);
+		s_gbe_semaphore.fw_semaphore =
+			ioremap_nocache(
+				(unsigned long)fw_addr,
 				descriptor->counter_size_in_bytes);
-		if ((void *)(unsigned long)__ipc_mmio->data_remapped_address ==
-		    NULL) {
+		if (s_gbe_semaphore.hw_semaphore == NULL ||
+			s_gbe_semaphore.fw_semaphore == NULL) {
+			pw_pr_error(
+				"couldn't mmap hw/fw semaphores for GBE MMIO op!\n");
 			return -EIO;
 		}
-		pw_pr_debug("mapped addr 0x%llx\n",
-			    __ipc_mmio->data_remapped_address);
-		if (__ipc_mmio->is_gbe) {
-			if (!s_gbe_semaphore.hw_semaphore ||
-			    !s_gbe_semaphore.fw_semaphore) {
-				pw_pr_debug("Initializing GBE semaphore\n");
-				if (data_address >= GBE_CTRL_OFFSET) {
-					u64 hw_addr = (data_address -
-						       GBE_CTRL_OFFSET) +
-						      EXTCNF_CTRL;
-					u64 fw_addr = (data_address -
-						       GBE_CTRL_OFFSET) +
-						      FWSM_CTRL;
-					s_gbe_semaphore.hw_semaphore =
-						ioremap_nocache(
-						       (unsigned long)hw_addr,
-						       descriptor
-						       ->counter_size_in_bytes);
-					s_gbe_semaphore.fw_semaphore =
-						ioremap_nocache(
-						       (unsigned long)fw_addr,
-						       descriptor
-						       ->counter_size_in_bytes);
-					if (s_gbe_semaphore.hw_semaphore ==
-						    NULL ||
-					    s_gbe_semaphore.fw_semaphore ==
-						    NULL) {
-						pw_pr_error(
-							"couldn't mmap hw/fw semaphores for GBE MMIO op!\n");
-						return -EIO;
-					}
-					pw_pr_debug(
-						"GBE has hw_sem = 0x%llx, fw_sem = 0x%llx, size = %u\n",
-						(unsigned long long)
-							s_gbe_semaphore
-								.hw_semaphore,
-						(unsigned long long)
-							s_gbe_semaphore
-								.fw_semaphore,
-						descriptor
-						->counter_size_in_bytes);
-				}
-			}
-		}
+		pw_pr_debug(
+			"GBE has hw_sem = 0x%llx, fw_sem = 0x%llx, size = %u\n",
+			(unsigned long long)s_gbe_semaphore.hw_semaphore,
+			(unsigned long long)s_gbe_semaphore.fw_semaphore,
+			descriptor->counter_size_in_bytes);
 	}
+
 	return PW_SUCCESS;
 }
 
@@ -433,23 +372,23 @@ int sw_pch_mailbox_descriptor_init_func_i(
 	/* Perform any required 'io_remap' calls here */
 	struct sw_driver_pch_mailbox_io_descriptor *__pch_mailbox = NULL;
 
-	if (!descriptor) { /* Should NEVER happen */
+	if (!descriptor) /* Should NEVER happen */
 		return -PW_ERROR;
-	}
+
 	__pch_mailbox = &descriptor->pch_mailbox_descriptor;
 	pw_pr_debug("pch_mailbox data_addr = 0x%llx\n",
-		    (unsigned long long)__pch_mailbox->data_address);
+		(unsigned long long)__pch_mailbox->data_address);
 	if (__pch_mailbox->mtpmc_address) {
 		__pch_mailbox->mtpmc_remapped_address =
 			(pw_u64_t)(unsigned long)ioremap_nocache(
 				(unsigned long)__pch_mailbox->mtpmc_address,
 				descriptor->counter_size_in_bytes);
 		if ((void *)(unsigned long)
-			    __pch_mailbox->mtpmc_remapped_address == NULL) {
+			__pch_mailbox->mtpmc_remapped_address == NULL)
 			return -PW_ERROR;
-		}
+
 		pw_pr_debug("mtpmc_mapped addr 0x%llx\n",
-			    __pch_mailbox->mtpmc_remapped_address);
+			__pch_mailbox->mtpmc_remapped_address);
 	}
 	if (__pch_mailbox->msg_full_sts_address) {
 		__pch_mailbox->msg_full_sts_remapped_address =
@@ -457,12 +396,12 @@ int sw_pch_mailbox_descriptor_init_func_i(
 				(unsigned long)
 					__pch_mailbox->msg_full_sts_address,
 				descriptor->counter_size_in_bytes);
-		if ((void *)(unsigned long)__pch_mailbox
-			    ->msg_full_sts_remapped_address == NULL) {
+		if ((void *)(unsigned long)
+			__pch_mailbox->msg_full_sts_remapped_address == NULL)
 			return -PW_ERROR;
-		}
+
 		pw_pr_debug("msg_full_sts_mapped addr 0x%llx\n",
-			    __pch_mailbox->msg_full_sts_address);
+			__pch_mailbox->msg_full_sts_address);
 	}
 	if (__pch_mailbox->mfpmc_address) {
 		__pch_mailbox->mfpmc_remapped_address =
@@ -470,24 +409,24 @@ int sw_pch_mailbox_descriptor_init_func_i(
 				(unsigned long)__pch_mailbox->mfpmc_address,
 				descriptor->counter_size_in_bytes);
 		if ((void *)(unsigned long)
-			    __pch_mailbox->mfpmc_remapped_address == NULL) {
+			__pch_mailbox->mfpmc_remapped_address == NULL)
 			return -PW_ERROR;
-		}
+
 		pw_pr_debug("mfpmc_mapped addr 0x%llx\n",
-			    __pch_mailbox->mfpmc_remapped_address);
+			__pch_mailbox->mfpmc_remapped_address);
 	}
 	return PW_SUCCESS;
 }
 
-int sw_mailbox_descriptor_init_func_i(struct sw_driver_io_descriptor
-				      *descriptor)
+int sw_mailbox_descriptor_init_func_i(
+	struct sw_driver_io_descriptor *descriptor)
 {
 	/* Perform any required 'io_remap' calls here */
 	struct sw_driver_mailbox_io_descriptor *__mailbox = NULL;
 
-	if (!descriptor) { /* Should NEVER happen */
+	if (!descriptor) /* Should NEVER happen */
 		return -PW_ERROR;
-	}
+
 	__mailbox = &descriptor->mailbox_descriptor;
 
 	pw_pr_debug(
@@ -499,11 +438,10 @@ int sw_mailbox_descriptor_init_func_i(struct sw_driver_io_descriptor
 		if (__mailbox->interface_address) {
 			__mailbox->interface_remapped_address =
 				(pw_u64_t)(unsigned long)ioremap_nocache(
-					(unsigned long)
-						__mailbox->interface_address,
+					(unsigned long)__mailbox->interface_address,
 					descriptor->counter_size_in_bytes);
-			if ((void *)(unsigned long)__mailbox
-				    ->interface_remapped_address == NULL) {
+			if ((void *)(unsigned long)
+				__mailbox->interface_remapped_address == NULL) {
 				pw_pr_error(
 					"Couldn't iomap interface_address = 0x%llx\n",
 					__mailbox->interface_address);
@@ -516,7 +454,7 @@ int sw_mailbox_descriptor_init_func_i(struct sw_driver_io_descriptor
 					(unsigned long)__mailbox->data_address,
 					descriptor->counter_size_in_bytes);
 			if ((void *)(unsigned long)
-				    __mailbox->data_remapped_address == NULL) {
+				__mailbox->data_remapped_address == NULL) {
 				pw_pr_error(
 					"Couldn't iomap data_address = 0x%llx\n",
 					__mailbox->data_address);
@@ -524,26 +462,29 @@ int sw_mailbox_descriptor_init_func_i(struct sw_driver_io_descriptor
 			}
 		}
 		pw_pr_debug("OK, mapped addr 0x%llx, 0x%llx\n",
-			    __mailbox->interface_remapped_address,
-			    __mailbox->data_remapped_address);
+			__mailbox->interface_remapped_address,
+			__mailbox->data_remapped_address);
 	}
 	return PW_SUCCESS;
 }
 
-void sw_read_msr_info_i(char *dst_vals, int cpu,
-			const struct sw_driver_io_descriptor *descriptors,
-			u16 counter_size_in_bytes)
+void sw_read_msr_info_i(
+	char *dst_vals, int cpu,
+	const struct sw_driver_io_descriptor *descriptors,
+	u16 counter_size_in_bytes)
 {
 	u64 address = descriptors->msr_descriptor.address;
 	u32 l = 0, h = 0;
 
-	if (likely(cpu == RAW_CPU())) {
-		if (rdmsr_safe((unsigned long)address, &l, &h)) {
-			pw_pr_warn("Failed to read MSR address = 0x%llx\n", address);
-		}
-	} else {
-		if (rdmsr_safe_on_cpu(cpu, (unsigned long)address, &l, &h)) {
-			pw_pr_warn("Failed to read MSR address = 0x%llx\n", address);
+	if (likely(cpu == RAW_CPU()))
+		rdmsr_safe((unsigned long)address, &l, &h);
+	else {
+		if (rdmsr_safe_on_cpu(
+			cpu, (unsigned long)address, &l, &h)) {
+			pw_pr_warn(
+				"Failed to read MSR address = 0x%llx\n",
+				address);
+				l = 0; h = 0;
 		}
 	}
 	switch (counter_size_in_bytes) {
@@ -552,27 +493,29 @@ void sw_read_msr_info_i(char *dst_vals, int cpu,
 		break;
 	case 8:
 		*((u64 *)dst_vals) = ((u64)h << 32) | l;
+		pw_pr_debug(
+			"read MSR value = %llu\n", *((u64 *)dst_vals));
 		break;
 	default:
 		break;
 	}
-	return;
 }
 
 #ifdef CONFIG_RPMSG_IPC
-#define SW_DO_IPC(cmd, sub_cmd) rpmsg_send_generic_simple_command(cmd, sub_cmd)
+	#define SW_DO_IPC(cmd, sub_cmd) rpmsg_send_generic_simple_command(cmd, sub_cmd)
 #else
-#define SW_DO_IPC(cmd, sub_cmd) (-ENODEV)
-#endif /* CONFIG_RPMSG_IPC */
+	#define SW_DO_IPC(cmd, sub_cmd) (-ENODEV)
+#endif // CONFIG_RPMSG_IPC
 
-void sw_read_ipc_info_i(char *dst_vals, int cpu,
-			const struct sw_driver_io_descriptor *descriptors,
-			u16 counter_size_in_bytes)
+void sw_read_ipc_info_i(
+	char *dst_vals, int cpu,
+	const struct sw_driver_io_descriptor *descriptors,
+	u16 counter_size_in_bytes)
 {
-	u16 cmd = descriptors->ipc_descriptor.command,
-	    sub_cmd = descriptors->ipc_descriptor.sub_command;
-	unsigned long remapped_address =
-		(unsigned long)descriptors->ipc_descriptor.data_remapped_address;
+	u16 cmd = descriptors->ipc_descriptor.command;
+	u16 sub_cmd = descriptors->ipc_descriptor.sub_command;
+	unsigned long remapped_address = (unsigned long)
+		descriptors->ipc_descriptor.data_remapped_address;
 
 	if (cmd || sub_cmd) {
 		pw_pr_debug("EXECUTING IPC Cmd = %u, %u\n", cmd, sub_cmd);
@@ -583,23 +526,21 @@ void sw_read_ipc_info_i(char *dst_vals, int cpu,
 	}
 
 	if (remapped_address) {
-		/* memcpy(&value, (void *)remapped_address, counter_size_in_bytes); */
 		pw_pr_debug("COPYING MMIO size %u\n", counter_size_in_bytes);
 		memcpy(dst_vals, (void *)remapped_address,
-		       counter_size_in_bytes);
+				counter_size_in_bytes);
 	}
 	pw_pr_debug("Value = %llu\n", *((u64 *)dst_vals));
 }
 
-static void
-sw_read_gbe_mmio_info_i(char *dst_vals,
-			const struct sw_driver_io_descriptor *descriptors,
-			u16 counter_size_in_bytes)
+static void sw_read_gbe_mmio_info_i(
+	char *dst_vals,
+	const struct sw_driver_io_descriptor *descriptors,
+	u16 counter_size_in_bytes)
 {
 	u32 hw_val = 0, fw_val = 0;
-	unsigned long remapped_address =
-		(unsigned long)
-			descriptors->mmio_descriptor.data_remapped_address;
+	unsigned long remapped_address = (unsigned long)
+		descriptors->mmio_descriptor.data_remapped_address;
 	u64 write_value = descriptors->write_value;
 
 	memset(dst_vals, 0, counter_size_in_bytes);
@@ -608,56 +549,52 @@ sw_read_gbe_mmio_info_i(char *dst_vals,
 		"hw_sem = 0x%llx, fw_sem = 0x%llx, addr = 0x%lx, dst_vals = 0x%lx, size = %u\n",
 		(unsigned long long)s_gbe_semaphore.hw_semaphore,
 		(unsigned long long)s_gbe_semaphore.fw_semaphore,
-		remapped_address, (unsigned long)dst_vals,
+		remapped_address,
+		(unsigned long)dst_vals,
 		counter_size_in_bytes);
 	if (!s_gbe_semaphore.hw_semaphore || !s_gbe_semaphore.fw_semaphore ||
-	    !remapped_address) {
+		!remapped_address)
 		return;
-	}
 
 	memcpy_fromio(&hw_val, s_gbe_semaphore.hw_semaphore, sizeof(hw_val));
 	memcpy_fromio(&fw_val, s_gbe_semaphore.fw_semaphore, sizeof(fw_val));
-	pw_pr_debug("HW_VAL = 0x%lx, FW_VAL = 0x%lx\n", (unsigned long)hw_val,
-		    (unsigned long)fw_val);
+	pw_pr_debug("HW_VAL = 0x%lx, FW_VAL = 0x%lx\n",
+		(unsigned long)hw_val, (unsigned long)fw_val);
 	if (!IS_HW_SEMAPHORE_SET(hw_val) && !IS_FW_SEMAPHORE_SET(fw_val)) {
 		memcpy_toio((volatile void __iomem *)remapped_address,
-			    &write_value,
-			    4 /* counter_size_in_bytes*/);
-		memcpy_fromio(dst_vals,
-			      (volatile void __iomem *)remapped_address,
-			      counter_size_in_bytes);
+				&write_value, 4 /* counter_size_in_bytes*/);
+		memcpy_fromio(dst_vals, (volatile void __iomem *)remapped_address,
+				counter_size_in_bytes);
 	}
 }
 void sw_read_mmio_info_i(char *dst_vals, int cpu,
-			 const struct sw_driver_io_descriptor *descriptors,
-			 u16 counter_size_in_bytes)
+	const struct sw_driver_io_descriptor *descriptors,
+	u16 counter_size_in_bytes)
 {
 	unsigned long remapped_address =
-		(unsigned long)
-			descriptors->mmio_descriptor.data_remapped_address;
-	if (descriptors->mmio_descriptor.is_gbe) {
-		/* MMIO for GBE requires a mailbox-like operation */
-		sw_read_gbe_mmio_info_i(dst_vals, descriptors,
-					counter_size_in_bytes);
-	} else {
-		if (remapped_address) {
-			memcpy_fromio(dst_vals,
-				      (volatile void __iomem *)remapped_address,
-				      counter_size_in_bytes);
-		}
+	(unsigned long)descriptors->mmio_descriptor.data_remapped_address;
+
+	/* MMIO for GBE requires a mailbox-like operation */
+	if (descriptors->mmio_descriptor.is_gbe)
+		sw_read_gbe_mmio_info_i(dst_vals, descriptors, counter_size_in_bytes);
+	else {
+		if (remapped_address)
+			memcpy_fromio(dst_vals, (volatile void __iomem *)remapped_address,
+				counter_size_in_bytes);
 	}
 	pw_pr_debug("Value = %llu\n", *((u64 *)dst_vals));
 }
 
-void sw_read_pch_mailbox_info_i(char *dst_vals, int cpu,
-				const struct sw_driver_io_descriptor
-				*descriptor, u16 counter_size_in_bytes)
+void sw_read_pch_mailbox_info_i(
+	char *dst_vals, int cpu,
+	const struct sw_driver_io_descriptor *descriptor,
+	u16 counter_size_in_bytes)
 {
 	/*
 	 * TODO: spinlock?
 	 */
 	const struct sw_driver_pch_mailbox_io_descriptor *pch_mailbox =
-		&descriptor->pch_mailbox_descriptor;
+					 &descriptor->pch_mailbox_descriptor;
 	u32 address = pch_mailbox->data_address;
 	u64 mtpmc_remapped_address = pch_mailbox->mtpmc_remapped_address;
 	u64 msg_full_sts_remapped_address =
@@ -665,33 +602,31 @@ void sw_read_pch_mailbox_info_i(char *dst_vals, int cpu,
 	u64 mfpmc_remapped_address = pch_mailbox->mfpmc_remapped_address;
 
 	/*
-	 * write address of desired device counter to request
-	 * from PMC (shift and add 2 to format device offset)
+	 * write address of desired device counter to request from PMC
+	 * (shift and add 2 to format device offset)
 	 */
 	if (mtpmc_remapped_address) {
 		int iter = 0;
 		u32 written_val = 0;
-		u32 write_value =
-			(address << 16) +
-			2; /* shift and add 2 to format device offset */
+		/* shift and add 2 to format device offset */
+		u32 write_value = (address << 16) + 2;
+
 		memcpy_toio(
-			(volatile void __iomem *)
-			(unsigned long)mtpmc_remapped_address,
-			&write_value, 4 /*counter_size_in_bytes*/);
+			(volatile void __iomem *)(unsigned long)mtpmc_remapped_address,
+			 &write_value, 4 /*counter_size_in_bytes*/);
 		/*
 		 * Check if address has been written using a while loop in
-		 * order to wait for the PMC to consume that address
-		 * and to introduce sufficient delay so that the message full
-		 * status bit has time to flip. This should ensure
-		 * all is ready when begin the wait loop for it to turn 0,
-		 * which indicates the value is available to be read.
+		 * order to wait for the PMC to consume that address and to
+		 * introduce sufficient delay so that the message full
+		 * status bit has time to flip. This should ensure all is
+		 * ready when begin the wait loop for it to turn 0, which
+		 * indicates the value is available to be read.
 		 * (This fixes problem where values being read were huge.)
 		 */
 		do {
 			memcpy_fromio(&written_val,
-				      (volatile void __iomem *)(unsigned long)
-					      mtpmc_remapped_address,
-				      4 /*counter_size_in_bytes*/);
+				(volatile void __iomem *)(unsigned long)mtpmc_remapped_address,
+				4 /*counter_size_in_bytes*/);
 			pw_pr_debug(
 				"DEBUG: written_val = 0x%x, address = 0x%x\n",
 				written_val, address);
@@ -699,9 +634,10 @@ void sw_read_pch_mailbox_info_i(char *dst_vals, int cpu,
 		} while ((written_val >> 16) != address && ++iter < NUM_RETRY);
 	}
 
+
 	/*
-	 * wait for PMC to set status indicating that device counter
-	 * is available for read.
+	 * wait for PMC to set status indicating that device
+	 * counter is available for read.
 	 */
 	if (msg_full_sts_remapped_address) {
 		u32 status_wait = 0;
@@ -709,32 +645,31 @@ void sw_read_pch_mailbox_info_i(char *dst_vals, int cpu,
 
 		do {
 			memcpy_fromio(&status_wait,
-				      (volatile void __iomem *)(unsigned long)
-					      msg_full_sts_remapped_address,
-				      4 /*counter_size_in_bytes*/);
-			pw_pr_debug("DEBUG: status_wait = 0x%x\n", status_wait);
+				(volatile void __iomem*)(unsigned long)
+					msg_full_sts_remapped_address,
+				4 /*counter_size_in_bytes*/);
+			pw_pr_debug("DEBUG: status_wait = 0x%x\n",
+				status_wait);
 			udelay(USEC_DELAY);
 		} while ((status_wait & 0x01000000) >> 24 &&
-			 ++iter < NUM_RETRY);
+			++iter < NUM_RETRY);
 	}
 
 	/*
 	 * read device counter
 	 */
 	if (mfpmc_remapped_address) {
-		memcpy_fromio(
-			dst_vals,
-			(volatile void __iomem *)
-			(unsigned long)mfpmc_remapped_address,
+		memcpy_fromio(dst_vals,
+			(volatile void __iomem*)(unsigned long)mfpmc_remapped_address,
 			4 /*counter_size_in_bytes*/);
 		pw_pr_debug("DEBUG: read value = 0x%x\n",
-			    *((pw_u32_t *)dst_vals));
+			*((pw_u32_t *)dst_vals));
 	}
 }
 
 void sw_read_mailbox_info_i(char *dst_vals, int cpu,
-			    const struct sw_driver_io_descriptor *descriptor,
-			    u16 counter_size_in_bytes)
+		const struct sw_driver_io_descriptor *descriptor,
+		u16 counter_size_in_bytes)
 {
 	/*
 	 * TODO: spinlock?
@@ -742,156 +677,152 @@ void sw_read_mailbox_info_i(char *dst_vals, int cpu,
 	const struct sw_driver_mailbox_io_descriptor *mailbox =
 		&descriptor->mailbox_descriptor;
 	unsigned long interface_address = mailbox->interface_address;
-	unsigned long interface_remapped_address =
-		mailbox->interface_remapped_address;
+	unsigned long interface_remapped_address = mailbox->interface_remapped_address;
 	unsigned long data_address = mailbox->data_address;
 	size_t iter = 0;
 
 	if (mailbox->is_msr_type) {
 		u64 command = 0;
 
-		if (rdmsrl_safe(interface_address, &command)) {
-			pw_pr_warn("Failed to read MSR address = 0x%llx\n",
-				   interface_address);
-		}
+		rdmsrl_safe(interface_address, &command);
 		command &= mailbox->command_mask;
 		command |= mailbox->command | (u64)0x1 << mailbox->run_busy_bit;
 		wrmsrl_safe(interface_address, command);
 		do {
 			udelay(1);
-			if (rdmsrl_safe(interface_address, &command)) {
-				pw_pr_warn("Failed to read MSR address = 0x%llx\n",
-					   interface_address);
-			}
+			rdmsrl_safe(interface_address, &command);
 		} while ((command & ((u64)0x1 << mailbox->run_busy_bit)) &&
-			 ++iter < MAX_MAILBOX_ITERS);
+				++iter < MAX_MAILBOX_ITERS);
 		if (iter >= MAX_MAILBOX_ITERS) {
 			pw_pr_error("Couldn't write to BIOS mailbox\n");
-			command = 0;
-		} else {
-			if (rdmsrl_safe(data_address, &command)) {
-				pw_pr_warn("Failed to read MSR address = 0x%llx\n",
-					   data_address);
-			}
+			command = MAX_UNSIGNED_64_BIT_VALUE;
+		} else
+			rdmsrl_safe(data_address, &command);
+		switch (counter_size_in_bytes) {
+		case 4:
+			*((u32 *)dst_vals) = (u32)command;
+			break;
+		case 8:
+			*((u64 *)dst_vals) = command;
+			break;
+		default:
+			pw_pr_error("Invalid counter size %u, assuming 4 bytes!\n", counter_size_in_bytes);
+			*((u32 *)dst_vals) = (u32)command;
+			break;
 		}
-		*((u64 *)dst_vals) = command;
-	} else {
+	}  else {
 		u32 command = 0;
-		const size_t counter_size =
-			4; /* Always use 4 bytes, regardless of
-			    *'counter_size_in_bytes'
-			    */
+		/* Always use 4 bytes, regardless of 'counter_size_in_bytes' */
+		const size_t counter_size = 4;
+
 		memcpy_fromio(&command,
-			      (volatile void __iomem *)(unsigned long)
-				      interface_remapped_address,
-			      sizeof(command));
+			(volatile void __iomem *)(unsigned long)interface_remapped_address,
+			sizeof(command));
 		command &= mailbox->command_mask;
 		command |= (u32)mailbox->command |
-			   (u32)0x1 << mailbox->run_busy_bit;
-		memcpy_toio((volatile void __iomem *)(unsigned long)
-				    interface_remapped_address,
-			    &command, sizeof(command));
+				(u32)0x1 << mailbox->run_busy_bit;
+		memcpy_toio((volatile void __iomem *)(unsigned long)interface_remapped_address,
+			&command, sizeof(command));
 		do {
 			udelay(1);
 			memcpy_fromio(&command,
-				      (volatile void __iomem *)(unsigned long)
-					      interface_remapped_address,
-				      sizeof(command));
+				(volatile void __iomem *)(unsigned long)interface_remapped_address,
+				sizeof(command));
 		} while ((command & ((u32)0x1 << mailbox->run_busy_bit)) &&
-			 ++iter < MAX_MAILBOX_ITERS);
+				++iter < MAX_MAILBOX_ITERS);
 		if (iter >= MAX_MAILBOX_ITERS) {
 			pw_pr_error("Couldn't write to BIOS mailbox\n");
-			command = 0;
-		} else {
+			command = MAX_UNSIGNED_32_BIT_VALUE;
+		} else
 			memcpy_fromio(&command,
-				      (volatile void __iomem *)(unsigned long)
-					      mailbox->data_remapped_address,
-				      counter_size);
-		}
+				(volatile void __iomem *)(unsigned long)mailbox->data_remapped_address,
+				counter_size);
+
 		*((u32 *)dst_vals) = command;
 	}
 }
 
 void sw_read_pci_info_i(char *dst_vals, int cpu,
-			const struct sw_driver_io_descriptor *descriptors,
-			u16 counter_size_in_bytes)
+	const struct sw_driver_io_descriptor *descriptors,
+	u16 counter_size_in_bytes)
 {
-	u32 bus = descriptors->pci_descriptor.bus,
-	    device = descriptors->pci_descriptor.device;
-	u32 function = descriptors->pci_descriptor.function,
-	    offset = descriptors->pci_descriptor.offset;
+	u32 bus = descriptors->pci_descriptor.bus;
+	u32 device = descriptors->pci_descriptor.device;
+	u32 function = descriptors->pci_descriptor.function;
+	u32 offset = descriptors->pci_descriptor.offset;
 	u32 data32 = 0;
 	u64 data64 = 0;
 
 	switch (counter_size_in_bytes) {
 	case 4:
 		data32 = sw_platform_pci_read32(bus, device, function,
-						0 /* CTRL-OFFSET */,
-						0 /* CTRL-DATA, don't care */,
-						offset /* DATA-OFFSET */);
+			0 /* CTRL-OFFSET */, 0 /* CTRL-DATA, don't care */,
+			offset /* DATA-OFFSET */);
 		*((u32 *)dst_vals) = data32;
 		break;
 	case 8:
 		data64 = sw_platform_pci_read64(bus, device, function,
-						0 /* CTRL-OFFSET */,
-						0 /* CTRL-DATA, don't care */,
-						offset /* DATA-OFFSET */);
+			0 /* CTRL-OFFSET */, 0 /* CTRL-DATA, don't care */,
+			offset /* DATA-OFFSET */);
 		*((u64 *)dst_vals) = data64;
 		break;
 	default:
 		pw_pr_error("ERROR: invalid read size = %u\n",
-			    counter_size_in_bytes);
-		return;
+				counter_size_in_bytes);
 	}
-	return;
 }
 void sw_read_configdb_info_i(char *dst_vals, int cpu,
-			     const struct sw_driver_io_descriptor *descriptors,
-			     u16 counter_size_in_bytes)
+	const struct sw_driver_io_descriptor *descriptors,
+	u16 counter_size_in_bytes)
 {
-	{
-		pw_u32_t address = descriptors->configdb_descriptor.address;
-		u32 data = sw_platform_configdb_read32(address);
+	pw_u32_t address = descriptors->configdb_descriptor.address;
+	u32 data = sw_platform_configdb_read32(address);
 
-		pw_pr_debug(
-			"ADDRESS = 0x%x, CPU = %d, dst_vals = %p, counter size = %u, data = %u\n",
-			address, cpu, dst_vals, counter_size_in_bytes, data);
-		/*
-		 * 'counter_size_in_bytes' is ignored, for now.
-		 */
-		*((u32 *)dst_vals) = data;
-	}
-	return;
+	pw_pr_debug(
+		"ADDRESS = 0x%x, CPU = %d, dst_vals = %p, counter size = %u, data = %u\n",
+		address, cpu, dst_vals, counter_size_in_bytes, data);
+	/*
+	 * 'counter_size_in_bytes' is ignored, for now.
+	 */
+	*((u32 *)dst_vals) = data;
 }
 void sw_read_socperf_info_i(char *dst_vals, int cpu,
-			    const struct sw_driver_io_descriptor *descriptors,
-			    u16 counter_size_in_bytes)
+	const struct sw_driver_io_descriptor *descriptors,
+	u16 counter_size_in_bytes)
 {
-#if IS_ENABLED(CONFIG_INTEL_SOCPERF)
 	u64 *socperf_buffer = (u64 *)dst_vals;
 
 	memset(socperf_buffer, 0, counter_size_in_bytes);
-	SOCPERF_Read_Data2(socperf_buffer);
-#endif /* IS_ENABLED(CONFIG_INTEL_SOCPERF) */
-	return;
+	SOCPERF_Read_Data3(socperf_buffer);
+
 }
 
 /**
  * Decide if the socperf interface is available for use
- * @returns     true if available
+ * @returns	 true if available
  */
 bool sw_socperf_available_i(void)
 {
 	bool retVal = false;
-#if IS_ENABLED(CONFIG_INTEL_SOCPERF)
-	retVal = true;
-#endif /* IS_ENABLED(CONFIG_INTEL_SOCPERF) */
+
+	/* The symbol below is weak.  We return 1 if we have a definition
+	 * for this socperf-driver-supplied symbol, or 0 if only the
+	 * weak definition exists. This test will suffice to detect if
+	 * the socperf driver is loaded.
+	 */
+	if (SOCPERF_Read_Data3 != 0) {
+		pw_pr_debug("INFO: SoCPerf support in ON!\n");
+		retVal = true;
+	} else
+		pw_pr_debug("INFO: SoCPerf support is OFF!\n");
+
 	return retVal;
 }
 
+
 /**
  * sw_platform_configdb_read32 - for reading PCI space through config registers
- *                               of the platform.
+ *							   of the platform.
  * @address: An address in the PCI space
  *
  * Returns: the value read from address.
@@ -900,13 +831,10 @@ u32 sw_platform_configdb_read32(u32 address)
 {
 	u32 read_value = 0;
 #if DO_DIRECT_PCI_READ_WRITE
-	read_value =
-		sw_platform_pci_read32(0 /*bus*/,
-				       0 /*device*/,
-				       0 /*function*/,
-				       SW_PCI_MSG_CTRL_REG /*ctrl-offset*/,
-				       address /*ctrl-value*/,
-				       SW_PCI_MSG_DATA_REG /*data-offset*/);
+	read_value = sw_platform_pci_read32(
+		0/*bus*/, 0/*device*/, 0/*function*/,
+		SW_PCI_MSG_CTRL_REG/*ctrl-offset*/, address/*ctrl-value*/,
+		SW_PCI_MSG_DATA_REG/*data-offset*/);
 #else /* !DO_DIRECT_PCI_READ_WRITE */
 	read_value = intel_mid_msgbus_read32_raw(address);
 #endif /* if DO_DIRECT_PCI_READ_WRITE */
@@ -914,43 +842,47 @@ u32 sw_platform_configdb_read32(u32 address)
 	return read_value;
 }
 
-u32 sw_platform_pci_read32(u32 bus, u32 device, u32 function, u32 write_offset,
-			   u32 write_value, u32 read_offset)
+u32 sw_platform_pci_read32(u32 bus, u32 device, u32 function,
+		u32 write_offset, u32 write_value, u32 read_offset)
 {
 	u32 read_value = 0;
-	struct pci_dev *pci_root = pci_get_domain_bus_and_slot(
-		0, bus, PCI_DEVFN(device, function)); /* 0, PCI_DEVFN(0, 0)); */
-	if (!pci_root) {
+	struct pci_dev *pci_root =
+		pci_get_domain_bus_and_slot(0, bus,
+			/* 0, PCI_DEVFN(0, 0)); */
+			PCI_DEVFN(device, function));
+
+	if (!pci_root)
 		return 0; /* Application will verify the data */
-	}
-	if (write_offset) {
-		pci_write_config_dword(
-			pci_root, write_offset,
-			write_value); /* SW_PCI_MSG_CTRL_REG, address); */
-	}
-	pci_read_config_dword(
-		pci_root, read_offset,
-		&read_value); /* SW_PCI_MSG_DATA_REG, &read_value); */
+
+	if (write_offset)
+		pci_write_config_dword(pci_root,
+			/* SW_PCI_MSG_CTRL_REG, address); */
+			write_offset, write_value);
+
+	pci_read_config_dword(pci_root,
+		/* SW_PCI_MSG_DATA_REG, &read_value); */
+		read_offset, &read_value);
 	return read_value;
 }
 
 u64 sw_platform_pci_read64(u32 bus, u32 device, u32 function, u32 write_offset,
-			   u32 write_value, u32 read_offset)
+	u32 write_value, u32 read_offset)
 {
-	u32 lo = sw_platform_pci_read32(bus, device, function,
-					0 /* CTRL-OFFSET */,
-					0 /* CTRL-DATA, don't care */,
-					read_offset /* DATA-OFFSET */);
-	u32 hi = sw_platform_pci_read32(bus, device, function,
-					0 /* CTRL-OFFSET */,
-					0 /* CTRL-DATA, don't care */,
-					read_offset + 4 /* DATA-OFFSET */);
+	u32 lo = sw_platform_pci_read32(
+		bus, device, function, 0 /* CTRL-OFFSET */,
+		0 /* CTRL-DATA, don't care */,
+		read_offset /* DATA-OFFSET */);
+	u32 hi = sw_platform_pci_read32(
+		bus, device, function, 0 /* CTRL-OFFSET */,
+		0 /* CTRL-DATA, don't care */,
+		read_offset + 4 /* DATA-OFFSET */);
+
 	return ((u64)hi << 32) | lo;
 }
 
 void sw_write_msr_info_i(char *dst_vals, int cpu,
-			 const struct sw_driver_io_descriptor *descriptor,
-			 u16 counter_size_in_bytes)
+	const struct sw_driver_io_descriptor *descriptor,
+	u16 counter_size_in_bytes)
 {
 	u64 write_value = descriptor->write_value;
 	u64 address = descriptor->msr_descriptor.address;
@@ -958,45 +890,43 @@ void sw_write_msr_info_i(char *dst_vals, int cpu,
 	pw_pr_debug(
 		"ADDRESS = 0x%llx, CPU = %d, counter size = %u, value = %llu\n",
 		address, cpu, counter_size_in_bytes, write_value);
-	if (likely(cpu == RAW_CPU())) {
+	if (likely(cpu == RAW_CPU()))
 		wrmsrl_safe((unsigned long)address, write_value);
-	} else {
-		u32 l = write_value & 0xffffffff,
-		    h = (write_value >> 32) & 0xffffffff;
+	else {
+		u32 l = write_value & 0xffffffff;
+		u32 h = (write_value >> 32) & 0xffffffff;
+
 		wrmsr_safe_on_cpu(cpu, (u32)address, l, h);
 	}
-	return;
 };
 
 void sw_write_mmio_info_i(char *dst_vals, int cpu,
-			  const struct sw_driver_io_descriptor *descriptor,
-			  u16 counter_size_in_bytes)
+	const struct sw_driver_io_descriptor *descriptor,
+	u16 counter_size_in_bytes)
 {
-	unsigned long remapped_address =
-		(unsigned long)
+	unsigned long remapped_address = (unsigned long)
 		descriptor->mmio_descriptor.data_remapped_address;
 	u64 write_value = descriptor->write_value;
 
-	if (remapped_address) {
-		memcpy_toio((volatile void __iomem *)remapped_address,
-			    &write_value,
-			    counter_size_in_bytes);
-	}
+	if (remapped_address)
+		memcpy_toio((volatile void __iomem *)remapped_address, &write_value,
+			counter_size_in_bytes);
+
 	pw_pr_debug("Value = %llu\n", *((u64 *)dst_vals));
 };
 
 void sw_write_mailbox_info_i(char *dst_vals, int cpu,
-			     const struct sw_driver_io_descriptor *descriptor,
-			     u16 counter_size_in_bytes)
+	const struct sw_driver_io_descriptor *descriptor,
+	u16 counter_size_in_bytes)
 {
 	/*
 	 * TODO: spinlock?
 	 */
 	const struct sw_driver_mailbox_io_descriptor *mailbox =
-		&descriptor->mailbox_descriptor;
+					&descriptor->mailbox_descriptor;
 	unsigned long interface_address = mailbox->interface_address;
 	unsigned long interface_remapped_address =
-		mailbox->interface_remapped_address;
+					mailbox->interface_remapped_address;
 	unsigned long data_address = mailbox->data_address;
 	u64 data = descriptor->write_value;
 	size_t iter = 0;
@@ -1004,82 +934,73 @@ void sw_write_mailbox_info_i(char *dst_vals, int cpu,
 	if (mailbox->is_msr_type) {
 		u64 command = 0;
 
-		if (rdmsrl_safe(interface_address, &command)) {
-			pw_pr_warn("Failed to read MSR address = 0x%llx\n",
-				   interface_address);
-		}
+		rdmsrl_safe(interface_address, &command);
 		command &= mailbox->command_mask;
-		command |= mailbox->command | (u64)0x1 << mailbox->run_busy_bit;
+		command |= mailbox->command |
+				(u64)0x1 << mailbox->run_busy_bit;
 		wrmsrl_safe(data_address, data);
 		wrmsrl_safe(interface_address, command);
 		do {
-			if (rdmsrl_safe(interface_address, &command)) {
-				pw_pr_warn("Failed to read MSR address = 0x%llx\n",
-					   interface_address);
-			}
+			rdmsrl_safe(interface_address, &command);
 		} while ((command & ((u64)0x1 << mailbox->run_busy_bit)) &&
-			 ++iter < MAX_MAILBOX_ITERS);
+				++iter < MAX_MAILBOX_ITERS);
 	} else {
 		u32 command = 0;
 
 		memcpy_fromio(&command,
-			      (volatile void __iomem *)(unsigned long)
-				      interface_remapped_address,
-			      sizeof(command));
+			(volatile void __iomem *)(unsigned long)interface_remapped_address,
+			sizeof(command));
 		command &= mailbox->command_mask;
 		command |= (u32)mailbox->command |
-			   (u32)0x1 << mailbox->run_busy_bit;
+			(u32)0x1 << mailbox->run_busy_bit;
 		memcpy_toio((volatile void __iomem *)(unsigned long)
-				    mailbox->data_remapped_address,
-			    &data, sizeof(data));
-		memcpy_toio((volatile void __iomem *)(unsigned long)
-				    interface_remapped_address,
-			    &command, sizeof(command));
+			mailbox->data_remapped_address,
+			&data, sizeof(data));
+		memcpy_toio((volatile void __iomem *)(unsigned long)interface_remapped_address,
+			&command, sizeof(command));
 		do {
-			memcpy_fromio(&command,
-				      (volatile void __iomem *)(unsigned long)
-					      interface_remapped_address,
-				      sizeof(command));
+			memcpy_fromio(&command, (volatile void __iomem *)(unsigned long)
+				interface_remapped_address, sizeof(command));
 		} while ((command & ((u32)0x1 << mailbox->run_busy_bit)) &&
-			 ++iter < MAX_MAILBOX_ITERS);
+				++iter < MAX_MAILBOX_ITERS);
 	}
 }
 
 void sw_write_pci_info_i(char *dst_vals, int cpu,
-			 const struct sw_driver_io_descriptor *descriptor,
-			 u16 counter_size_in_bytes)
+	const struct sw_driver_io_descriptor *descriptor,
+	u16 counter_size_in_bytes)
 {
-	u32 bus = descriptor->pci_descriptor.bus,
-	    device = descriptor->pci_descriptor.device;
-	u32 function = descriptor->pci_descriptor.function,
-	    offset = descriptor->pci_descriptor.offset;
+	u32 bus = descriptor->pci_descriptor.bus;
+	u32 device = descriptor->pci_descriptor.device;
+	u32 function = descriptor->pci_descriptor.function;
+	u32 offset = descriptor->pci_descriptor.offset;
 	u32 write_value = (u32)descriptor->write_value;
 	/*
 	 * 'counter_size_in_bytes' is ignored for now.
 	 */
 	if (!sw_platform_pci_write32(bus, device, function, offset,
-				     write_value)) {
-		pw_pr_error("ERROR writing to PCI B/D/F/O %u/%u/%u/%u\n", bus,
-			    device, function, offset);
-	} else {
-		pw_pr_debug(
-			"OK, successfully wrote to PCI B/D/F/O %u/%u/%u/%u\n",
+			write_value))
+		pw_pr_error("ERROR writing to PCI B/D/F/O %u/%u/%u/%u\n",
 			bus, device, function, offset);
-	}
-	return;
+	else
+		pw_pr_debug("OK, successfully wrote to PCI B/D/F/O %u/%u/%u/%u\n",
+			bus, device, function, offset);
+
 };
 
 /*
  * Write to PCI space via config registers.
  */
 bool sw_platform_pci_write32(u32 bus, u32 device, u32 function,
-			     u32 write_offset, u32 data_value)
+	u32 write_offset, u32 data_value)
 {
-	struct pci_dev *pci_root = pci_get_domain_bus_and_slot(
-		0, bus, PCI_DEVFN(device, function)); /* 0, PCI_DEVFN(0, 0)); */
-	if (!pci_root) {
+	struct pci_dev *pci_root =
+		pci_get_domain_bus_and_slot(0, bus,
+			PCI_DEVFN(device, function));/* 0, PCI_DEVFN(0, 0)); */
+
+	if (!pci_root)
 		return false;
-	}
+
 
 	pci_write_config_dword(pci_root, write_offset, data_value);
 
@@ -1088,11 +1009,11 @@ bool sw_platform_pci_write32(u32 bus, u32 device, u32 function,
 
 int sw_print_msr_io_descriptor(const struct sw_driver_io_descriptor *descriptor)
 {
-	if (!descriptor) {
+	if (!descriptor)
 		return -PW_ERROR;
-	}
+
 	pw_pr_debug("MSR address = 0x%llx\n",
-		    descriptor->msr_descriptor.address);
+		descriptor->msr_descriptor.address);
 	return PW_SUCCESS;
 }
 
@@ -1102,34 +1023,33 @@ int sw_ipc_mmio_descriptor_reset_func_i(
 	/* Unmap previously mapped memory here */
 	struct sw_driver_ipc_mmio_io_descriptor *__ipc_mmio = NULL;
 
-	if (!descriptor) { /* Should NEVER happen */
+	if (!descriptor) /* Should NEVER happen */
 		return -PW_ERROR;
-	}
-	if (descriptor->collection_type == SW_IO_IPC) {
-		__ipc_mmio =
-			(struct sw_driver_ipc_mmio_io_descriptor *)&descriptor
-				->ipc_descriptor;
-	} else {
-		__ipc_mmio =
-			(struct sw_driver_ipc_mmio_io_descriptor *)&descriptor
-				->mmio_descriptor;
-	}
+
+	if (descriptor->collection_type == SW_IO_IPC)
+		__ipc_mmio = (struct sw_driver_ipc_mmio_io_descriptor *)
+			&descriptor->ipc_descriptor;
+	else
+		__ipc_mmio = (struct sw_driver_ipc_mmio_io_descriptor *)
+			&descriptor->mmio_descriptor;
+
 	if (__ipc_mmio->data_remapped_address) {
 		pw_pr_debug("unmapping addr 0x%llx\n",
-			    __ipc_mmio->data_remapped_address);
+			__ipc_mmio->data_remapped_address);
 		iounmap((volatile void __iomem *)(unsigned long)
-				__ipc_mmio->data_remapped_address);
+			__ipc_mmio->data_remapped_address);
 		__ipc_mmio->data_remapped_address = 0;
 	}
 	/* Uninitialize the GBE, if it wasn't already done */
-	if (s_gbe_semaphore.hw_semaphore || s_gbe_semaphore.fw_semaphore) {
+	if (s_gbe_semaphore.hw_semaphore ||
+			s_gbe_semaphore.fw_semaphore) {
 		pw_pr_debug("Uninitializing gbe!\n");
-		if (s_gbe_semaphore.hw_semaphore) {
+		if (s_gbe_semaphore.hw_semaphore)
 			iounmap(s_gbe_semaphore.hw_semaphore);
-		}
-		if (s_gbe_semaphore.fw_semaphore) {
+
+		if (s_gbe_semaphore.fw_semaphore)
 			iounmap(s_gbe_semaphore.fw_semaphore);
-		}
+
 		memset(&s_gbe_semaphore, 0, sizeof(s_gbe_semaphore));
 	}
 	return PW_SUCCESS;
@@ -1141,31 +1061,30 @@ int sw_pch_mailbox_descriptor_reset_func_i(
 	/* Unmap previously mapped memory here */
 	struct sw_driver_pch_mailbox_io_descriptor *__pch_mailbox = NULL;
 
-	if (!descriptor) { /* Should NEVER happen */
+	if (!descriptor) /* Should NEVER happen */
 		return -PW_ERROR;
-	}
-	__pch_mailbox =
-		(struct sw_driver_pch_mailbox_io_descriptor *)&descriptor
-			->pch_mailbox_descriptor;
+
+	__pch_mailbox = (struct sw_driver_pch_mailbox_io_descriptor *)
+			&descriptor->pch_mailbox_descriptor;
 	if (__pch_mailbox->mtpmc_remapped_address) {
 		pw_pr_debug("unmapping addr 0x%llx\n",
-			    __pch_mailbox->mtpmc_remapped_address);
+			__pch_mailbox->mtpmc_remapped_address);
 		iounmap((volatile void __iomem *)(unsigned long)
-				__pch_mailbox->mtpmc_remapped_address);
+			__pch_mailbox->mtpmc_remapped_address);
 		__pch_mailbox->mtpmc_remapped_address = 0;
 	}
 	if (__pch_mailbox->msg_full_sts_remapped_address) {
 		pw_pr_debug("unmapping addr 0x%llx\n",
-			    __pch_mailbox->msg_full_sts_remapped_address);
+			__pch_mailbox->msg_full_sts_remapped_address);
 		iounmap((volatile void __iomem *)(unsigned long)
-				__pch_mailbox->msg_full_sts_remapped_address);
+			__pch_mailbox->msg_full_sts_remapped_address);
 		__pch_mailbox->msg_full_sts_remapped_address = 0;
 	}
 	if (__pch_mailbox->mfpmc_remapped_address) {
 		pw_pr_debug("unmapping addr 0x%llx\n",
-			    __pch_mailbox->mfpmc_remapped_address);
+			__pch_mailbox->mfpmc_remapped_address);
 		iounmap((volatile void __iomem *)(unsigned long)
-				__pch_mailbox->mfpmc_remapped_address);
+			__pch_mailbox->mfpmc_remapped_address);
 		__pch_mailbox->mfpmc_remapped_address = 0;
 	}
 	return PW_SUCCESS;
@@ -1177,24 +1096,24 @@ int sw_mailbox_descriptor_reset_func_i(
 	/* Unmap previously mapped memory here */
 	struct sw_driver_mailbox_io_descriptor *__mailbox = NULL;
 
-	if (!descriptor) { /* Should NEVER happen */
+	if (!descriptor) /* Should NEVER happen */
 		return -PW_ERROR;
-	}
-	__mailbox = (struct sw_driver_mailbox_io_descriptor *)&descriptor
-			    ->mailbox_descriptor;
+
+	__mailbox = (struct sw_driver_mailbox_io_descriptor *)
+			&descriptor->mailbox_descriptor;
 	if (!__mailbox->is_msr_type) {
 		if (__mailbox->interface_remapped_address) {
 			pw_pr_debug("unmapping addr 0x%llx\n",
-				    __mailbox->interface_remapped_address);
+				__mailbox->interface_remapped_address);
 			iounmap((volatile void __iomem *)(unsigned long)
-					__mailbox->interface_remapped_address);
+				__mailbox->interface_remapped_address);
 			__mailbox->interface_remapped_address = 0;
 		}
 		if (__mailbox->data_remapped_address) {
 			pw_pr_debug("unmapping addr 0x%llx\n",
-				    __mailbox->data_remapped_address);
+				__mailbox->data_remapped_address);
 			iounmap((volatile void __iomem *)(unsigned long)
-					__mailbox->data_remapped_address);
+				__mailbox->data_remapped_address);
 			__mailbox->data_remapped_address = 0;
 		}
 	}
@@ -1202,19 +1121,18 @@ int sw_mailbox_descriptor_reset_func_i(
 }
 
 #define NUM_HW_OPS SW_ARRAY_SIZE(s_hw_ops)
-#define FOR_EACH_HW_OP(idx, op)                                                \
-	for (idx = 0; idx < NUM_HW_OPS && (op = &s_hw_ops[idx]); ++idx)
+#define FOR_EACH_HW_OP(idx, op)					\
+	for (idx = 0; idx < NUM_HW_OPS && (op =  &s_hw_ops[idx]); ++idx)
 
 int sw_register_ops_providers(void)
 {
 	size_t idx = 0;
 	const struct sw_hw_ops *op = NULL;
 
-	FOR_EACH_HW_OP(idx, op)
-	{
+	FOR_EACH_HW_OP(idx, op) {
 		if (op->name && sw_register_hw_op(op)) {
-			pw_pr_error("ERROR registering provider %s\n",
-				    op->name);
+			pw_pr_error(
+				"ERROR registering provider %s\n", op->name);
 			return -EIO;
 		}
 	}
diff --git a/drivers/platform/x86/socwatch/sw_output_buffer.c b/drivers/platform/x86/socwatch/sw_output_buffer.c
index a0c1c5fedd05..eaccc29f18ea 100644
--- a/drivers/platform/x86/socwatch/sw_output_buffer.c
+++ b/drivers/platform/x86/socwatch/sw_output_buffer.c
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #include "sw_internal.h"
 #include "sw_output_buffer.h"
@@ -84,25 +83,19 @@
  * How much space is available in a given segment?
  */
 #define EMPTY_TSC ((u64)-1)
-#define SEG_IS_FULL(seg)                                                       \
-	({                                                                     \
-		bool __full = false;                                           \
-		smp_mb();                                                      \
-		__full = ((seg)->is_full != EMPTY_TSC);                        \
-		__full;                                                        \
-	})
-#define SEG_SET_FULL(seg, tsc)                                                 \
-	do {                                                                   \
-		(seg)->is_full = (tsc);                                        \
-		smp_mb();                                                      \
-	} while (0)
-#define SEG_SET_EMPTY(seg)                                                     \
-	do {                                                                   \
-		barrier();                                                     \
-		(seg)->bytes_written = 0;                                      \
-		SEG_SET_FULL(seg, EMPTY_TSC);                                  \
-		/*smp_mb(); */                                                 \
-	} while (0)
+#define SEG_IS_FULL(seg) ({bool __full = false; \
+	smp_mb(); /* memory access ordering */\
+	__full = ((seg)->is_full != EMPTY_TSC); \
+	__full; })
+#define SEG_SET_FULL(seg, tsc) do { \
+	(seg)->is_full = (tsc); \
+	smp_mb(); /* memory access ordering */\
+} while (0)
+#define SEG_SET_EMPTY(seg) do { \
+	barrier(); \
+	(seg)->bytes_written = 0; \
+	SEG_SET_FULL(seg, EMPTY_TSC); \
+} while (0)
 #define SPACE_AVAIL(seg) (SW_SEG_DATA_SIZE - (seg)->bytes_written)
 #define SEG_IS_EMPTY(seg) (SPACE_AVAIL(seg) == SW_SEG_DATA_SIZE)
 
@@ -111,9 +104,10 @@
  * Convenience macro: iterate over each segment in a per-cpu output buffer.
  */
 #define for_each_segment(i) for (i = 0; i < NUM_SEGS_PER_BUFFER; ++i)
-#define for_each_seg(buffer, seg)                                              \
-	for (int i = 0;                                                        \
-	     i < NUM_SEGS_PER_BUFFER && (seg = (buffer)->segments[i]); ++i)
+#define for_each_seg(buffer, seg)					 \
+	for (int i = 0;							 \
+		i < NUM_SEGS_PER_BUFFER && (seg = (buffer)->segments[i]);\
+		++i)
 /*
  * How many buffers are we using?
  */
@@ -127,17 +121,15 @@
  * Local data structures.
  * -------------------------------------------------
  */
-typedef struct sw_data_buffer sw_data_buffer_t;
-typedef struct sw_output_buffer sw_output_buffer_t;
 struct sw_data_buffer {
 	u64 is_full;
 	u32 bytes_written;
 	char *buffer;
-} __attribute__((packed));
+} __packed;
 #define SW_SEG_HEADER_SIZE() (sizeof(struct sw_data_buffer) - sizeof(char *))
 
 struct sw_output_buffer {
-	sw_data_buffer_t buffers[NUM_SEGS_PER_BUFFER];
+	struct sw_data_buffer buffers[NUM_SEGS_PER_BUFFER];
 	int buff_index;
 	u32 produced_samples;
 	u32 dropped_samples;
@@ -146,6 +138,24 @@ struct sw_output_buffer {
 	unsigned long free_pages;
 } ____cacheline_aligned_in_smp;
 
+/* *************************************************
+ * For circular buffer (continuous profiling)
+ * *************************************************
+ */
+static char *output_buffer;
+
+struct buffer {
+	union {
+		char *data;
+		unsigned long free_pages;
+	};
+	size_t read_index, write_index;
+	unsigned long size;
+};
+SW_DECLARE_RWLOCK(sw_continuous_lock);
+
+static struct buffer buffer; /* TODO: rename */
+
 /* -------------------------------------------------
  * Function declarations.
  * -------------------------------------------------
@@ -163,7 +173,7 @@ DECLARE_OVERHEAD_VARS(sw_produce_generic_msg_i);
 /*
  * Per-cpu output buffers.
  */
-static sw_output_buffer_t *per_cpu_output_buffers;
+static struct sw_output_buffer *per_cpu_output_buffers;
 /*
  * Variables for book keeping.
  */
@@ -183,26 +193,254 @@ unsigned long sw_buffer_alloc_size = (1 << 16); /* 64 KB */
  * -------------------------------------------------
  */
 
+/* *************************************************
+ * For circular buffer (continuous profiling)
+ * *************************************************
+ */
+#define MIN(x, y) ((x) <= (y) ? (x) : (y))
+
+#define IS_BUFFER_EMPTY(buffer)					\
+	((buffer).write_index == (buffer).read_index)
+#define IS_BUFFER_FULL(buffer)					\
+	((buffer).write_index ==				\
+		((buffer).read_index + 1) & (buffer.size - 1))
+
+static inline size_t get_space_available(struct buffer *buffer)
+{
+	size_t read = 0, write = 0;
+
+	smp_mb(); /* memory access ordering */
+	read = buffer->read_index;
+	write = buffer->write_index;
+	if (write < read)
+		return read - write;
+
+	return (buffer->size - write) + read;
+}
+
+static inline size_t get_data_available(struct buffer *buffer)
+{
+	size_t read = 0, write = 0;
+
+	smp_mb(); /* memory access ordering */
+	read = buffer->read_index;
+	write = buffer->write_index;
+	if (read <= write)
+		return write - read;
+
+	return (buffer->size - read) + write;
+}
+
+static void copy_wraparound(const char *src, size_t src_size, size_t *index)
+{
+	size_t buff_size_left = buffer.size - *index;
+	size_t to_write = MIN(buff_size_left, src_size);
+	size_t _index = *index;
+
+	if (src_size < buff_size_left) {
+		memcpy(&buffer.data[_index], src, src_size);
+		_index += src_size;
+	} else {
+		memcpy(&buffer.data[_index], src, to_write);
+		_index = 0;
+		src += to_write;
+		to_write = src_size - to_write;
+		memcpy(&buffer.data[_index], src, to_write);
+		_index += to_write;
+		pw_pr_debug("DEBUG: wrap memcpy\n");
+	}
+	*index = (*index + src_size) & (buffer.size - 1);
+}
+
+static int enqueue_data(struct sw_driver_msg *msg, enum sw_wakeup_action action)
+{
+	size_t size = SW_DRIVER_MSG_HEADER_SIZE() + msg->payload_len;
+	bool wrapped = false;
+
+	msg->tsc = 0;
+
+	READ_LOCK(sw_continuous_lock);
+	while (true) {
+		size_t old_write_index = buffer.write_index;
+		size_t new_write_index = (old_write_index + size) &
+						(buffer.size - 1);
+
+		if (get_space_available(&buffer) < size)
+			break;
+
+		if (CAS32(&buffer.write_index, old_write_index,
+				new_write_index)) {
+			msg->tsc = sw_timestamp();
+			wrapped = new_write_index <= old_write_index;
+			/* First copy header */
+			copy_wraparound((const char *)msg,
+				SW_DRIVER_MSG_HEADER_SIZE(), &old_write_index);
+			/* Then copy payload */
+			copy_wraparound((const char *)msg->p_payload,
+				msg->payload_len, &old_write_index);
+			break;
+		}
+	}
+	READ_UNLOCK(sw_continuous_lock);
+	if (!msg->tsc)
+		pw_pr_error("ERROR: couldn't enqueue data\n");
+	if (wrapped)
+		pw_pr_debug("DEBUG: wrapped!\n");
+
+	return msg->tsc ? 0 : -1;
+}
+
+/*
+ * Returns # of bytes successfully consumed on success
+ * 0 on EOF (no error condition)
+ */
+static size_t consume_buffer(void *dest, size_t bytes_to_read)
+{
+	size_t read_index = 0, write_index = 0, dst_index = 0;
+	size_t to_read = 0;
+	bool wrapped = false;
+	size_t read_size = bytes_to_read;
+	unsigned long bytes_not_copied = 0;
+	struct sw_driver_continuous_collect data = {0};
+
+	WRITE_LOCK(sw_continuous_lock);
+	smp_mb(); /* memory access ordering */
+	read_index = buffer.read_index;
+	write_index = buffer.write_index;
+	/* EXE sends size as header + payload; we only want payload */
+	read_size -= SW_DRIVER_CONTINUOUS_COLLECT_HEADER_SIZE();
+	data.collection_size = to_read =
+		MIN(read_size, get_data_available(&buffer));
+	pw_pr_debug(
+		"DEBUG: read = %zu, write = %zu, avail = %zu, to_read = %zu\n",
+		read_index, write_index, get_data_available(&buffer), to_read);
+	while (to_read) {
+		size_t curr_read = to_read;
+
+		if (read_index + to_read > buffer.size) {
+			curr_read = buffer.size - read_index;
+			wrapped = true;
+			pw_pr_debug(
+				"DEBUG: read = %zu, to_read = %zu, curr_read = %zu, buffer.size = %lu, WRAPPED!\n",
+				read_index, to_read, curr_read, buffer.size);
+		}
+		memcpy(&output_buffer[dst_index],
+			&buffer.data[read_index], curr_read);
+		read_index = (read_index + curr_read) & (buffer.size - 1);
+		to_read -= curr_read;
+		dst_index += curr_read;
+	}
+	buffer.read_index = read_index;
+	smp_mb(); /* memory access ordering */
+	pw_pr_debug("DEBUG: read at end of while = %zu\n", buffer.read_index);
+	WRITE_UNLOCK(sw_continuous_lock);
+
+	/*
+	 * Call 'copy_to_user' instead of 'sw_copy_to_user' since
+	 * sw_copy_to_user expects to see a 'struct uio' while this
+	 * is called from an IOCTL which does NOT have a 'struct uio'
+	 */
+	bytes_not_copied =
+	copy_to_user(dest, (char *)&data,
+		SW_DRIVER_CONTINUOUS_COLLECT_HEADER_SIZE());
+	if (bytes_not_copied)
+		return 0;
+
+	pw_pr_debug("DEBUG: collection size = %u\n", data.collection_size);
+	if (data.collection_size) {
+		bytes_not_copied =
+			copy_to_user(dest +
+				SW_DRIVER_CONTINUOUS_COLLECT_HEADER_SIZE(),
+				output_buffer, data.collection_size);
+		if (bytes_not_copied)
+			return 0;
+
+	}
+	return data.collection_size;
+}
+
+long initialize_circular_buffer(size_t size)
+{
+	size_t alloc_size = size, read_size = size;
+	/*
+	 * We require a power of two size
+	 */
+	pw_pr_debug("DEBUG: old alloc size = %zu\n", alloc_size);
+	if ((alloc_size & (alloc_size - 1)) != 0)
+		alloc_size = 1 << fls(alloc_size);
+
+	pw_pr_debug("DEBUG: new alloc size = %zu\n", alloc_size);
+	/* Create double-sized buffer */
+	alloc_size <<= 1;
+	pw_pr_debug("DEBUG: double alloc size = %zu\n", alloc_size);
+	memset(&buffer, 0, sizeof(buffer));
+	buffer.free_pages =
+		sw_allocate_pages(GFP_KERNEL | __GFP_ZERO, alloc_size);
+	if (!buffer.free_pages) {
+		pw_pr_error("Couldn't allocate space for buffer!\n");
+		return -ENOMEM;
+	}
+	buffer.read_index = buffer.write_index = 0;
+	buffer.size = alloc_size;
+	SW_INIT_RWLOCK(sw_continuous_lock);
+	/*
+	 * Create temp output buffer
+	 */
+	output_buffer = vmalloc(read_size);
+	if (!output_buffer) {
+		pw_pr_error(
+			"Couldn't create temporary buffer for data output!\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+void reset_output_buffers(void)
+{
+	buffer.read_index = buffer.write_index = 0;
+}
+
+
+void destroy_circular_buffer(void)
+{
+	if (buffer.free_pages) {
+		sw_release_pages(buffer.free_pages, buffer.size);
+		buffer.free_pages = 0;
+	}
+	if (output_buffer) {
+		vfree(output_buffer);
+		output_buffer = NULL;
+	}
+	SW_DESTROY_RWLOCK(sw_continuous_lock);
+	pw_pr_debug("DEBUG: read = %zu, write = %zu\n", buffer.read_index,
+	buffer.write_index);
+}
+
+/* *************************************************
+ * For per-cpu buffers (non circular)
+ * *************************************************
+ */
+
 static char *reserve_seg_space_i(size_t size, int cpu, bool *should_wakeup,
-				 u64 *reservation_tsc)
+	u64 *reservation_tsc)
 {
-	sw_output_buffer_t *buffer = GET_OUTPUT_BUFFER(cpu);
+	struct sw_output_buffer *buffer = GET_OUTPUT_BUFFER(cpu);
 	int i = 0;
 	int buff_index = buffer->buff_index;
 	char *dst = NULL;
 
-	if (buff_index < 0 || buff_index >= NUM_SEGS_PER_BUFFER) {
+	if (buff_index < 0 || buff_index >= NUM_SEGS_PER_BUFFER)
 		goto prod_seg_done;
-	}
+
 	for_each_segment(i) {
-		sw_data_buffer_t *seg = &buffer->buffers[buff_index];
+		struct sw_data_buffer *seg = &buffer->buffers[buff_index];
 
 		if (SEG_IS_FULL(seg) == false) {
 			if (SPACE_AVAIL(seg) >= size) {
 				*reservation_tsc = sw_timestamp();
 				dst = &seg->buffer[seg->bytes_written];
 				seg->bytes_written += size;
-				smp_mb();
+				smp_mb(); /* memory access ordering */
 				buffer->buff_index = buff_index;
 				buffer->produced_samples++;
 				goto prod_seg_done;
@@ -213,36 +451,38 @@ static char *reserve_seg_space_i(size_t size, int cpu, bool *should_wakeup,
 		*should_wakeup = true;
 	}
 prod_seg_done:
-	if (!dst) {
+	if (!dst)
 		buffer->dropped_samples++;
-	}
+
 	return dst;
 };
 
-static int sw_produce_polled_msg_i(struct sw_driver_msg *msg,
-				enum sw_wakeup_action action)
+#ifdef CONFIG_PREEMPT_COUNT
+static int produce_polled_msg(struct sw_driver_msg *msg,
+	enum sw_wakeup_action action)
 {
 	int cpu = GET_POLLED_CPU();
 	bool should_wakeup = false;
 	int retVal = PW_SUCCESS;
 
-	if (!msg) {
+	if (!msg)
 		return -PW_ERROR;
-	}
+
 	pw_pr_debug("POLLED! cpu = %d\n", cpu);
 	LOCK(sw_polled_lock);
 	{
 		size_t size = SW_DRIVER_MSG_HEADER_SIZE() + msg->payload_len;
-		char *dst = reserve_seg_space_i(size, cpu, &should_wakeup,
-						&msg->tsc);
+		char *dst = reserve_seg_space_i(size, cpu,
+						&should_wakeup, &msg->tsc);
+
 		if (dst) {
 			/*
 			 * Assign a special CPU number to this CPU.
 			 * This is OK, because messages enqueued in this buffer
 			 * are always CPU agnostic (otherwise they would
 			 * be invoked from within a preempt_disable()d context
-			 * in 'sw_handle_collector_node_i()', which ensures they
-			 * will be enqueued within the
+			 * in 'sw_handle_collector_node_i()', which ensures
+			 * they will be enqueued within the
 			 * 'sw_produce_generic_msg_on_cpu()' function).
 			 */
 			msg->cpuidx = cpu;
@@ -255,14 +495,15 @@ static int sw_produce_polled_msg_i(struct sw_driver_msg *msg,
 		}
 	}
 	UNLOCK(sw_polled_lock);
-	if (unlikely(should_wakeup)) {
+	if (unlikely(should_wakeup))
 		sw_wakeup_reader(action);
-	}
+
 	return retVal;
 };
+#endif /* CONFIG_PREEMPT_COUNT */
 
 static int sw_produce_generic_msg_i(struct sw_driver_msg *msg,
-				    enum sw_wakeup_action action)
+	enum sw_wakeup_action action)
 {
 	int retval = PW_SUCCESS;
 	bool should_wakeup = false;
@@ -274,55 +515,51 @@ static int sw_produce_generic_msg_i(struct sw_driver_msg *msg,
 		return -PW_ERROR;
 	}
 
+	/* Check if we need to use circular buffer */
+	if (output_buffer)
+		return enqueue_data(msg, action);
+
 #ifdef CONFIG_PREEMPT_COUNT
-	if (!in_atomic()) {
-		return sw_produce_polled_msg(msg, action);
-	}
+	if (!in_atomic())
+		return produce_polled_msg(msg, action);
 #endif
 
 	cpu = sw_get_cpu(&flags);
 	{
-		size_t size = msg->payload_len + SW_DRIVER_MSG_HEADER_SIZE();
+		size_t size = msg->payload_len +
+				SW_DRIVER_MSG_HEADER_SIZE();
 		char *dst = reserve_seg_space_i(size, cpu, &should_wakeup,
 						&msg->tsc);
+
 		if (likely(dst)) {
 			memcpy(dst, msg, SW_DRIVER_MSG_HEADER_SIZE());
 			dst += SW_DRIVER_MSG_HEADER_SIZE();
 			memcpy(dst, msg->p_payload, msg->payload_len);
-		} else {
+		} else
 			retval = -PW_ERROR;
-		}
 	}
 	sw_put_cpu(flags);
 
-	if (unlikely(should_wakeup)) {
+	if (unlikely(should_wakeup))
 		sw_wakeup_reader(action);
-	}
 
 	return retval;
 };
 
-int sw_produce_polled_msg(struct sw_driver_msg *msg,
-			   enum sw_wakeup_action action)
-{
-	return DO_PER_CPU_OVERHEAD_FUNC_RET(int, sw_produce_polled_msg_i, msg,
-					    action);
-};
-
 int sw_produce_generic_msg(struct sw_driver_msg *msg,
-			   enum sw_wakeup_action action)
+	enum sw_wakeup_action action)
 {
-	return DO_PER_CPU_OVERHEAD_FUNC_RET(int, sw_produce_generic_msg_i, msg,
-					    action);
+	return DO_PER_CPU_OVERHEAD_FUNC_RET(int, sw_produce_generic_msg_i,
+		msg, action);
 };
 
 static int sw_init_per_cpu_buffers_i(unsigned long per_cpu_mem_size)
 {
 	int cpu = -1;
 
-	per_cpu_output_buffers = (sw_output_buffer_t *)sw_kmalloc(
-		sizeof(sw_output_buffer_t) * GET_NUM_OUTPUT_BUFFERS(),
-		GFP_KERNEL | __GFP_ZERO);
+	per_cpu_output_buffers =
+	(struct sw_output_buffer *)sw_kmalloc(sizeof(struct sw_output_buffer) *
+	GET_NUM_OUTPUT_BUFFERS(), GFP_KERNEL | __GFP_ZERO);
 	if (per_cpu_output_buffers == NULL) {
 		pw_pr_error(
 			"ERROR allocating space for per-cpu output buffers!\n");
@@ -330,17 +567,16 @@ static int sw_init_per_cpu_buffers_i(unsigned long per_cpu_mem_size)
 		return -PW_ERROR;
 	}
 	for_each_output_buffer(cpu) {
-		sw_output_buffer_t *buffer = &per_cpu_output_buffers[cpu];
+		struct sw_output_buffer *buffer = &per_cpu_output_buffers[cpu];
 		char *buff = NULL;
 		int i = 0;
 
 		buffer->mem_alloc_size = per_cpu_mem_size;
-		buffer->free_pages =
-			sw_allocate_pages(GFP_KERNEL | __GFP_ZERO,
-					  (unsigned int)per_cpu_mem_size);
+		buffer->free_pages = sw_allocate_pages(GFP_KERNEL | __GFP_ZERO,
+			(unsigned int)per_cpu_mem_size);
 		if (buffer->free_pages == 0) {
 			pw_pr_error("ERROR allocating pages for buffer [%d]!\n",
-				    cpu);
+				cpu);
 			sw_destroy_per_cpu_buffers();
 			return -PW_ERROR;
 		}
@@ -351,8 +587,7 @@ static int sw_init_per_cpu_buffers_i(unsigned long per_cpu_mem_size)
 		}
 	}
 	pw_pr_debug("PER_CPU_MEM_SIZE = %lu, order = %u\n",
-		    (unsigned long)per_cpu_mem_size,
-		    get_order(per_cpu_mem_size));
+	(unsigned long)per_cpu_mem_size, get_order(per_cpu_mem_size));
 	return PW_SUCCESS;
 };
 
@@ -364,30 +599,28 @@ int sw_init_per_cpu_buffers(void)
 
 	if (GET_NUM_OUTPUT_BUFFERS() <= 0) {
 		pw_pr_error("ERROR: max # output buffers= %d\n",
-			    GET_NUM_OUTPUT_BUFFERS());
+			GET_NUM_OUTPUT_BUFFERS());
 		return -PW_ERROR;
 	}
 
 	pw_pr_debug("DEBUG: sw_max_num_cpus = %d, num output buffers = %d\n",
-		    sw_max_num_cpus, GET_NUM_OUTPUT_BUFFERS());
+	sw_max_num_cpus, GET_NUM_OUTPUT_BUFFERS());
 
 	/*
-	 * Try to allocate per-cpu buffers. If allocation fails,
-	 * decrease buffer size and retry. Stop trying if size
-	 * drops below 2KB (which means 1KB for each buffer).
+	 * Try to allocate per-cpu buffers. If allocation fails, decrease
+	 * buffer size and retry. Stop trying if size drops below 2KB
+	 * (which means 1KB for each buffer).
 	 */
 	while (per_cpu_mem_size >= SW_MIN_OUTPUT_BUFFER_SIZE &&
-	       sw_init_per_cpu_buffers_i(per_cpu_mem_size)) {
-		pw_pr_debug(
-			"WARNING: couldn't allocate per-cpu buffers with size %u -- trying smaller size!\n",
+		sw_init_per_cpu_buffers_i(per_cpu_mem_size)) {
+		pw_pr_debug("WARNING: couldn't allocate per-cpu buffers with size %u -- trying smaller size!\n",
 			per_cpu_mem_size);
 		sw_buffer_alloc_size >>= 1;
 		per_cpu_mem_size = sw_get_output_buffer_size();
 	}
 
 	if (unlikely(per_cpu_output_buffers == NULL)) {
-		pw_pr_error(
-			"ERROR: couldn't allocate space for per-cpu output buffers!\n");
+		pw_pr_error("ERROR: couldn't allocate space for per-cpu output buffers!\n");
 		return -PW_ERROR;
 	}
 	/*
@@ -396,7 +629,7 @@ int sw_init_per_cpu_buffers(void)
 	SW_INIT_SPINLOCK(sw_polled_lock);
 
 	pw_pr_debug("OK, allocated per-cpu buffers with size = %lu\n",
-		    (unsigned long)per_cpu_mem_size);
+		(unsigned long)per_cpu_mem_size);
 
 	if (sw_init_reader_queue()) {
 		pw_pr_error("ERROR initializing reader subsys\n");
@@ -417,11 +650,12 @@ void sw_destroy_per_cpu_buffers(void)
 
 	if (per_cpu_output_buffers != NULL) {
 		for_each_output_buffer(cpu) {
-			sw_output_buffer_t *buffer =
-				&per_cpu_output_buffers[cpu];
+			struct sw_output_buffer *buffer =
+					&per_cpu_output_buffers[cpu];
+
 			if (buffer->free_pages != 0) {
 				sw_release_pages(buffer->free_pages,
-						 buffer->mem_alloc_size);
+					buffer->mem_alloc_size);
 				buffer->free_pages = 0;
 			}
 		}
@@ -435,14 +669,14 @@ void sw_reset_per_cpu_buffers(void)
 	int cpu = 0, i = 0;
 
 	for_each_output_buffer(cpu) {
-		sw_output_buffer_t *buffer = GET_OUTPUT_BUFFER(cpu);
+		struct sw_output_buffer *buffer = GET_OUTPUT_BUFFER(cpu);
 
 		buffer->buff_index = buffer->dropped_samples =
 			buffer->produced_samples = 0;
 		buffer->last_seg_read = -1;
 
 		for_each_segment(i) {
-			sw_data_buffer_t *seg = &buffer->buffers[i];
+			struct sw_data_buffer *seg = &buffer->buffers[i];
 
 			memset(seg->buffer, 0, SW_SEG_DATA_SIZE);
 			SEG_SET_EMPTY(seg);
@@ -451,6 +685,12 @@ void sw_reset_per_cpu_buffers(void)
 	sw_last_cpu_read = -1;
 	sw_last_mask = -1;
 	pw_pr_debug("OK, reset per-cpu output buffers!\n");
+	/*
+	 * Reset circular buffer if it has been allocated
+	 */
+	if (output_buffer)
+		buffer.read_index = buffer.write_index = 0;
+
 };
 
 bool sw_any_seg_full(u32 *val, bool is_flush_mode)
@@ -458,34 +698,34 @@ bool sw_any_seg_full(u32 *val, bool is_flush_mode)
 	int num_visited = 0, i = 0;
 
 	if (!val) {
-		pw_pr_error("ERROR: NULL ptrs in sw_any_seg_full!\n");
+		pw_pr_error("ERROR: NULL ptrs in %s!\n", __func__);
 		return false;
 	}
 
 	*val = SW_NO_DATA_AVAIL_MASK;
-	pw_pr_debug("Checking for full seg: val = %u, flush = %s\n", *val,
-		    GET_BOOL_STRING(is_flush_mode));
+	pw_pr_debug("Checking for full seg: val = %u, flush = %s\n",
+		 *val, GET_BOOL_STRING(is_flush_mode));
 	for_each_output_buffer(num_visited) {
 		int min_seg = EMPTY_SEG, non_empty_seg = EMPTY_SEG;
 		u64 min_tsc = EMPTY_TSC;
-		sw_output_buffer_t *buffer = NULL;
+		struct sw_output_buffer *buffer = NULL;
 
-		if (++sw_last_cpu_read >= GET_NUM_OUTPUT_BUFFERS()) {
+		if (++sw_last_cpu_read >= GET_NUM_OUTPUT_BUFFERS())
 			sw_last_cpu_read = 0;
-		}
+
 		buffer = GET_OUTPUT_BUFFER(sw_last_cpu_read);
 		for_each_segment(i) {
-			sw_data_buffer_t *seg = &buffer->buffers[i];
+			struct sw_data_buffer *seg = &buffer->buffers[i];
 			u64 seg_tsc = seg->is_full;
 
-			if (SEG_IS_EMPTY(seg)) {
+			if (SEG_IS_EMPTY(seg))
 				continue;
-			}
+
 			non_empty_seg = i;
 			if (seg_tsc < min_tsc) {
 				/*
-				 * Can only happen if seg was full,
-				 * provided 'EMPTY_TSC' is set to "(u64)-1"
+				 * Can only happen if seg was full, provided
+				 * 'EMPTY_TSC' is set to "(u64)-1"
 				 */
 				min_tsc = seg_tsc;
 				min_seg = i;
@@ -493,11 +733,11 @@ bool sw_any_seg_full(u32 *val, bool is_flush_mode)
 		}
 		if (min_seg != EMPTY_SEG) {
 			*val = (sw_last_cpu_read & 0xffff) << 16 |
-			       (min_seg & 0xffff);
+				(min_seg & 0xffff);
 			return true;
 		} else if (is_flush_mode && non_empty_seg != EMPTY_SEG) {
 			*val = (sw_last_cpu_read & 0xffff) << 16 |
-			       (non_empty_seg & 0xffff);
+				(non_empty_seg & 0xffff);
 			return true;
 		}
 	}
@@ -518,31 +758,34 @@ bool sw_any_seg_full(u32 *val, bool is_flush_mode)
 };
 
 /*
- * Has semantics of 'copy_to_user()' -- returns # of bytes that could
- * NOT be copied (On success ==> returns 0).
+ * Returns: number of bytes consumed on SUCCESS, 0 on EOF, negative
+ * error code on FAILURE
  */
-size_t sw_consume_data(u32 mask, void __user *buffer, size_t bytes_to_read)
+ssize_t sw_consume_data(u32 mask, void __user *buffer, size_t bytes_to_read)
 {
 	int which_cpu = -1, which_seg = -1;
 	unsigned long bytes_not_copied = 0;
-	sw_output_buffer_t *buff = NULL;
-	sw_data_buffer_t *seg = NULL;
+	struct sw_output_buffer *buff = NULL;
+	struct sw_data_buffer *seg = NULL;
 	size_t bytes_read = 0;
 
+	/* Check if we need to use circular buffer */
+	if (output_buffer)
+		return (ssize_t)consume_buffer(buffer, bytes_to_read);
+
 	if (!sw_check_output_buffer_params(buffer, bytes_to_read,
-					   SW_SEG_DATA_SIZE)) {
-		pw_pr_error("ERROR: invalid params to \"sw_consume_data\"!\n");
-		return -PW_ERROR;
+			SW_SEG_DATA_SIZE)) {
+		pw_pr_error("ERROR: invalid params to \"%s\"!\n", __func__);
+		return -EIO;
 	}
 
-	which_cpu = mask >> 16;
-	which_seg = mask & 0xffff;
+	which_cpu = mask >> 16; which_seg = mask & 0xffff;
 	pw_pr_debug("CONSUME: cpu = %d, seg = %d\n", which_cpu, which_seg);
 	if (which_seg >= NUM_SEGS_PER_BUFFER) {
 		pw_pr_error(
 			"Error: which_seg (%d) >= NUM_SEGS_PER_BUFFER (%d)\n",
 			which_seg, NUM_SEGS_PER_BUFFER);
-		return bytes_to_read;
+		return -EIO;
 	}
 	/*
 	 * OK to access unlocked; either the segment is FULL, or no collection
@@ -552,16 +795,14 @@ size_t sw_consume_data(u32 mask, void __user *buffer, size_t bytes_to_read)
 	buff = GET_OUTPUT_BUFFER(which_cpu);
 	seg = &buff->buffers[which_seg];
 
-	bytes_not_copied = sw_copy_to_user(buffer, seg->buffer,
-					   seg->bytes_written); /* dst, src */
+	bytes_not_copied = sw_copy_to_user(buffer,
+		seg->buffer, seg->bytes_written); /* dst, src */
 
-	/* bytes_not_copied = */
-	/* copy_to_user(buffer, seg->buffer, seg->bytes_written);  dst,src */
-	if (likely(bytes_not_copied == 0)) {
+	if (likely(bytes_not_copied == 0))
 		bytes_read = seg->bytes_written;
-	} else {
+	else {
 		pw_pr_error("Warning: couldn't copy %lu bytes\n",
-			    bytes_not_copied);
+			bytes_not_copied);
 		bytes_read = 0;
 	}
 	SEG_SET_EMPTY(seg);
@@ -578,12 +819,11 @@ void sw_count_samples_produced_dropped(void)
 	int cpu = 0;
 
 	sw_num_samples_produced = sw_num_samples_dropped = 0;
-
-	if (per_cpu_output_buffers == NULL) {
+	if (per_cpu_output_buffers == NULL)
 		return;
-	}
+
 	for_each_output_buffer(cpu) {
-		sw_output_buffer_t *buff = GET_OUTPUT_BUFFER(cpu);
+		struct sw_output_buffer *buff = GET_OUTPUT_BUFFER(cpu);
 
 		sw_num_samples_dropped += buff->dropped_samples;
 		sw_num_samples_produced += buff->produced_samples;
@@ -593,6 +833,6 @@ void sw_count_samples_produced_dropped(void)
 void sw_print_output_buffer_overheads(void)
 {
 	PRINT_CUMULATIVE_OVERHEAD_PARAMS(sw_produce_generic_msg_i,
-					 "PRODUCE_GENERIC_MSG");
+		"PRODUCE_GENERIC_MSG");
 	sw_print_reader_stats();
 };
diff --git a/drivers/platform/x86/socwatch/sw_reader.c b/drivers/platform/x86/socwatch/sw_reader.c
index 2e55ae1a54cc..ea039c6fe72a 100644
--- a/drivers/platform/x86/socwatch/sw_reader.c
+++ b/drivers/platform/x86/socwatch/sw_reader.c
@@ -1,64 +1,63 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 #include "sw_internal.h"
 #include "sw_output_buffer.h"
 #include "sw_kernel_defines.h"
 
-#define SW_BUFFER_CLEANUP_TIMER_DELAY_NSEC                                     \
-	1000000 /* delay buffer cleanup by 10^6 nsec i.e. 1 msec */
+/* delay buffer cleanup by 10^6 nsec i.e. 1 msec */
+#define SW_BUFFER_CLEANUP_TIMER_DELAY_NSEC 1000000
 
 /*
  * The alarm queue.
@@ -92,7 +91,8 @@ int sw_init_reader_queue(void)
 	/*
 	 * Also init wakeup timer (used in low-overhead mode).
 	 */
-	hrtimer_init(&s_reader_wakeup_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	hrtimer_init(&s_reader_wakeup_timer,
+		CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 	s_reader_wakeup_timer.function = &sw_wakeup_callback_i;
 
 	return PW_SUCCESS;
@@ -109,29 +109,26 @@ void sw_destroy_reader_queue(void)
  */
 void sw_wakeup_reader(enum sw_wakeup_action action)
 {
-	if (!waitqueue_active(&sw_reader_queue)) {
-		return;
-	}
-	/*
-	 * Direct mode?
-	 */
-	switch (action) {
-	case SW_WAKEUP_ACTION_DIRECT:
-		wake_up_interruptible(&sw_reader_queue);
-		break;
-	case SW_WAKEUP_ACTION_TIMER:
-		if (!hrtimer_active(&s_reader_wakeup_timer)) {
-			ktime_t ktime =
-				ns_to_ktime(SW_BUFFER_CLEANUP_TIMER_DELAY_NSEC);
-			/* TODO: possible race here -- introduce locks? */
-			hrtimer_start(&s_reader_wakeup_timer, ktime,
-				      HRTIMER_MODE_REL);
+	if (waitqueue_active(&sw_reader_queue)) { /* direct mode */
+		switch (action) {
+		case SW_WAKEUP_ACTION_DIRECT:
+			wake_up_interruptible(&sw_reader_queue);
+			break;
+		case SW_WAKEUP_ACTION_TIMER:
+			if (!hrtimer_active(&s_reader_wakeup_timer)) {
+				ktime_t ktime = ns_to_ktime(
+					SW_BUFFER_CLEANUP_TIMER_DELAY_NSEC);
+				/* TODO: possible race here --
+				 * introduce locks?
+				 */
+				hrtimer_start(&s_reader_wakeup_timer,
+					ktime, HRTIMER_MODE_REL);
+			}
+			break;
+		default:
+			break;
 		}
-		break;
-	default:
-		break;
 	}
-	return;
 }
 /*
  * Wakeup client waiting for a full buffer, and
@@ -143,9 +140,9 @@ void sw_cancel_reader(void)
 	/*
 	 * Cancel pending wakeup timer (used in low-overhead mode).
 	 */
-	if (hrtimer_active(&s_reader_wakeup_timer)) {
+	if (hrtimer_active(&s_reader_wakeup_timer))
 		hrtimer_cancel(&s_reader_wakeup_timer);
-	}
+
 	/*
 	 * There might be a reader thread blocked on a read: wake
 	 * it up to give it a chance to respond to changed
@@ -157,7 +154,6 @@ void sw_cancel_reader(void)
 void sw_print_reader_stats(void)
 {
 #if DO_OVERHEAD_MEASUREMENTS
-	printk(KERN_INFO "# reader queue timer fires = %d\n",
-	       s_num_timer_fires);
+	pw_pr_debug("# reader queue timer fires = %d\n", s_num_timer_fires);
 #endif /* OVERHEAD */
 }
diff --git a/drivers/platform/x86/socwatch/sw_telem.c b/drivers/platform/x86/socwatch/sw_telem.c
index eccb37df44d5..38bfd89d7a2b 100644
--- a/drivers/platform/x86/socwatch/sw_telem.c
+++ b/drivers/platform/x86/socwatch/sw_telem.c
@@ -1,67 +1,67 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #include <linux/module.h>
 #include <linux/init.h>
-#include <linux/compiler.h> /* Definition of __weak */
-#include <linux/version.h> /* LINUX_VERSION_CODE */
-#include "sw_kernel_defines.h" /* pw_pr_debug */
-#include "sw_mem.h" /* sw_kmalloc/free */
-#include "sw_lock_defs.h" /* Various lock-related definitions */
-#include "sw_telem.h" /* Signatures of fn's exported from here. */
+#include <linux/compiler.h>     /* Definition of __weak */
+#include <linux/version.h>      /* LINUX_VERSION_CODE */
+#include <linux/delay.h>       /* 'udelay' */
+#include "sw_kernel_defines.h"  /* pw_pr_debug */
+#include "sw_mem.h"             /* sw_kmalloc/free */
+#include "sw_lock_defs.h"       /* Various lock-related definitions */
+#include "sw_telem.h"           /* Signatures of fn's exported from here. */
 
 /*
  * These functions and data structures are exported by the Telemetry
@@ -76,17 +76,17 @@
  * @telem_evtlog:  The actual telemetry data.
  */
 struct telemetry_evtlog {
-	u32 telem_evtid; /* Event ID of a data item. */
-	u64 telem_evtlog; /* Counter data */
+	u32 telem_evtid;	/* Event ID of a data item. */
+	u64 telem_evtlog;   /* Counter data */
 };
 
 struct telemetry_evtconfig {
-	u32 *evtmap; /* Array of Event-IDs to Enable */
-	u8 num_evts; /* Number of Events (<29) in evtmap */
-	u8 period; /* Sampling period */
+	u32 *evtmap;	/* Array of Event-IDs to Enable */
+	u8 num_evts;	/* Number of Events (<29) in evtmap */
+	u8 period;	  /* Sampling period */
 };
 
-#define MAX_TELEM_EVENTS 28 /* Max telem events per unit */
+#define MAX_TELEM_EVENTS 28  /* Max telem events per unit */
 
 /* The enable bit is set when programming events, but is returned
  * cleared for queried events requests.
@@ -96,113 +96,599 @@ struct telemetry_evtconfig {
 /*
  * Sampling Period values.
  * The sampling period is encoded in an 7-bit value, where
- *    Period = (Value * 16^Exponent) usec where:
- *        bits[6:3] -> Value;
- *        bits [0:2]-> Exponent;
+ *	Period = (Value * 16^Exponent) usec where:
+ *		bits[6:3] -> Value;
+ *		bits [0:2]-> Exponent;
  * Here are some of the calculated possible values:
  * | Value  Val+Exp  | Value | Exponent | Period (usec) | Period (msec) |
  * |-----------------+-------+----------+---------------+---------------|
- * | 0xA = 000 1+010 |     1 |        2 |           256 |         0.256 |
- * | 0x12= 001 0+010 |     2 |        2 |           512 |         0.512 |
- * | 0x22= 010 0+010 |     4 |        2 |          1024 |         1.024 |
- * | 0xB = 000 1+011 |     1 |        3 |          4096 |         4.096 |
- * | 0x13= 001 0+011 |     2 |        3 |          8192 |         8.192 |
- * | 0x1B= 001 1+011 |     3 |        3 |         12288 |        12.288 |
- * | 0x0C= 000 1+100 |     1 |        4 |         65536 |        65.536 |
- * | 0x0D= 000 1+101 |     1 |        5 |       1048576 |      1048.576 |
+ * | 0xA = 000 1+010 |   1   |     2    |           256 |         0.256 |
+ * | 0x12= 001 0+010 |   2   |     2    |           512 |         0.512 |
+ * | 0x22= 010 0+010 |   4   |     2    |          1024 |         1.024 |
+ * | 0xB = 000 1+011 |   1   |     3    |          4096 |         4.096 |
+ * | 0x13= 001 0+011 |   2   |     3    |          8192 |         8.192 |
+ * | 0x1B= 001 1+011 |   3   |     3    |         12288 |        12.288 |
+ * | 0x0C= 000 1+100 |   1   |     4    |         65536 |        65.536 |
+ * | 0x0D= 000 1+101 |   1   |     5    |       1048576 |      1048.576 |
  */
-#define TELEM_SAMPLING_1MS 0x22 /* Approximately 1 ms */
-#define TELEM_SAMPLING_1S 0x0D /* Approximately 1 s */
+#define TELEM_SAMPLING_1MS 0x22  /* Approximately 1 ms */
+#define TELEM_SAMPLING_1S  0x0D  /* Approximately 1 s */
 
 /* These functions make up the main APIs of the telemetry driver.  We
  * define all of them with weak linkage so that we can still compile
  * and load into kernels which don't have a telemetry driver.
  */
-extern int __weak telemetry_raw_read_eventlog(enum telemetry_unit telem_unit,
-					      struct telemetry_evtlog *evtlog,
-					      int evcount);
-extern int __weak telemetry_reset(void);
-extern int __weak telemetry_reset_events(void);
-extern int __weak telemetry_get_sampling_period(u8 *punit_min, u8 *punit_max,
-						u8 *pmc_min, u8 *pmc_max);
-extern int __weak telemetry_set_sampling_period(u8 punit_period, u8 pmc_period);
 extern int __weak telemetry_get_eventconfig(
 	struct telemetry_evtconfig *punit_config,
-	struct telemetry_evtconfig *pmc_config, int punit_len, int pmc_len);
-extern int __weak telemetry_add_events(u8 num_punit_evts, u8 num_pmc_evts,
-				       u32 *punit_evtmap, u32 *pmc_evtmap);
+	struct telemetry_evtconfig *pmc_config,
+	int  punit_len,
+	int  pmc_len);
 
-extern int __weak
-telemetry_update_events(struct telemetry_evtconfig punit_config,
-			struct telemetry_evtconfig pmc_config);
+extern int __weak telemetry_reset_events(void);
 
+extern int __weak telemetry_set_sampling_period(
+	u8 punit_period,
+	u8 pmc_period);
 /*
- * Some telemetry IDs have multiple instances, indexed by cpu ID.  We
- * implement these by defining two types of IDs: 'regular' and 'scaled'.
- * For Telemetry IDs with a single instance (the majority of them), the
- * index into the system's telemetry table is stored in the
- * sw_driver_io_descriptor.idx.  At read time, the driver gets the telemetry
- * "slot" from sw_driver_io_descriptor.idx, and reads that data.  This case
- * is illustrated by telem_desc_A in the illustration below, where idx 2
- * indicates that telem_data[2] contains the telem data for this descriptor.
- *
- *   telem_desc_A                            telem_data
- *    scale_op: X                              |..|[0]
- *    idx     : 2 --------------------         |..|[1]
- *                                    \------->|..|[2]
- *                     Scaled_IDs              |..|[3]
- *   telem_desc_B     CPU#0 1 2 3       ------>|..|[4]
- *    scale_op: /     [0]|.|.|.|.|     /
- *    idx     : 1---->[1]|4|4|5|5|    /
- *                        +----------/
- *
- * Descriptors with scaled IDs contain a scale operation (scale_op) and
- * value.  They use a 'scaled_ids' table, which is indexed by descriptor
- * number and CPU id, and stores the telem_data index.  So in the
- * illustration above, CPU 0 reading from telem_desc_B would fetch row 1
- * (from telem_desc_B.idx == 1), and column [0] yielding element 4, so
- * that's the telemetry ID it looks up in the telemetry data.
- *
- * The scaled_ids table is populated at telemetry ID initialization time
+ * Older kernels didn't have the p-unit/pmc ipc command interface
+ */
+extern int __weak intel_punit_ipc_command(
+	u32 cmd, u32 para1, u32 para2, u32 *in, u32 *out);
+
+extern int __weak intel_pmc_ipc_command(
+	u32 cmd, u32 sub, u8 *in, u32 inlen, u32 *out, u32 outlen);
+/*
+ * Spinlock to guard updates to the 'iters' values.
+ */
+static SW_DEFINE_SPINLOCK(sw_telem_lock);
+
+
+/* ************************************************
+ * Constants for P-unit/PMC telemetry interface
+ *  ***********************************************
+ */
+
+#define PUNIT_MAILBOX_INTERFACE_OFFSET		0x7084
+#define PUNIT_MAILBOX_DATA_OFFSET		0x7080
+
+#define PSS_TELEM_SSRAM_OFFSET			0x1A00
+#define IOSS_TELEM_SSRAM_OFFSET			0x1B00
+#define TELEM_SSRAM_SIZE			240
+
+#define PMC_IPC_CMD				0x0
+
+#define PMC_IPC_STATUS				0x04
+
+#define PMC_IPC_WRITE_BUFFER			0x80
+#define PMC_IPC_READ_BUFFER			0x90
+
+#define PMC_IPC_PMC_TELEMETRY_COMMAND		0xEB
+
+
+#define TELEM_READ_TIMEOUT_TRIAL		10
+#define TELEM_MAILBOX_STATUS_TIMEOUT		1000
+
+#define IPC_BIOS_PUNIT_CMD_BASE			0x00
+
+#define IPC_BIOS_PUNIT_CMD_READ_TELE_INFO				\
+					(IPC_BIOS_PUNIT_CMD_BASE + 0x09)
+#define IPC_BIOS_PUNIT_CMD_READ_TELE_EVENT_CTRL				\
+					(IPC_BIOS_PUNIT_CMD_BASE + 0x0c)
+#define IPC_BIOS_PUNIT_CMD_WRITE_TELE_EVENT_CTRL			\
+					(IPC_BIOS_PUNIT_CMD_BASE + 0x0d)
+#define IPC_BIOS_PUNIT_CMD_WRITE_TELE_EVENT				\
+					(IPC_BIOS_PUNIT_CMD_BASE + 0x11)
+
+#define IOSS_TELEM_EVENT_WRITE			0x1
+#define IOSS_TELEM_INFO_READ			0x2
+#define IOSS_TELEM_EVENT_CTL_READ		0x7
+#define IOSS_TELEM_EVENT_CTL_WRITE		0x8
+
+#define IOSS_TELEM_EVT_CTRL_WRITE_SIZE		0x4
+#define IOSS_TELEM_READ_WORD			0x1
+#define IOSS_TELEM_EVT_WRITE_SIZE		0x3
+
+#ifndef BIT
+	#define BIT(x)				(1<<x)
+#endif /* BIT */
+
+#define TELEM_DISABLE(x)			((x) &= ~(BIT(31)))
+#define TELEM_ENABLE_SSRAM_EVT_TRACE(x)		((x) &= ~(BIT(30) | BIT(24)))
+#define TELEM_ENABLE_PERIODIC(x)	((x) |= (BIT(23) | BIT(31) | BIT(7)))
+#define TELEM_IOSS_EVTID_SHIFT			8
+
+#define TELEM_INFO_SSRAMEVTS_MASK		0xFF00
+#define TELEM_INFO_SSRAMEVTS_SHIFT		0x8
+
+#define TELEM_MIN_PERIOD(x)			((x) & 0x7F0000)
+#define TELEM_MAX_PERIOD(x)			((x) & 0x7F000000)
+#define TELEM_CLEAR_SAMPLE_PERIOD(x)		((x) &= ~0x7F)
+#define TELEM_DEFAULT_SAMPLING_PERIOD		TELEM_SAMPLING_1MS
+
+#define IS_TELEM_CONFIGURED()			\
+	(s_telemEventInfo[TELEM_PUNIT].idx > 0	\
+	|| s_telemEventInfo[TELEM_PMC].idx > 0)
+
+static u64 s_mchBarAddrs[3] = {0, 0, 0};
+
+static struct {
+	volatile u64 *ssram_virt_addr;
+	int idx, iters;
+	u32 events[MAX_TELEM_EVENTS];
+	u64 data_buffer[MAX_TELEM_EVENTS];
+} s_telemEventInfo[TELEM_UNIT_NONE] = {
+	[TELEM_PUNIT] = {NULL, 0, 0},
+	[TELEM_PMC] = {NULL, 0, 0},
+};
+
+static volatile u64 *s_punitInterfaceAddr;
+static volatile u64 *s_punitDataAddr;
+static volatile u64 *s_pmcIPCCmdAddr;
+static volatile u64 *s_pmcIPCStsAddr;
+static volatile u64 *s_pmcIPCWBufAddr;
+static volatile u64 *s_pmcIPCRBufAddr;
+
+/**
+ * setup_punit_mbox -- Setup P-Unit virtual mappings
  *
+ * Returns: true if setup successfully
  */
-static unsigned char *sw_telem_scaled_ids; /* Allocate on demand */
-static unsigned int sw_telem_rows_alloced; /* Rows currently allocated */
-static unsigned int sw_telem_rows_avail; /* Available rows */
+static bool setup_punit_mbox(void)
+{
+	s_punitInterfaceAddr = ioremap_nocache(
+				(unsigned long)s_mchBarAddrs[TELEM_MCHBAR_CFG] +
+				PUNIT_MAILBOX_INTERFACE_OFFSET, 0x4);
+	s_punitDataAddr = ioremap_nocache(
+				(unsigned long)s_mchBarAddrs[TELEM_MCHBAR_CFG] +
+				PUNIT_MAILBOX_DATA_OFFSET, 0x4);
+	s_telemEventInfo[TELEM_PUNIT].ssram_virt_addr = ioremap_nocache(
+				(unsigned long)
+					s_mchBarAddrs[TELEM_SSRAMBAR_CFG] +
+				PSS_TELEM_SSRAM_OFFSET, TELEM_SSRAM_SIZE);
+
+	return (s_punitInterfaceAddr && s_punitDataAddr &&
+		s_telemEventInfo[TELEM_PUNIT].ssram_virt_addr);
+}
 
-extern int sw_max_num_cpus; /* SoC Watch's copy of cpu count. */
+/**
+ * destroy_punit_mbox -- Unmap p-unit virtual addresses
+ */
+static void destroy_punit_mbox(void)
+{
+	if (s_punitInterfaceAddr) {
+		iounmap(s_punitInterfaceAddr);
+		s_punitInterfaceAddr = NULL;
+	}
+	if (s_punitDataAddr) {
+		iounmap(s_punitDataAddr);
+		s_punitDataAddr = NULL;
+	}
+	if (s_telemEventInfo[TELEM_PUNIT].ssram_virt_addr) {
+		iounmap(s_telemEventInfo[TELEM_PUNIT].ssram_virt_addr);
+		s_telemEventInfo[TELEM_PUNIT].ssram_virt_addr = NULL;
+	}
+}
 
-/* Macro for identifying telemetry IDs with either per-cpu, or per-module
- * instances.  These IDs need to be 'scaled' as per scale_op and scale_val.
+/**
+ * setup_pmc_mbox -- Setup PMC virtual mappings
+ *
+ * Returns: true if setup successfully
  */
-#define IS_SCALED_ID(td) ((td)->scale_op != TELEM_OP_NONE)
-/*
- * Event map that is populated with user-supplied IDs
+static bool setup_pmc_mbox(void)
+{
+	s_pmcIPCCmdAddr = ioremap_nocache(
+			(unsigned long)s_mchBarAddrs[TELEM_IPC1BAR_CFG] +
+			PMC_IPC_CMD, 0x4);
+	s_pmcIPCStsAddr = ioremap_nocache(
+			(unsigned long)s_mchBarAddrs[TELEM_IPC1BAR_CFG] +
+			PMC_IPC_STATUS, 0x4);
+	s_pmcIPCWBufAddr = ioremap_nocache(
+			(unsigned long)s_mchBarAddrs[TELEM_IPC1BAR_CFG] +
+			PMC_IPC_WRITE_BUFFER, 0x4);
+	s_pmcIPCRBufAddr = ioremap_nocache(
+			(unsigned long)s_mchBarAddrs[TELEM_IPC1BAR_CFG] +
+			PMC_IPC_READ_BUFFER, 0x4);
+	s_telemEventInfo[TELEM_PMC].ssram_virt_addr  = ioremap_nocache(
+			(unsigned long)s_mchBarAddrs[TELEM_SSRAMBAR_CFG] +
+			IOSS_TELEM_SSRAM_OFFSET, TELEM_SSRAM_SIZE);
+
+	return (s_pmcIPCCmdAddr && s_pmcIPCStsAddr &&
+		s_pmcIPCWBufAddr && s_pmcIPCRBufAddr &&
+		s_telemEventInfo[TELEM_PMC].ssram_virt_addr);
+}
+
+/**
+ * destroy_pmc_mbox -- Unmap PMC virtual addresses
  */
-static u32 s_event_map[2][MAX_TELEM_EVENTS];
-/*
- * Index into event map(s)
+static void destroy_pmc_mbox(void)
+{
+	if (s_pmcIPCCmdAddr) {
+		iounmap(s_pmcIPCCmdAddr);
+		s_pmcIPCCmdAddr = NULL;
+	}
+	if (s_pmcIPCStsAddr) {
+		iounmap(s_pmcIPCStsAddr);
+		s_pmcIPCStsAddr = NULL;
+	}
+	if (s_pmcIPCWBufAddr) {
+		iounmap(s_pmcIPCWBufAddr);
+		s_pmcIPCWBufAddr = NULL;
+	}
+	if (s_pmcIPCRBufAddr) {
+		iounmap(s_pmcIPCRBufAddr);
+		s_pmcIPCRBufAddr = NULL;
+	}
+	if (s_telemEventInfo[TELEM_PMC].ssram_virt_addr) {
+		iounmap(s_telemEventInfo[TELEM_PMC].ssram_virt_addr);
+		s_telemEventInfo[TELEM_PMC].ssram_virt_addr = NULL;
+	}
+}
+
+/**
+ * setup_telem - Setup telemetry interface
+ *
+ * Returns: 0 if setup successfully, 1 otherwise
  */
-static size_t s_unit_idx[2] = { 0, 0 };
-/*
- * Used to decide if telemetry values need refreshing
+int setup_telem(u64 addrs[3])
+{
+	/*
+	 * Don't setup if already done so
+	 */
+	if (s_mchBarAddrs[TELEM_MCHBAR_CFG])
+		return 0;
+
+	memcpy(s_mchBarAddrs, addrs, sizeof(s_mchBarAddrs));
+	/*
+	 * Setup Punit
+	 */
+	if (!setup_punit_mbox()) {
+		pw_pr_error("Couldn't setup PUNIT mbox\n");
+		return -1;
+	}
+	/*
+	 * Setup PMC
+	 */
+	if (!setup_pmc_mbox()) {
+		pw_pr_error("Couldn't setup PMC mbox\n");
+		return -1;
+	}
+	return 0;
+}
+
+/**
+ * destroy_telem - Destroy telemetry interface
  */
-static size_t s_unit_iters[2] = { 0, 0 };
-/*
- * Spinlock to guard updates to the 'iters' values.
+void destroy_telem(void)
+{
+	destroy_punit_mbox();
+	destroy_pmc_mbox();
+
+	memset(s_mchBarAddrs, 0, sizeof(s_mchBarAddrs));
+}
+
+/**
+ * get_or_set_id - Add ID to list of events if not previously added
+ *
+ * Returns: 0 if setup successfully, 1 otherwise
  */
-static SW_DEFINE_SPINLOCK(sw_telem_lock);
-/*
- * Macro to determine if socwatch telemetry system has been configured
+static int get_or_set_id(u32 *events, u32 *unit_idx, u32 id)
+{
+	u32 i = 0;
+
+	if (*unit_idx >= MAX_TELEM_EVENTS)
+		return -1;
+
+	for (i = 0; i <  *unit_idx; ++i) {
+		if (events[i] == id)
+			return i;
+	}
+	events[*unit_idx] = id;
+	return (*unit_idx)++;
+}
+
+static int add_telem_id(enum telemetry_unit unit, u32 id)
+{
+	return get_or_set_id(
+		s_telemEventInfo[unit].events,
+		&s_telemEventInfo[unit].idx, id);
+}
+
+static void remove_telem_ids(void)
+{
+	memset(s_telemEventInfo, 0, sizeof(s_telemEventInfo));
+}
+
+
+static u64 read_telem_data(u64 *dst, volatile void *src, size_t num_events)
+{
+	u32 i, timeout = 0;
+	u64 prev_timestamp = 0, next_timestamp = 0, start_time = 0, event_data;
+
+	if (!dst)
+		return 0;
+
+	do {
+		u64 *_src = (u64 *)src;
+
+		prev_timestamp = *_src;
+		if (!prev_timestamp)
+			return 0;
+
+		start_time = *(_src + 1);
+
+		for (i = 0; i < num_events; ++i) {
+			event_data = *(_src + 2 + i);
+			dst[i] = event_data;
+		}
+		next_timestamp = *_src;
+
+		if (!next_timestamp)
+			return 0;
+
+		if (++timeout == TELEM_READ_TIMEOUT_TRIAL)
+			break;
+
+	} while (prev_timestamp != next_timestamp);
+	return prev_timestamp == next_timestamp ? start_time : 0;
+}
+
+/**
+ * @returns timestamp (1st entry of SSRAM)
+ */
+static u64 flush_telem_to_buffer(enum telemetry_unit unit)
+{
+	return read_telem_data(s_telemEventInfo[unit].data_buffer,
+			   s_telemEventInfo[unit].ssram_virt_addr,
+			   s_telemEventInfo[unit].idx);
+}
+
+static void read_telem_from_buffer(u64 *dst, enum telemetry_unit unit)
+{
+	memcpy(dst, s_telemEventInfo[unit].data_buffer,
+		s_telemEventInfo[unit].idx * sizeof(*dst));
+}
+
+static u64 read_event_from_buffer(enum telemetry_unit unit, int idx)
+{
+	if (idx < 0 || idx >= MAX_TELEM_EVENTS)
+		return SW_TELEM_READ_FAIL_VALUE;
+
+	return s_telemEventInfo[unit].data_buffer[idx];
+}
+
+static bool punit_start_telem(void)
+{
+	u32 telem_info = 0, telem_ctrl = 0, i;
+
+	/* Reset data buffer */
+	memset(s_telemEventInfo[TELEM_PUNIT].data_buffer, 0,
+		sizeof(s_telemEventInfo[TELEM_PUNIT].data_buffer));
+
+	/* Read basic config */
+	if (intel_punit_ipc_command(IPC_BIOS_PUNIT_CMD_READ_TELE_INFO, 0, 0,
+			NULL, &telem_info))
+		pw_pr_warn("Could not execute P-unit IPC command to read telem info\n");
+
+	/* Debug info */
+	pw_pr_debug("DEBUG: Read P-Unit telem_info = 0x%x\n", telem_info);
+	pw_pr_debug("## SOCWATCHDRV ## PUNIT Telemetry info has events = %u\n",
+		(telem_info & TELEM_INFO_SSRAMEVTS_MASK) >>
+			TELEM_INFO_SSRAMEVTS_SHIFT);
+	pw_pr_debug(
+		"## SOCWATCHDRV ## PUNIT Telemetry info has event_regs = %u\n",
+		telem_info & TELEM_INFO_SSRAMEVTS_MASK);
+	pw_pr_debug(
+		"## SOCWATCHDRV ## PUNIT Telemetry info has min_period = %u\n",
+		TELEM_MIN_PERIOD(telem_info));
+	pw_pr_debug(
+		"## SOCWATCHDRV ## PUNIT Telemetry info has max_period = %u\n",
+		TELEM_MAX_PERIOD(telem_info));
+
+	/*TODO: check if #events or #event_regs is less than 28; exit if so */
+
+	/* Read control structure */
+	if (intel_punit_ipc_command(IPC_BIOS_PUNIT_CMD_READ_TELE_EVENT_CTRL,
+			0, 0, NULL, &telem_ctrl))
+		pw_pr_warn("Could not execute P-unit IPC command to read telem ctrl structure\n");
+
+	/* Disable telem */
+	TELEM_DISABLE(telem_ctrl);
+	if (intel_punit_ipc_command(IPC_BIOS_PUNIT_CMD_WRITE_TELE_EVENT_CTRL,
+			0, 0, &telem_ctrl, NULL))
+		pw_pr_warn("Could not execute P-unit IPC command to write telem ctrl structure\n");
+
+	/* Each event added requires a separate command */
+	for (i = 0; i < s_telemEventInfo[TELEM_PUNIT].idx; ++i) {
+		u32 event = s_telemEventInfo[TELEM_PUNIT].events[i] |
+			TELEM_EVENT_ENABLE;
+
+		pw_pr_debug("DEBUG: enabling PUNIT event 0x%x\n",
+		s_telemEventInfo[TELEM_PUNIT].events[i]);
+		if (intel_punit_ipc_command(
+				IPC_BIOS_PUNIT_CMD_WRITE_TELE_EVENT, i, 0,
+				&event, NULL))
+			pw_pr_warn("Could not execute P-unit IPC command to write telem event\n");
+
+	}
+
+	TELEM_CLEAR_SAMPLE_PERIOD(telem_ctrl);
+	TELEM_ENABLE_SSRAM_EVT_TRACE(telem_ctrl);
+	TELEM_ENABLE_PERIODIC(telem_ctrl);
+	telem_ctrl |= TELEM_DEFAULT_SAMPLING_PERIOD;
+
+	/* Enable telemetry via control structure */
+	if (intel_punit_ipc_command(IPC_BIOS_PUNIT_CMD_WRITE_TELE_EVENT_CTRL,
+			0, 0, &telem_ctrl, NULL))
+		pw_pr_warn("Could not execute P-unit IPC command to write telem ctrl structure\n");
+
+	return true;
+}
+
+static void punit_stop_telem(void)
+{
+	u32 telem_ctrl = 0;
+
+	if (intel_punit_ipc_command(
+			IPC_BIOS_PUNIT_CMD_READ_TELE_EVENT_CTRL, 0, 0,
+			NULL, &telem_ctrl))
+		pw_pr_warn("Could not execute P-unit IPC command to read telem ctrl structure\n");
+
+	/* Disable telem */
+	TELEM_DISABLE(telem_ctrl);
+	if (intel_punit_ipc_command(
+			IPC_BIOS_PUNIT_CMD_WRITE_TELE_EVENT_CTRL, 0, 0,
+			&telem_ctrl, NULL))
+		pw_pr_warn("Could not execute P-unit IPC command to write telem ctrl structure\n");
+}
+
+static bool pmc_start_telem(void)
+{
+	u32 telem_info = 0, telem_ctrl = 0, i;
+
+	/* Reset data buffer */
+	memset(s_telemEventInfo[TELEM_PMC].data_buffer,
+		0, sizeof(s_telemEventInfo[TELEM_PMC].data_buffer));
+
+	/* Read basic config */
+	if (intel_pmc_ipc_command(PMC_IPC_PMC_TELEMETRY_COMMAND,
+			IOSS_TELEM_INFO_READ, NULL, 0, &telem_info,
+			IOSS_TELEM_READ_WORD))
+		pw_pr_warn("Could not execute PMC IPC command to read telemetry info\n");
+
+	pw_pr_debug("DEBUG: Read PMC telem_info = 0x%x\n", telem_info);
+	pw_pr_debug("## SOCWATCHDRV ## PMC Telemetry info has events = %u\n",
+		(telem_info & TELEM_INFO_SSRAMEVTS_MASK) >>
+			TELEM_INFO_SSRAMEVTS_SHIFT);
+	pw_pr_debug("## SOCWATCHDRV ## PMC Telemetry info has event_regs = %u\n",
+		telem_info & TELEM_INFO_SSRAMEVTS_MASK);
+	pw_pr_debug("## SOCWATCHDRV ## PMC Telemetry info has min_period = %u\n",
+		TELEM_MIN_PERIOD(telem_info));
+	pw_pr_debug("## SOCWATCHDRV ## PMC Telemetry info has max_period = %u\n",
+		TELEM_MAX_PERIOD(telem_info));
+
+	/*TODO: check if #events or #event_regs is less than 28; exit if so */
+
+	/* Read control structure */
+	if (intel_pmc_ipc_command(PMC_IPC_PMC_TELEMETRY_COMMAND,
+			IOSS_TELEM_EVENT_CTL_READ, NULL, 0, &telem_ctrl,
+			IOSS_TELEM_READ_WORD))
+		pw_pr_warn("Could not execute PMC IPC command to read telem control info\n");
+
+	/* Disable telemetry */
+	TELEM_DISABLE(telem_ctrl);
+	if (intel_pmc_ipc_command(PMC_IPC_PMC_TELEMETRY_COMMAND,
+			IOSS_TELEM_EVENT_CTL_WRITE, (u8 *)&telem_ctrl,
+			IOSS_TELEM_EVT_CTRL_WRITE_SIZE, NULL, 0))
+		pw_pr_warn("Could not execute PMC IPC command to read telem control info\n");
+
+
+	/* Each event added requires a separate command */
+	for (i = 0; i < s_telemEventInfo[TELEM_PMC].idx; ++i) {
+		u32 event =
+			s_telemEventInfo[TELEM_PMC].events[i] |
+			TELEM_EVENT_ENABLE;
+
+		event <<= TELEM_IOSS_EVTID_SHIFT;
+		event |= i; /* Set the index register */
+		pw_pr_debug("DEBUG: enabling PMC event 0x%x\n",
+			s_telemEventInfo[TELEM_PMC].events[i]);
+		if (intel_pmc_ipc_command(PMC_IPC_PMC_TELEMETRY_COMMAND,
+				IOSS_TELEM_EVENT_WRITE, (u8 *)&event,
+				IOSS_TELEM_EVT_WRITE_SIZE, NULL, 0))
+			pw_pr_warn("Could not execute PMC IPC command to read telem control info\n");
+	}
+
+	TELEM_CLEAR_SAMPLE_PERIOD(telem_ctrl);
+	TELEM_ENABLE_SSRAM_EVT_TRACE(telem_ctrl);
+	TELEM_ENABLE_PERIODIC(telem_ctrl);
+	telem_ctrl |= TELEM_DEFAULT_SAMPLING_PERIOD;
+
+	/* Enable telemetry via control structure */
+	if (intel_pmc_ipc_command(PMC_IPC_PMC_TELEMETRY_COMMAND,
+			IOSS_TELEM_EVENT_CTL_WRITE, (u8 *)&telem_ctrl,
+			IOSS_TELEM_EVT_CTRL_WRITE_SIZE, NULL, 0))
+		pw_pr_warn("Could not execute PMC IPC command to read telem control info\n");
+
+	return true;
+}
+
+static void pmc_stop_telem(void)
+{
+	u32 telem_ctrl = 0;
+
+	/* Read control structure */
+	if (intel_pmc_ipc_command(PMC_IPC_PMC_TELEMETRY_COMMAND,
+			IOSS_TELEM_EVENT_CTL_READ, NULL, 0, &telem_ctrl,
+			IOSS_TELEM_READ_WORD))
+		pw_pr_warn("Could not execute PMC IPC command to read telem control info\n");
+
+	/* Disable telemetry */
+	TELEM_DISABLE(telem_ctrl);
+	if (intel_pmc_ipc_command(PMC_IPC_PMC_TELEMETRY_COMMAND,
+			IOSS_TELEM_EVENT_CTL_WRITE, (u8 *)&telem_ctrl,
+			IOSS_TELEM_EVT_CTRL_WRITE_SIZE, NULL, 0))
+		pw_pr_warn("Could not execute PMC IPC command to read telem control info\n");
+}
+
+/**
+ * Configurs events + starts counters
+ * @returns  0 on success
  */
-#define SW_TELEM_CONFIGURED() (s_unit_idx[0] > 0 || s_unit_idx[1] > 0)
+static int start_telem(void)
+{
+	if (s_telemEventInfo[TELEM_PUNIT].idx) {
+		if (punit_start_telem() == false)
+			return -1;
+
+		/* Return value is don't care */
+		flush_telem_to_buffer(TELEM_PUNIT);
+	}
+
+	if (s_telemEventInfo[TELEM_PMC].idx) {
+		if (pmc_start_telem() == false)
+			return -1;
+
+		flush_telem_to_buffer(TELEM_PMC);
+	}
+	pw_pr_debug("OK, bypass telem started\n");
+	return 0;
+}
+
+static void stop_telem(void)
+{
+	if (s_telemEventInfo[TELEM_PUNIT].idx) {
+		punit_stop_telem();
+		s_telemEventInfo[TELEM_PUNIT].idx = 0;
+	}
+	if (s_telemEventInfo[TELEM_PMC].idx) {
+		pmc_stop_telem();
+		s_telemEventInfo[TELEM_PMC].idx = 0;
+	}
+	pw_pr_debug("OK, bypass telem stopped\n");
+}
+
+int read_telem(u64 *dst, enum telemetry_unit unit, bool should_retry)
+{
+	size_t num_iters = should_retry ? 10 : 0;
+	u64 timestamp = 0;
+
+	do {
+		timestamp = flush_telem_to_buffer(unit);
+	} while (!timestamp && should_retry && num_iters--);
+
+	if (timestamp) {
+		read_telem_from_buffer(dst, unit);
+		return 0;
+	}
+	return -1;
+}
 
 /**
- * telemetry_available - Determine if telemetry driver is present
+ * builtin_telemetry_available - Determine if telemetry driver is present
  *
  * Returns: 1 if telemetry driver is present, 0 if not.
  */
-static int telemetry_available(void)
+static int builtin_telemetry_available(void)
 {
 	int retval = 0;
 	struct telemetry_evtconfig punit_evtconfig;
@@ -210,14 +696,15 @@ static int telemetry_available(void)
 	u32 punit_event_map[MAX_TELEM_EVENTS];
 	u32 pmc_event_map[MAX_TELEM_EVENTS];
 
+
 	/* The symbol below is weak.  We return 1 if we have a definition
 	 * for this telemetry-driver-supplied symbol, or 0 if only the
 	 * weak definition exists. This test will suffice to detect if
 	 * the telemetry driver is loaded.
 	 */
-	if (telemetry_get_eventconfig == NULL) {
+	if (telemetry_get_eventconfig == 0)
 		return 0;
-	}
+
 	/* OK, the telemetry driver is loaded. But it's possible it
 	 * hasn't been configured properly. To check that, retrieve
 	 * the number of events currently configured. This should never
@@ -227,191 +714,114 @@ static int telemetry_available(void)
 	memset(&punit_evtconfig, 0, sizeof(punit_evtconfig));
 	memset(&pmc_evtconfig, 0, sizeof(pmc_evtconfig));
 
-	punit_evtconfig.evtmap = (u32 *)&punit_event_map;
-	pmc_evtconfig.evtmap = (u32 *)&pmc_event_map;
+	punit_evtconfig.evtmap = (u32 *) &punit_event_map;
+	pmc_evtconfig.evtmap = (u32 *) &pmc_event_map;
 
 	retval = telemetry_get_eventconfig(&punit_evtconfig, &pmc_evtconfig,
-					   MAX_TELEM_EVENTS, MAX_TELEM_EVENTS);
-	return retval == 0 && punit_evtconfig.num_evts > 0 &&
-	       pmc_evtconfig.num_evts > 0;
-}
-
-/**
- * sw_get_instance_row -- Get the address of a 'row' of instance IDs.
- * @rownum: The row number of the Instance ID table, whose address to return.
- * Returns: The address of the appropriate row, or NULL if rownum is bad.
- */
-static unsigned char *sw_get_instance_row_addr(unsigned int rownum)
-{
-	if (rownum >= (sw_telem_rows_alloced - sw_telem_rows_avail)) {
-		pw_pr_error("ERROR: Cannot retrieve row Instance ID row %d\n",
-			    rownum);
-		return NULL;
-	}
-	return &sw_telem_scaled_ids[rownum * sw_max_num_cpus];
+					MAX_TELEM_EVENTS, MAX_TELEM_EVENTS);
+	return (retval == 0 && punit_evtconfig.num_evts > 0 &&
+		pmc_evtconfig.num_evts > 0);
 }
 
 /**
- * sw_free_telem_scaled_id_table - Free the allocated slots.
- * Returns: Nothing
+ * was_telemetry_setup - Check if the P-unit and PMC addresses have been mapped
  *
- * Admittedly, a more symmetrical function name would be nice.
+ * Returns: true if successfully mapped
  */
-static void sw_telem_release_scaled_ids(void)
+static bool was_telemetry_setup(void)
 {
-	sw_telem_rows_alloced = 0;
-	sw_telem_rows_avail = 0;
-	if (sw_telem_scaled_ids) {
-		sw_kfree(sw_telem_scaled_ids);
-	}
-	sw_telem_scaled_ids = NULL;
+	return s_punitInterfaceAddr && s_punitDataAddr &&
+		s_telemEventInfo[TELEM_PUNIT].ssram_virt_addr /* P-unit */ &&
+		s_pmcIPCCmdAddr && s_pmcIPCStsAddr && s_pmcIPCWBufAddr &&
+		s_pmcIPCRBufAddr && s_telemEventInfo[TELEM_PMC].ssram_virt_addr;
 }
 
+
 /**
  * sw_telem_init_func - Set up the telemetry unit to retrieve a data item
- *                        (e.g. counter).
+ *						(e.g. counter).
  * @descriptor:  The IO descriptor containing the unit and ID
- *                        of the telemetry info to gather.
+ *						of the telemetry info to gather.
  *
  * Because we don't (currently) control all of the counters, we
  * economize by seeing if it's already being collected before allocate
  * a slot for it.
  *
  * Returns: PW_SUCCESS  if the telem collector can collect the requested data.
- *         -PW_ERROR   if the the addition of that item fails.
+ *		 -PW_ERROR   if the the addition of that item fails.
  */
 int sw_telem_init_func(struct sw_driver_io_descriptor *descriptor)
 {
 	struct sw_driver_telem_io_descriptor *td =
 		&(descriptor->telem_descriptor);
-	u8 unit = td->unit; /* Telemetry unit to use. */
+	u8  unit = td->unit;  /* Telemetry unit to use. */
 	u32 id; /* Event ID we want telemetry to track. */
-	size_t idx; /* Index into telemetry data array of event ID to gather. */
-	const char *unit_str = unit == TELEM_PUNIT ? "PUNIT" : "PMC";
-	size_t *unit_idx = &s_unit_idx[unit];
 
-	if (!telemetry_available()) {
+	if (!was_telemetry_setup())
 		return -ENXIO;
-	}
 
 	id = (u32)(td->id);
 
-	/* Check if we've already added this ID */
-	for (idx = 0; idx < *unit_idx && idx < MAX_TELEM_EVENTS; ++idx) {
-		if (s_event_map[unit][idx] == id) {
-			/* Invariant: idx contains the
-			 * index of the new data item.
-			 */
-			/* Save the index for later fast lookup. */
-			td->idx = (u16)idx;
-			return 0;
-		}
-	}
-
-	if (*unit_idx >= MAX_TELEM_EVENTS) {
-		pw_pr_error(
-			"Too many events %s units requested; max of %u available!\n",
-			unit_str, MAX_TELEM_EVENTS);
-		return -E2BIG;
+	td->idx = add_telem_id(unit, id);
+	if (td->idx < 0) {
+		pw_pr_error("ERROR adding id 0x%x to unit %d\n", id, unit);
+		return -1;
 	}
-	s_event_map[unit][(*unit_idx)++] = id;
-	/* Invariant: idx contains the index of the new data item. */
-	/* Save the index for later fast lookup. */
-	td->idx = (u16)idx;
-	pw_pr_debug(
-		"OK, added id = 0x%x to unit %s at entry %zu; retrieved = 0x%x\n",
-		id, unit_str, *unit_idx - 1, s_event_map[unit][*unit_idx - 1]);
+	pw_pr_debug("OK, added id 0x%x to unit %d at pos %d\n",
+			id, unit, td->idx);
 
 	return 0;
 }
 
+
 /**
  * sw_read_telem_info - Read a metric's data from the telemetry driver.
- * @dest:               Destination (storage for the read data)
- * @cpu:                Which CPU to read from (not used)
- * @descriptor:         The descriptor containing the data ID to read
+ * @dest:		Destination (storage for the read data)
+ * @cpu:		Which CPU to read from (not used)
+ * @descriptor:		The descriptor containing the data ID to read
  * @data_size_in_bytes: The # of bytes in the result (always 8)
  *
- * Returns: Nothing, but stores SW_TELEM_READ_FAIL_VALUE to dest
- * if the read fails.
+ * Returns: Nothing, but stores SW_TELEM_READ_FAIL_VALUE to dest if
+ * the read fails.
  */
 void sw_read_telem_info(char *dest, int cpu,
-			const sw_driver_io_descriptor_t *descriptor,
-			u16 data_size_in_bytes)
+			  const sw_driver_io_descriptor_t *descriptor,
+			  u16 data_size_in_bytes)
 {
-	int len;
 	u64 *data_dest = (u64 *)dest;
-	int retry_count;
 	const struct sw_driver_telem_io_descriptor *td =
 		&(descriptor->telem_descriptor);
-	unsigned int idx;
 	u8 unit = td->unit;
 	bool needs_refresh = false;
 
-#define TELEM_PKT_SIZE 16 /* sizeof(struct telemetry_evtlog) + padding */
-	static struct telemetry_evtlog events[MAX_TELEM_EVENTS];
-
-	/* Get the event index */
-	if (IS_SCALED_ID(td)) {
-		unsigned char *scaled_ids;
-
-		scaled_ids = sw_get_instance_row_addr(td->idx);
-		if (scaled_ids == NULL) {
-			pw_pr_error(
-				"Sw_read_telem_info_i: Illegal row index: *%p = %d",
-				&td->idx, td->idx);
-			*data_dest = SW_TELEM_READ_FAIL_VALUE;
-			return; /* Don't set the dest/data buffer. */
-		}
-		idx = scaled_ids[RAW_CPU()]; /* Get per-cpu entry */
-	} else {
-		idx = td->idx;
-	}
-
 	/*
 	 * Check if we need to refresh the list of values
 	 */
 	LOCK(sw_telem_lock);
 	{
-		if (s_unit_iters[unit] == 0) {
+		if (s_telemEventInfo[unit].iters == 0)
 			needs_refresh = true;
-		}
-		if (++s_unit_iters[unit] == s_unit_idx[unit]) {
-			s_unit_iters[unit] = 0;
-		}
+
+		if (++s_telemEventInfo[unit].iters ==
+				s_telemEventInfo[unit].idx)
+			s_telemEventInfo[unit].iters = 0;
 	}
+
 	UNLOCK(sw_telem_lock);
 
-	/*
-	 * Because of the enormous overhead of reading telemetry data from
-	 * the current kernel driver, failure to read the data is not
-	 * unheard of.  As such, 3 times, should the read fail.  Once we
-	 * get a higher-performance read routine, we should be able to
-	 * eliminate this retry (or maybe decrease it.)
-	 */
-	retry_count = 3;
-	while (needs_refresh && retry_count--) {
-		len = telemetry_raw_read_eventlog(
-			unit, events, sizeof(events) / TELEM_PKT_SIZE);
-
-		if ((len < 0) || (len < idx)) {
-			pw_pr_error(
-				"sw_read_telem_info_i: read failed: len=%d\n",
-				len);
-		} else {
-			break;
+	if (needs_refresh) {
+		u64 timestamp = flush_telem_to_buffer(unit);
+
+		pw_pr_debug("DEBUG: unit %d refreshed, timestamp = %llu\n",
+			unit, timestamp);
+		if (!timestamp) { /* failure */
+			*data_dest = SW_TELEM_READ_FAIL_VALUE;
+			return;
 		}
-	}
+	} else
+		pw_pr_debug("DEBUG: unit %d NOT refreshed\n", unit);
 
-	if (retry_count) {
-		/* TODO: Resolve if we should return something other than
-		 *       SW_TELEM_READ_FAIL_VALUE, if the actual data
-		 *	 happens to be that.
-		 */
-		*data_dest = events[idx].telem_evtlog;
-	} else {
-		*data_dest = SW_TELEM_READ_FAIL_VALUE;
-	}
+	*data_dest = read_event_from_buffer(unit, td->idx);
 }
 
 /**
@@ -420,24 +830,24 @@ void sw_read_telem_info(char *dest, int cpu,
  *
  * Stop collecting anything extra, and give the driver back to
  * debugfs.  Because this driver increases the sampling rate, the
- * kernel's telemetry driver can't successfully reset the driver unless
+ * kernel's telemetry driver can't succesfully reset the driver unless
  * we first drop the rate back down to a much slower rate.  This is a
  * temporary measure, since the reset operation will then reset the
  * sampling interval to whatever the GMIN driver wants.
  *
- * Return: PW_SUCCESS.
+ * Returns: 0
  */
 int sw_reset_telem(const struct sw_driver_io_descriptor *descriptor)
 {
-	if (telemetry_available() && SW_TELEM_CONFIGURED()) {
+	if (IS_TELEM_CONFIGURED()) {
+		stop_telem();
+		remove_telem_ids();
+		/* Return control to 'builtin' telemetry driver */
 		telemetry_set_sampling_period(TELEM_SAMPLING_1S,
-					      TELEM_SAMPLING_1S);
+					  TELEM_SAMPLING_1S);
 		telemetry_reset_events();
-		sw_telem_release_scaled_ids();
-		memset(s_unit_idx, 0, sizeof(s_unit_idx));
-		memset(s_unit_iters, 0, sizeof(s_unit_iters));
 	}
-	return PW_SUCCESS;
+	return 0;
 }
 
 /**
@@ -445,54 +855,18 @@ int sw_reset_telem(const struct sw_driver_io_descriptor *descriptor)
  */
 bool sw_telem_available(void)
 {
-	return telemetry_available();
+	/*
+	 * Telemetry driver MUST be loaded; we perform this check because
+	 * on some systems an error with the p-unit/pmc IPC interface causes
+	 * kernel panics.
+	 */
+	return builtin_telemetry_available();
 };
 
 bool sw_telem_post_config(void)
 {
-	bool retval = true;
-	size_t i = 0;
-	struct telemetry_evtconfig punit_evtconfig;
-	struct telemetry_evtconfig pmc_evtconfig;
-
-	if (!SW_TELEM_CONFIGURED()) {
-		return true;
-	}
-
-	memset(&punit_evtconfig, 0, sizeof(punit_evtconfig));
-	memset(&pmc_evtconfig, 0, sizeof(pmc_evtconfig));
-
-	telemetry_set_sampling_period(TELEM_SAMPLING_1S, TELEM_SAMPLING_1S);
-
-	punit_evtconfig.period = TELEM_SAMPLING_1S;
-	pmc_evtconfig.period = TELEM_SAMPLING_1S;
-
-	/* Punit */
-	punit_evtconfig.evtmap = (u32 *)&s_event_map[TELEM_PUNIT];
-	punit_evtconfig.num_evts = s_unit_idx[TELEM_PUNIT];
-	/* PMC */
-	pmc_evtconfig.evtmap = (u32 *)&s_event_map[TELEM_PMC];
-	pmc_evtconfig.num_evts = s_unit_idx[TELEM_PMC];
-
-	for (i = 0; i < punit_evtconfig.num_evts; ++i) {
-		pw_pr_debug("PUNIT[%zu] = 0x%x\n", i,
-			    punit_evtconfig.evtmap[i]);
-	}
-	for (i = 0; i < pmc_evtconfig.num_evts; ++i) {
-		pw_pr_debug("PMC[%zu] = 0x%x\n", i, pmc_evtconfig.evtmap[i]);
-	}
-
-	/*
-	 * OK, everything done. Now update
-	 */
-	if (telemetry_update_events(punit_evtconfig, pmc_evtconfig)) {
-		pw_pr_error("telemetry_update_events error");
-		retval = false;
-	} else {
-		pw_pr_debug("OK, telemetry_update_events success\n");
-	}
-
-	telemetry_set_sampling_period(TELEM_SAMPLING_1MS, TELEM_SAMPLING_1MS);
+	if (start_telem())
+		return false;
 
-	return retval;
+	return true;
 }
diff --git a/drivers/platform/x86/socwatch/sw_trace_notifier_provider.c b/drivers/platform/x86/socwatch/sw_trace_notifier_provider.c
index 153fa7010295..4fd32ff25565 100644
--- a/drivers/platform/x86/socwatch/sw_trace_notifier_provider.c
+++ b/drivers/platform/x86/socwatch/sw_trace_notifier_provider.c
@@ -1,64 +1,64 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
-*/
 #include <linux/version.h> /* "LINUX_VERSION_CODE" */
 #include <linux/hrtimer.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 11, 0)
-#include <asm/cputime.h>
+#if KERNEL_VERSION(4, 11, 0) > LINUX_VERSION_CODE
+	#include <asm/cputime.h>
 #else
-#include <linux/sched/cputime.h>
+	#include <linux/sched/cputime.h>
 #endif
 #include <asm/hardirq.h>
 #include <asm/local.h>
@@ -68,12 +68,12 @@
 #include <trace/events/timer.h>
 #include <trace/events/power.h>
 #include <trace/events/sched.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+#if KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE
 #include <asm/trace/irq_vectors.h> /* for the various APIC vector tracepoints
 				    *  (e.g. "thermal_apic",
 				    *  "local_timer" etc.)
 				    */
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0) */
+#endif /* KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE */
 struct pool_workqueue;
 struct cpu_workqueue_struct;
 #include <trace/events/workqueue.h>
@@ -129,12 +129,12 @@ struct cpu_workqueue_struct;
  * helper macros.
  */
 #if IS_ENABLED(CONFIG_TRACEPOINTS)
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+#if KERNEL_VERSION(2, 6, 35) > LINUX_VERSION_CODE
 #define DO_REGISTER_SW_TRACEPOINT_PROBE(node, name, probe)                     \
 	WARN_ON(register_trace_##name(probe))
 #define DO_UNREGISTER_SW_TRACEPOINT_PROBE(node, name, probe)                   \
 	unregister_trace_##name(probe)
-#elif LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
+#elif KERNEL_VERSION(3, 15, 0) > LINUX_VERSION_CODE
 #define DO_REGISTER_SW_TRACEPOINT_PROBE(node, name, probe)                     \
 	WARN_ON(register_trace_##name(probe, NULL))
 #define DO_UNREGISTER_SW_TRACEPOINT_PROBE(node, name, probe)                   \
@@ -149,7 +149,7 @@ struct cpu_workqueue_struct;
 #define DO_REGISTER_SW_TRACEPOINT_PROBE(...) /* NOP */
 #define DO_UNREGISTER_SW_TRACEPOINT_PROBE(...) /* NOP */
 #endif /* CONFIG_TRACEPOINTS */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+#if KERNEL_VERSION(2, 6, 35) > LINUX_VERSION_CODE
 #define _DEFINE_PROBE_FUNCTION(name, ...) static void name(__VA_ARGS__)
 #else
 #define _DEFINE_PROBE_FUNCTION(name, ...)                                      \
@@ -161,10 +161,10 @@ struct cpu_workqueue_struct;
  * Tracepoint probe function parameters.
  * These tracepoint signatures depend on kernel version.
  */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
+#if KERNEL_VERSION(2, 6, 36) > LINUX_VERSION_CODE
 #define PROBE_TPS_PARAMS                                                       \
 	sw_probe_power_start_i, unsigned int type, unsigned int state
-#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
+#elif KERNEL_VERSION(2, 6, 38) > LINUX_VERSION_CODE
 #define PROBE_TPS_PARAMS                                                       \
 	sw_probe_power_start_i, unsigned int type, unsigned int state,         \
 		unsigned int cpu_id
@@ -173,7 +173,7 @@ struct cpu_workqueue_struct;
 	sw_probe_cpu_idle_i, unsigned int state, unsigned int cpu_id
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
+#if KERNEL_VERSION(2, 6, 38) > LINUX_VERSION_CODE
 #define PROBE_TPF_PARAMS                                                       \
 	sw_probe_power_frequency_i, unsigned int type, unsigned int state
 #else
@@ -181,7 +181,7 @@ struct cpu_workqueue_struct;
 	sw_probe_cpu_frequency_i, unsigned int new_freq, unsigned int cpu
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+#if KERNEL_VERSION(2, 6, 35) > LINUX_VERSION_CODE
 #define PROBE_SCHED_WAKEUP_PARAMS                                              \
 	sw_probe_sched_wakeup_i, struct rq *rq, struct task_struct *task,      \
 		int success
@@ -191,7 +191,7 @@ struct cpu_workqueue_struct;
 #endif
 
 #if IS_ENABLED(CONFIG_ANDROID)
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+#if KERNEL_VERSION(3, 4, 0) > LINUX_VERSION_CODE
 #define PROBE_WAKE_LOCK_PARAMS sw_probe_wake_lock_i, struct wake_lock *lock
 #define PROBE_WAKE_UNLOCK_PARAMS                                               \
 	sw_probe_wake_unlock_i, struct wake_unlock *unlock
@@ -204,7 +204,7 @@ struct cpu_workqueue_struct;
 #endif /* version */
 #endif /* CONFIG_ANDROID */
 
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)
+#if KERNEL_VERSION(2, 6, 35) >= LINUX_VERSION_CODE
 #define PROBE_WORKQUEUE_PARAMS                                                 \
 	sw_probe_workqueue_execution_i, struct task_struct *wq_thread,         \
 		struct work_struct *work
@@ -260,13 +260,13 @@ struct cpu_workqueue_struct;
  * Use these macros if all tracepoint ID numbers
  * ARE contiguous from 0 -- max tracepoint ID #
  */
-#if 0
+/* #if 0
 #define IS_VALID_TRACE_NOTIFIER_ID(id)                                         \
 	((id) >= 0 && (id) < SW_ARRAY_SIZE(s_trace_collector_lists))
 #define GET_COLLECTOR_TRACE_NODE(id) (&s_trace_collector_lists[id])
 #define FOR_EACH_trace_notifier_id(idx)                                        \
 	for (idx = 0; idx < SW_ARRAY_SIZE(s_trace_collector_lists); ++idx)
-#endif /* if 0 */
+#endif */
 /*
  * Use these macros if all tracepoint ID numbers
  * are NOT contiguous from 0 -- max tracepoint ID #
@@ -315,52 +315,38 @@ int sw_unregister_trace_cpu_idle_i(struct sw_trace_notifier_data *node);
 int sw_register_trace_cpu_frequency_i(struct sw_trace_notifier_data *node);
 int sw_unregister_trace_cpu_frequency_i(struct sw_trace_notifier_data *node);
 int sw_register_trace_irq_handler_entry_i(struct sw_trace_notifier_data *node);
-int sw_unregister_trace_irq_handler_entry_i(struct sw_trace_notifier_data
-					    *node);
+int sw_unregister_trace_irq_handler_entry_i(struct sw_trace_notifier_data *node);
 int sw_register_trace_timer_expire_entry_i(struct sw_trace_notifier_data *node);
-int sw_unregister_trace_timer_expire_entry_i(
-	struct sw_trace_notifier_data *node);
-int sw_register_trace_hrtimer_expire_entry_i(
-	struct sw_trace_notifier_data *node);
-int sw_unregister_trace_hrtimer_expire_entry_i(
-	struct sw_trace_notifier_data *node);
+int sw_unregister_trace_timer_expire_entry_i(struct sw_trace_notifier_data *node);
+int sw_register_trace_hrtimer_expire_entry_i(struct sw_trace_notifier_data *node);
+int sw_unregister_trace_hrtimer_expire_entry_i(struct sw_trace_notifier_data *node);
 int sw_register_trace_sched_wakeup_i(struct sw_trace_notifier_data *node);
 int sw_unregister_trace_sched_wakeup_i(struct sw_trace_notifier_data *node);
 int sw_register_trace_sched_process_fork_i(struct sw_trace_notifier_data *node);
-int sw_unregister_trace_sched_process_fork_i(
-	struct sw_trace_notifier_data *node);
+int sw_unregister_trace_sched_process_fork_i(struct sw_trace_notifier_data *node);
 int sw_register_trace_sched_process_exit_i(struct sw_trace_notifier_data *node);
-int sw_unregister_trace_sched_process_exit_i(
-	struct sw_trace_notifier_data *node);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-int sw_register_trace_thermal_apic_entry_i(struct sw_trace_notifier_data *node);
-int sw_unregister_trace_thermal_apic_entry_i(
-	struct sw_trace_notifier_data *node);
-int sw_register_trace_thermal_apic_exit_i(struct sw_trace_notifier_data *node);
-int sw_unregister_trace_thermal_apic_exit_i(struct sw_trace_notifier_data
-					    *node);
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0) */
+int sw_unregister_trace_sched_process_exit_i(struct sw_trace_notifier_data *node);
+#if KERNEL_VERSION(3,14,0) <= LINUX_VERSION_CODE
+    int sw_register_trace_thermal_apic_entry_i(struct sw_trace_notifier_data *node);
+    int sw_unregister_trace_thermal_apic_entry_i(struct sw_trace_notifier_data *node);
+    int sw_register_trace_thermal_apic_exit_i(struct sw_trace_notifier_data *node);
+    int sw_unregister_trace_thermal_apic_exit_i(struct sw_trace_notifier_data *node);
+#endif // KERNEL_VERSION(3,14,0) <= LINUX_VERSION_CODE
 #if IS_ENABLED(CONFIG_ANDROID)
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
-int sw_register_trace_wake_lock_i(struct sw_trace_notifier_data *node);
-int sw_unregister_trace_wake_lock_i(struct sw_trace_notifier_data *node);
-int sw_register_trace_wake_unlock_i(struct sw_trace_notifier_data *node);
-int sw_unregister_trace_wake_unlock_i(struct sw_trace_notifier_data *node);
-#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0) */
-int sw_register_trace_wakeup_source_activate_i(
-	struct sw_trace_notifier_data *node);
-int sw_unregister_trace_wakeup_source_activate_i(
-	struct sw_trace_notifier_data *node);
-int sw_register_trace_wakeup_source_deactivate_i(
-	struct sw_trace_notifier_data *node);
-int sw_unregister_trace_wakeup_source_deactivate_i(
-	struct sw_trace_notifier_data *node);
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0) */
-#endif /* CONFIG_ANDROID */
-int sw_register_trace_workqueue_execution_i(struct sw_trace_notifier_data
-					    *node);
-int sw_unregister_trace_workqueue_execution_i(
-	struct sw_trace_notifier_data *node);
+    #if KERNEL_VERSION(3,4,0) > LINUX_VERSION_CODE
+        int sw_register_trace_wake_lock_i(struct sw_trace_notifier_data *node);
+        int sw_unregister_trace_wake_lock_i(struct sw_trace_notifier_data *node);
+        int sw_register_trace_wake_unlock_i(struct sw_trace_notifier_data *node);
+        int sw_unregister_trace_wake_unlock_i(struct sw_trace_notifier_data *node);
+    #else // KERNEL_VERSION(3,4,0) > LINUX_VERSION_CODE
+        int sw_register_trace_wakeup_source_activate_i(struct sw_trace_notifier_data *node);
+        int sw_unregister_trace_wakeup_source_activate_i(struct sw_trace_notifier_data *node);
+        int sw_register_trace_wakeup_source_deactivate_i(struct sw_trace_notifier_data *node);
+        int sw_unregister_trace_wakeup_source_deactivate_i(struct sw_trace_notifier_data *node);
+    #endif // KERNEL_VERSION(3,4,0) > LINUX_VERSION_CODE
+#endif // IS_ENABLED(CONFIG_ANDROID)
+int sw_register_trace_workqueue_execution_i(struct sw_trace_notifier_data *node);
+int sw_unregister_trace_workqueue_execution_i(struct sw_trace_notifier_data *node);
 int sw_register_trace_sched_switch_i(struct sw_trace_notifier_data *node);
 int sw_unregister_trace_sched_switch_i(struct sw_trace_notifier_data *node);
 int sw_register_pm_notifier_i(struct sw_trace_notifier_data *node);
@@ -369,25 +355,20 @@ int sw_register_cpufreq_notifier_i(struct sw_trace_notifier_data *node);
 int sw_unregister_cpufreq_notifier_i(struct sw_trace_notifier_data *node);
 int sw_register_hotcpu_notifier_i(struct sw_trace_notifier_data *node);
 int sw_unregister_hotcpu_notifier_i(struct sw_trace_notifier_data *node);
-void sw_handle_sched_wakeup_i(struct sw_collector_data *node, int source_cpu,
-			      int target_cpu);
-void sw_handle_timer_wakeup_helper_i(struct sw_collector_data *curr,
-				     struct sw_trace_notifier_data *node,
-				     pid_t tid);
+void sw_handle_sched_wakeup_i(struct sw_collector_data *node, int source_cpu, int target_cpu);
+void sw_handle_timer_wakeup_helper_i(struct sw_collector_data *curr, struct sw_trace_notifier_data *node,
+                                     pid_t tid);
 void sw_handle_apic_timer_wakeup_i(struct sw_collector_data *node);
-void sw_handle_workqueue_wakeup_helper_i(int cpu,
-					 struct sw_collector_data *node);
+void sw_handle_workqueue_wakeup_helper_i(int cpu, struct sw_collector_data *node);
 void sw_handle_sched_switch_helper_i(void);
 void sw_tps_apic_i(int cpu);
 void sw_tps_tps_i(int cpu);
 void sw_tps_wakeup_i(int cpu);
 void sw_tps_i(void);
 void sw_tpf_i(int cpu, struct sw_trace_notifier_data *node);
-void sw_process_fork_exit_helper_i(struct sw_collector_data *node,
-				   struct task_struct *task, bool is_fork);
-void sw_produce_wakelock_msg_i(int cpu, struct sw_collector_data *node,
-			       const char *name, int type, u64 timeout, int pid,
-			       int tid, const char *proc_name);
+void sw_process_fork_exit_helper_i(struct sw_collector_data *node, struct task_struct *task, bool is_fork);
+void sw_produce_wakelock_msg_i(int cpu, struct sw_collector_data *node, const char *name,
+                               int type, u64 timeout, int pid, int tid, const char *proc_name);
 u64 sw_my_local_arch_irq_stats_cpu_i(void);
 
 /*
@@ -397,8 +378,7 @@ u64 sw_my_local_arch_irq_stats_cpu_i(void);
  * The tracepoint handlers.
  */
 void sw_handle_trace_notifier_i(struct sw_trace_notifier_data *node);
-void sw_handle_trace_notifier_on_cpu_i(int cpu,
-				       struct sw_trace_notifier_data *node);
+void sw_handle_trace_notifier_on_cpu_i(int cpu, struct sw_trace_notifier_data *node);
 void sw_handle_reset_messages_i(struct sw_trace_notifier_data *node);
 
 /* -------------------------------------------------
@@ -507,17 +487,17 @@ static const struct sw_trace_notifier_name s_trace_names[] = {
 					     "PROCESS-FORK" },
 	[SW_TRACE_ID_SCHED_PROCESS_EXIT] = { "sched_process_exit",
 					     "PROCESS-EXIT" },
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+#if KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE
 	[SW_TRACE_ID_THERMAL_APIC_ENTRY] = { "thermal_apic_entry",
 					     "THERMAL-THROTTLE-ENTRY" },
 	[SW_TRACE_ID_THERMAL_APIC_EXIT] = { "thermal_apic_exit",
 					    "THERMAL-THROTTLE-EXIT" },
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0) */
+#endif /* KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE  */
 #if IS_ENABLED(CONFIG_ANDROID)
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+#if KERNEL_VERSION(3, 4, 0) > LINUX_VERSION_CODE
 	[SW_TRACE_ID_WAKE_LOCK] = { "wake_lock", "WAKE-LOCK" },
 	[SW_TRACE_ID_WAKE_UNLOCK] = { "wake_unlock", "WAKE-UNLOCK" },
-#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0) */
+#else /* KERNEL_VERSION(3, 4, 0) <= LINUX_VERSION_CODE */
 	[SW_TRACE_ID_WAKE_LOCK] = { "wakeup_source_activate", "WAKE-LOCK" },
 	[SW_TRACE_ID_WAKE_UNLOCK] = { "wakeup_source_deactivate",
 				      "WAKE-UNLOCK" },
@@ -589,7 +569,7 @@ static struct sw_trace_notifier_data s_trace_collector_lists[] = {
 	  &s_trace_names[SW_TRACE_ID_SCHED_PROCESS_EXIT],
 	  &sw_register_trace_sched_process_exit_i,
 	  &sw_unregister_trace_sched_process_exit_i, NULL },
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+#if KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE
 	/*
 	 * For thermal throttling.
 	 * We probably only need one of either 'entry' or 'exit'. Use
@@ -606,10 +586,10 @@ static struct sw_trace_notifier_data s_trace_collector_lists[] = {
 	  &s_trace_names[SW_TRACE_ID_THERMAL_APIC_EXIT],
 	  &sw_register_trace_thermal_apic_exit_i,
 	  &sw_unregister_trace_thermal_apic_exit_i, NULL },
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0) */
+#endif /* KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE */
 /* Wakelocks have multiple tracepoints, depending on kernel version */
 #if IS_ENABLED(CONFIG_ANDROID)
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+#if KERNEL_VERSION(3, 4, 0) > LINUX_VERSION_CODE
 	{ SW_TRACE_COLLECTOR_TRACEPOINT, &s_trace_names[SW_TRACE_ID_WAKE_LOCK],
 	  &sw_register_trace_wake_lock_i, &sw_unregister_trace_wake_lock_i,
 	  NULL },
@@ -617,7 +597,7 @@ static struct sw_trace_notifier_data s_trace_collector_lists[] = {
 	  &s_trace_names[SW_TRACE_ID_WAKE_UNLOCK],
 	  &sw_register_trace_wake_unlock_i, &sw_unregister_trace_wake_unlock_i,
 	  NULL },
-#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0) */
+#else /* KERNEL_VERSION(3, 4, 0) <= LINUX_VERSION_CODE  */
 	{ SW_TRACE_COLLECTOR_TRACEPOINT, &s_trace_names[SW_TRACE_ID_WAKE_LOCK],
 	  &sw_register_trace_wakeup_source_activate_i,
 	  &sw_unregister_trace_wakeup_source_activate_i, NULL },
@@ -625,7 +605,7 @@ static struct sw_trace_notifier_data s_trace_collector_lists[] = {
 	  &s_trace_names[SW_TRACE_ID_WAKE_UNLOCK],
 	  &sw_register_trace_wakeup_source_deactivate_i,
 	  &sw_unregister_trace_wakeup_source_deactivate_i, NULL },
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0) */
+#endif /* KERNEL_VERSION(3, 4, 0) > LINUX_VERSION_CODE */
 #endif /* CONFIG_ANDROID */
 	{ SW_TRACE_COLLECTOR_TRACEPOINT,
 	  &s_trace_names[SW_TRACE_ID_WORKQUEUE_EXECUTE_START],
@@ -746,11 +726,11 @@ u64 sw_my_local_arch_irq_stats_cpu_i(void)
 		sum += stats->apic_timer_irqs;
 		sum += stats->irq_spurious_count;
 #endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+#if KERNEL_VERSION(2, 6, 34) <= LINUX_VERSION_CODE
 		sum += stats->x86_platform_ipis;
 #endif /* 2,6,34 */
 		sum += stats->apic_perf_irqs;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
+#if KERNEL_VERSION(3, 5, 0) <= LINUX_VERSION_CODE
 		sum += stats->apic_irq_work_irqs;
 #endif /* 3,5,0 */
 #ifdef CONFIG_SMP
@@ -765,9 +745,9 @@ u64 sw_my_local_arch_irq_stats_cpu_i(void)
 #else
 		sum += stats->__softirq_pending;
 #ifdef CONFIG_SMP
-		for (i = 0; i < NR_IPI; ++i) {
+		for (i = 0; i < NR_IPI; ++i)
 			sum += stats->ipi_irqs[i];
-		}
+
 #endif
 #ifdef CONFIG_X86_MCE
 		sum += stats->mce_exception_count;
@@ -786,9 +766,9 @@ void sw_handle_trace_notifier_i(struct sw_trace_notifier_data *node)
 {
 	struct sw_collector_data *curr = NULL;
 
-	if (!node) {
+	if (!node)
 		return;
-	}
+
 	list_for_each_entry(curr, &node->list, list) {
 		pw_pr_debug("DEBUG: handling message\n");
 		sw_handle_per_cpu_msg(curr);
@@ -803,21 +783,21 @@ void sw_handle_trace_notifier_on_cpu_i(int cpu,
 {
 	struct sw_collector_data *curr = NULL;
 
-	if (!node) {
+	if (!node)
 		return;
-	}
-	list_for_each_entry(curr, &node->list, list) {
+
+	list_for_each_entry(curr, &node->list, list)
 		sw_handle_per_cpu_msg_on_cpu(cpu, curr);
-	}
+
 };
 
 void sw_handle_reset_messages_i(struct sw_trace_notifier_data *node)
 {
 	struct sw_collector_data *curr = NULL;
 
-	if (!node) {
+	if (!node)
 		return;
-	}
+
 	list_for_each_entry(curr, &node->list, list) {
 		pw_pr_debug("Handling message of unknown cpumask on cpu %d\n",
 			    RAW_CPU());
@@ -852,9 +832,9 @@ static void sw_handle_timer_wakeup_i(struct sw_collector_data *node, pid_t pid,
 	dst_vals += sizeof(pid);
 	*((int *)dst_vals) = tid;
 
-	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_DIRECT)) {
+	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_DIRECT))
 		pw_pr_warn("WARNING: could NOT produce message!\n");
-	}
+
 	pw_pr_debug("HANDLED timer expire for %d, %d\n", pid, tid);
 };
 
@@ -867,18 +847,16 @@ void sw_handle_timer_wakeup_helper_i(struct sw_collector_data *curr,
 {
 	pid_t pid = -1;
 
-	if (tid == 0) {
+	if (tid == 0)
 		pid = 0;
-	} else {
+	else {
 		struct task_struct *task =
 			pid_task(find_pid_ns(tid, &init_pid_ns), PIDTYPE_PID);
-		if (likely(task)) {
+		if (likely(task))
 			pid = task->tgid;
-		}
 	}
-	list_for_each_entry(curr, &node->list, list) {
+	list_for_each_entry(curr, &node->list, list)
 		sw_handle_timer_wakeup_i(curr, pid, tid);
-	}
 };
 
 /*
@@ -904,9 +882,9 @@ void sw_handle_sched_wakeup_i(struct sw_collector_data *node, int source_cpu,
 	dst_vals += sizeof(source_cpu);
 	*((int *)dst_vals) = target_cpu;
 
-	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_NONE)) {
+	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_NONE))
 		pw_pr_warn("WARNING: could NOT produce message!\n");
-	}
+
 };
 
 /*
@@ -926,9 +904,9 @@ void sw_handle_apic_timer_wakeup_i(struct sw_collector_data *node)
 	/* msg TSC assigned when msg is written to buffer */
 	msg->cpuidx = cpu;
 
-	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_DIRECT)) {
+	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_DIRECT))
 		pw_pr_warn("WARNING: could NOT produce message!\n");
-	}
+
 	pw_pr_debug("HANDLED APIC timer wakeup for cpu = %d\n", cpu);
 };
 
@@ -948,9 +926,8 @@ void sw_handle_workqueue_wakeup_helper_i(int cpu,
 	/*
 	 * Workqueue wakeup ==> empty message.
 	 */
-	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_DIRECT)) {
+	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_DIRECT))
 		pw_pr_error("WARNING: could NOT produce message!\n");
-	}
 };
 
 /*
@@ -964,9 +941,9 @@ void sw_handle_sched_switch_helper_i(void)
 		node = GET_COLLECTOR_TRACE_NODE(SW_TRACE_ID_SCHED_SWITCH);
 		pw_pr_debug("SCHED SWITCH NODE = %p\n", node);
 	}
-	if (!node) {
+	if (!node)
 		return;
-	}
+
 	preempt_disable();
 	{
 		struct sw_collector_data *curr;
@@ -980,15 +957,15 @@ void sw_handle_sched_switch_helper_i(void)
 			struct cpumask *mask = &curr->cpumask;
 			u16 timeout = curr->info->sampling_interval_msec;
 
-			if (!timeout) {
+			if (!timeout)
 				timeout = sw_min_polling_interval_msecs;
-			}
+
 			/* Has there been enough time since the last
 			 * collection point?
 			 */
-			if (delta_msecs < timeout) {
+			if (delta_msecs < timeout)
 				continue;
-			}
+
 			/* Update timestamp and handle message */
 			if (cpumask_test_cpu(
 				    RAW_CPU(),
@@ -1052,6 +1029,7 @@ void sw_tps_apic_i(int cpu)
 		if (local_apic_timer_fired &&
 		    SHOULD_PRODUCE_WAKEUP_SAMPLE(cpu)) {
 			struct sw_collector_data *curr = NULL;
+
 			list_for_each_entry(curr, &apic_timer_node->list,
 					     list) {
 				sw_handle_apic_timer_wakeup_i(curr);
@@ -1118,17 +1096,16 @@ void sw_tpf_i(int cpu, struct sw_trace_notifier_data *node)
 #if IS_ENABLED(CONFIG_TRACEPOINTS)
 DEFINE_PROBE_FUNCTION(PROBE_TPS_PARAMS)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
-	if (state == PWR_EVENT_EXIT) {
+#if KERNEL_VERSION(2, 6, 38) <= LINUX_VERSION_CODE
+	if (state == PWR_EVENT_EXIT)
 		return;
-	}
 #endif
 	DO_PER_CPU_OVERHEAD_FUNC(sw_tps_i);
 };
 
 DEFINE_PROBE_FUNCTION(PROBE_TPF_PARAMS)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
+#if KERNEL_VERSION(2, 6, 38) > LINUX_VERSION_CODE
 	int cpu = RAW_CPU();
 #endif /* version < 2.6.38 */
 	static struct sw_trace_notifier_data *node;
@@ -1160,9 +1137,9 @@ static void sw_handle_irq_wakeup_i(struct sw_collector_data *node, int irq)
 	 */
 	*((int *)dst_vals) = irq;
 
-	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_DIRECT)) {
+	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_DIRECT))
 		pw_pr_warn("WARNING: could NOT produce message!\n");
-	}
+
 };
 
 /*
@@ -1179,12 +1156,12 @@ DEFINE_PROBE_FUNCTION(PROBE_IRQ_PARAMS)
 		node = GET_COLLECTOR_TRACE_NODE(SW_TRACE_ID_IRQ_HANDLER_ENTRY);
 		pw_pr_debug("NODE = %p\n", node);
 	}
-	if (!node || !SHOULD_PRODUCE_WAKEUP_SAMPLE(cpu)) {
+	if (!node || !SHOULD_PRODUCE_WAKEUP_SAMPLE(cpu))
 		return;
-	}
-	list_for_each_entry(curr, &node->list, list) {
+
+	list_for_each_entry(curr, &node->list, list)
 		DO_PER_CPU_OVERHEAD_FUNC(sw_handle_irq_wakeup_i, curr, irq);
-	}
+
 };
 
 /*
@@ -1203,9 +1180,9 @@ DEFINE_PROBE_FUNCTION(PROBE_TIMER_ARGS)
 		pw_pr_debug("NODE = %p\n", node);
 	}
 
-	if (!node || !SHOULD_PRODUCE_WAKEUP_SAMPLE(cpu)) {
+	if (!node || !SHOULD_PRODUCE_WAKEUP_SAMPLE(cpu))
 		return;
-	}
+
 	DO_PER_CPU_OVERHEAD_FUNC(sw_handle_timer_wakeup_helper_i, curr, node,
 				 tid);
 };
@@ -1226,9 +1203,9 @@ DEFINE_PROBE_FUNCTION(PROBE_HRTIMER_PARAMS)
 		pw_pr_debug("NODE = %p\n", node);
 	}
 
-	if (!node || !SHOULD_PRODUCE_WAKEUP_SAMPLE(cpu)) {
+	if (!node || !SHOULD_PRODUCE_WAKEUP_SAMPLE(cpu))
 		return;
-	}
+
 	DO_PER_CPU_OVERHEAD_FUNC(sw_handle_timer_wakeup_helper_i, curr, node,
 				 tid);
 };
@@ -1244,9 +1221,9 @@ DEFINE_PROBE_FUNCTION(PROBE_SCHED_WAKEUP_PARAMS)
 	/*
 	 * "Self-sched" samples are "don't care".
 	 */
-	if (target_cpu == source_cpu) {
+	if (target_cpu == source_cpu)
 		return;
-	}
+
 	if (unlikely(node == NULL)) {
 		node = GET_COLLECTOR_TRACE_NODE(SW_TRACE_ID_SCHED_WAKEUP);
 		pw_pr_debug("NODE = %p\n", node);
@@ -1255,9 +1232,9 @@ DEFINE_PROBE_FUNCTION(PROBE_SCHED_WAKEUP_PARAMS)
 	 * Unlike other wakeup sources, we check the per-cpu flag
 	 * of the TARGET cpu to decide if we should produce a sample.
 	 */
-	if (!node || !SHOULD_PRODUCE_WAKEUP_SAMPLE(target_cpu)) {
+	if (!node || !SHOULD_PRODUCE_WAKEUP_SAMPLE(target_cpu))
 		return;
-	}
+
 	list_for_each_entry(curr, &node->list, list) {
 		/* sw_handle_sched_wakeup_i(curr, source_cpu, target_cpu); */
 		DO_PER_CPU_OVERHEAD_FUNC(sw_handle_sched_wakeup_i, curr,
@@ -1292,13 +1269,13 @@ void sw_process_fork_exit_helper_i(struct sw_collector_data *node,
 	dst_vals += sizeof(pid);
 	*((int *)dst_vals) = tid;
 	dst_vals += sizeof(tid);
-	if (is_fork) {
+	if (is_fork)
 		memcpy(dst_vals, name, SW_MAX_PROC_NAME_SIZE);
-	}
 
-	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_DIRECT)) {
+
+	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_DIRECT))
 		pw_pr_warn("WARNING: could NOT produce message!\n");
-	}
+
 	pw_pr_debug(
 		"HANDLED process %s event for task: pid = %d, tid = %d, name = %s\n",
 		is_fork ? "FORK" : "EXIT", pid, tid, name);
@@ -1313,9 +1290,9 @@ DEFINE_PROBE_FUNCTION(PROBE_PROCESS_FORK_PARAMS)
 		node = GET_COLLECTOR_TRACE_NODE(SW_TRACE_ID_SCHED_PROCESS_FORK);
 		pw_pr_debug("NODE = %p\n", node);
 	}
-	if (!node) {
+	if (!node)
 		return;
-	}
+
 	list_for_each_entry(curr, &node->list, list) {
 		DO_PER_CPU_OVERHEAD_FUNC(sw_process_fork_exit_helper_i, curr,
 					 child, true /* true ==> fork */);
@@ -1334,16 +1311,16 @@ DEFINE_PROBE_FUNCTION(PROBE_SCHED_PROCESS_EXIT_PARAMS)
 		node = GET_COLLECTOR_TRACE_NODE(SW_TRACE_ID_SCHED_PROCESS_EXIT);
 		pw_pr_debug("NODE = %p\n", node);
 	}
-	if (!node) {
+	if (!node)
 		return;
-	}
+
 	list_for_each_entry(curr, &node->list, list) {
 		DO_PER_CPU_OVERHEAD_FUNC(sw_process_fork_exit_helper_i, curr,
 					 task, false /* false ==> exit */);
 	}
 };
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+#if KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE
 /*
  * 10. THERMAL_APIC entry
  */
@@ -1373,7 +1350,7 @@ DEFINE_PROBE_FUNCTION(PROBE_THERMAL_APIC_EXIT_PARAMS)
 	}
 	DO_PER_CPU_OVERHEAD_FUNC(sw_tpf_i, (int)cpu, node);
 };
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0) */
+#endif /* KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE */
 
 #if IS_ENABLED(CONFIG_ANDROID)
 /*
@@ -1412,9 +1389,9 @@ void sw_produce_wakelock_msg_i(int cpu, struct sw_collector_data *node,
 	strncpy(dst_vals, proc_name, SW_MAX_PROC_NAME_SIZE);
 	dst_vals += SW_MAX_PROC_NAME_SIZE;
 
-	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_DIRECT)) {
+	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_DIRECT))
 		pw_pr_warn("WARNING: could NOT produce message!\n");
-	}
+
 };
 
 /*
@@ -1427,9 +1404,9 @@ void sw_handle_wakelock_i(int cpu, struct sw_trace_notifier_data *node,
 	const char *proc_name = NAME();
 	struct sw_collector_data *curr = NULL;
 
-	if (!node) {
+	if (!node)
 		return;
-	}
+
 
 	list_for_each_entry(curr, &node->list, list) {
 		sw_produce_wakelock_msg_i(cpu, curr, name, type, timeout, pid,
@@ -1443,7 +1420,7 @@ DEFINE_PROBE_FUNCTION(PROBE_WAKE_LOCK_PARAMS)
 	static struct sw_trace_notifier_data *node;
 	enum sw_kernel_wakelock_type type = SW_WAKE_LOCK;
 	u64 timeout = 0;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+#if KERNEL_VERSION(3, 4, 0) > LINUX_VERSION_CODE
 	const char *name = lock->name;
 #endif
 
@@ -1451,7 +1428,7 @@ DEFINE_PROBE_FUNCTION(PROBE_WAKE_LOCK_PARAMS)
 		node = GET_COLLECTOR_TRACE_NODE(SW_TRACE_ID_WAKE_LOCK);
 		pw_pr_debug("NODE = %p\n", node);
 	}
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+#if KERNEL_VERSION(3, 4, 0) > LINUX_VERSION_CODE
 	/*
 	 * Was this wakelock acquired with a timeout i.e.
 	 * is this an auto expire wakelock?
@@ -1460,7 +1437,7 @@ DEFINE_PROBE_FUNCTION(PROBE_WAKE_LOCK_PARAMS)
 		type = SW_WAKE_LOCK_TIMEOUT;
 		timeout = jiffies_to_msecs(lock->expires - jiffies);
 	}
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0) */
+#endif /* KERNEL_VERSION(3, 4, 0) > LINUX_VERSION_CODE */
 	DO_PER_CPU_OVERHEAD_FUNC(sw_handle_wakelock_i, cpu, node, name,
 				 (int)type, timeout);
 };
@@ -1473,7 +1450,7 @@ DEFINE_PROBE_FUNCTION(PROBE_WAKE_UNLOCK_PARAMS)
 	int cpu = RAW_CPU();
 	static struct sw_trace_notifier_data *node;
 	enum sw_kernel_wakelock_type type = SW_WAKE_UNLOCK;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+#if KERNEL_VERSION(3, 4, 0) > LINUX_VERSION_CODE
 	const char *name = lock->name;
 #endif
 
@@ -1501,13 +1478,13 @@ DEFINE_PROBE_FUNCTION(PROBE_WORKQUEUE_PARAMS)
 		pw_pr_debug("NODE = %p\n", node);
 	}
 
-	if (!node || !SHOULD_PRODUCE_WAKEUP_SAMPLE(cpu)) {
+	if (!node || !SHOULD_PRODUCE_WAKEUP_SAMPLE(cpu))
 		return;
-	}
-	list_for_each_entry(curr, &node->list, list) {
+
+	list_for_each_entry(curr, &node->list, list)
 		DO_PER_CPU_OVERHEAD_FUNC(sw_handle_workqueue_wakeup_helper_i,
 					 cpu, curr);
-	}
+
 };
 
 /*
@@ -1542,9 +1519,9 @@ static void sw_send_pm_notification_i(int value)
 	msg->payload_len = sizeof(value);
 	msg->p_payload = buffer + sizeof(*msg);
 	*((int *)msg->p_payload) = value;
-	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_DIRECT)) {
+	if (sw_produce_generic_msg(msg, SW_WAKEUP_ACTION_DIRECT))
 		pw_pr_error("couldn't produce generic message!\n");
-	}
+
 	vfree(buffer);
 }
 
@@ -1580,23 +1557,23 @@ static void sw_probe_pm_helper_i(int id, int both_id, bool is_enter,
 		/*
 		 * Exitting HIBERNATION/SUSPEND
 		 */
-		if (sw_is_reset_i() && reset_node) {
+		if (sw_is_reset_i() && reset_node)
 			sw_handle_reset_messages_i(reset_node);
-		}
+
 	}
-	if (node) {
+	if (node)
 		sw_handle_trace_notifier_i(node);
-	}
-	if (both_node) {
+
+	if (both_node)
 		sw_handle_trace_notifier_i(both_node);
-	}
+
 	/* Send the suspend-resume notification */
 	sw_send_pm_notification_i(SW_PM_VALUE(mode, action));
 }
 
 static bool sw_is_suspend_via_firmware(void)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
+#if KERNEL_VERSION(4, 4, 0) <= LINUX_VERSION_CODE
 	/* 'pm_suspend_via_firmware' only available in kernel >= 4.4 */
 	return pm_suspend_via_firmware();
 #endif
@@ -1666,7 +1643,7 @@ static void sw_store_topology_change_i(enum cpu_action type,
 	++sw_num_topology_entries;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
 int sw_probe_hotplug_notifier_i(struct notifier_block *block,
 				unsigned long action, void *pcpu)
 {
@@ -1750,7 +1727,7 @@ static void sw_probe_cpuhp_helper_i(unsigned int cpu, enum cpu_action action)
 
 static int sw_probe_cpu_offline_i(unsigned int cpu)
 {
-	printk(KERN_INFO "DEBUG: offline notification for cpu %u at %llu\n",
+	pw_pr_debug("DEBUG: offline notification for cpu %u at %llu\n",
 	       cpu, sw_tscval());
 	sw_probe_cpuhp_helper_i(cpu, SW_CPU_ACTION_OFFLINE);
 	return 0;
@@ -1758,13 +1735,13 @@ static int sw_probe_cpu_offline_i(unsigned int cpu)
 
 static int sw_probe_cpu_online_i(unsigned int cpu)
 {
-	printk(KERN_INFO "DEBUG: online notification for cpu %u at %llu\n", cpu,
+	pw_pr_debug("DEBUG: online notification for cpu %u at %llu\n", cpu,
 	       sw_tscval());
 	sw_probe_cpuhp_helper_i(cpu, SW_CPU_ACTION_ONLINE_PREPARE);
 	sw_probe_cpuhp_helper_i(cpu, SW_CPU_ACTION_ONLINE);
 	return 0;
 }
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0) */
+#endif /* KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE  */
 
 /*
  * 2. CPUFREQ notifier
@@ -1798,23 +1775,23 @@ static int sw_probe_cpufreq_notifier_i(struct notifier_block *block,
  */
 int sw_register_trace_cpu_idle_i(struct sw_trace_notifier_data *node)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
+#if KERNEL_VERSION(2, 6, 38) > LINUX_VERSION_CODE
 	DO_REGISTER_SW_TRACEPOINT_PROBE(node, power_start,
 					sw_probe_power_start_i);
 #else /* kernel version >= 2.6.38 */
 	DO_REGISTER_SW_TRACEPOINT_PROBE(node, cpu_idle, sw_probe_cpu_idle_i);
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) */
+#endif /* KERNEL_VERSION(2, 6, 38) > LINUX_VERSION_CODE */
 	return PW_SUCCESS;
 };
 
 int sw_unregister_trace_cpu_idle_i(struct sw_trace_notifier_data *node)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
+#if KERNEL_VERSION(2, 6, 38) > LINUX_VERSION_CODE
 	DO_UNREGISTER_SW_TRACEPOINT_PROBE(node, power_start,
 					  sw_probe_power_start_i);
 #else /* kernel version >= 2.6.38 */
 	DO_UNREGISTER_SW_TRACEPOINT_PROBE(node, cpu_idle, sw_probe_cpu_idle_i);
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) */
+#endif /* KERNEL_VERSION(2, 6, 38) > LINUX_VERSION_CODE */
 	return PW_SUCCESS;
 };
 
@@ -1823,25 +1800,25 @@ int sw_unregister_trace_cpu_idle_i(struct sw_trace_notifier_data *node)
  */
 int sw_register_trace_cpu_frequency_i(struct sw_trace_notifier_data *node)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
+#if KERNEL_VERSION(2, 6, 38) > LINUX_VERSION_CODE
 	DO_REGISTER_SW_TRACEPOINT_PROBE(node, power_frequency,
 					sw_probe_power_frequency_i);
 #else /* kernel version >= 2.6.38 */
 	DO_REGISTER_SW_TRACEPOINT_PROBE(node, cpu_frequency,
 					sw_probe_cpu_frequency_i);
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) */
+#endif /* KERNEL_VERSION(2, 6, 38) > LINUX_VERSION_CODE */
 	return PW_SUCCESS;
 };
 
 int sw_unregister_trace_cpu_frequency_i(struct sw_trace_notifier_data *node)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
+#if KERNEL_VERSION(2, 6, 38) > LINUX_VERSION_CODE
 	DO_UNREGISTER_SW_TRACEPOINT_PROBE(node, power_frequency,
 					  sw_probe_power_frequency_i);
 #else /* kernel version >= 2.6.38 */
 	DO_UNREGISTER_SW_TRACEPOINT_PROBE(node, cpu_frequency,
 					  sw_probe_cpu_frequency_i);
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) */
+#endif /* KERNEL_VERSION(2, 6, 38) > LINUX_VERSION_CODE */
 	return PW_SUCCESS;
 };
 
@@ -1955,7 +1932,7 @@ int sw_unregister_trace_sched_process_exit_i(struct sw_trace_notifier_data
 /*
  * 10. THERMAL_APIC entry
  */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+#if KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE
 int sw_register_trace_thermal_apic_entry_i(struct sw_trace_notifier_data *node)
 {
 	DO_REGISTER_SW_TRACEPOINT_PROBE(node, thermal_apic_entry,
@@ -1987,13 +1964,13 @@ int sw_unregister_trace_thermal_apic_exit_i(struct sw_trace_notifier_data *node)
 					  sw_probe_thermal_apic_exit_i);
 	return PW_SUCCESS;
 };
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0) */
+#endif /* KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE */
 
 /*
  * 11. WAKE lock / WAKEUP source activate.
  */
 #if IS_ENABLED(CONFIG_ANDROID)
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+#if KERNEL_VERSION(3, 4, 0) > LINUX_VERSION_CODE
 int sw_register_trace_wake_lock_i(struct sw_trace_notifier_data *node)
 {
 	DO_REGISTER_SW_TRACEPOINT_PROBE(node, wake_lock, sw_probe_wake_lock_i);
@@ -2006,7 +1983,7 @@ int sw_unregister_trace_wake_lock_i(struct sw_trace_notifier_data *node)
 					  sw_probe_wake_lock_i);
 	return PW_SUCCESS;
 };
-#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0) */
+#else /* KERNEL_VERSION(3, 4, 0) > LINUX_VERSION_CODE */
 int sw_register_trace_wakeup_source_activate_i(
 	struct sw_trace_notifier_data *node)
 {
@@ -2022,12 +1999,12 @@ int sw_unregister_trace_wakeup_source_activate_i(
 					  sw_probe_wakeup_source_activate_i);
 	return PW_SUCCESS;
 };
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0) */
+#endif /* KERNEL_VERSION(3, 4, 0) > LINUX_VERSION_CODE */
 
 /*
  * 11. WAKE unlock / WAKEUP source deactivate.
  */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+#if KERNEL_VERSION(3, 4, 0) > LINUX_VERSION_CODE
 int sw_register_trace_wake_unlock_i(struct sw_trace_notifier_data *node)
 {
 	DO_REGISTER_SW_TRACEPOINT_PROBE(node, wake_unlock,
@@ -2042,7 +2019,7 @@ int sw_unregister_trace_wake_unlock_i(struct sw_trace_notifier_data *node)
 	return PW_SUCCESS;
 };
 
-#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0) */
+#else /* KERNEL_VERSION(3, 4, 0) > LINUX_VERSION_CODE */
 int sw_register_trace_wakeup_source_deactivate_i(
 	struct sw_trace_notifier_data *node)
 {
@@ -2058,7 +2035,7 @@ int sw_unregister_trace_wakeup_source_deactivate_i(
 					  sw_probe_wakeup_source_deactivate_i);
 	return PW_SUCCESS;
 };
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0) */
+#endif /*  KERNEL_VERSION(3, 4, 0) > LINUX_VERSION_CODE */
 #endif /* CONFIG_ANDROID */
 
 /*
@@ -2066,7 +2043,7 @@ int sw_unregister_trace_wakeup_source_deactivate_i(
  */
 int sw_register_trace_workqueue_execution_i(struct sw_trace_notifier_data *node)
 {
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)
+#if KERNEL_VERSION(2, 6, 35) >= LINUX_VERSION_CODE
 	DO_REGISTER_SW_TRACEPOINT_PROBE(node, workqueue_execution,
 					sw_probe_workqueue_execution_i);
 #else
@@ -2079,7 +2056,7 @@ int sw_register_trace_workqueue_execution_i(struct sw_trace_notifier_data *node)
 int sw_unregister_trace_workqueue_execution_i(
 	struct sw_trace_notifier_data *node)
 {
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)
+#if KERNEL_VERSION(2, 6, 35) >= LINUX_VERSION_CODE
 	DO_UNREGISTER_SW_TRACEPOINT_PROBE(node, workqueue_execution,
 					  sw_probe_workqueue_execution_i);
 #else
@@ -2102,9 +2079,10 @@ int sw_register_trace_sched_switch_i(struct sw_trace_notifier_data *node)
 	 */
 	{
 		int cpu = 0;
-		for_each_present_cpu(cpu) {
+
+		for_each_present_cpu(cpu)
 			*(&per_cpu(sw_pcpu_polling_jiff, cpu)) = jiffies;
-		}
+
 	}
 	DO_REGISTER_SW_TRACEPOINT_PROBE(node, sched_switch,
 					sw_probe_sched_switch_i);
@@ -2162,7 +2140,7 @@ int sw_unregister_cpufreq_notifier_i(struct sw_trace_notifier_data *node)
 	return PW_SUCCESS;
 };
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
 /*
  * 3. CPU hot plug notifier.
  */
@@ -2182,7 +2160,7 @@ int sw_unregister_hotcpu_notifier_i(struct sw_trace_notifier_data *node)
 	return PW_SUCCESS;
 };
 
-#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0) */
+#else /* KERNEL_VERSION(4, 10, 0) <= LINUX_VERSION_CODE */
 static int sw_cpuhp_state = -1;
 int sw_register_hotcpu_notifier_i(struct sw_trace_notifier_data *node)
 {
@@ -2199,18 +2177,18 @@ int sw_register_hotcpu_notifier_i(struct sw_trace_notifier_data *node)
 
 int sw_unregister_hotcpu_notifier_i(struct sw_trace_notifier_data *node)
 {
-	if (sw_cpuhp_state >= 0) {
+	if (sw_cpuhp_state >= 0)
 		cpuhp_remove_state_nocalls((enum cpuhp_state)sw_cpuhp_state);
-	}
+
 	return 0;
 };
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0) */
+#endif /* KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE */
 
 /*
  * Tracepoint extraction routines.
  * Required for newer kernels (>=3.15)
  */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+#if KERNEL_VERSION(3, 15, 0) <= LINUX_VERSION_CODE
 static void sw_extract_tracepoint_callback(struct tracepoint *tp, void *priv)
 {
 	struct sw_trace_notifier_data *node = NULL;
@@ -2239,7 +2217,7 @@ static void sw_extract_tracepoint_callback(struct tracepoint *tp, void *priv)
 		}
 	}
 };
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0) */
+#endif /* KERNEL_VERSION(3, 15, 0) <= LINUX_VERSION_CODE */
 #endif /* CONFIG_TRACEPOINTS */
 
 /*
@@ -2248,7 +2226,7 @@ static void sw_extract_tracepoint_callback(struct tracepoint *tp, void *priv)
  */
 int sw_extract_trace_notifier_providers(void)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0) &&                          \
+#if KERNEL_VERSION(3, 15, 0) <= LINUX_VERSION_CODE  &&			\
 	IS_ENABLED(CONFIG_TRACEPOINTS)
 	int numCallbacks = 0;
 
@@ -2257,11 +2235,10 @@ int sw_extract_trace_notifier_providers(void)
 	/*
 	 * Did we get the complete list?
 	 */
-	if (numCallbacks != NUM_VALID_TRACEPOINTS) {
-		printk(KERN_WARNING
-		       "WARNING: Could NOT find tracepoint structs for some tracepoints!\n");
-	}
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0) */
+	if (numCallbacks != NUM_VALID_TRACEPOINTS)
+		pw_pr_warn(
+		       "WARNING : Could NOT find tracepoint structs for some tracepoints !\n");
+#endif /* KERNEL_VERSION(3, 15, 0) <= LINUX_VERSION_CODE */
 	return PW_SUCCESS;
 };
 
@@ -2274,9 +2251,8 @@ void sw_reset_trace_notifier_providers(void)
 	{
 		int cpu = 0;
 
-		for_each_online_cpu(cpu) {
+		for_each_online_cpu(cpu)
 			RESET_VALID_WAKEUP_EVENT_COUNTER(cpu);
-		}
 	}
 	/*
 	 * Reset the wakeup event flag. Not strictly required if we
@@ -2319,7 +2295,7 @@ int sw_add_trace_notifier_providers(void)
 	FOR_EACH_TRACEPOINT_NODE(i, node)
 	{
 		if (sw_register_trace_notify_provider(node)) {
-			pw_pr_error("ERROR: couldn't add a trace provider!\n");
+			pw_pr_error("ERROR : couldn't add a trace provider!\n");
 			return -EIO;
 		}
 	}
@@ -2327,11 +2303,10 @@ int sw_add_trace_notifier_providers(void)
 	{
 		if (sw_register_trace_notify_provider(node)) {
 			pw_pr_error(
-				"ERROR: couldn't add a notifier provider!\n");
+				"ERROR: couldn't add a notifier provider !\n");
 			return -EIO;
 		}
 	}
-#if IS_ENABLED(CONFIG_TRACEPOINTS)
 	/*
 	 * Add the cpu hot plug notifier.
 	 */
@@ -2339,11 +2314,10 @@ int sw_add_trace_notifier_providers(void)
 		if (sw_register_trace_notify_provider(
 			    &s_hotplug_notifier_data)) {
 			pw_pr_error(
-				"ERROR: couldn't add cpu notifier provider!\n");
+				"ERROR : couldn't add cpu notifier provider!\n");
 			return -EIO;
 		}
 	}
-#endif /* CONFIG_TRACEPOINTS */
 	return PW_SUCCESS;
 }
 
diff --git a/drivers/platform/x86/socwatch/sw_tracepoint_handlers.c b/drivers/platform/x86/socwatch/sw_tracepoint_handlers.c
index 8154f6b516c8..b03155c89c14 100644
--- a/drivers/platform/x86/socwatch/sw_tracepoint_handlers.c
+++ b/drivers/platform/x86/socwatch/sw_tracepoint_handlers.c
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 #include "sw_structs.h"
 #include "sw_kernel_defines.h"
 #include "sw_types.h"
@@ -71,15 +70,16 @@ struct sw_trace_list_node {
 	SW_LIST_ENTRY(list, sw_trace_list_node);
 };
 static SW_DEFINE_LIST_HEAD(s_trace_list, sw_trace_list_node) =
-	SW_LIST_HEAD_INITIALIZER(s_trace_list);
+				SW_LIST_HEAD_INITIALIZER(s_trace_list);
 static SW_DEFINE_LIST_HEAD(s_notifier_list, sw_trace_list_node) =
-	SW_LIST_HEAD_INITIALIZER(s_notifier_list);
+				SW_LIST_HEAD_INITIALIZER(s_notifier_list);
 static int s_trace_idx = -1, s_notifier_idx = -1;
 
 SW_DEFINE_LIST_HEAD(sw_topology_list, sw_topology_node) =
-	SW_LIST_HEAD_INITIALIZER(sw_topology_list);
+				SW_LIST_HEAD_INITIALIZER(sw_topology_list);
 size_t sw_num_topology_entries;
 
+
 /* -------------------------------------------------
  * Function definitions.
  * -------------------------------------------------
@@ -99,46 +99,45 @@ void sw_print_trace_notifier_overheads(void)
 	sw_print_trace_notifier_provider_overheads();
 }
 
-static int sw_for_each_node_i(void *list_head,
-			      int (*func)(struct sw_trace_notifier_data *node,
-					  void *priv),
-			      void *priv, bool return_on_error)
+static int sw_for_each_node_i(
+	void *list_head,
+	int (*func)(struct sw_trace_notifier_data *node, void *priv),
+	void *priv, bool return_on_error)
 {
 	SW_LIST_HEAD_VAR(sw_trace_list_node) * head = list_head;
 	int retval = PW_SUCCESS;
 	struct sw_trace_list_node *lnode = NULL;
 
-	SW_LIST_FOR_EACH_ENTRY(lnode, head, list)
-	{
+	SW_LIST_FOR_EACH_ENTRY(lnode, head, list) {
 		if ((*func)(lnode->data, priv)) {
 			retval = -EIO;
-			if (return_on_error) {
+			if (return_on_error)
 				break;
-			}
 		}
 	}
 	return retval;
 }
 
-int sw_for_each_tracepoint_node(int (*func)(struct sw_trace_notifier_data *node,
-					    void *priv),
-				void *priv, bool return_on_error)
+int sw_for_each_tracepoint_node(
+	int (*func)(struct sw_trace_notifier_data *node, void *priv),
+	void *priv, bool return_on_error)
 {
-	if (func) {
-		return sw_for_each_node_i(&s_trace_list, func, priv,
-					  return_on_error);
-	}
+	if (func)
+		return sw_for_each_node_i(&s_trace_list,
+			func, priv, return_on_error);
+
 	return PW_SUCCESS;
 }
 
-int sw_for_each_notifier_node(int (*func)(struct sw_trace_notifier_data *node,
-					  void *priv),
-			      void *priv, bool return_on_error)
+int sw_for_each_notifier_node(
+	int (*func)(struct sw_trace_notifier_data *node, void *priv),
+	void *priv, bool return_on_error)
 {
-	if (func) {
-		return sw_for_each_node_i(&s_notifier_list, func, priv,
-					  return_on_error);
-	}
+
+	if (func)
+		return sw_for_each_node_i(&s_notifier_list,
+						func, priv, return_on_error);
+
 	return PW_SUCCESS;
 }
 
@@ -156,7 +155,7 @@ int sw_get_trace_notifier_id(struct sw_trace_notifier_data *tnode)
 		return -EIO;
 	}
 	if (!(tnode->type == SW_TRACE_COLLECTOR_TRACEPOINT ||
-	      tnode->type == SW_TRACE_COLLECTOR_NOTIFIER)) {
+			tnode->type == SW_TRACE_COLLECTOR_NOTIFIER)) {
 		pw_pr_error(
 			"ERROR: cannot get ID for invalid trace/notifier data!\n");
 		return -EIO;
@@ -166,43 +165,43 @@ int sw_get_trace_notifier_id(struct sw_trace_notifier_data *tnode)
 			"ERROR: cannot get ID for trace/notifier data without valid name!\n");
 		return -EIO;
 	}
-#ifdef LINUX_VERSION_CODE
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0) &&                          \
+
+#if defined(LINUX_VERSION_CODE)
+#if KERNEL_VERSION(3, 15, 0) <= LINUX_VERSION_CODE &&	\
 	defined(CONFIG_TRACEPOINTS)
+
 	if (tnode->type == SW_TRACE_COLLECTOR_TRACEPOINT &&
-	    tnode->name->kernel_name && !tnode->tp) {
+		tnode->name->kernel_name && !tnode->tp) {
 		/* No tracepoint structure found so no ID possible */
 		return -EIO;
 	}
 #endif
 #endif
-	if (tnode->type == SW_TRACE_COLLECTOR_NOTIFIER) {
+	if (tnode->type == SW_TRACE_COLLECTOR_NOTIFIER)
 		head = (void *)&s_notifier_list;
-	}
-	SW_LIST_FOR_EACH_ENTRY(lnode, head, list)
-	{
+
+	SW_LIST_FOR_EACH_ENTRY(lnode, head, list) {
 		struct sw_trace_notifier_data *data = lnode->data;
 
-		if (!strcmp(data->name->abstract_name,
-			    tnode->name->abstract_name)) {
+		if (!strcmp(
+			data->name->abstract_name, tnode->name->abstract_name))
 			return lnode->id;
-		}
 	}
 	return -1;
 }
 /*
  * Retrieve the "kernel" name for this tracepoint/notifier.
  */
-const char *
-sw_get_trace_notifier_kernel_name(struct sw_trace_notifier_data *node)
+const char *sw_get_trace_notifier_kernel_name(
+		struct sw_trace_notifier_data *node)
 {
 	return node->name->kernel_name;
 };
 /*
  * Retrieve the "abstract" name for this tracepoint/notifier.
  */
-const char *
-sw_get_trace_notifier_abstract_name(struct sw_trace_notifier_data *node)
+const char *sw_get_trace_notifier_abstract_name(
+			struct sw_trace_notifier_data *node)
 {
 	return node->name->abstract_name;
 };
@@ -220,12 +219,14 @@ int sw_register_trace_notify_provider(struct sw_trace_notifier_data *data)
 		return -EIO;
 	}
 	if (!(data->type == SW_TRACE_COLLECTOR_TRACEPOINT ||
-	      data->type == SW_TRACE_COLLECTOR_NOTIFIER)) {
-		pw_pr_error("ERROR: cannot add invalid trace/notifier data!\n");
+			data->type == SW_TRACE_COLLECTOR_NOTIFIER)) {
+		pw_pr_error(
+			"ERROR: cannot add invalid trace/notifier data!\n");
 		return -EIO;
 	}
 	/*
-	 * Kernel name is allowed to be NULL, but abstract name MUST be present!
+	 * Kernel name is allowed to be NULL, but abstract name
+	 * MUST be present!
 	 */
 	if (!data->name || !data->name->abstract_name) {
 		pw_pr_error(
@@ -264,6 +265,7 @@ static void sw_free_trace_notifier_list_i(void *list_head)
 	while (!SW_LIST_EMPTY(head)) {
 		struct sw_trace_list_node *lnode =
 			SW_LIST_GET_HEAD_ENTRY(head, sw_trace_list_node, list);
+
 		SW_LIST_UNLINK(lnode, list);
 		sw_kfree(lnode);
 	}
@@ -291,53 +293,53 @@ void sw_remove_trace_notify(void)
 #define REG_FLAG (void *)1
 #define UNREG_FLAG (void *)2
 static int sw_reg_unreg_node_i(struct sw_trace_notifier_data *node,
-			       void *is_reg)
+				void *is_reg)
 {
 	if (is_reg == REG_FLAG) {
 		/*
 		 * Do we have anything to collect?
 		 * Update: or were we asked to always register?
 		 */
-		if (SW_LIST_EMPTY(&node->list) && !node->always_register) {
+		if (SW_LIST_EMPTY(&node->list) && !node->always_register)
 			return PW_SUCCESS;
-		}
+
 		/*
-		 * Sanity: ensure we have a register AND an
-		 * unregister function before proceeding!
+		 * Sanity: ensure we have a register AND an unregister function
+		 * before proceeding!
 		 */
 		if (node->probe_register == NULL ||
-		    node->probe_unregister == NULL) {
+				node->probe_unregister == NULL) {
 			pw_pr_debug(
 				"WARNING: invalid trace/notifier register/unregister function for %s\n",
-				sw_get_trace_notifier_kernel_name(node));
+				 sw_get_trace_notifier_kernel_name(node));
 			/*
-			 * Don't flag this as an error --
-			 * some socwatch trace providers don't have a
-			 * register/unregister function
+			 * Don't flag this as an error -- some socwatch
+			 * trace providers don't have a register/unregister
+			 * function
 			 */
 			return PW_SUCCESS;
 		}
-		if ((*node->probe_register)(node)) {
+		if ((*node->probe_register)(node))
 			return -EIO;
-		}
+
 		node->was_registered = true;
 		return PW_SUCCESS;
 	} else if (is_reg == UNREG_FLAG) {
 		if (node->was_registered) {
 			/*
-			 * No need to check for validity of probe
-			 * unregister function -- 'sw_register_notifiers_i()'
+			 * No need to check for validity of probe unregister
+			 * function -- 'sw_register_notifiers_i()'
 			 * would already have done so!
 			 */
 			WARN_ON((*node->probe_unregister)(node));
 			node->was_registered = false;
 			pw_pr_debug("OK, unregistered trace/notifier for %s\n",
-				    sw_get_trace_notifier_kernel_name(node));
+				sw_get_trace_notifier_kernel_name(node));
 		}
 		return PW_SUCCESS;
 	}
 	pw_pr_error("ERROR: invalid reg/unreg flag value 0x%lx\n",
-		    (unsigned long)is_reg);
+		(unsigned long)is_reg);
 	return -EIO;
 }
 /*
@@ -348,16 +350,16 @@ int sw_register_trace_notifiers(void)
 	/*
 	 * First, the tracepoints.
 	 */
-	if (sw_for_each_tracepoint_node(&sw_reg_unreg_node_i, REG_FLAG,
-					true /* return on error */)) {
+	if (sw_for_each_tracepoint_node(&sw_reg_unreg_node_i,
+			REG_FLAG, true /* return on error */)) {
 		pw_pr_error("ERROR registering some tracepoints\n");
 		return -EIO;
 	}
 	/*
 	 * And then the notifiers.
 	 */
-	if (sw_for_each_notifier_node(&sw_reg_unreg_node_i, REG_FLAG,
-				      true /* return on error */)) {
+	if (sw_for_each_notifier_node(&sw_reg_unreg_node_i,
+			REG_FLAG, true /* return on error */)) {
 		pw_pr_error("ERROR registering some tracepoints\n");
 		return -EIO;
 	}
@@ -372,15 +374,16 @@ int sw_unregister_trace_notifiers(void)
 	 * First, the notifiers.
 	 */
 	if (sw_for_each_notifier_node(&sw_reg_unreg_node_i, UNREG_FLAG,
-				      true /* return on error */)) {
+			true /* return on error */)) {
 		pw_pr_error("ERROR registering some tracepoints\n");
 		return -EIO;
 	}
 	/*
 	 * And then the tracepoints.
 	 */
-	if (sw_for_each_tracepoint_node(&sw_reg_unreg_node_i, UNREG_FLAG,
-					true /* return on error */)) {
+	if (sw_for_each_tracepoint_node(
+			&sw_reg_unreg_node_i,
+			UNREG_FLAG, true /* return on error */)) {
 		pw_pr_error("ERROR registering some tracepoints\n");
 		return -EIO;
 	}
@@ -393,10 +396,11 @@ void sw_clear_topology_list(void)
 	while (!SW_LIST_EMPTY(head)) {
 		struct sw_topology_node *lnode =
 			SW_LIST_GET_HEAD_ENTRY(head, sw_topology_node, list);
+
 		pw_pr_debug("Clearing topology node for cpu %d\n",
-			    lnode->change.cpu);
+			lnode->change.cpu);
 		SW_LIST_UNLINK(lnode, list);
 		sw_kfree(lnode);
 	}
-	sw_num_topology_entries = 0;
+	sw_num_topology_entries  = 0;
 }
diff --git a/drivers/platform/x86/socwatchhv/inc/asm_helper.h b/drivers/platform/x86/socwatchhv/inc/asm_helper.h
index 10e95190e4f0..ee5585e45686 100644
--- a/drivers/platform/x86/socwatchhv/inc/asm_helper.h
+++ b/drivers/platform/x86/socwatchhv/inc/asm_helper.h
@@ -1,65 +1,64 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef _ASM_HELPER_H_
 #define _ASM_HELPER_H_
 
 #include <linux/version.h>
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0)
+#if KERNEL_VERSION(4, 1, 0) > LINUX_VERSION_CODE
 
 #include <asm/dwarf2.h>
 #include <asm/calling.h>
@@ -68,91 +67,150 @@
 
 #ifdef CONFIG_AS_CFI
 
-#define CFI_STARTPROC (.cfi_startproc)
-#define CFI_ENDPROC (.cfi_endproc)
+#define CFI_STARTPROC         (.cfi_startproc)
+#define CFI_ENDPROC           (.cfi_endproc)
 #define CFI_ADJUST_CFA_OFFSET (.cfi_adjust_cfa_offset)
-#define CFI_REL_OFFSET (.cfi_rel_offset)
-#define CFI_RESTORE (.cfi_restore)
+#define CFI_REL_OFFSET        (.cfi_rel_offset)
+#define CFI_RESTORE           (.cfi_restore)
 
 #else
 
-.macro cfi_ignore a = 0, b = 0, c = 0, d = 0.endm
+.macro cfi_ignore a = 0, b = 0, c = 0, d = 0
+.endm
 
-#define CFI_STARTPROC cfi_ignore
-#define CFI_ENDPROC cfi_ignore
-#define CFI_ADJUST_CFA_OFFSET cfi_ignore
-#define CFI_REL_OFFSET cfi_ignore
-#define CFI_RESTORE cfi_ignore
+#define CFI_STARTPROC           cfi_ignore
+#define CFI_ENDPROC             cfi_ignore
+#define CFI_ADJUST_CFA_OFFSET   cfi_ignore
+#define CFI_REL_OFFSET          cfi_ignore
+#define CFI_RESTORE             cfi_ignore
 #endif
 
 #ifdef CONFIG_X86_64
-.macro SAVE_C_REGS_HELPER
-	offset = 0 rax = 1 rcx = 1 r8910 = 1 r11 = 1.if \r11 movq % r11,
-	6 * 8 +\offset(% rsp) CFI_REL_OFFSET r11, \offset.endif.if \r8910 movq
-							  % r10,
-	7 * 8 +\offset(% rsp) CFI_REL_OFFSET r10, \offset movq % r9,
-	8 * 8 +\offset(% rsp) CFI_REL_OFFSET r9, \offset movq % r8,
-	9 * 8 +\offset(% rsp) CFI_REL_OFFSET r8, \offset.endif.if \rax movq
-							 % rax,
-	10 * 8 +\offset(% rsp) CFI_REL_OFFSET rax, \offset.endif.if \rcx movq
-							   % rcx,
-	11 * 8 +\offset(% rsp) CFI_REL_OFFSET rcx, \offset.endif movq % rdx,
-	12 * 8 +\offset(% rsp) CFI_REL_OFFSET rdx, \offset movq % rsi,
-	13 * 8 +\offset(% rsp) CFI_REL_OFFSET rsi, \offset movq % rdi,
-	14 * 8 +\offset(% rsp) CFI_REL_OFFSET rdi, \offset.endm.macro
-						   SAVE_C_REGS offset =
-							   0 SAVE_C_REGS_HELPER \offset
-	,
-	1, 1, 1, 1.endm.macro SAVE_EXTRA_REGS offset = 0 movq % r15,
-	0 * 8 +\offset(% rsp) CFI_REL_OFFSET r15, \offset movq % r14,
-	1 * 8 +\offset(% rsp) CFI_REL_OFFSET r14, \offset movq % r13,
-	2 * 8 +\offset(% rsp) CFI_REL_OFFSET r13, \offset movq % r12,
-	3 * 8 +\offset(% rsp) CFI_REL_OFFSET r12, \offset movq % rbp,
-	4 * 8 +\offset(% rsp) CFI_REL_OFFSET rbp, \offset movq % rbx,
-	5 * 8 +\offset(% rsp) CFI_REL_OFFSET rbx, \offset.endm
-
-							  .macro
-						  RESTORE_EXTRA_REGS offset =
-							  0 movq 0 * 8 +\offset(
-								  % rsp),
-	% r15 CFI_RESTORE r15 movq 1 * 8 +\offset(% rsp),
-	% r14 CFI_RESTORE r14 movq 2 * 8 +\offset(% rsp),
-	% r13 CFI_RESTORE r13 movq 3 * 8 +\offset(% rsp),
-	% r12 CFI_RESTORE r12 movq 4 * 8 +\offset(% rsp),
-	% rbp CFI_RESTORE rbp movq 5 * 8 +\offset(% rsp),
-	% rbx CFI_RESTORE rbx.endm.macro RESTORE_C_REGS_HELPER rstor_rax = 1,
-	rstor_rcx = 1, rstor_r11 = 1,
-	rstor_r8910 = 1, rstor_rdx = 1.if \rstor_r11 movq 6 * 8(% rsp),
-	% r11 CFI_RESTORE r11.endif.if \rstor_r8910 movq 7 * 8(% rsp),
-	% r10 CFI_RESTORE r10 movq 8 * 8(% rsp),
-	% r9 CFI_RESTORE r9 movq 9 * 8(% rsp),
-	% r8 CFI_RESTORE r8.endif.if \rstor_rax movq 10 * 8(% rsp),
-	% rax CFI_RESTORE rax.endif.if \rstor_rcx movq 11 * 8(% rsp),
-	% rcx CFI_RESTORE rcx.endif.if \rstor_rdx movq 12 * 8(% rsp),
-	% rdx CFI_RESTORE rdx.endif movq 13 * 8(% rsp),
-	% rsi CFI_RESTORE rsi movq 14 * 8(% rsp),
-	% rdi CFI_RESTORE rdi.endm.macro RESTORE_C_REGS RESTORE_C_REGS_HELPER 1,
-	1, 1, 1,
-	1.endm
-
-		.macro ALLOC_PT_GPREGS_ON_STACK addskip = 0 subq $15 *
-								  8 +\addskip,
-	% rsp CFI_ADJUST_CFA_OFFSET
-			15 * 8 +\addskip.endm
-
-					.macro REMOVE_PT_GPREGS_FROM_STACK
-				addskip = 0 addq $15 * 8 +\addskip,
-	% rsp CFI_ADJUST_CFA_OFFSET -
-		(15 * 8 +\addskip)
-			.endm
-
-			.macro SAVE_ALL ALLOC_PT_GPREGS_ON_STACK SAVE_C_REGS
-		SAVE_EXTRA_REGS
-			.endm
-
-			.macro RESTORE_ALL RESTORE_EXTRA_REGS RESTORE_C_REGS
-		REMOVE_PT_GPREGS_FROM_STACK.endm
-#endif /*CONFIG_X86_64 */
+	.macro SAVE_C_REGS_HELPER offset = 0 rax = 1 rcx = 1 r8910 = 1 r11 = 1
+	.if \r11
+	movq % r11, 6*8+\offset(%rsp)
+	CFI_REL_OFFSET r11, \offset
+	.endif
+	.if \r8910
+	movq % r10, 7*8+\offset(%rsp)
+	CFI_REL_OFFSET r10, \offset
+
+	movq % r9,  8*8+\offset(%rsp)
+	CFI_REL_OFFSET r9, \offset
+
+	movq % r8,  9*8+\offset(%rsp)
+	CFI_REL_OFFSET r8, \offset
+	.endif
+	.if \rax
+	movq % rax, 10*8+\offset(%rsp)
+	CFI_REL_OFFSET rax, \offset
+	.endif
+	.if \rcx
+	movq % rcx, 11*8+\offset(%rsp)
+	CFI_REL_OFFSET rcx, \offset
+	.endif
+	movq % rdx, 12*8+\offset(%rsp)
+	CFI_REL_OFFSET rdx, \offset
+
+	movq % rsi, 13*8+\offset(%rsp)
+	CFI_REL_OFFSET rsi, \offset
+
+	movq % rdi, 14*8+\offset(%rsp)
+	CFI_REL_OFFSET rdi, \offset
+	.endm
+	.macro SAVE_C_REGS offset = 0
+	SAVE_C_REGS_HELPER \offset, 1, 1, 1, 1
+	.endm
+	.macro SAVE_EXTRA_REGS offset = 0
+	movq % r15, 0*8+\offset(%rsp)
+	CFI_REL_OFFSET r15, \offset
+
+	movq % r14, 1*8+\offset(%rsp)
+	CFI_REL_OFFSET r14, \offset
+
+	movq % r13, 2*8+\offset(%rsp)
+	CFI_REL_OFFSET r13, \offset
+
+	movq % r12, 3*8+\offset(%rsp)
+	CFI_REL_OFFSET r12, \offset
+
+	movq % rbp, 4*8+\offset(%rsp)
+	CFI_REL_OFFSET rbp, \offset
+
+	movq % rbx, 5*8+\offset(%rsp)
+	CFI_REL_OFFSET rbx, \offset
+	.endm
+
+	.macro RESTORE_EXTRA_REGS offset = 0
+	movq 0*8+\offset(%rsp), % r15
+	CFI_RESTORE r15
+	movq 1*8+\offset(%rsp), % r14
+	CFI_RESTORE r14
+	movq 2*8+\offset(%rsp), % r13
+	CFI_RESTORE r13
+	movq 3*8+\offset(%rsp), % r12
+	CFI_RESTORE r12
+	movq 4*8+\offset(%rsp), % rbp
+	CFI_RESTORE rbp
+	movq 5*8+\offset(%rsp), % rbx
+	CFI_RESTORE rbx
+	.endm
+	.macro RESTORE_C_REGS_HELPER rstor_rax = 1, rstor_rcx = 1, rstor_r11 = 1, rstor_r8910 = 1, rstor_rdx = 1
+	.if \rstor_r11
+	movq 6*8(%rsp), % r11
+	CFI_RESTORE r11
+	.endif
+	.if \rstor_r8910
+	movq 7*8(%rsp), % r10
+	CFI_RESTORE r10
+	movq 8*8(%rsp), % r9
+	CFI_RESTORE r9
+	movq 9*8(%rsp), % r8
+	CFI_RESTORE r8
+	.endif
+	.if \rstor_rax
+	movq 10*8(%rsp), % rax
+	CFI_RESTORE rax
+	.endif
+	.if \rstor_rcx
+	movq 11*8(%rsp), % rcx
+	CFI_RESTORE rcx
+	.endif
+	.if \rstor_rdx
+	movq 12*8(%rsp), % rdx
+	CFI_RESTORE rdx
+	.endif
+	movq 13*8(%rsp), % rsi
+	CFI_RESTORE rsi
+	movq 14*8(%rsp), % rdi
+	CFI_RESTORE rdi
+	.endm
+	.macro RESTORE_C_REGS
+	RESTORE_C_REGS_HELPER 1, 1, 1, 1, 1
+	.endm
+
+	.macro ALLOC_PT_GPREGS_ON_STACK addskip = 0
+	subq	$15*8+\addskip, % rsp
+	CFI_ADJUST_CFA_OFFSET 15*8+\addskip
+	.endm
+
+	.macro REMOVE_PT_GPREGS_FROM_STACK addskip = 0
+	addq $15*8+\addskip, % rsp
+	CFI_ADJUST_CFA_OFFSET - (15*8+\addskip)
+	.endm
+
+	.macro SAVE_ALL
+	ALLOC_PT_GPREGS_ON_STACK
+	SAVE_C_REGS
+	SAVE_EXTRA_REGS
+	.endm
+
+	.macro RESTORE_ALL
+	RESTORE_EXTRA_REGS
+	RESTORE_C_REGS
+	REMOVE_PT_GPREGS_FROM_STACK
+	.endm
+#endif /* CONFIG_X86_64 */
 #endif
 
 #endif
diff --git a/drivers/platform/x86/socwatchhv/inc/control.h b/drivers/platform/x86/socwatchhv/inc/control.h
index 7403150dd679..a1629c3aa2d7 100644
--- a/drivers/platform/x86/socwatchhv/inc/control.h
+++ b/drivers/platform/x86/socwatchhv/inc/control.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef _CONTROL_H_
 #define _CONTROL_H_
@@ -73,9 +72,9 @@ typedef void *pvoid;
 /*
  *  These routines have macros defined in asm/system.h
  */
-#define SYS_Local_Irq_Enable() local_irq_enable()
-#define SYS_Local_Irq_Disable() local_irq_disable()
-#define SYS_Local_Irq_Save(flags) local_irq_save(flags)
+#define SYS_Local_Irq_Enable()       local_irq_enable()
+#define SYS_Local_Irq_Disable()      local_irq_disable()
+#define SYS_Local_Irq_Save(flags)    local_irq_save(flags)
 #define SYS_Local_Irq_Restore(flags) local_irq_restore(flags)
 
 /*
@@ -86,7 +85,7 @@ typedef void *pvoid;
  *         CPU number of the processor being executed on
  *
  */
-#define CONTROL_THIS_CPU() smp_processor_id()
+#define CONTROL_THIS_CPU()     smp_processor_id()
 
 /****************************************************************************
  **  Interface definitions
@@ -96,99 +95,93 @@ typedef void *pvoid;
  *  Execution Control Functions
  */
 
-extern void CONTROL_Invoke_Cpu(s32 cpuid, void (*func)(pvoid), pvoid ctx);
+extern void
+CONTROL_Invoke_Cpu(
+	s32   cpuid,
+	void  (*func)(pvoid),
+	pvoid ctx
+);
 
 /*
  * @fn VOID CONTROL_Invoke_Parallel_Service(func, ctx, blocking, exclude)
  *
- * @param    func     - function to be invoked by each core in the system
- * @param    ctx      - pointer to the parameter block for each function
- *                      invocation
- * @param    blocking - Wait for invoked function to complete
- * @param    exclude  - exclude the current core from executing the code
+ * @param	func	 - function to be invoked by each core in the system
+ * @param	ctx	  - pointer to the parameter block for each function invocation
+ * @param	blocking - Wait for invoked function to complete
+ * @param	exclude  - exclude the current core from executing the code
  *
  * @returns  none
  *
- * @brief    Service routine to handle all kinds of parallel invoke on
- *           all CPU calls
+ * @brief	Service routine to handle all kinds of parallel invoke on all CPU calls
  *
  * <I>Special Notes:</I>
- *         Invoke the function provided in parallel in either a
- *         blocking/non-blocking mode.
- *         The current core may be excluded if desired.
- *         NOTE - Do not call this function directly from source code.
- *         Use the aliases
- *         CONTROL_Invoke_Parallel(), CONTROL_Invoke_Parallel_NB(),
- *         CONTROL_Invoke_Parallel_XS().
+ *		 Invoke the function provided in parallel in either a blocking/non-blocking mode.
+ *		 The current core may be excluded if desired.
+ *		 NOTE - Do not call this function directly from source code.  Use the aliases
+ *		 CONTROL_Invoke_Parallel(), CONTROL_Invoke_Parallel_NB(), CONTROL_Invoke_Parallel_XS().
  *
  */
-extern void CONTROL_Invoke_Parallel_Service(void (*func)(pvoid), pvoid ctx,
-					    s32 blocking, s32 exclude);
+extern void
+CONTROL_Invoke_Parallel_Service(
+	void   (*func)(pvoid),
+	pvoid  ctx,
+	s32	blocking,
+	s32	exclude
+);
 
 /*
  * @fn VOID CONTROL_Invoke_Parallel(func, ctx)
  *
- * @param    func     - function to be invoked by each core in the system
- * @param    ctx      - pointer to the parameter block for each function
- *                      invocation
+ * @param	func	 - function to be invoked by each core in the system
+ * @param	ctx	  - pointer to the parameter block for each function invocation
  *
  * @returns  none
  *
- * @brief    Invoke the named function in parallel. Wait for all the
- *           functions to complete.
+ * @brief	Invoke the named function in parallel. Wait for all the functions to complete.
  *
  * <I>Special Notes:</I>
- *        Invoke the function named in parallel, including the CPU
- *        that the control is being invoked on
- *
- *        Macro built on the service routine
+ *		Invoke the function named in parallel, including the CPU that the control is
+ *		being invoked on
+ *		Macro built on the service routine
  *
  */
-#define CONTROL_Invoke_Parallel(a, b)                                          \
-	CONTROL_Invoke_Parallel_Service((a), (b), TRUE, FALSE)
+#define CONTROL_Invoke_Parallel(a, b)	  CONTROL_Invoke_Parallel_Service((a), (b), TRUE, FALSE)
 
 /*
  * @fn VOID CONTROL_Invoke_Parallel_NB(func, ctx)
  *
- * @param    func     - function to be invoked by each core in the system
- * @param    ctx      - pointer to the parameter block for each function
- *                      invocation
+ * @param	func	 - function to be invoked by each core in the system
+ * @param	ctx	 - pointer to the parameter block for each function invocation
  *
  * @returns  none
  *
- * @brief    Invoke the named function in parallel. DO NOT Wait for all
- *           the functions to complete.
+ * @brief	Invoke the named function in parallel. DO NOT Wait for all the functions to complete.
  *
  * <I>Special Notes:</I>
- *        Invoke the function named in parallel, including the CPU
- *        that the control is being invoked on
- *
- *        Macro built on the service routine
+ *		Invoke the function named in parallel, including the CPU that the control is
+ *		being invoked on
+ *		Macro built on the service routine
  *
  */
-#define CONTROL_Invoke_Parallel_NB(a, b)                                       \
-	CONTROL_Invoke_Parallel_Service((a), (b), FALSE, FALSE)
+#define CONTROL_Invoke_Parallel_NB(a, b)   CONTROL_Invoke_Parallel_Service((a), (b), FALSE, FALSE)
 
 /*
  * @fn VOID CONTROL_Invoke_Parallel_XS(func, ctx)
  *
- * @param    func     - function to be invoked by each core in the system
- * @param    ctx      - pointer to the parameter block for each function
- *                      invocation
+ * @param	func	 - function to be invoked by each core in the system
+ * @param	ctx	  - pointer to the parameter block for each function invocation
  *
  * @returns  none
  *
- * @brief    Invoke the named function in parallel. Wait for all
- *           the functions to complete.
+ * @brief	Invoke the named function in parallel. Wait for all the functions to complete.
  *
  * <I>Special Notes:</I>
- *        Invoke the function named in parallel, excluding the CPU
- *        that the control is being invoked on
- *
- *        Macro built on the service routine
+ *		Invoke the function named in parallel, excluding the CPU that the control is
+ *		being invoked on
+ *		Macro built on the service routine
  *
  */
-#define CONTROL_Invoke_Parallel_XS(a, b)                                       \
-	CONTROL_Invoke_Parallel_Service((a), (b), TRUE, TRUE)
+#define CONTROL_Invoke_Parallel_XS(a, b)   CONTROL_Invoke_Parallel_Service((a), (b), TRUE, TRUE)
+
 
 #endif
diff --git a/drivers/platform/x86/socwatchhv/inc/pw_types.h b/drivers/platform/x86/socwatchhv/inc/pw_types.h
index 8b56e5c265dc..b5047b3ed04b 100644
--- a/drivers/platform/x86/socwatchhv/inc/pw_types.h
+++ b/drivers/platform/x86/socwatchhv/inc/pw_types.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef _PW_TYPES_H_
 #define _PW_TYPES_H_
@@ -68,7 +67,7 @@
 /*
  * UNSIGNED types...
  */
-typedef uint8_t u8;
+typedef uint8_t  u8;
 typedef uint16_t u16;
 typedef uint32_t u32;
 typedef uint64_t u64;
diff --git a/drivers/platform/x86/socwatchhv/inc/pw_version.h b/drivers/platform/x86/socwatchhv/inc/pw_version.h
index 7f1a40d82d71..714096691f6e 100644
--- a/drivers/platform/x86/socwatchhv/inc/pw_version.h
+++ b/drivers/platform/x86/socwatchhv/inc/pw_version.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef _PW_VERSION_H_
 #define _PW_VERSION_H_ 1
diff --git a/drivers/platform/x86/socwatchhv/inc/sw_defines.h b/drivers/platform/x86/socwatchhv/inc/sw_defines.h
index f0ef6baceb3f..a670904e4e39 100644
--- a/drivers/platform/x86/socwatchhv/inc/sw_defines.h
+++ b/drivers/platform/x86/socwatchhv/inc/sw_defines.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef _PW_DEFINES_H_
 #define _PW_DEFINES_H_ 1
@@ -63,17 +62,17 @@
  * Common to kernel and userspace.
  * ***************************************************
  */
-#define PW_SUCCESS 0
-#define PW_ERROR 1
-#define PW_SUCCESS_NO_COLLECT 2
+#define PW_SUCCESS              0
+#define PW_ERROR                1
+#define PW_SUCCESS_NO_COLLECT   2
 
 /*
  * Helper macro to convert 'u64' to 'unsigned long long' to avoid gcc warnings.
  */
 #define TO_ULL(x) (unsigned long long)(x)
 /*
- * Convert an arg to 'long long'
- */
+* Convert an arg to 'long long'
+*/
 #define TO_LL(x) (long long)(x)
 /*
  * Convert an arg to 'unsigned long'
@@ -94,13 +93,10 @@
 /*
  * Circularly decrement 'i'.
  */
-#define CIRCULAR_DEC(i, m)                                                     \
-	({                                                                     \
-		int __tmp1 = (i);                                              \
-		if (--__tmp1 < 0)                                              \
-			__tmp1 = (m);                                          \
-		__tmp1;                                                        \
-	})
+#define CIRCULAR_DEC(i, m) ({			\
+	int __tmp1 = (i);			\
+	if (--__tmp1 < 0)			\
+		__tmp1 = (m); __tmp1; })
 /*
  * Retrieve size of an array.
  */
@@ -114,7 +110,7 @@
  * Assumes version numbers are 8b unsigned ints.
  */
 #define SW_GET_SCU_FW_VERSION_MAJOR(ver) (((ver) >> 8) & 0xff)
-#define SW_GET_SCU_FW_VERSION_MINOR(ver) ((ver)&0xff)
+#define SW_GET_SCU_FW_VERSION_MINOR(ver) ((ver) & 0xff)
 /*
  * Max size of process name retrieved from kernel.
  */
@@ -136,7 +132,7 @@
 #define SW_MAX_KERNEL_WAKELOCK_NAME_SIZE 100
 
 /* Data value read when a telemetry data read fails. */
-#define SW_TELEM_READ_FAIL_VALUE 0xF00DF00DF00DF00D
+#define SW_TELEM_READ_FAIL_VALUE 0xF00DF00DF00DF00DUL
 
 #ifdef SWW_MERGE
 typedef enum {
@@ -152,5 +148,12 @@ typedef enum {
 #define MAX_UNSIGNED_24_BIT_VALUE 0xFFFFFF
 #define MAX_UNSIGNED_32_BIT_VALUE 0xFFFFFFFF
 #define MAX_UNSIGNED_64_BIT_VALUE 0xFFFFFFFFFFFFFFFF
+/*
+ * TELEM BAR CONFIG
+ */
+#define MAX_TELEM_BAR_CFG	3
+#define TELEM_MCHBAR_CFG	0
+#define TELEM_IPC1BAR_CFG	1
+#define TELEM_SSRAMBAR_CFG	2
 
 #endif /* _PW_DEFINES_H_ */
diff --git a/drivers/platform/x86/socwatchhv/inc/sw_ioctl.h b/drivers/platform/x86/socwatchhv/inc/sw_ioctl.h
index 1f8e903a0e1c..43a1f69af9ab 100644
--- a/drivers/platform/x86/socwatchhv/inc/sw_ioctl.h
+++ b/drivers/platform/x86/socwatchhv/inc/sw_ioctl.h
@@ -1,71 +1,71 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
-*/
 #ifndef __SW_IOCTL_H__
 #define __SW_IOCTL_H__ 1
 
 #if defined(__linux__) || defined(__QNX__)
-#if __KERNEL__
-#include <linux/ioctl.h>
-#if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)
-#include <asm/compat.h>
-#include <linux/compat.h>
-#endif /* COMPAT && x64 */
-#else /* !__KERNEL__ */
-#include <sys/ioctl.h>
-#endif /* __KERNEL__ */
+	#if __KERNEL__
+		#include <linux/ioctl.h>
+		#if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)
+			#include <asm/compat.h>
+			#include <linux/compat.h>
+		#endif /* COMPAT && x64 */
+	#else /* !__KERNEL__ */
+		#include <sys/ioctl.h>
+	#endif /* __KERNEL__ */
 #endif /* __linux__ */
 /*
  * Ensure we pull in definition of 'DO_COUNT_DROPPED_SAMPLES'!
@@ -107,6 +107,9 @@ enum sw_ioctl_cmd {
 	sw_ioctl_cmd_avail_notify,
 	sw_ioctl_cmd_avail_collect,
 	sw_ioctl_cmd_topology_changes,
+	sw_ioctl_cmd_config_continuous,
+	sw_ioctl_cmd_read_continuous,
+	sw_ioctl_cmd_telem_bar,
 };
 /*
  * The actual IOCTL commands.
@@ -120,150 +123,136 @@ enum sw_ioctl_cmd {
  * (similar to the file "read" and "write" calls).
  */
 #ifdef SWW_MERGE /* Windows */
-/*
- * Device type           -- in the "User Defined" range."
- */
-#define POWER_I_CONF_TYPE 40000
+	 /*
+	  * Device type		   -- in the "User Defined" range."
+	  */
+	#define POWER_I_CONF_TYPE 40000
 
-/* List assigned tracepoint id */
-#define CSIR_TRACEPOINT_ID_MASK 1
-#define DEVICE_STATE_TRACEPOINT_ID_MASK 2
-#define CSIR_SEPARATE_TRACEPOINT_ID_MASK 3
-#define RESET_TRACEPOINT_ID_MASK 4
-#define DISPLAY_ON_TRACEPOINT_ID_MASK 5
+	/* List assigned tracepoint id */
+	#define CSIR_TRACEPOINT_ID_MASK			1
+	#define DEVICE_STATE_TRACEPOINT_ID_MASK		2
+	#define CSIR_SEPARATE_TRACEPOINT_ID_MASK	3
+	#define RESET_TRACEPOINT_ID_MASK		4
+	#define DISPLAY_ON_TRACEPOINT_ID_MASK		5
 
-#ifdef SWW_MERGE
-/*
- * TELEM BAR CONFIG
- */
-#define MAX_TELEM_BAR_CFG 3
-#define TELEM_MCHBAR_CFG 0
-#define TELEM_IPC1BAR_CFG 1
-#define TELEM_SSRAMBAR_CFG 2
-#endif
-
-/*
- * The IOCTL function codes from 0x800 to 0xFFF are for customer use.
- */
-#define PW_IOCTL_CONFIG                                                        \
+	/*
+	 * The IOCTL function codes from 0x800 to 0xFFF are for customer use.
+	 */
+	#define PW_IOCTL_CONFIG \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_START_COLLECTION                                              \
+	#define PW_IOCTL_START_COLLECTION \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x901, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_STOP_COLLECTION                                               \
+	#define PW_IOCTL_STOP_COLLECTION \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS)
 
-/* TODO: pause, resume, cancel not supported yet */
-#define PW_IOCTL_PAUSE_COLLECTION                                              \
+	/* TODO: pause, resume, cancel not supported yet */
+	#define PW_IOCTL_PAUSE_COLLECTION \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x903, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_RESUME_COLLECTION                                             \
+	#define PW_IOCTL_RESUME_COLLECTION \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x904, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_CANCEL_COLLECTION                                             \
+	#define PW_IOCTL_CANCEL_COLLECTION \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x905, METHOD_BUFFERED, FILE_ANY_ACCESS)
 
-#define PW_IOCTL_GET_PROCESSOR_GROUP_TOPOLOGY                                  \
+	#define PW_IOCTL_GET_PROCESSOR_GROUP_TOPOLOGY \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x906, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_TOPOLOGY                                                      \
+	#define PW_IOCTL_TOPOLOGY \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x907, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_GET_AVAILABLE_COLLECTORS                                      \
+	#define PW_IOCTL_GET_AVAILABLE_COLLECTORS \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x908, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_IMMEDIATE_IO                                                  \
+	#define PW_IOCTL_IMMEDIATE_IO \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x909, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_DRV_CLEANUP                                                   \
+	#define PW_IOCTL_DRV_CLEANUP \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x90A, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_SET_COLLECTION_EVENT                                          \
+	#define PW_IOCTL_SET_COLLECTION_EVENT \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x90B, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_TRY_STOP_EVENT                                                \
+	#define PW_IOCTL_TRY_STOP_EVENT \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x90C, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_SET_PCH_ACTIVE_INTERVAL                                       \
+	#define PW_IOCTL_SET_PCH_ACTIVE_INTERVAL \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x90D, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_SET_TELEM_BAR                                                 \
+	#define PW_IOCTL_SET_TELEM_BAR \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x90E, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_METADATA                                                      \
+	#define PW_IOCTL_METADATA \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x90F, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_SET_GBE_INTERVAL                                              \
+	#define PW_IOCTL_SET_GBE_INTERVAL \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x910, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_ENABLE_COLLECTION                                             \
+	#define PW_IOCTL_ENABLE_COLLECTION \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x911, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_DISABLE_COLLECTION                                            \
+	#define PW_IOCTL_DISABLE_COLLECTION \
 	CTL_CODE(POWER_I_CONF_TYPE, 0x912, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define PW_IOCTL_DRIVER_BUILD_DATE                                             \
-	CTL_CODE(POWER_I_CONF_TYPE, 0x913, METHOD_BUFFERED, FILE_ANY_ACCESS)
+	#define PW_IOCTL_DRIVER_BUILD_DATE \
+		CTL_CODE(POWER_I_CONF_TYPE, 0x913, METHOD_BUFFERED, FILE_ANY_ACCESS)
+	#define PW_IOCTL_CONFIG_CONTINUOUS \
+		CTL_CODE(POWER_I_CONF_TYPE, 0x914, METHOD_BUFFERED, FILE_ANY_ACCESS)
+	#define PW_IOCTL_READ_CONTINUOUS \
+		CTL_CODE(POWER_I_CONF_TYPE, 0x915, METHOD_BUFFERED, FILE_ANY_ACCESS)
 
 #elif !defined(__APPLE__)
-#define PW_IOCTL_CONFIG                                                        \
-	_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config,                        \
-	     struct sw_driver_ioctl_arg *)
-#if DO_COUNT_DROPPED_SAMPLES
-#define PW_IOCTL_CMD                                                           \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd,                          \
-	      struct sw_driver_ioctl_arg *)
-#else
-#define PW_IOCTL_CMD                                                           \
-	_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd,                           \
-	     struct sw_driver_ioctl_arg *)
-#endif /* DO_COUNT_DROPPED_SAMPLES */
-#define PW_IOCTL_POLL _IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
-#define PW_IOCTL_IMMEDIATE_IO                                                  \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io,                 \
-	      struct sw_driver_ioctl_arg *)
-#define PW_IOCTL_GET_SCU_FW_VERSION                                            \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version,                   \
-	     struct sw_driver_ioctl_arg *)
-#define PW_IOCTL_READ_IMMEDIATE                                                \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate,               \
-	      struct sw_driver_ioctl_arg *)
-#define PW_IOCTL_GET_DRIVER_VERSION                                            \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version,                \
-	     struct sw_driver_ioctl_arg *)
-#define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS                                     \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace,                   \
-	     struct sw_driver_ioctl_arg *)
-#define PW_IOCTL_GET_AVAILABLE_NOTIFIERS                                       \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify,                  \
-	     struct sw_driver_ioctl_arg *)
-#define PW_IOCTL_GET_AVAILABLE_COLLECTORS                                      \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect,                 \
-	     struct sw_driver_ioctl_arg *)
-#define PW_IOCTL_GET_TOPOLOGY_CHANGES                                          \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes,              \
-	     struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_CONFIG	\
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config, struct sw_driver_ioctl_arg *)
+	#if DO_COUNT_DROPPED_SAMPLES
+		#define PW_IOCTL_CMD \
+			_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, struct sw_driver_ioctl_arg *)
+	#else
+		#define PW_IOCTL_CMD \
+			_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, struct sw_driver_ioctl_arg *)
+	#endif /* DO_COUNT_DROPPED_SAMPLES */
+	#define PW_IOCTL_POLL _IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
+	#define PW_IOCTL_IMMEDIATE_IO	\
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_GET_SCU_FW_VERSION \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_READ_IMMEDIATE \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_GET_DRIVER_VERSION \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_GET_AVAILABLE_NOTIFIERS \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_GET_AVAILABLE_COLLECTORS \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_GET_TOPOLOGY_CHANGES \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_CONFIG_CONTINUOUS \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config_continuous, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_READ_CONTINUOUS \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_continuous, struct sw_driver_ioctl_arg *)
+	#define PW_IOCTL_SET_TELEM_BAR \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_telem_bar, struct sw_driver_ioctl_arg *)
 #else /* __APPLE__ */
-#define PW_IOCTL_CONFIG                                                        \
-	_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config,                        \
-	     struct sw_driver_ioctl_arg)
-#if DO_COUNT_DROPPED_SAMPLES
-#define PW_IOCTL_CMD                                                           \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd,                          \
-	      struct sw_driver_ioctl_arg)
-#else
-#define PW_IOCTL_CMD                                                           \
-	_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, struct sw_driver_ioctl_arg)
-#endif /* DO_COUNT_DROPPED_SAMPLES */
-#define PW_IOCTL_POLL _IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
-#define PW_IOCTL_IMMEDIATE_IO                                                  \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io,                 \
-	      struct sw_driver_ioctl_arg)
-#define PW_IOCTL_GET_SCU_FW_VERSION                                            \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version,                  \
-	      struct sw_driver_ioctl_arg)
-#define PW_IOCTL_READ_IMMEDIATE                                                \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate,               \
-	      struct sw_driver_ioctl_arg)
-#define PW_IOCTL_GET_DRIVER_VERSION                                            \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version,               \
-	      struct sw_driver_ioctl_arg)
-#define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS                                     \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace,                  \
-	      struct sw_driver_ioctl_arg)
-#define PW_IOCTL_GET_AVAILABLE_NOTIFIERS                                       \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify,                 \
-	      struct sw_driver_ioctl_arg)
-#define PW_IOCTL_GET_AVAILABLE_COLLECTORS                                      \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect,                \
-	      struct sw_driver_ioctl_arg)
-#define PW_IOCTL_GET_TOPOLOGY_CHANGES                                          \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes,             \
-	      struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_CONFIG \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config, struct sw_driver_ioctl_arg)
+	#if DO_COUNT_DROPPED_SAMPLES
+		#define PW_IOCTL_CMD \
+			_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, struct sw_driver_ioctl_arg)
+	#else
+		#define PW_IOCTL_CMD \
+			_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, struct sw_driver_ioctl_arg)
+	#endif /* DO_COUNT_DROPPED_SAMPLES */
+	#define PW_IOCTL_POLL \
+		_IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
+	#define PW_IOCTL_IMMEDIATE_IO \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_GET_SCU_FW_VERSION \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_READ_IMMEDIATE \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_GET_DRIVER_VERSION \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_GET_AVAILABLE_NOTIFIERS \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_GET_AVAILABLE_COLLECTORS \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_GET_TOPOLOGY_CHANGES \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_CONFIG_CONTINUOUS \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config_continuous, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_READ_CONTINUOUS \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_continuous, struct sw_driver_ioctl_arg)
+	#define PW_IOCTL_SET_TELEM_BAR \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_telem_bar, struct sw_driver_ioctl_arg *)
 #endif /* __APPLE__ */
 
 /*
@@ -273,31 +262,38 @@ enum sw_ioctl_cmd {
  * and ONLY by the driver.
  */
 #if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)
-#define PW_IOCTL_CONFIG32                                                      \
-	_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config, compat_uptr_t)
+	#define PW_IOCTL_CONFIG32 \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config, compat_uptr_t)
 #if DO_COUNT_DROPPED_SAMPLES
-#define PW_IOCTL_CMD32                                                         \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, compat_uptr_t)
+	#define PW_IOCTL_CMD32 \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, compat_uptr_t)
 #else
-#define PW_IOCTL_CMD32                                                         \
-	_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, compat_uptr_t)
+	#define PW_IOCTL_CMD32 \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, compat_uptr_t)
 #endif /* DO_COUNT_DROPPED_SAMPLES */
-#define PW_IOCTL_POLL32 _IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
-#define PW_IOCTL_IMMEDIATE_IO32                                                \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io, compat_uptr_t)
-#define PW_IOCTL_GET_SCU_FW_VERSION32                                          \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version, compat_uptr_t)
-#define PW_IOCTL_READ_IMMEDIATE32                                              \
-	_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate, compat_uptr_t)
-#define PW_IOCTL_GET_DRIVER_VERSION32                                          \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version, compat_uptr_t)
-#define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS32                                   \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace, compat_uptr_t)
-#define PW_IOCTL_GET_AVAILABLE_NOTIFIERS32                                     \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify, compat_uptr_t)
-#define PW_IOCTL_GET_AVAILABLE_COLLECTORS32                                    \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect, compat_uptr_t)
-#define PW_IOCTL_GET_TOPOLOGY_CHANGES32                                        \
-	_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes, compat_uptr_t)
+	#define PW_IOCTL_POLL32 \
+		_IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
+	#define PW_IOCTL_IMMEDIATE_IO32 \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io, compat_uptr_t)
+	#define PW_IOCTL_GET_SCU_FW_VERSION32 \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version, compat_uptr_t)
+	#define PW_IOCTL_READ_IMMEDIATE32 \
+		_IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate, compat_uptr_t)
+	#define PW_IOCTL_GET_DRIVER_VERSION32 \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version, compat_uptr_t)
+	#define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS32 \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace, compat_uptr_t)
+	#define PW_IOCTL_GET_AVAILABLE_NOTIFIERS32 \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify, compat_uptr_t)
+	#define PW_IOCTL_GET_AVAILABLE_COLLECTORS32 \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect, compat_uptr_t)
+	#define PW_IOCTL_GET_TOPOLOGY_CHANGES32 \
+		_IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes, compat_uptr_t)
+	#define PW_IOCTL_CONFIG_CONTINUOUS32 \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config_continuous, compat_uptr_t)
+	#define PW_IOCTL_READ_CONTINUOUS32 \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_continuous, compat_uptr_t)
+	#define PW_IOCTL_SET_TELEM_BAR32 \
+		_IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_telem_bar, compat_uptr_t)
 #endif /* defined(CONFIG_COMPAT) && defined(CONFIG_X86_64) */
 #endif /* __SW_IOCTL_H__ */
diff --git a/drivers/platform/x86/socwatchhv/inc/sw_structs.h b/drivers/platform/x86/socwatchhv/inc/sw_structs.h
index baac8520e7fd..738edd35de24 100644
--- a/drivers/platform/x86/socwatchhv/inc/sw_structs.h
+++ b/drivers/platform/x86/socwatchhv/inc/sw_structs.h
@@ -1,58 +1,58 @@
-/*
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
 #ifndef __SW_STRUCTS_H__
 #define __SW_STRUCTS_H__ 1
 
@@ -82,7 +82,7 @@ typedef struct sw_string_type {
 	char data[1];
 } sw_string_type_t;
 #pragma pack(pop)
-#define SW_STRING_TYPE_HEADER_SIZE()                                           \
+#define SW_STRING_TYPE_HEADER_SIZE()			\
 	(sizeof(struct sw_string_type) - sizeof(char[1]))
 
 #pragma pack(push, 1)
@@ -91,19 +91,22 @@ struct sw_key_value_payload {
 	char data[1];
 };
 #pragma pack(pop)
-#define SW_KEY_VALUE_PAYLOAD_HEADER_SIZE()                                     \
+#define SW_KEY_VALUE_PAYLOAD_HEADER_SIZE()		\
 	(sizeof(struct sw_key_value_payload) - sizeof(char[1]))
 
 typedef enum sw_kernel_wakelock_type {
-	SW_WAKE_LOCK = 0, /* A kernel wakelock was acquired */
-	SW_WAKE_UNLOCK = 1, /* A kernel wakelock was released */
-	SW_WAKE_LOCK_TIMEOUT =
-		2, /* A kernel wakelock was acquired with a timeout */
-	SW_WAKE_LOCK_INITIAL = 3, /* A kernel wakelock was acquired
-				   * before the collection started
-				   */
-	SW_WAKE_UNLOCK_ALL = 4, /* All previously held kernel wakelocks were */
-	/*   released -- used in ACPI S3 notifications */
+	/* A kernel wakelock was acquired */
+	SW_WAKE_LOCK = 0,
+	/* A kernel wakelock was released */
+	SW_WAKE_UNLOCK = 1,
+	/* A kernel wakelock was acquired with a timeout */
+	SW_WAKE_LOCK_TIMEOUT = 2,
+	/* A kernel wakelock was acquired before the collection started*/
+	SW_WAKE_LOCK_INITIAL = 3,
+	/* All previously held kernel wakelocks were
+	 * released -- used in ACPI S3 notifications
+	 */
+	SW_WAKE_UNLOCK_ALL = 4,
 } sw_kernel_wakelock_type_t;
 
 typedef enum sw_when_type {
@@ -116,18 +119,23 @@ typedef enum sw_when_type {
 } sw_when_type_t;
 
 /**
- * trigger_bits is defined to use type pw_u8_t that makes only up
- * to 8 types possible
+ * trigger_bits is defined to use type pw_u8_t that makes only
+ * upto 8 types possible
  */
-#define SW_TRIGGER_BEGIN_MASK() (1U << SW_WHEN_TYPE_BEGIN)
-#define SW_TRIGGER_END_MASK() (1U << SW_WHEN_TYPE_END)
-#define SW_TRIGGER_POLL_MASK() (1U << SW_WHEN_TYPE_POLL)
-#define SW_TRIGGER_TRACEPOINT_MASK() (1U << SW_WHEN_TYPE_TRACEPOINT)
-#define SW_TRIGGER_NOTIFIER_MASK() (1U << SW_WHEN_TYPE_NOTIFIER)
-#define SW_GET_TRIGGER_MASK_VALUE(m) (1U << (m))
-#define SW_TRIGGER_MASK_ALL() (0xFF)
+#define SW_TRIGGER_BEGIN_MASK()		(1U << SW_WHEN_TYPE_BEGIN)
+#define SW_TRIGGER_END_MASK()		(1U << SW_WHEN_TYPE_END)
+#define SW_TRIGGER_POLL_MASK()		(1U << SW_WHEN_TYPE_POLL)
+#define SW_TRIGGER_TRACEPOINT_MASK()	(1U << SW_WHEN_TYPE_TRACEPOINT)
+#define SW_TRIGGER_NOTIFIER_MASK()	(1U << SW_WHEN_TYPE_NOTIFIER)
+#define SW_GET_TRIGGER_MASK_VALUE(m)	(1U << (m))
+#define SW_TRIGGER_MASK_ALL()		(0xFF)
+
+enum sw_io_cmd {
+	SW_IO_CMD_READ = 0,
+	SW_IO_CMD_WRITE,
+	SW_IO_CMD_MAX
+};
 
-enum sw_io_cmd { SW_IO_CMD_READ = 0, SW_IO_CMD_WRITE, SW_IO_CMD_MAX };
 
 #pragma pack(push, 1)
 struct sw_driver_msr_io_descriptor {
@@ -141,10 +149,8 @@ struct sw_driver_ipc_mmio_io_descriptor {
 	union {
 #ifdef SWW_MERGE
 #pragma warning(push)
-#pragma warning(                                                               \
-	disable : 4201) /* disable C4201: nonstandard extension used:
-			 * nameless struct/union
-			 */
+/* disable C4201: nonstandard extension used: nameless struct/union */
+#pragma warning(disable:4201)
 #endif
 		struct {
 			pw_u16_t command;
@@ -154,13 +160,14 @@ struct sw_driver_ipc_mmio_io_descriptor {
 #pragma warning(pop) /* enable C4201 */
 #endif
 		union {
-			pw_u32_t ipc_command; /* (sub_command << 12)
-					       * | (command)
-					       */
+			/* (sub_command << 12) | (command) */
+			pw_u32_t ipc_command;
 			pw_u8_t is_gbe; /* Used only for GBE MMIO */
 		};
 	};
-	/* TODO: add a section for 'ctrl_address' and 'ctrl_remapped_address' */
+	/* TODO: add a section for 'ctrl_address' and
+	 * 'ctrl_remapped_address'
+	 */
 	union {
 		pw_u64_t data_address; /* Will be "io_remapped" */
 		pw_u64_t data_remapped_address;
@@ -194,10 +201,12 @@ struct sw_driver_configdb_io_descriptor {
 
 #pragma pack(push, 1)
 struct sw_driver_trace_args_io_descriptor {
-	pw_u8_t num_args; /* Number of valid entries in the 'args' array,
-			   * below; 1 <= num_args <= 7
-			   */
-	pw_u8_t args[7]; /* Max of 7 args can be recorded */
+	/* Number of valid entries in the 'args' array, below;
+	 * 1 <= num_args <= 7
+	 */
+	pw_u8_t num_args;
+	/* Max of 7 args can be recorded */
+	pw_u8_t args[7];
 };
 #pragma pack(pop)
 
@@ -205,14 +214,14 @@ struct sw_driver_trace_args_io_descriptor {
 /**
  * struct - sw_driver_telem_io_descriptor - Telemetry Metric descriptor
  *
- * @id:    (Client & Driver) Telemetry ID of the counter to read.
+ * @id:	(Client & Driver) Telemetry ID of the counter to read.
  * @idx:   (Driver only) index into telem array to read, or the row
- *            of the telem_indirect table to lookup the telem array index.
+ *		of the telem_indirect table to lookup the telem array index.
  * @unit:  Unit from which to collect:  0 = PMC, 1 = PUNIT
- *              Values come from the telemetry_unit enum.
+ *		Values come from the telemetry_unit enum.
  * @scale_op:  When there are multiple instances of a telem value (e.g.
- *              module C-states) the operation to use when scaling the CPU ID
- *              and adding it to the telemetry data ID.
+ *		module C-states) the operation to use when scaling the CPU ID
+ *		and adding it to the telemetry data ID.
  * @scale_val: Amount to scale an ID (when scaling one.)
  *
  * Like all hardware mechanism descriptors, the client uses this to pass
@@ -223,13 +232,13 @@ struct sw_driver_trace_args_io_descriptor {
  * the equation: ID = ID_value + (cpuid <scaling_op> <scaling_val>)
  * where <scaling_op> is one of +, *, /, or %, and scaling_val is an integer
  * value.  This gives you:
- *            Operation             scale_op     scale_val
- *       Single instance of an ID       *            0
- *       Sequentially increasing
- *          CPU-specific values         *            1
- *       Per module cpu-specific
- *          values (2 cores/module)     /            2
- *       Round Robin assignment         %         cpu_count
+ *	Operation			scale_op	 	scale_val
+ *	Single instance of an ID	*			0
+ *	sequentially increasing
+ *	CPU-specific values		*			1
+ *	Per module cpu-specific
+ *	values (2 cores/module)		/			2
+ *	Round Robin assignment		%			cpu_count
  *
  * Note that scaling_value of 0 implies that no scaling should be
  * applied.  While (*, 1) is equivalent to (+, 0), the scaling value of 0
@@ -241,21 +250,21 @@ struct sw_driver_trace_args_io_descriptor {
 struct sw_driver_telem_io_descriptor {
 	union {
 		pw_u16_t id;
-		pw_u8_t idx;
+		pw_u8_t  idx;
 	};
-	pw_u8_t unit;
-	pw_u8_t scale_op;
-	pw_u16_t scale_val;
+	pw_u8_t   unit;
+	pw_u8_t   scale_op;
+	pw_u16_t  scale_val;
 };
 #pragma pack(pop)
 enum telemetry_unit { TELEM_PUNIT = 0, TELEM_PMC, TELEM_UNIT_NONE };
-#define TELEM_MAX_ID 0xFFFF /* Maximum value of a Telemtry event ID. */
-#define TELEM_MAX_SCALE 0xFFFF /* Maximum ID scaling value. */
-#define TELEM_OP_ADD '+' /* Addition operator */
-#define TELEM_OP_MULT '*' /* Multiplication operator */
-#define TELEM_OP_DIV '/' /* Division operator */
-#define TELEM_OP_MOD '%' /* Modulus operator */
-#define TELEM_OP_NONE 'X' /* No operator--Not a scaled ID */
+#define TELEM_MAX_ID	0xFFFF  /* Maximum value of a Telemtry event ID. */
+#define TELEM_MAX_SCALE 0xFFFF  /* Maximum ID scaling value. */
+#define TELEM_OP_ADD	'+'	 /* Addition operator */
+#define TELEM_OP_MULT	'*'	 /* Multiplication operator */
+#define TELEM_OP_DIV	'/'	 /* Division operator */
+#define TELEM_OP_MOD	'%'	 /* Modulus operator */
+#define TELEM_OP_NONE	'X'	 /* No operator--Not a scaled ID */
 
 #pragma pack(push, 1)
 struct sw_driver_mailbox_io_descriptor {
@@ -291,8 +300,8 @@ struct sw_driver_pch_mailbox_io_descriptor {
 	};
 	union {
 		/*
-		 * Will be "io_remapped"
-		 */
+	 	* Will be "io_remapped"
+		*/
 		pw_u64_t msg_full_sts_address;
 		pw_u64_t msg_full_sts_remapped_address;
 	};
@@ -312,20 +321,17 @@ typedef struct sw_driver_io_descriptor {
 	pw_u16_t collection_type;
 	/* TODO: specify READ/WRITE */
 	pw_s16_t collection_command; /* One of 'enum sw_io_cmd' */
-	pw_u16_t counter_size_in_bytes; /* The number of bytes to
-					 * READ or WRITE
-					 */
+	pw_u16_t counter_size_in_bytes; /* The number of bytes to READ or WRITE */
 	union {
-		struct sw_driver_msr_io_descriptor msr_descriptor;
-		struct sw_driver_ipc_mmio_io_descriptor ipc_descriptor;
-		struct sw_driver_ipc_mmio_io_descriptor mmio_descriptor;
-		struct sw_driver_pci_io_descriptor pci_descriptor;
-		struct sw_driver_configdb_io_descriptor configdb_descriptor;
-		struct sw_driver_trace_args_io_descriptor trace_args_descriptor;
-		struct sw_driver_telem_io_descriptor telem_descriptor;
-		struct sw_driver_pch_mailbox_io_descriptor
-			pch_mailbox_descriptor;
-		struct sw_driver_mailbox_io_descriptor mailbox_descriptor;
+		struct sw_driver_msr_io_descriptor 		msr_descriptor;
+		struct sw_driver_ipc_mmio_io_descriptor 	ipc_descriptor;
+		struct sw_driver_ipc_mmio_io_descriptor 	mmio_descriptor;
+		struct sw_driver_pci_io_descriptor		pci_descriptor;
+		struct sw_driver_configdb_io_descriptor		configdb_descriptor;
+		struct sw_driver_trace_args_io_descriptor 	trace_args_descriptor;
+		struct sw_driver_telem_io_descriptor		telem_descriptor;
+		struct sw_driver_pch_mailbox_io_descriptor 	pch_mailbox_descriptor;
+		struct sw_driver_mailbox_io_descriptor		mailbox_descriptor;
 	};
 	pw_u64_t write_value; /* The value to WRITE */
 } sw_driver_io_descriptor_t;
@@ -343,49 +349,38 @@ typedef struct sw_driver_io_descriptor {
 struct sw_driver_interface_info {
 	pw_u64_t tracepoint_id_mask;
 	pw_u64_t notifier_id_mask;
-	pw_s16_t cpu_mask; /* On which CPU(s) should the driver
-			    * read the data?
-			    * Currently:  -2 ==> read on ALL CPUs,
-			    *             -1 ==> read on ANY CPU,
-			    *           >= 0 ==> the specific CPU to read on
-			    */
+	pw_s16_t cpu_mask;  /* On which CPU(s) should the driver read the data? */
+			/* Currently:  -2 ==> read on ALL CPUs, */
+			/* -1 ==> read on ANY CPU, */
+			/* >= 0 ==> the specific CPU to read on */
 	pw_s16_t plugin_id; /* Metric Plugin SID */
-	pw_s16_t metric_id; /* Domain-specific ID assigned by each
-			     * Metric Plugin
-			     */
+	pw_s16_t metric_id; /* Domain-specific ID assigned by each Metric Plugin */
 	pw_s16_t msg_id; /* Msg ID retrieved from the SoC Watch config file */
-	pw_u16_t num_io_descriptors; /* Number of descriptors in the array,
-				      * below.
-				      */
-	pw_u8_t trigger_bits; /* Mask of 'when bits' to fire this collector. */
+	pw_u16_t num_io_descriptors; /* Number of descriptors in the array, below. */
+	pw_u8_t  trigger_bits;  /* Mask of 'when bits' to fire this collector. */
 	pw_u16_t sampling_interval_msec; /* Sampling interval, in msecs */
-	pw_u8_t descriptors[1]; /* Array of sw_driver_io_descriptor structs. */
+	pw_u8_t  descriptors[1];	 /* Array of sw_driver_io_descriptor structs. */
 };
 #pragma pack(pop)
 
-#define SW_DRIVER_INTERFACE_INFO_HEADER_SIZE()                                 \
+#define SW_DRIVER_INTERFACE_INFO_HEADER_SIZE()	\
 	(sizeof(struct sw_driver_interface_info) - sizeof(pw_u8_t[1]))
 
 #pragma pack(push, 1)
 struct sw_driver_interface_msg {
-	pw_u16_t num_infos; /* Number of 'sw_driver_interface_info'
-			     * structs contained within the 'infos' variable,
-			     * below
-			     */
-	pw_u16_t min_polling_interval_msecs; /* Min time to wait before
-					      * polling; used exclusively
-					      * with the low overhead,
-					      * context-switch based
-					      * polling mode
-					      */
-					      /* pw_u16_t infos_size_bytes;
-					       * Size of data inlined within the
-					       * 'infos' variable, below
-					       */
+	/* Number of 'sw_driver_interface_info' structs contained within
+	 * the 'infos' variable, below
+	 */
+	pw_u16_t num_infos;
+	/* Min time to wait before polling; used exclusively
+	 * with the low overhead, context-switch based
+	 * polling mode
+	 */
+	pw_u16_t min_polling_interval_msecs;
 	pw_u8_t infos[1];
 };
 #pragma pack(pop)
-#define SW_DRIVER_INTERFACE_MSG_HEADER_SIZE()                                  \
+#define SW_DRIVER_INTERFACE_MSG_HEADER_SIZE()	\
 	(sizeof(struct sw_driver_interface_msg) - sizeof(pw_u8_t[1]))
 
 typedef enum sw_name_id_type {
@@ -402,7 +397,7 @@ struct sw_name_id_pair {
 	struct sw_string_type name;
 };
 #pragma pack(pop)
-#define SW_NAME_ID_HEADER_SIZE()                                               \
+#define SW_NAME_ID_HEADER_SIZE() 		\
 	(sizeof(struct sw_name_id_pair) - sizeof(struct sw_string_type))
 
 #pragma pack(push, 1)
@@ -423,20 +418,23 @@ struct sw_name_info_msg {
 typedef struct sw_driver_msg {
 	pw_u64_t tsc;
 	pw_u16_t cpuidx;
-	pw_u8_t plugin_id; /* Cannot have more than 256 plugins */
-	pw_u8_t metric_id; /* Each plugin cannot handle more than 256 metrics */
-	pw_u8_t msg_id; /* Each metric cannot have more than 256 components */
+	/* Cannot have more than 256 plugins */
+	pw_u8_t  plugin_id;
+	/* Each plugin cannot handle more than 256 metrics */
+	pw_u8_t  metric_id;
+	/* Each metric cannot have more than 256 components */
+	pw_u8_t  msg_id;
 	pw_u16_t payload_len;
-	/* pw_u64_t p_payload;  Ptr to payload */
+	/* pw_u64_t p_payload;  // Ptr to payload */
 	union {
-		pw_u64_t __dummy; /* Ensure size of struct is
-				   * consistent on x86, x64
-				   */
-		char *p_payload; /* Ptr to payload (collected data values). */
+		/* Ensure size of struct is consistent on x86, x64 */
+		pw_u64_t __dummy;
+		/* Ptr to payload (collected data values). */
+		char	*p_payload;
 	};
 } sw_driver_msg_t;
 #pragma pack(pop)
-#define SW_DRIVER_MSG_HEADER_SIZE()                                            \
+#define SW_DRIVER_MSG_HEADER_SIZE() 		\
 	(sizeof(struct sw_driver_msg) - sizeof(pw_u64_t))
 
 typedef enum sw_driver_collection_cmd {
@@ -500,6 +498,21 @@ enum sw_pm_mode {
 
 #define SW_PM_VALUE(mode, action) ((mode) << 16 | (action))
 
+#pragma pack(push, 1)
+/*
+ * Structure for continuous collection
+ */
+struct sw_driver_continuous_collect {
+	/* Size of data that needs to be collected every second */
+	pw_u32_t collection_size;
+	/* struct sw_driver_interface_msg for this collection */
+	pw_u8_t payload[1];
+};
+#define SW_DRIVER_CONTINUOUS_COLLECT_HEADER_SIZE() 		\
+		(sizeof(struct sw_driver_continuous_collect) -	\
+			sizeof(pw_u8_t[1]))
+#pragma pack(pop)
+
 /*
  * Wrapper for ioctl arguments.
  * EVERY ioctl MUST use this struct!
@@ -508,8 +521,8 @@ enum sw_pm_mode {
 struct sw_driver_ioctl_arg {
 	pw_s32_t in_len;
 	pw_s32_t out_len;
-	/* pw_u64_t p_in_arg; Pointer to input arg */
-	/* pw_u64_t p_out_arg; Pointer to output arg */
+	/* pw_u64_t p_in_arg; // Pointer to input arg */
+	/* pw_u64_t p_out_arg; // Pointer to output arg */
 	char *in_arg;
 	char *out_arg;
 };
@@ -517,10 +530,14 @@ struct sw_driver_ioctl_arg {
 
 #pragma pack(push, 1)
 typedef struct sw_driver_msg_interval {
-	pw_u8_t plugin_id; /* Cannot have more than 256 plugins */
-	pw_u8_t metric_id; /* Each plugin cannot handle more than 256 metrics */
-	pw_u8_t msg_id; /* Each metric cannot have more than 256 components */
-	pw_u16_t interval; /* collection interval */
+	/* Cannot have more than 256 plugins */
+	pw_u8_t  plugin_id;
+	/* Each plugin cannot handle more than 256 metrics */
+	pw_u8_t  metric_id;
+	/* Each metric cannot have more than 256 components */
+	pw_u8_t  msg_id;
+	/* collection interval */
+	pw_u16_t interval;
 } sw_driver_msg_interval_t;
 #pragma pack(pop)
 
diff --git a/drivers/platform/x86/socwatchhv/inc/sw_types.h b/drivers/platform/x86/socwatchhv/inc/sw_types.h
index 156c92c8349a..e9af829c31c8 100644
--- a/drivers/platform/x86/socwatchhv/inc/sw_types.h
+++ b/drivers/platform/x86/socwatchhv/inc/sw_types.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef _PW_TYPES_H_
 #define _PW_TYPES_H_
@@ -68,7 +67,7 @@
 /*
  * UNSIGNED types...
  */
-typedef uint8_t u8;
+typedef uint8_t  u8;
 typedef uint16_t u16;
 typedef uint32_t u32;
 typedef uint64_t u64;
@@ -87,13 +86,13 @@ typedef int64_t s64;
 #include <sys/types.h>
 #include <stdint.h> /* Grab 'uint64_t' etc. */
 
-typedef uint8_t u8;
+typedef uint8_t  u8;
 typedef uint16_t u16;
 typedef uint32_t u32;
 typedef uint64_t u64;
 /*
- * SIGNED types...
- */
+* SIGNED types...
+*/
 typedef int8_t s8;
 typedef int16_t s16;
 typedef int32_t s32;
diff --git a/drivers/platform/x86/socwatchhv/inc/sw_version.h b/drivers/platform/x86/socwatchhv/inc/sw_version.h
index 5476b0d79ac5..b6fe1eecdd0e 100644
--- a/drivers/platform/x86/socwatchhv/inc/sw_version.h
+++ b/drivers/platform/x86/socwatchhv/inc/sw_version.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef __SW_VERSION_H__
 #define __SW_VERSION_H__ 1
@@ -61,14 +60,14 @@
  * SOCWatch driver version
  */
 #define SW_DRIVER_VERSION_MAJOR 2
-#define SW_DRIVER_VERSION_MINOR 6
-#define SW_DRIVER_VERSION_OTHER 2
+#define SW_DRIVER_VERSION_MINOR 10
+#define SW_DRIVER_VERSION_OTHER 0
 
 /*
  * Every SOC Watch userspace component shares the same version number.
  */
 #define SOCWATCH_VERSION_MAJOR 2
-#define SOCWATCH_VERSION_MINOR 8
-#define SOCWATCH_VERSION_OTHER 0
+#define SOCWATCH_VERSION_MINOR 10
+#define SOCWATCH_VERSION_OTHER 1
 
 #endif /* __SW_VERSION_H__ */
diff --git a/drivers/platform/x86/socwatchhv/inc/swhv_acrn.h b/drivers/platform/x86/socwatchhv/inc/swhv_acrn.h
index 2bcc97a84bbc..cfacb3bba7c8 100644
--- a/drivers/platform/x86/socwatchhv/inc/swhv_acrn.h
+++ b/drivers/platform/x86/socwatchhv/inc/swhv_acrn.h
@@ -1,3 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 #ifndef _SWHV_ACRN_H_
 #define _SWHV_ACRN_H_ 1
 
@@ -18,30 +73,27 @@
 #include "swhv_defines.h"
 #include "pw_version.h"
 
-#define SW_DEFINE_LIST_HEAD(name, dummy) struct list_head name
-#define SW_DECLARE_LIST_HEAD(name, dummy) extern struct list_head name
-#define SW_LIST_ENTRY(name, dummy) struct list_head name
-#define SW_LIST_HEAD_VAR(dummy) struct list_head
-#define SW_LIST_HEAD_INIT(head) INIT_LIST_HEAD(head)
-#define SW_LIST_ENTRY_INIT(node, field) INIT_LIST_HEAD(&node->field)
-#define SW_LIST_ADD(head, node, field) list_add_tail(&node->field, head)
-#define SW_LIST_GET_HEAD_ENTRY(head, type, field)                              \
-	list_first_entry(head, struct type, field)
-#define SW_LIST_UNLINK(node, field) list_del(&node->field)
-#define SW_LIST_FOR_EACH_ENTRY(node, head, field)                              \
-	list_for_each_entry(node, head, field)
-#define SW_LIST_EMPTY(head) list_empty(head)
-#define SW_LIST_HEAD_INITIALIZER(head) LIST_HEAD_INIT(head)
+#define SW_DEFINE_LIST_HEAD(name, dummy)            struct list_head name
+#define SW_DECLARE_LIST_HEAD(name, dummy)           extern struct list_head name
+#define SW_LIST_ENTRY(name, dummy)                  struct list_head name
+#define SW_LIST_HEAD_VAR(dummy)                     struct list_head
+#define SW_LIST_HEAD_INIT(head)                     INIT_LIST_HEAD(head)
+#define SW_LIST_ENTRY_INIT(node, field)             INIT_LIST_HEAD(&node->field)
+#define SW_LIST_ADD(head, node, field)              list_add_tail(&node->field, head)
+#define SW_LIST_GET_HEAD_ENTRY(head, type, field)   list_first_entry(head, struct type, field)
+#define SW_LIST_UNLINK(node, field)                 list_del(&node->field)
+#define SW_LIST_FOR_EACH_ENTRY(node, head, field)   list_for_each_entry(node, head, field)
+#define SW_LIST_EMPTY(head)                         list_empty(head)
+#define SW_LIST_HEAD_INITIALIZER(head)              LIST_HEAD_INIT(head)
 
 int device_open_i(struct inode *inode, struct file *file);
 
 ssize_t device_read_i(struct file *file, /* see include/linux/fs.h   */
-		      char __user *buffer, /* buffer to be filled with data */
-		      size_t length, /* length of the buffer */
-		      loff_t *offset);
+	char __user *buffer, /* buffer to be filled with data */
+	size_t length, /* length of the buffer */
+	loff_t *offset);
 
-long swhv_configure(struct swhv_driver_interface_msg __user *remote_msg,
-		    int local_len);
+long swhv_configure(struct swhv_driver_interface_msg __user *remote_msg, int local_len);
 long swhv_start(void);
 long swhv_stop(void);
 long swhv_get_cpu_count(u32 __user *remote_args);
@@ -55,63 +107,60 @@ long swhv_msr_read(u32 __user *remote_in_args, u64 __user *remote_args);
 long swhv_collection_poll(void);
 
 enum MSR_CMD_TYPE {
-	MSR_OP_NONE = 0,
-	MSR_OP_READ,
-	MSR_OP_WRITE,
-	MSR_OP_READ_CLEAR
+    MSR_OP_NONE = 0,
+    MSR_OP_READ,
+    MSR_OP_WRITE,
+    MSR_OP_READ_CLEAR
 };
 
-enum MSR_CMD_STATUS { MSR_OP_READY = 0, MSR_OP_REQUESTED, MSR_OP_HANDLED };
+enum MSR_CMD_STATUS {
+    MSR_OP_READY = 0,
+    MSR_OP_REQUESTED,
+    MSR_OP_HANDLED
+};
 
 struct profiling_msr_op {
-	/* value to write or location to write into */
-	uint64_t value;
-	/* MSR address to read/write; last entry will have value of -1 */
-	uint32_t msr_id;
-	/* parameter; usage depends on operation */
-	uint16_t param;
-	uint8_t msr_op_type;
-	uint8_t reg_type;
+    /* value to write or location to write into */
+    uint64_t value;
+    /* MSR address to read/write; last entry will have value of -1 */
+    uint32_t msr_id;
+    /* parameter; usage depends on operation */
+    uint16_t param;
+    uint8_t msr_op_type;
+    uint8_t reg_type;
 };
 
 #define MAX_MSR_LIST_NUM 15
 struct profiling_msr_ops_list {
-	int32_t collector_id;
-	uint32_t num_entries;
-	int32_t msr_op_state; /* enum value from 'MSR_CMD_STATUS' */
-	struct profiling_msr_op entries[MAX_MSR_LIST_NUM];
+    int32_t collector_id;
+    uint32_t num_entries;
+    int32_t msr_op_state;   /* enum value from 'MSR_CMD_STATUS' */
+    struct profiling_msr_op entries[MAX_MSR_LIST_NUM];
 };
 
 #define COLLECTOR_SOCWATCH 1
 
 struct profiling_control {
-	int32_t collector_id;
-	int32_t reserved;
-	uint64_t switches;
+    int32_t collector_id;
+    int32_t reserved;
+    uint64_t switches;
 };
 
 /**
- * struct - sw_collector_data
- * Information about the collector to be invoked at collection time.
- *
- * The collector_lists array holds linked lists of collectors to
- * be exercised at specific points in time during the collection
- * (e.g. begin, poll, end, etc.).  At a trigger time, the driver walks
- * that time's list of nodes, and exercises the collectors on that list.
+ * struct - swhv_acrn_msr_collector_data
+ * Information about the MSR collector to be invoked at collection time.
  *
  * @list:                   List/link implementation
- * @cpumask:                Collect if cpu matches mask
- * @info:                   Ptr to metric info
- * @ops:                    Ptr to collector's operations
- * @last_update_jiffies:    Indicates when this node was last exercised.
+ * @cpu_mask:               Collect if cpu matches mask
+ * @sample_id:              ID of the metric requesting these operations
+ * @msr_ops_list:           Ptr to list of MSR read/write operations
  * @per_msg_payload_size:   Data size
- * @msg:                    Ptr to collected data
  */
 typedef struct swhv_acrn_msr_collector_data {
-	SW_LIST_ENTRY(list, swhv_acrn_msr_collector_data);
-	pw_s16_t cpu_mask;
-	pw_s16_t sample_id;
-	struct profiling_msr_ops_list *msr_ops_list;
-	size_t per_msg_payload_size;
+    SW_LIST_ENTRY(list, swhv_acrn_msr_collector_data);
+    pw_s16_t                        cpu_mask;
+    pw_s16_t                        sample_id;
+    struct profiling_msr_ops_list *msr_ops_list;
+    size_t                          per_msg_payload_size;
 } swhv_acrn_msr_collector_data_t;
 #endif /* _SWHV_ACRN_H_ */
diff --git a/drivers/platform/x86/socwatchhv/inc/swhv_acrn_sbuf.h b/drivers/platform/x86/socwatchhv/inc/swhv_acrn_sbuf.h
index 5f62c2d43e11..4bbaafb72923 100644
--- a/drivers/platform/x86/socwatchhv/inc/swhv_acrn_sbuf.h
+++ b/drivers/platform/x86/socwatchhv/inc/swhv_acrn_sbuf.h
@@ -1,3 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 #ifndef _SWHV_ACRN_SBUF_H_
 #define _SWHV_ACRN_SBUF_H_ 1
 
@@ -8,11 +63,11 @@
  */
 static inline bool sbuf_is_empty(struct shared_buf *sbuf)
 {
-	return (sbuf->head == sbuf->tail);
+    return (sbuf->head == sbuf->tail);
 }
 
-static inline uint32_t sbuf_next_ptr(uint32_t pos, uint32_t span,
-				     uint32_t scope)
+static inline uint32_t sbuf_next_ptr(uint32_t pos,
+	uint32_t span, uint32_t scope)
 {
 	pos += span;
 	pos = (pos >= scope) ? (pos - scope) : pos;
@@ -28,9 +83,9 @@ inline uint32_t sbuf_available_space(struct shared_buf *sbuf)
 	uint32_t remaining_space;
 	/*
 	 * if tail isn't wrapped around
-	 *      subtract difference of tail and head from size
+	 *	  subtract difference of tail and head from size
 	 * otherwise
-	 *      difference between head and tail
+	 *	  difference between head and tail
 	 */
 	if (sbuf->tail >= sbuf->head)
 		remaining_space = sbuf->size - (sbuf->tail - sbuf->head);
@@ -53,8 +108,8 @@ int sbuf_get_variable(struct shared_buf *sbuf, void **data, uint32_t size)
 	 * 2. check if enough ('size' bytes) data to be read is present.
 	 * 3. Continue if buffer has enough data
 	 * 4. Copy data from buffer
-	 *      4a. copy data in 2 parts if there is a wrap-around
-	 *      4b. Otherwise do a simple copy
+	 *	  4a. copy data in 2 parts if there is a wrap-around
+	 *	  4b. Otherwise do a simple copy
 	 */
 	const void *from;
 	uint32_t current_data_size, offset = 0, next_head;
@@ -113,34 +168,33 @@ int sbuf_get_wrapper(struct shared_buf *sbuf, uint8_t **data)
 	uint32_t payload_size, sample_size, _size;
 
 	/*
-	 * Assumption: A partial variable sample will not be written
-	 *             to the buffer.
+	 * Assumption: A partial variable sample will not be written to
+	 *	  the buffer.
 	 * do while buf isn't empty
 	 *  Read header from the buffer
-	 *      write to data
-	 *      get size of payload
-	 *      check if the size of 'data' is enough for the
-	 *      variable sample to be read to
+	 *	  write to data
+	 *	  get size of payload
+	 *	  check if the size of 'data' is enough for the variable
+	 *	  sample to be read to
 	 *  Read the payload
-	 *      Keep reading ele_size chunks till available and write to data
-	 *      if the last chunk is less than ele_size, do a partial copy to
-	 *      data
+	 *	  Keep reading ele_size chunks till available and write to data
+	 *	  if the last chunk is less than ele_size, do a partial
+	 *	  copy to data
 	 *
 	 *
 	 */
 	if ((sbuf == NULL) || (data == NULL))
 		return -EINVAL;
 
-	if (sbuf_is_empty(sbuf)) {
-		/* no data available */
+	if (sbuf_is_empty(sbuf)) /* no data available */
 		return 0;
-	}
+
 
 	sample_offset = 0;
 
 	header = vmalloc(sizeof(ACRN_MSG_HEADER_SIZE));
 	memset(header, 0, sizeof(ACRN_MSG_HEADER_SIZE));
-	/*read header */
+	/* read header */
 	sbuf_get(sbuf, (uint8_t *)header);
 
 	payload_size = header->payload_size;
@@ -149,7 +203,7 @@ int sbuf_get_wrapper(struct shared_buf *sbuf, uint8_t **data)
 
 	sample = vmalloc(sample_size);
 
-	/*copy header */
+	/* copy header */
 	memcpy((void *)sample, (void *)header, ACRN_MSG_HEADER_SIZE);
 
 	sample_offset += ACRN_MSG_HEADER_SIZE;
@@ -165,16 +219,17 @@ int sbuf_get_wrapper(struct shared_buf *sbuf, uint8_t **data)
 				"error: payload has to be multiple of 32\n");
 			return 0;
 			/*
-			 * This code can be enabled when support for variable
-			 * sized samples needs to be added.
+			 * This code can be enabled when support for
+			 * variable sized samples needs to be added.
 			 */
-#if 0
+/* #if 0
 			chunk = malloc(sbuf->ele_size);
 			sbuf_get(sbuf, chunk);
-			memcpys((void *)(sample + sample_offset), _size, chunk);
+			memcpys((void *)(sample + sample_offset),
+					_size, chunk);
 			_size -= _size;
 			free(chunk);
-#endif
+#endif */
 		}
 	}
 
diff --git a/drivers/platform/x86/socwatchhv/inc/swhv_defines.h b/drivers/platform/x86/socwatchhv/inc/swhv_defines.h
index 2f51a5d760f6..b70cef1616a9 100644
--- a/drivers/platform/x86/socwatchhv/inc/swhv_defines.h
+++ b/drivers/platform/x86/socwatchhv/inc/swhv_defines.h
@@ -1,70 +1,68 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef _SWHV_DEFINES_H_
-#define _SWHV_DEFINES_H_
+#define  _SWHV_DEFINES_H_
 
 /* ***************************************************
  * Common to kernel and userspace.
  * ***************************************************
  */
-#define PW_SUCCESS 0
-#define PW_ERROR 1
-#define PW_SUCCESS_NO_COLLECT 2
+#define PW_SUCCESS              0
+#define PW_ERROR                1
+#define PW_SUCCESS_NO_COLLECT   2
 
 /*
  * Start off with none of the OS'es are defined
@@ -81,8 +79,8 @@
 
 /*
  * Make sure one (and only one) of the OS'es gets defined here
- *
- * Unfortunately entirex defines _WIN32 so we need to check for linux
+ */
+/* Unfortunately entirex defines _WIN32 so we need to check for linux
  * first.  The definition of these flags is one and only one
  * _OS_xxx is allowed to be defined.
  */
@@ -101,11 +99,11 @@
  * as well as one (and only one) pointer__ size
  */
 #if defined(_M_IX86) || defined(__i386__)
-#define SWDRV_IA32
+	#define SWDRV_IA32
 #elif defined(_M_AMD64) || defined(__x86_64__)
-#define SWDRV_EM64T
+	#define SWDRV_EM64T
 #else
-#error "Unknown architecture for compilation"
+	#error "Unknown architecture for compilation"
 #endif
 
 #endif /* _SWHV_DEFINES_H_ */
diff --git a/drivers/platform/x86/socwatchhv/inc/swhv_driver.h b/drivers/platform/x86/socwatchhv/inc/swhv_driver.h
index f2f9f662b311..d1940649ec01 100644
--- a/drivers/platform/x86/socwatchhv/inc/swhv_driver.h
+++ b/drivers/platform/x86/socwatchhv/inc/swhv_driver.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef _SWHV_DRIVER_H_
 #define _SWHV_DRIVER_H_ 1
@@ -75,7 +74,7 @@ extern void SYS_Perfvec_Handler(void);
 extern short SYS_Get_cs(void);
 
 #if defined(SWDRV_IA32) && (SOCWATCH_IDT_IRQ)
-extern void *SYS_Get_IDT_Base_HWR(void); /* IDT base from hardware IDTR */
+extern void *SYS_Get_IDT_Base_HWR(void);   /* / IDT base from hardware IDTR */
 
 #define SYS_Get_IDT_Base SYS_Get_IDT_Base_HWR
 #endif /* defined(SWDRV_IA32) && (SOCWATCH_IDT_IRQ) */
@@ -94,10 +93,10 @@ typedef struct gate_struct64 gate_struct_t;
 #define CPU() (raw_smp_processor_id())
 #define GET_BOOL_STRING(b) ((b) ? "TRUE" : "FALSE")
 
-#define _STRINGIFY(x) #x
-#define STRINGIFY(x) _STRINGIFY(x)
-#define _STRINGIFY_W(x) (L#x)
-#define STRINGIFY_W(x) _STRINGIFY_W(x)
+#define _STRINGIFY(x)     #x
+#define STRINGIFY(x)      _STRINGIFY(x)
+#define _STRINGIFY_W(x)   L#x
+#define STRINGIFY_W(x)    _STRINGIFY_W(x)
 
 /*
  * 64bit Compare-and-swap.
diff --git a/drivers/platform/x86/socwatchhv/inc/swhv_ioctl.h b/drivers/platform/x86/socwatchhv/inc/swhv_ioctl.h
index 0d2a368c12ca..0807177f3bf1 100644
--- a/drivers/platform/x86/socwatchhv/inc/swhv_ioctl.h
+++ b/drivers/platform/x86/socwatchhv/inc/swhv_ioctl.h
@@ -1,72 +1,72 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
-*/
 #ifndef __SWHV_IOCTL_H__
 #define __SWHV_IOCTL_H__
 
 #include "pw_types.h"
 
 #if defined(__linux__) || defined(__QNX__)
-#if __KERNEL__
-#include <linux/ioctl.h>
-#if defined(HAVE_COMPAT_IOCTL) && defined(CONFIG_X86_64)
-#include <linux/compat.h>
-#endif /* COMPAT && x64 */
-#else /* !__KERNEL__ */
-#include <sys/ioctl.h>
-#endif /* __KERNEL__ */
+	#if __KERNEL__
+		#include <linux/ioctl.h>
+		#if defined(HAVE_COMPAT_IOCTL) && defined(CONFIG_X86_64)
+			#include <linux/compat.h>
+		#endif /* COMPAT && x64 */
+	#else /* !__KERNEL__ */
+		#include <sys/ioctl.h>
+	#endif /* __KERNEL__ */
 #endif /* __linux__ */
 /*
  * Path to the Hypervisor driver device file.
@@ -80,20 +80,20 @@
  * are delivered to the correct
  * driver.
  */
-#define SP_IOC_MAGIC 99
+#define SP_IOC_MAGIC			99
 /*
  * CONSTANTS that define the various operations.
  * TODO: convert to enum?
  */
-#define SWHVDRV_OPERATION_CONFIGURE 1 /* configure a collection */
-#define SWHVDRV_OPERATION_CMD 2 /* control a collection */
-#define SWHVDRV_OPERATION_VERSION 3 /* retrieve driver version info */
-#define SWHVDRV_OPERATION_CLOCK 4 /* retrieve STM clock */
-#define SWHVDRV_OPERATION_TOPOLOGY 5 /* retrieve CPU topology */
-#define SWHVDRV_OPERATION_CPUCOUNT 6 /* retrieve CPU count */
+#define SWHVDRV_OPERATION_CONFIGURE	1 /* configure a collection */
+#define SWHVDRV_OPERATION_CMD		2 /* control a collection */
+#define SWHVDRV_OPERATION_VERSION	3 /* retrieve driver version info */
+#define SWHVDRV_OPERATION_CLOCK		4 /* retrieve STM clock */
+#define SWHVDRV_OPERATION_TOPOLOGY	5 /* retrieve CPU topology */
+#define SWHVDRV_OPERATION_CPUCOUNT	6 /* retrieve CPU count */
 #define SWHVDRV_OPERATION_HYPERVISOR_TYPE 7 /* retrieve hypervisor type */
-#define SWHVDRV_OPERATION_MSR_READ 8 /* retrieve MSR value */
-#define SWHVDRV_OPERATION_POLL 9 /* Polling tick */
+#define SWHVDRV_OPERATION_MSR_READ	8 /* retrieve MSR value */
+#define SWHVDRV_OPERATION_POLL		9 /* Polling tick */
 
 enum swhv_ioctl_cmd {
 	swhv_ioctl_cmd_none = 0,
@@ -116,49 +116,46 @@ enum swhv_ioctl_cmd {
  * Where "Read" and "Write" are from the user's perspective
  * (similar to the file "read" and "write" calls).
  */
-#define SWHVDRV_IOCTL_CONFIGURE                                                \
-	_IOW(SP_IOC_MAGIC, SWHVDRV_OPERATION_CONFIGURE,                        \
-	     struct spdrv_ioctl_arg *)
-#define SWHVDRV_IOCTL_CMD                                                      \
+#define SWHVDRV_IOCTL_CONFIGURE						\
+	_IOW(SP_IOC_MAGIC, SWHVDRV_OPERATION_CONFIGURE, struct spdrv_ioctl_arg *)
+#define SWHVDRV_IOCTL_CMD						\
 	_IOW(SP_IOC_MAGIC, SWHVDRV_OPERATION_CMD, struct spdrv_ioctl_arg *)
-#define SWHVDRV_IOCTL_VERSION                                                  \
+#define SWHVDRV_IOCTL_VERSION						\
 	_IOR(SP_IOC_MAGIC, SWHVDRV_OPERATION_VERSION, struct spdrv_ioctl_arg *)
-#define SWHVDRV_IOCTL_CLOCK                                                    \
+#define SWHVDRV_IOCTL_CLOCK						\
 	_IOR(SP_IOC_MAGIC, SWHVDRV_OPERATION_CLOCK, struct spdrv_ioctl_arg *)
-#define SWHVDRV_IOCTL_TOPOLOGY                                                 \
+#define SWHVDRV_IOCTL_TOPOLOGY						\
 	_IOR(SP_IOC_MAGIC, SWHVDRV_OPERATION_TOPOLOGY, struct spdrv_ioctl_arg *)
-#define SWHVDRV_IOCTL_CPUCOUNT                                                 \
+#define SWHVDRV_IOCTL_CPUCOUNT						\
 	_IOR(SP_IOC_MAGIC, SWHVDRV_OPERATION_CPUCOUNT, struct spdrv_ioctl_arg *)
-#define SWHVDRV_IOCTL_HYPERVISOR_TYPE                                          \
-	_IOR(SP_IOC_MAGIC, SWHVDRV_OPERATION_HYPERVISOR_TYPE,                  \
-	     struct spdrv_ioctl_arg *)
-#define SWHVDRV_IOCTL_MSR_READ                                                 \
-	_IOWR(SP_IOC_MAGIC, SWHVDRV_OPERATION_MSR_READ,                        \
-	      struct spdrv_ioctl_arg *)
-#define SWHVDRV_IOCTL_POLL                                                     \
+#define SWHVDRV_IOCTL_HYPERVISOR_TYPE					\
+	_IOR(SP_IOC_MAGIC, SWHVDRV_OPERATION_HYPERVISOR_TYPE, struct spdrv_ioctl_arg *)
+#define SWHVDRV_IOCTL_MSR_READ						\
+	_IOWR(SP_IOC_MAGIC, SWHVDRV_OPERATION_MSR_READ, struct spdrv_ioctl_arg *)
+#define SWHVDRV_IOCTL_POLL						\
 	_IO(SP_IOC_MAGIC, SWHVDRV_OPERATION_POLL, struct spdrv_ioctl_arg *)
 
 #if defined(HAVE_COMPAT_IOCTL) && defined(CONFIG_X86_64)
-#include <linux/compat.h>
+  #include <linux/compat.h>
 
-#define SWHVDRV_IOCTL_CONFIGURE32                                              \
-	_IOW(SP_IOC_MAGIC, SWHVDRV_OPERATION_CONFIGURE, compat_uptr_t)
-#define SWHVDRV_IOCTL_CMD32                                                    \
+  #define SWHVDRV_IOCTL_CONFIGURE32					\
+	_IOW(SP_IOC_MAGIC,  SWHVDRV_OPERATION_CONFIGURE, compat_uptr_t)
+  #define SWHVDRV_IOCTL_CMD32						\
 	_IOW(SP_IOC_MAGIC, SWHVDRV_OPERATION_CMD, compat_uptr_t)
-#define SWHVDRV_IOCTL_VERSION32                                                \
-	_IOR(SP_IOC_MAGIC, SWHVDRV_OPERATION_VERSION, compat_uptr_t)
-#define SWHVDRV_IOCTL_CLOCK32                                                  \
-	_IOR(SP_IOC_MAGIC, SWHVDRV_OPERATION_CLOCK, compat_uptr_t)
-#define SWHVDRV_IOCTL_TOPOLOGY32                                               \
-	_IOR(SP_IOC_MAGIC, SWHVDRV_OPERATION_TOPOLOGY, compat_uptr_t)
-#define SWHVDRV_IOCTL_CPUCOUNT32                                               \
-	_IOR(SP_IOC_MAGIC, SWHVDRV_OPERATION_CPUCOUNT, compat_uptr_t)
-#define SWHVDRV_IOCTL_HYPERVISOR_TYPE32                                        \
-	_IOR(SP_IOC_MAGIC, SWHVDRV_OPERATION_HYPERVISOR_TYPE, compat_uptr_t)
-#define SWHVDRV_IOCTL_MSR_READ32                                               \
-	_IOWR(SP_IOC_MAGIC, SWHVDRV_OPERATION_MSR_READ, compat_uptr_t)
-#define SWHVDRV_IOCTL_POLL32                                                   \
-	_IO(SP_IOC_MAGIC, SWHVDRV_OPERATION_POLL, compat_uptr_t)
+  #define SWHVDRV_IOCTL_VERSION32					\
+	_IOR(SP_IOC_MAGIC,  SWHVDRV_OPERATION_VERSION, compat_uptr_t)
+  #define SWHVDRV_IOCTL_CLOCK32						\
+	_IOR(SP_IOC_MAGIC,  SWHVDRV_OPERATION_CLOCK, compat_uptr_t)
+  #define SWHVDRV_IOCTL_TOPOLOGY32					\
+	_IOR(SP_IOC_MAGIC,  SWHVDRV_OPERATION_TOPOLOGY, compat_uptr_t)
+  #define SWHVDRV_IOCTL_CPUCOUNT32		  			\
+	_IOR(SP_IOC_MAGIC,  SWHVDRV_OPERATION_CPUCOUNT, compat_uptr_t)
+  #define SWHVDRV_IOCTL_HYPERVISOR_TYPE32				\
+	_IOR(SP_IOC_MAGIC,  SWHVDRV_OPERATION_HYPERVISOR_TYPE, compat_uptr_t)
+  #define SWHVDRV_IOCTL_MSR_READ32					\
+	_IOWR(SP_IOC_MAGIC,  SWHVDRV_OPERATION_MSR_READ, compat_uptr_t)
+  #define SWHVDRV_IOCTL_POLL32						\
+	_IO(SP_IOC_MAGIC,  SWHVDRV_OPERATION_POLL, compat_uptr_t)
 #endif /* COMPAT && x64 */
 
 #endif /* __SWHV_IOCTL_H__ */
diff --git a/drivers/platform/x86/socwatchhv/inc/swhv_structs.h b/drivers/platform/x86/socwatchhv/inc/swhv_structs.h
index 0393a95e4875..3922d39601f4 100644
--- a/drivers/platform/x86/socwatchhv/inc/swhv_structs.h
+++ b/drivers/platform/x86/socwatchhv/inc/swhv_structs.h
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #ifndef _SWHV_STRUCTS_H_
 #define _SWHV_STRUCTS_H_ 1
@@ -100,7 +99,11 @@ enum swhv_collector_type {
 	SWHV_COLLECTOR_TYPE_MSR,
 };
 
-enum swhv_io_cmd { SWHV_IO_CMD_READ = 0, SWHV_IO_CMD_WRITE, SWHV_IO_CMD_MAX };
+enum swhv_io_cmd {
+	SWHV_IO_CMD_READ = 0,
+	SWHV_IO_CMD_WRITE,
+	SWHV_IO_CMD_MAX
+};
 
 #pragma pack(push, 1)
 struct swhv_driver_msr_io_descriptor {
@@ -117,11 +120,12 @@ struct swhv_driver_switch_io_descriptor {
 
 #pragma pack(push, 1)
 typedef struct swhv_driver_io_descriptor {
-	pw_u16_t collection_type; /* One of 'enum swhv_collector_type' */
-	pw_s16_t collection_command; /* One of 'enum swhv_io_cmd' */
-	pw_u16_t counter_size_in_bytes; /* The number of bytes to
-					 * READ or WRITE
-					 */
+	/* One of 'enum swhv_collector_type' */
+	pw_u16_t collection_type;
+	/* One of 'enum swhv_io_cmd' */
+	pw_s16_t collection_command;
+	/* The number of bytes to READ or WRITE */
+	pw_u16_t counter_size_in_bytes;
 	union {
 		struct swhv_driver_msr_io_descriptor msr_descriptor;
 		struct swhv_driver_switch_io_descriptor switch_descriptor;
@@ -132,47 +136,42 @@ typedef struct swhv_driver_io_descriptor {
 
 #pragma pack(push, 1)
 struct swhv_driver_interface_info {
-	pw_s16_t cpu_mask; /* On which CPU(s) should the driver
-			    * read the data?
-			    */
-		/* Currently:  -2 ==> read on ALL CPUs,
-		 *             -1 ==> read on ANY CPU,
-		 *           >= 0 ==> the specific CPU to read on
-		 */
-	pw_s16_t sample_id; /* Sample ID, used to map it back
-			     * to Metric Plugin, Metric and Msg ID combo
-			     */
-	pw_u16_t num_io_descriptors; /* Number of descriptors in the array,
-				      * below.
-				      */
-	pw_u8_t descriptors[1]; /* Array of swhv_driver_io_descriptor
-				 * structs.
-				 */
+	/* On which CPU(s) should the driver read the data?
+	 * Currently:  -2 ==> read on ALL CPUs,
+	 * -1 ==> read on ANY CPU,
+	 * >= 0 ==> the specific CPU to read on
+	 */
+	pw_s16_t cpu_mask;
+	/* Sample ID, used to map it back to Metric Plugin,
+	 * Metric and Msg ID combo
+         */
+	pw_s16_t sample_id;
+	/* Number of descriptors in the array, below. */
+	pw_u16_t num_io_descriptors;
+	/* Array of swhv_driver_io_descriptor structs. */
+	pw_u8_t  descriptors[1];
 };
 #pragma pack(pop)
-#define SWHV_DRIVER_INTERFACE_INFO_HEADER_SIZE()                               \
+#define SWHV_DRIVER_INTERFACE_INFO_HEADER_SIZE() 	\
 	(sizeof(struct swhv_driver_interface_info) - sizeof(pw_u8_t[1]))
 
 #pragma pack(push, 1)
 struct swhv_driver_interface_msg {
-	pw_u16_t num_infos; /* Number of 'swhv_driver_interface_info'
-			     * structs contained within the 'infos' variable,
-			     * below
-			     */
-	/* pw_u16_t infos_size_bytes; Size of data inlined within
+	/* Number of 'swhv_driver_interface_info' structs contained within
 	 * the 'infos' variable, below
 	 */
+	pw_u16_t num_infos;
 	pw_u8_t infos[1];
 };
 #pragma pack(pop)
-#define SWHV_DRIVER_INTERFACE_MSG_HEADER_SIZE()                                \
+#define SWHV_DRIVER_INTERFACE_MSG_HEADER_SIZE() 	\
 	(sizeof(struct swhv_driver_interface_msg) - sizeof(pw_u8_t[1]))
 
 /*
  * ACRN specific structs, copied from the ACRN profiling service
  * DO NOT modify these below stucts
  */
-#define SBUF_HEAD_SIZE 64 /* bytes */
+#define SBUF_HEAD_SIZE  64 /* bytes */
 
 typedef enum PROFILING_SOCWATCH_FEATURE {
 	SOCWATCH_COMMAND = 0,
@@ -205,7 +204,7 @@ struct vm_switch_trace {
 #define VM_SWITCH_TRACE_SIZE ((uint64_t)sizeof(struct vm_switch_trace))
 
 #define CONFIG_MAX_VCPUS_PER_VM 8
-#define CONFIG_MAX_VM_NUM       6
+#define CONFIG_MAX_VM_NUM	   6
 
 struct profiling_vcpu_pcpu_map {
 	int16_t vcpu_id;
@@ -236,16 +235,18 @@ typedef struct vm_switch_trace vmswitch_trace_t;
  * ACRN specific constants shared between the driver and user-mode
  */
 /* Per CPU buffer size */
-#define ACRN_BUF_SIZE ((4 * 1024 * 1024) - SBUF_HEAD_SIZE /* 64 bytes */)
+#define ACRN_BUF_SIZE				\
+	((4 * 1024 * 1024) - SBUF_HEAD_SIZE /* 64 bytes */)
 /* Size of buffer at which data should be transferred to user-mode */
-#define ACRN_BUF_TRANSFER_SIZE (ACRN_BUF_SIZE / 2)
+#define ACRN_BUF_TRANSFER_SIZE	  (ACRN_BUF_SIZE / 2)
 /*
  * The ACRN 'sbuf' buffers consist of fixed size elements.
  * This is how they are intended to be used, though SoCWatch only uses it to
  * allocate the correct buffer size.
  */
-#define ACRN_BUF_ELEMENT_SIZE 32 /* byte */
-#define ACRN_BUF_ELEMENT_NUM (ACRN_BUF_SIZE / ACRN_BUF_ELEMENT_SIZE)
-#define ACRN_BUF_FILLED_SIZE(sbuf) (sbuf->size - sbuf_available_space(sbuf))
+#define ACRN_BUF_ELEMENT_SIZE	   	32 /* byte */
+#define ACRN_BUF_ELEMENT_NUM		(ACRN_BUF_SIZE / ACRN_BUF_ELEMENT_SIZE)
+#define ACRN_BUF_FILLED_SIZE(sbuf)  		\
+			(sbuf->size - sbuf_available_space(sbuf))
 
 #endif /* _SWHV_STRUCTS_H_ */
diff --git a/drivers/platform/x86/socwatchhv/swhv_acrn.c b/drivers/platform/x86/socwatchhv/swhv_acrn.c
index 962db47cec45..2506388cb1a7 100644
--- a/drivers/platform/x86/socwatchhv/swhv_acrn.c
+++ b/drivers/platform/x86/socwatchhv/swhv_acrn.c
@@ -1,3 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/timer.h>
@@ -34,9 +89,8 @@
 static int pcpu_num;
 bool flush_mode;
 
-/* TODO is this needed?
- * module_param(nr_cpus, int, S_IRUSR | S_IWUSR);
- */
+/* TODO is this needed? */
+/* module_param(nr_cpus, int, S_IRUSR | S_IWUSR); */
 
 static struct shared_buf **sbuf_per_cpu;
 
@@ -51,31 +105,32 @@ bool buffer_not_ready(int *cpu);
 struct swhv_acrn_msr_collector_data *swhv_alloc_msr_collector_node(void)
 {
 	struct swhv_acrn_msr_collector_data *node =
-		(struct swhv_acrn_msr_collector_data *)kmalloc(
-			sizeof(struct swhv_acrn_msr_collector_data),
-			GFP_KERNEL);
+		(struct swhv_acrn_msr_collector_data *)
+		kmalloc(sizeof(struct swhv_acrn_msr_collector_data),
+				GFP_KERNEL);
+
 	if (node) {
 		node->per_msg_payload_size = 0x0;
 		node->sample_id = 0x0;
-		node->msr_ops_list = kmalloc(
-			pcpu_num * sizeof(struct profiling_msr_ops_list),
-			GFP_KERNEL);
-		memset(node->msr_ops_list, 0,
-		       pcpu_num * sizeof(struct profiling_msr_ops_list));
+		node->msr_ops_list =
+			kmalloc_array(pcpu_num,
+				sizeof(struct profiling_msr_ops_list),
+				GFP_KERNEL);
+		memset(node->msr_ops_list, 0, pcpu_num *
+			sizeof(struct profiling_msr_ops_list));
 		SW_LIST_ENTRY_INIT(node, list);
 	}
 	return node;
 }
-struct swhv_acrn_msr_collector_data *
-swhv_add_driver_msr_info(void *list_head,
-			 const struct swhv_driver_interface_info *info)
+struct swhv_acrn_msr_collector_data *swhv_add_driver_msr_info(void *list_head,
+			   const struct swhv_driver_interface_info *info)
 {
 	int cpu;
 
 	SW_LIST_HEAD_VAR(swhv_acrn_msr_collector_data) * head = list_head;
 
-	struct swhv_acrn_msr_collector_data *node =
-		swhv_alloc_msr_collector_node();
+	struct swhv_acrn_msr_collector_data *node = swhv_alloc_msr_collector_node();
+
 	if (!node) {
 		pw_pr_error("ERROR allocating MSR collector node!\n");
 		return NULL;
@@ -83,8 +138,7 @@ swhv_add_driver_msr_info(void *list_head,
 
 	node->sample_id = info->sample_id;
 	node->cpu_mask = info->cpu_mask;
-	foreach_cpu(cpu, pcpu_num)
-	{
+	foreach_cpu(cpu, pcpu_num) {
 		node->msr_ops_list[cpu].collector_id = COLLECTOR_SOCWATCH;
 		node->msr_ops_list[cpu].msr_op_state = MSR_OP_REQUESTED;
 	}
@@ -93,6 +147,7 @@ swhv_add_driver_msr_info(void *list_head,
 	return node;
 }
 
+
 int swhv_add_driver_msr_io_desc(struct swhv_acrn_msr_collector_data *node,
 				struct swhv_driver_io_descriptor *info)
 {
@@ -102,17 +157,14 @@ int swhv_add_driver_msr_io_desc(struct swhv_acrn_msr_collector_data *node,
 
 	/* Confirm this is an MSR IO descriptor */
 	if (info->collection_type != SWHV_COLLECTOR_TYPE_MSR) {
-		pw_pr_error(
-			"ERROR trying to configure MSR collector with other data!\n");
+		pw_pr_error("ERROR trying to configure MSR collector with other data!\n");
 		return -EINVAL;
 	}
 
-	foreach_cpu(cpu, pcpu_num)
-	{
+	foreach_cpu(cpu, pcpu_num) {
 		num_entries = node->msr_ops_list[cpu].num_entries;
 		if (num_entries >= MAX_MSR_LIST_NUM) {
-			pw_pr_error(
-				"ERROR trying to add too many MSRs to collect!\n");
+			pw_pr_error("ERROR trying to add too many MSRs to collect!\n");
 			return -PW_ERROR;
 		}
 
@@ -121,25 +173,23 @@ int swhv_add_driver_msr_io_desc(struct swhv_acrn_msr_collector_data *node,
 		msr_op = &(node->msr_ops_list[cpu].entries[idx]);
 
 		msr_op->msr_id = info->msr_descriptor.address;
-		if (info->collection_command == SWHV_IO_CMD_READ) {
+		if (info->collection_command == SWHV_IO_CMD_READ)
 			msr_op->msr_op_type = MSR_OP_READ;
-		} else if (info->collection_command == SWHV_IO_CMD_WRITE) {
+		else if (info->collection_command == SWHV_IO_CMD_WRITE)
 			msr_op->msr_op_type = MSR_OP_WRITE;
-		}
+
 
 		/*
 		 * Use the param field to set sample id.
-		 * This'll be used in the hypervisor to
-		 * set the id in the samples
+		 * This'll be used in the hypervisor to set the id in the samples
 		 */
 		msr_op->param = (uint16_t)node->sample_id;
 
 		num_entries++;
 
-		if (num_entries < MAX_MSR_LIST_NUM) {
-			node->msr_ops_list[cpu].entries[num_entries].msr_id =
-				-1;
-		}
+		if (num_entries < MAX_MSR_LIST_NUM)
+			node->msr_ops_list[cpu].entries[num_entries].msr_id = -1;
+
 		node->msr_ops_list[cpu].num_entries = num_entries;
 	}
 	return PW_SUCCESS;
@@ -151,22 +201,19 @@ int swhv_init_per_cpu_buffers(void)
 
 	sbuf_per_cpu = vmalloc(pcpu_num * sizeof(struct shared_buf *));
 
-	foreach_cpu(cpu, pcpu_num)
-	{
+	foreach_cpu(cpu, pcpu_num) {
 		/* allocate shared_buf */
 		sbuf_per_cpu[cpu] = sbuf_allocate(ACRN_BUF_ELEMENT_NUM,
-						  ACRN_BUF_ELEMENT_SIZE);
+					ACRN_BUF_ELEMENT_SIZE);
 		if (!sbuf_per_cpu[cpu]) {
-			pw_pr_error("Failed  to allocate buffer for cpu %d\n",
-				    cpu);
+			pw_pr_error("Failed  to allocate buffer for cpu %d\n", cpu);
 			ret = -ENOMEM;
 			goto out_free;
 		}
 	}
 
 	/* TODO understand the use of this API */
-	foreach_cpu(cpu, pcpu_num)
-	{
+	foreach_cpu(cpu, pcpu_num) {
 		ret = sbuf_share_setup(cpu, ACRN_SOCWATCH, sbuf_per_cpu[cpu]);
 		if (ret < 0) {
 			pw_pr_error("Failed to setup buffer for cpu %d\n", cpu);
@@ -176,15 +223,15 @@ int swhv_init_per_cpu_buffers(void)
 
 	return PW_SUCCESS;
 out_sbuf:
-	for (i = --cpu; i >= 0; i--) {
+	for (i = --cpu; i >= 0; i--)
 		sbuf_share_setup(i, ACRN_SOCWATCH, NULL);
-	}
+
 	cpu = pcpu_num;
 
 out_free:
-	for (i = --cpu; i >= 0; i--) {
+	for (i = --cpu; i >= 0; i--)
 		sbuf_free(sbuf_per_cpu[i]);
-	}
+
 
 	vfree(sbuf_per_cpu);
 	return ret;
@@ -196,11 +243,9 @@ void swhv_destroy_per_cpu_buffers(void)
 
 	pw_pr_debug("%s, pcpu_num: %d\n", __func__, pcpu_num);
 
-	foreach_cpu(cpu, pcpu_num)
-	{
-		/* TODO anything else to de-register?
-		 * deregister devices
-		 */
+	foreach_cpu(cpu, pcpu_num) {
+		/* TODO anything else to de-register? */
+		/* deregister devices */
 
 		/* set sbuf pointer to NULL in HV */
 		sbuf_share_setup(cpu, ACRN_SOCWATCH, NULL);
@@ -213,13 +258,10 @@ void swhv_destroy_per_cpu_buffers(void)
 
 void swhv_free_msr_collector_node(struct swhv_acrn_msr_collector_data *node)
 {
-	if (!node) {
-		return;
+	if (node) {
+		kfree(node->msr_ops_list);
+		kfree(node);
 	}
-
-	kfree(node->msr_ops_list);
-	kfree(node);
-	return;
 }
 
 void swhv_init_msr_collector_list(void)
@@ -237,8 +279,9 @@ void swhv_destroy_msr_collector_list(void)
 	SW_LIST_HEAD_VAR(swhv_acrn_msr_collector_data) * head = list_head;
 	while (!SW_LIST_EMPTY(head)) {
 		struct swhv_acrn_msr_collector_data *curr =
-			SW_LIST_GET_HEAD_ENTRY(
-				head, swhv_acrn_msr_collector_data, list);
+			SW_LIST_GET_HEAD_ENTRY(head,
+				swhv_acrn_msr_collector_data, list);
+
 		SW_LIST_UNLINK(curr, list);
 		swhv_free_msr_collector_node(curr);
 	}
@@ -254,15 +297,13 @@ void swhv_handle_hypervisor_collector(uint32_t control_cmd)
 
 	acrn_profiling_control->collector_id = COLLECTOR_SOCWATCH;
 
-	if (control_cmd == 1) { /* start collection + send switch bitmask */
+	if (control_cmd == 1) {
+		/* start collection + send switch bitmask */
 		pw_pr_debug("STARTING ACRN PROFILING SERVICE\n");
-		global_collection_switch |=
-			control_cmd;	/* first bit controls start/stop
-					 * of collection
-					 */
-	} else if (control_cmd == 0) { /* stop collection
-					* + reset switch bitmask
-					*/
+		/* first bit controls start/stop of collection */
+		global_collection_switch |= control_cmd;
+	} else if (control_cmd == 0) {
+		/* stop collection + reset switch bitmask */
 		pw_pr_debug("STOPPING ACRN PROFILING SERVICE\n");
 		global_collection_switch = control_cmd;
 	}
@@ -270,7 +311,7 @@ void swhv_handle_hypervisor_collector(uint32_t control_cmd)
 
 	/* send collection command + switch bitmask */
 	acrn_hypercall2(HC_PROFILING_OPS, PROFILING_SET_CONTROL_SWITCH,
-			virt_to_phys(acrn_profiling_control));
+		virt_to_phys(acrn_profiling_control));
 	kfree(acrn_profiling_control);
 }
 
@@ -287,22 +328,20 @@ int swhv_handle_msr_collector_list(void)
 		return retVal;
 	}
 
-	if (!head) {
+	if (!head)
 		return -PW_ERROR;
-	}
-	SW_LIST_FOR_EACH_ENTRY(curr, head, list)
-	{
+
+	SW_LIST_FOR_EACH_ENTRY(curr, head, list) {
 		pw_pr_debug("HANDLING MSR NODE\n");
 
-		/*hypervisor call to do immediate MSR read */
+		/* hypervisor call to do immediate MSR read */
 		acrn_hypercall2(HC_PROFILING_OPS, PROFILING_MSR_OPS,
 				virt_to_phys(curr->msr_ops_list));
 	}
 	return retVal;
 }
 
-long swhv_configure(struct swhv_driver_interface_msg __user *remote_msg,
-		    int local_len)
+long swhv_configure(struct swhv_driver_interface_msg __user *remote_msg, int local_len)
 {
 	struct swhv_driver_interface_info *local_info = NULL;
 	struct swhv_driver_io_descriptor *local_io_desc = NULL;
@@ -341,33 +380,33 @@ long swhv_configure(struct swhv_driver_interface_msg __user *remote_msg,
 	num_infos = local_msg->num_infos;
 	pw_pr_debug("LOCAL NUM INFOS = %u\n", num_infos);
 	for (; num_infos > 0 && !done; --num_infos) {
-		local_info =
-			(struct swhv_driver_interface_info *)&__data[dst_idx];
+		local_info = (struct swhv_driver_interface_info *)&__data[dst_idx];
 		desc_idx = dst_idx + SWHV_DRIVER_INTERFACE_INFO_HEADER_SIZE();
 		dst_idx += (SWHV_DRIVER_INTERFACE_INFO_HEADER_SIZE() +
-			    local_info->num_io_descriptors *
-				    sizeof(struct swhv_driver_io_descriptor));
+				local_info->num_io_descriptors *
+				sizeof(struct swhv_driver_io_descriptor));
 		pw_pr_debug("# msrs = %u\n",
-			    (unsigned int)local_info->num_io_descriptors);
+			(unsigned)local_info->num_io_descriptors);
 
 		num_io_desc = local_info->num_io_descriptors;
 		pw_pr_debug("LOCAL NUM IO DESC = %u\n", num_io_desc);
 
 		driver_info_added = false;
 		for (; num_io_desc > 0; --num_io_desc) {
-			local_io_desc = (struct swhv_driver_io_descriptor
-						 *)&__data[desc_idx];
+			local_io_desc = (struct swhv_driver_io_descriptor *)
+					&__data[desc_idx];
 			desc_idx += sizeof(struct swhv_driver_io_descriptor);
 			if (local_io_desc->collection_type ==
-			    SWHV_COLLECTOR_TYPE_MSR) {
+					SWHV_COLLECTOR_TYPE_MSR) {
+
 				if (!driver_info_added) {
 					msr_collector_node =
 						swhv_add_driver_msr_info(
 							&swhv_msr_collector,
 							local_info);
-					if (msr_collector_node == NULL) {
+					if (msr_collector_node == NULL)
 						return -PW_ERROR;
-					}
+
 					driver_info_added = true;
 				}
 
@@ -376,15 +415,12 @@ long swhv_configure(struct swhv_driver_interface_msg __user *remote_msg,
 					local_io_desc->msr_descriptor.address,
 					local_io_desc->msr_descriptor.type,
 					local_io_desc->collection_command);
-				swhv_add_driver_msr_io_desc(msr_collector_node,
-							    local_io_desc);
+				swhv_add_driver_msr_io_desc(msr_collector_node, local_io_desc);
 			} else if (local_io_desc->collection_type ==
-				   SWHV_COLLECTOR_TYPE_SWITCH) {
-				local_config_bitmap =
-					local_io_desc->switch_descriptor
-						.switch_bitmask;
-				pw_pr_debug("local bitmask = %u\n",
-					    local_config_bitmap);
+					SWHV_COLLECTOR_TYPE_SWITCH) {
+
+				local_config_bitmap = local_io_desc->switch_descriptor.switch_bitmask;
+				pw_pr_debug("local bitmask = %u\n", local_config_bitmap);
 
 				global_collection_switch = local_config_bitmap;
 
@@ -393,11 +429,11 @@ long swhv_configure(struct swhv_driver_interface_msg __user *remote_msg,
 				 */
 				done = 1;
 				break;
-			} else {
+			} else
 				pw_pr_error(
 					"WARNING: unknown collector configuration requested, collector id: %u!\n",
 					local_io_desc->collection_type);
-			}
+
 		}
 		driver_info_added = false;
 	}
@@ -411,7 +447,7 @@ long swhv_stop(void)
 
 	pw_pr_debug("socwatch: stop called\n");
 
-	/*If MSR ops are present, perform them to get begin snapshot data. */
+	/* If MSR ops are present, perform them to get begin snapshot data. */
 	swhv_handle_msr_collector_list();
 
 	/* stop collection + reset switch bitmask */
@@ -446,15 +482,12 @@ long swhv_start(void)
 	swhv_handle_msr_collector_list();
 
 #if 0
-	/* Expand this eventually to retrieve VM-related info
-	 * from the hypervisor. Leaving it here for now.
-	 */
-	vm_info_list = kmalloc(sizeof(struct profiling_vm_info_list),
-			       GFP_KERNEL);
+	/* Expand this eventually to retrive VM-realted info from the hypervisor */
+	/* Leaving it here for now. */
+	vm_info_list = kmalloc(sizeof(struct profiling_vm_info_list), GFP_KERNEL);
 	memset(vm_info_list, 0, sizeof(struct profiling_vm_info_list));
 
-	acrn_hypercall2(HC_PROFILING_OPS, PROFILING_GET_VMINFO,
-			virt_to_phys(vm_info_list));
+	acrn_hypercall2(HC_PROFILING_OPS, PROFILING_GET_VMINFO, virt_to_phys(vm_info_list));
 
 	pw_pr_debug("Number of VMs: %d\n", vm_info_list->num_vms);
 	for (i = 0; i < vm_info_list->num_vms; ++i) {
@@ -493,7 +526,7 @@ long swhv_get_hypervisor_type(u32 __user *remote_args)
 	uint32_t hypervisor_type = swhv_hypervisor_acrn;
 
 	return copy_to_user(remote_args, &hypervisor_type,
-			    sizeof(hypervisor_type));
+			sizeof(hypervisor_type));
 }
 
 long swhv_msr_read(u32 __user *remote_in_args, u64 __user *remote_args)
@@ -503,44 +536,39 @@ long swhv_msr_read(u32 __user *remote_in_args, u64 __user *remote_args)
 	int ret = PW_SUCCESS;
 
 	if (get_user(msr_addr, remote_in_args)) {
-		pw_pr_error(
-			"ERROR: couldn't copy remote args for read MSR IOCTL!\n");
-		return -1;
+	pw_pr_error("ERROR: couldn't copy remote args for read MSR IOCTL!\n");
+	return -1;
 	}
 
 	if (!msr_read_ops_list) {
-		msr_read_ops_list = kmalloc(
-			pcpu_num * sizeof(struct profiling_msr_ops_list),
-			GFP_KERNEL);
-		if (!msr_read_ops_list) {
-			pw_pr_error(
-				"couldn't allocate memory for doing an MSR read!\n");
-			return -1;
-		}
-		memset(msr_read_ops_list, 0,
-		       pcpu_num * sizeof(struct profiling_msr_ops_list));
+	msr_read_ops_list = kmalloc_array(pcpu_num,
+			sizeof(struct profiling_msr_ops_list), GFP_KERNEL);
+	if (!msr_read_ops_list) {
+		pw_pr_error("couldn't allocate memory for doing an MSR read!\n");
+		return -1;
+	}
+	memset(msr_read_ops_list, 0, pcpu_num * sizeof(struct profiling_msr_ops_list));
 	}
 
 	/*
 	 * The hypercall is set in such a way that the MSR read will occur on
 	 * all CPUs and as a result we have to set up structures for each CPU.
 	 */
-	foreach_cpu(cpu, pcpu_num)
-	{
+	foreach_cpu(cpu, pcpu_num) {
 		msr_read_ops_list[cpu].collector_id = COLLECTOR_SOCWATCH;
 		msr_read_ops_list[cpu].msr_op_state = MSR_OP_REQUESTED;
 		msr_read_ops_list[cpu].num_entries = 1;
 		msr_read_ops_list[cpu].entries[0].msr_id = msr_addr;
 		msr_read_ops_list[cpu].entries[0].msr_op_type = MSR_OP_READ;
-		msr_read_ops_list[cpu].entries[1].msr_id =
-			-1; /* the next entry is expected to be set to -1 */
-		msr_read_ops_list[cpu].entries[1].param =
-			0; /* set to 0 to not generate sample in hypervisor */
+		/* the next entry is expected to be set to -1 */
+		msr_read_ops_list[cpu].entries[1].msr_id = -1;
+		/* set to 0 to not generate sample in hypervisor */
+		msr_read_ops_list[cpu].entries[1].param = 0;
 	}
 
 	/* hypervisor call to do immediate MSR read */
 	acrn_hypercall2(HC_PROFILING_OPS, PROFILING_MSR_OPS,
-			virt_to_phys(msr_read_ops_list));
+		virt_to_phys(msr_read_ops_list));
 
 	/* copy value to remote args, pick from any CPU */
 	value = msr_read_ops_list[0].entries[0].value;
@@ -559,9 +587,9 @@ long swhv_collection_poll(void)
 	/*
 	 * Handle 'POLL' timer expirations.
 	 */
-	if (SW_LIST_EMPTY(&swhv_msr_collector)) {
+	if (SW_LIST_EMPTY(&swhv_msr_collector))
 		pw_pr_debug("DEBUG: EMPTY MSR COLLECTOR POLL LIST\n");
-	}
+
 
 	if (swhv_handle_msr_collector_list()) {
 		pw_pr_error("ERROR: unable to copy MSR value to userspace!\n");
@@ -570,8 +598,7 @@ long swhv_collection_poll(void)
 	return ret;
 }
 
-ssize_t swhv_transfer_data(void *user_buffer, struct shared_buf *sbuf_to_copy,
-			   size_t bytes_to_read)
+ssize_t swhv_transfer_data(void *user_buffer, struct shared_buf *sbuf_to_copy, size_t bytes_to_read)
 {
 	unsigned long bytes_not_copied;
 	ssize_t bytes_read;
@@ -579,29 +606,26 @@ ssize_t swhv_transfer_data(void *user_buffer, struct shared_buf *sbuf_to_copy,
 	void *data_read = NULL;
 
 	if (bytes_to_read == 0) {
-		pw_pr_debug(
-			"%s - 0 bytes requested to transfer! Returning...\n",
-			__func__);
-
+		pw_pr_debug("%s - 0 bytes requested to transfer! Returning...\n", __func__);
 		return bytes_to_read;
 	}
 
 	data_read = vmalloc(bytes_to_read);
 	if (!data_read) {
-		pw_pr_error(
-			"couldn't allocate memory when trying to transfer data to userspace!\n");
+		pw_pr_error("couldn't allocate memory when trying to transfer data to userspace!\n");
 		return 0;
 	}
 
 	pw_pr_debug("%s - bytes to transfer %zu\n", __func__, bytes_to_read);
 
 	if (sbuf_to_copy) {
-		bytes_read = sbuf_get_variable(sbuf_to_copy, &data_read,
-					       bytes_to_read);
+		bytes_read = sbuf_get_variable(sbuf_to_copy, &data_read, bytes_to_read);
+
+		if (bytes_read != bytes_to_read)
+			pw_pr_warn(
+				"%s - bytes read (%zu bytes) are not equal to expected bytes (%zu bytes) to be read!",
+				__func__, bytes_read, bytes_to_read);
 
-		if (bytes_read != bytes_to_read) {
-			pw_pr_warn("%s - bytes read (%zu bytes) are not equal to expected bytes (%zu bytes) to be read!", __func__, bytes_read, bytes_to_read);
-		}
 
 		if (bytes_read < 0) {
 			pw_pr_error("Error reading this buffer\n");
@@ -616,8 +640,8 @@ ssize_t swhv_transfer_data(void *user_buffer, struct shared_buf *sbuf_to_copy,
 				goto ret_free;
 			}
 
-			bytes_not_copied = copy_to_user(user_buffer, data_read,
-							bytes_read);
+			bytes_not_copied =
+				copy_to_user(user_buffer, data_read, bytes_read);
 			/* TODO check if this is meaningful enough to have */
 			/* *offset += bytes_read - bytes_not_copied; */
 
@@ -631,10 +655,10 @@ ssize_t swhv_transfer_data(void *user_buffer, struct shared_buf *sbuf_to_copy,
 			}
 			ret = bytes_read;
 			goto ret_free;
-		} else {
+		} else
 			pw_pr_debug(
 				"Buffer empty! nothing more to read from this buffer\n");
-		}
+
 	}
 
 ret_free:
@@ -644,8 +668,8 @@ ssize_t swhv_transfer_data(void *user_buffer, struct shared_buf *sbuf_to_copy,
 
 bool buffer_not_ready(int *cpu)
 {
-	/* cycle through and confirm buffers on all CPUs
-	 * are less than ACRN_BUF_TRANSFER_SIZE
+	/* cycle through and confirm buffers on all CPUs are less than
+	 * ACRN_BUF_TRANSFER_SIZE
 	 * as well as flush mode has not been requested
 	 */
 	int i = 0;
@@ -654,15 +678,14 @@ bool buffer_not_ready(int *cpu)
 	pw_pr_debug(
 		"checking if a buffer is ready to be copied to the device file\n");
 	/*
-	 * It's possible that the buffer from cpu0 may always have
-	 * data to transfer and can potentially prevent buffers from
-	 * other cpus from ever being serviced.
+	 * It's possible that the buffer from cpu0 may always have data to
+	 * transfer and can potentially prevent buffers from other cpus from
+	 * ever being serviced.
 	 * TODO Consider adding an optimization to check for last cpu read.
 	 */
 	for (i = 0; i < pcpu_num; ++i) {
-		if (ACRN_BUF_FILLED_SIZE(sbuf_per_cpu[i]) >=
-		    ACRN_BUF_TRANSFER_SIZE ||
-		    (flush_mode && ACRN_BUF_FILLED_SIZE(sbuf_per_cpu[i]))) {
+		if (ACRN_BUF_FILLED_SIZE(sbuf_per_cpu[i]) >= ACRN_BUF_TRANSFER_SIZE ||
+				(flush_mode && ACRN_BUF_FILLED_SIZE(sbuf_per_cpu[i]))) {
 			not_enough_data = false;
 			*cpu = i;
 			pw_pr_debug(
@@ -675,20 +698,21 @@ bool buffer_not_ready(int *cpu)
 }
 
 ssize_t device_read_i(struct file *file, char __user *user_buffer,
-		      size_t length, loff_t *offset)
+		size_t length, loff_t *offset)
 {
 	ssize_t bytes_read = 0;
 	int cpu = 0;
 
 	pw_pr_debug("%s - usermode attempting to read device file\n", __func__);
+
 	if (buffer_not_ready(&cpu)) {
 		pw_pr_debug("%s - no buffer ready to be read\n", __func__);
 		return bytes_read;
 	}
 
-	if (flush_mode) {
+	if (flush_mode)
 		pw_pr_debug("flush mode on, ready to flush a buffer\n");
-	}
+
 	length = ACRN_BUF_FILLED_SIZE(sbuf_per_cpu[cpu]);
 	pw_pr_debug("on cpu %d, buffer size is %zu bytes\n", cpu, length);
 
@@ -716,9 +740,9 @@ int swhv_load_driver_i(void)
 	pw_pr_debug("%s, pcpu_num: %d\n", __func__, pcpu_num);
 
 	ret = swhv_init_per_cpu_buffers();
-	if (ret < 0) {
+	if (ret < 0)
 		return ret;
-	}
+
 
 	swhv_init_msr_collector_list();
 
diff --git a/drivers/platform/x86/socwatchhv/swhv_driver.c b/drivers/platform/x86/socwatchhv/swhv_driver.c
index 7a4e6c57ab45..50c87bdcbec8 100644
--- a/drivers/platform/x86/socwatchhv/swhv_driver.c
+++ b/drivers/platform/x86/socwatchhv/swhv_driver.c
@@ -1,58 +1,57 @@
-/*
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  SoC Watch Developer Team <socwatchdevelopers@intel.com>
-  Intel Corporation,
-  1300 S Mopac Expwy,
-  Austin, TX 78746
-
-  BSD LICENSE
-
-  Copyright(c) 2014 - 2018 Intel Corporation.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+/* SPDX-License-Identifier: GPL-2.0 AND BSD-3-Clause
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Contact Information:
+ * SoC Watch Developer Team <socwatchdevelopers@intel.com>
+ * Intel Corporation,
+ * 1300 S Mopac Expwy,
+ * Austin, TX 78746
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2019 Intel Corporation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 #define MOD_AUTHOR "SoCWatch Team"
 #define MOD_DESC "SoCWatch kernel module to communicate with hypervisors"
 
@@ -85,7 +84,6 @@
  * Compile-time constants
  * *******************************************
  */
-
 /* *******************************************
  * Local data structures.
  * *******************************************
@@ -97,10 +95,10 @@
  * from 32b user programs in 64b kernels.
  */
 struct spdrv_ioctl_arg32 {
-	pw_s32_t in_len;
-	pw_s32_t out_len;
-	compat_caddr_t in_arg;
-	compat_caddr_t out_arg;
+    pw_s32_t in_len;
+    pw_s32_t out_len;
+    compat_caddr_t in_arg;
+    compat_caddr_t out_arg;
 };
 #endif /* COMPAT && x64 */
 
@@ -115,7 +113,7 @@ static struct class *sp_class;
  */
 
 /* Per-CPU variable containing the currently running vcpu. */
-/*static DEFINE_PER_CPU(int, curr_vcpu) = 0; */
+/* static DEFINE_PER_CPU(int, curr_vcpu) = 0; */
 
 /* *******************************************
  * Function definitions.
@@ -153,24 +151,22 @@ static long swhv_handle_cmd(u32 __user *remote_cmd)
 long swhv_get_version(u64 __user *remote_args)
 {
 	u64 local_version = (u64)SWHVDRV_VERSION_MAJOR << 32 |
-			    (u64)SWHVDRV_VERSION_MINOR << 16 |
-			    (u64)SWHVDRV_VERSION_OTHER;
+			(u64)SWHVDRV_VERSION_MINOR << 16 |
+			(u64)SWHVDRV_VERSION_OTHER;
 
 	return put_user(local_version, remote_args);
 };
 
 #if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)
-#define MATCH_IOCTL(num, pred) ((num) == (pred) || (num) == (pred##32))
+	#define MATCH_IOCTL(num, pred) ((num) == (pred) || (num) == (pred##32))
 #else
-#define MATCH_IOCTL(num, pred) ((num) == (pred))
+	#define MATCH_IOCTL(num, pred) ((num) == (pred))
 #endif
 
-static long handle_ioctl(unsigned int ioctl_num,
-			 struct spdrv_ioctl_arg __user *remote_args)
+static long handle_ioctl(unsigned int ioctl_num, struct spdrv_ioctl_arg __user *remote_args)
 {
 	long status = 0;
 	struct spdrv_ioctl_arg local_args;
-
 	int local_in_len, local_out_len;
 
 	if (copy_from_user(&local_args, remote_args, sizeof(local_args))) {
@@ -189,10 +185,8 @@ static long handle_ioctl(unsigned int ioctl_num,
 
 	case SWHVDRV_OPERATION_CONFIGURE:
 		pw_pr_debug("Trying to configure driver!\n");
-		status = swhv_configure(
-			(struct swhv_driver_interface_msg __user *)
-				local_args.in_arg,
-			local_in_len);
+		status = swhv_configure((struct swhv_driver_interface_msg __user *)
+					local_args.in_arg, local_in_len);
 		break;
 
 	case SWHVDRV_OPERATION_VERSION:
@@ -202,7 +196,8 @@ static long handle_ioctl(unsigned int ioctl_num,
 
 	case SWHVDRV_OPERATION_CLOCK:
 		pw_pr_debug("Trying to get hypervisor type!\n");
-		status = swhv_get_clock((u32 __user *)local_args.in_arg,
+		status = swhv_get_clock((u32 __user *)
+					local_args.in_arg,
 					(u64 __user *)local_args.out_arg);
 		break;
 
@@ -218,14 +213,14 @@ static long handle_ioctl(unsigned int ioctl_num,
 
 	case SWHVDRV_OPERATION_HYPERVISOR_TYPE:
 		pw_pr_debug("Trying to get hypervisor type!\n");
-		status = swhv_get_hypervisor_type(
-			(u32 __user *)local_args.out_arg);
+		status = swhv_get_hypervisor_type((u32 __user *)
+					local_args.out_arg);
 		break;
 
 	case SWHVDRV_OPERATION_MSR_READ:
 		pw_pr_debug("Trying to do MSR read!\n");
 		status = swhv_msr_read((u32 __user *)local_args.in_arg,
-				       (u64 __user *)local_args.out_arg);
+					(u64 __user *)local_args.out_arg);
 		break;
 	case SWHVDRV_OPERATION_POLL:
 		pw_pr_debug("Polling tick!\n");
@@ -236,42 +231,43 @@ static long handle_ioctl(unsigned int ioctl_num,
 }
 
 static long device_unlocked_ioctl(struct file *filep, unsigned int ioctl_num,
-				  unsigned long ioctl_param)
+		unsigned long ioctl_param)
 {
 	return handle_ioctl(_IOC_NR(ioctl_num),
-			    (struct spdrv_ioctl_arg __user *)ioctl_param);
+				(struct spdrv_ioctl_arg __user *)ioctl_param);
 };
 
+
 #if defined(HAVE_COMPAT_IOCTL) && defined(CONFIG_X86_64)
-static long device_compat_ioctl(struct file *file, unsigned int ioctl_num,
-				unsigned long ioctl_param)
+static long device_compat_ioctl(struct file *file,
+		unsigned int ioctl_num, unsigned long ioctl_param)
 {
 	struct spdrv_ioctl_arg32 __user *remote_args32 =
-		compat_ptr(ioctl_param);
+			compat_ptr(ioctl_param);
 	struct spdrv_ioctl_arg __user *remote_args =
-		compat_alloc_user_space(sizeof(*remote_args));
+			compat_alloc_user_space(sizeof(*remote_args));
 	int tmp;
 	u32 data;
 
-	if (!remote_args) {
+	if (!remote_args)
 		return -1;
-	}
+
 	if (get_user(tmp, &remote_args32->in_len) ||
-	    put_user(tmp, &remote_args->in_len)) {
+			put_user(tmp, &remote_args->in_len))
 		return -1;
-	}
+
 	if (get_user(tmp, &remote_args32->out_len) ||
-	    put_user(tmp, &remote_args->out_len)) {
+			put_user(tmp, &remote_args->out_len))
 		return -1;
-	}
+
 	if (get_user(data, &remote_args32->in_arg) ||
-	    put_user(compat_ptr(data), &remote_args->in_arg)) {
+			put_user(compat_ptr(data), &remote_args->in_arg))
 		return -1;
-	}
+
 	if (get_user(data, &remote_args32->out_arg) ||
-	    put_user(compat_ptr(data), &remote_args->out_arg)) {
+			put_user(compat_ptr(data), &remote_args->out_arg))
 		return -1;
-	}
+
 	return handle_ioctl(_IOC_NR(ioctl_num), remote_args);
 };
 #endif /* COMPAT && x64 */
@@ -281,11 +277,11 @@ static int device_open(struct inode *inode, struct file *file)
 	return device_open_i(inode, file);
 }
 
-static ssize_t
-device_read(struct file *file, /* see include/linux/fs.h */
-	    char __user *buffer, /* buffer to be filled with data */
-	    size_t length, /* length of the buffer */
-	    loff_t *offset)
+static ssize_t device_read(struct file *file, /* see include/linux/fs.h */
+	char __user *buffer, /* buffer to be filled with data */
+	size_t length, /* length of the buffer */
+
+	loff_t *offset)
 {
 	return device_read_i(file, buffer, length, offset);
 }
@@ -338,7 +334,7 @@ int __init swhv_load_driver(void)
 	}
 	sp_cdev->owner = THIS_MODULE;
 	sp_cdev->ops = &s_fops;
-	if (cdev_add(sp_cdev, sp_dev, 1) < 0) {
+	if (cdev_add(sp_cdev, sp_dev, 1) < 0)  {
 		error = -1;
 		pw_pr_error("Error registering device driver\n");
 		goto cleanup_return_error;
-- 
2.17.1

