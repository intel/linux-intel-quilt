From 087f9d476b15560d015fb5ba6dbb90b1493134c8 Mon Sep 17 00:00:00 2001
From: Zhou Furong <furong.zhou@intel.com>
Date: Mon, 7 Jan 2019 13:04:55 +0800
Subject: [PATCH 03/12] keystore: add keystore driver support

The keystore driver is designed to provide a secure storage solution for
secret keys in TEE environment. The basic functions it provides including:
register/unregister, generate key, wrap key, load key/unload key, and
encrypt/decrypt, etc.

Applications interface is through the char device ioctls on /dev/keystore.

Change-Id: Id181c9d469b7ff865efbe368a2c35a1803ff9634
Signed-off-by: Cliff Cai <cliff.cai@intel.com>
---
 include/uapi/security/keystore_api_common.h |  116 +++
 include/uapi/security/keystore_api_user.h   |  427 ++++++++
 security/Kconfig                            |    2 +-
 security/Makefile                           |    1 +
 security/keystore/Kconfig                   |   41 +
 security/keystore/Makefile                  |   22 +
 security/keystore/api_dal.c                 | 1041 +++++++++++++++++++
 security/keystore/api_dal.h                 |  139 +++
 security/keystore/applet_read.c             |  141 +++
 security/keystore/client.c                  |  124 +++
 security/keystore/dal_client.c              |  115 ++
 security/keystore/dal_client.h              |   99 ++
 security/keystore/dal_context.c             |  388 +++++++
 security/keystore/dal_context.h             |  167 +++
 security/keystore/dal_context_safe.c        |  235 +++++
 security/keystore/dal_context_safe.h        |  170 +++
 security/keystore/debug.c                   |   69 ++
 security/keystore/ioctls.c                  |  514 +++++++++
 security/keystore/keystore_client.h         |   48 +
 security/keystore/keystore_debug.h          |   95 ++
 security/keystore/keystore_ioctl.h          |   33 +
 security/keystore/keystore_kmod.c           |  232 +++++
 security/keystore/keystore_mac.h            |   54 +
 security/keystore/keystore_rand.h           |   37 +
 security/keystore/mac.c                     |  154 +++
 security/keystore/rdrand.c                  |   83 ++
 26 files changed, 4546 insertions(+), 1 deletion(-)
 create mode 100644 include/uapi/security/keystore_api_common.h
 create mode 100644 include/uapi/security/keystore_api_user.h
 create mode 100644 security/keystore/Kconfig
 create mode 100644 security/keystore/Makefile
 create mode 100644 security/keystore/api_dal.c
 create mode 100644 security/keystore/api_dal.h
 create mode 100644 security/keystore/applet_read.c
 create mode 100644 security/keystore/client.c
 create mode 100644 security/keystore/dal_client.c
 create mode 100644 security/keystore/dal_client.h
 create mode 100644 security/keystore/dal_context.c
 create mode 100644 security/keystore/dal_context.h
 create mode 100644 security/keystore/dal_context_safe.c
 create mode 100644 security/keystore/dal_context_safe.h
 create mode 100644 security/keystore/debug.c
 create mode 100644 security/keystore/ioctls.c
 create mode 100644 security/keystore/keystore_client.h
 create mode 100644 security/keystore/keystore_debug.h
 create mode 100644 security/keystore/keystore_ioctl.h
 create mode 100644 security/keystore/keystore_kmod.c
 create mode 100644 security/keystore/keystore_mac.h
 create mode 100644 security/keystore/keystore_rand.h
 create mode 100644 security/keystore/mac.c
 create mode 100644 security/keystore/rdrand.c

diff --git a/include/uapi/security/keystore_api_common.h b/include/uapi/security/keystore_api_common.h
new file mode 100644
index 000000000000..2c51ab3860f4
--- /dev/null
+++ b/include/uapi/security/keystore_api_common.h
@@ -0,0 +1,116 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _KEYSTORE_API_COMMON_H_
+#define _KEYSTORE_API_COMMON_H_
+
+#include <linux/types.h>
+
+/**
+ * DOC: Introduction
+ *
+ * Common constants and structures common to both user- and kernel-space
+ * clients are listed here.
+ *
+ */
+
+/* Version numbers of the Keystore API
+ * Follows the Apache versioning scheme
+ *
+ * Major versions represent large scale changes in the API.
+ * Minor changes return API compatibility with older minor versions.
+ * Patch changes are forwards and backwards compatible.
+ *
+ * Ensure that version numbers are updated if changes are made to
+ * the API!
+ */
+#define KEYSTORE_VERSION_MAJOR 2
+#define KEYSTORE_VERSION_MINOR 1
+#define KEYSTORE_VERSION_PATCH 1
+
+/**
+ * KEYSTORE_CLIENT_TICKET_SIZE - client_ticket size in bytes
+ */
+#define KEYSTORE_CLIENT_TICKET_SIZE	8
+
+/**
+ * KEYSTORE_MAX_CLIENT_ID_SIZE - size of the client ID
+ *
+ * The client ID is unique per application and is not normally
+ * needed outside of Keystore. It is only required when migrated
+ * from one application to another during the backup and migration
+ * proceedure.
+ */
+#define KEYSTORE_MAX_CLIENT_ID_SIZE	32
+
+/**
+ * KEYSTORE_CLIENT_KEY_SIZE - size of the client key
+ *
+ * The client keys are used to wrap application keys in keystore.
+ * This variable is only needed outside of keystore during the
+ * backup and migration proceedure.
+ */
+#define KEYSTORE_CLIENT_KEY_SIZE	32
+
+/**
+ * KEYSTORE_MAX_IV_SIZE - Maximum size of the Initialization Vector
+ */
+#define KEYSTORE_MAX_IV_SIZE	16
+
+/**
+ * enum keystore_seed_type - User/device seed type
+ * @SEED_TYPE_DEVICE: The keys should be associated to the device.
+ *                    SEED will only change if the device SEED is
+ *                    compromised.
+ * @SEED_TYPE_USER:   The keys should be associated to the user. The
+ *                    SEED can be changed by the user if requested.
+ */
+enum keystore_seed_type {
+	SEED_TYPE_DEVICE = 0,
+	SEED_TYPE_USER   = 1
+};
+
+/**
+ * enum keystore_key_spec - The key specification
+ * @KEYSPEC_INVALID: Invalid keyspec
+ * @KEYSPEC_LENGTH_128: 128-bit raw key (for AES)
+ * @KEYSPEC_LENGTH_256: 256-bit raw key (for AES)
+ * @KEYSPEC_LENGTH_ECC_PAIR: 1664-bit raw key pair (for ECC)
+ */
+enum keystore_key_spec {
+	KEYSPEC_INVALID = 0,
+	KEYSPEC_LENGTH_128 = 1,
+	KEYSPEC_LENGTH_256 = 2,
+	KEYSPEC_LENGTH_ECC_PAIR = 128,
+};
+
+/**
+ * enum keystore_algo_spec - The encryption algorithm specification
+ * @ALGOSPEC_INVALID: Invalid Algospec
+ * @ALGOSPEC_AES_CCM: AES_CCM Algorithm (128/256 bit depending on key length)
+ * @ALGOSPEC_AES_GCM: AES_GCM Algorithm (128/256 bit depending on key length)
+ * @ALGOSPEC_ECIES: ECC/ECIES Encryption Algorithm (using secp521r1)
+ * @ALGOSPEC_ECDSA: ECC/ECDSA Signature Algorithm (using secp521r1)
+ */
+enum keystore_algo_spec {
+	ALGOSPEC_INVALID = 0,
+	ALGOSPEC_AES_CCM = 1,
+	ALGOSPEC_AES_GCM = 2,
+	ALGOSPEC_ECIES = 128,
+	ALGOSPEC_ECDSA = 129
+};
+
+#endif /* _KEYSTORE_API_COMMON_H_ */
diff --git a/include/uapi/security/keystore_api_user.h b/include/uapi/security/keystore_api_user.h
new file mode 100644
index 000000000000..7ac5899a435f
--- /dev/null
+++ b/include/uapi/security/keystore_api_user.h
@@ -0,0 +1,427 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _KEYSTORE_API_USER_H_
+#define _KEYSTORE_API_USER_H_
+
+#include <linux/types.h>
+#include <security/keystore_api_common.h>
+
+/**
+ * DOC: Introduction
+ *
+ * Keystore is a key-wrapping service running inside the kernel. It allows a
+ * client to wrap (encrypt) secret keys for local storage on a filesystem or
+ * other medium. Keystore also provides interfaces to perfrom cryptographic
+ * operations with the wrapped keys.
+ *
+ */
+
+/**
+ * DOC: Configuration
+ *
+ * The following configuration options are related to keystore:
+ *
+ * KEYSTORE (default = n)
+ * The option enables keystore.
+ *
+ * KEYSTORE_DEBUG (default = n)
+ * The option enables additional debug prints, hexdumps during keystore
+ * operation. It includes hexdump of sensitive cryptographic data structures
+ * such as public keys and for this reason should not be enabled in production.
+ */
+
+/**
+ * DOC: Key Wrapping
+ *
+ * The main function of keystore is to wrap keys (encrypt) from an application.
+ * The application can safely store these wrapped keys on a filesystem.
+ * Cryptographic operations on these keys are also performed within keystore
+ * so that the bare keys are not exposed outside of the kernel.
+ *
+ * An application must first register with keystore by calling:
+ *
+ * keystore_register()
+ *
+ * The application can then either import or generate keys using the functions:
+ *
+ * keystore_generate_key() and keystore_wrap_key()
+ *
+ * The wrapped keys can be stored in non-volatile memory for future use.
+ * Once a key has been wrapped, it can be loaded into a client "slot" where it
+ * is internally wrapped:
+ *
+ * keystore_load_key()
+ *
+ * Following loading, data can be encrypted or decrypted using the key:
+ *
+ * keystore_encrypt() and keystore_decrypt()
+ *
+ * Finally, the slot can be freed and session ended using:
+ *
+ * keystore_unload_key() and keystore_unregister()
+ *
+ * For more details see the descriptions of the relevant functions.
+ */
+
+/**
+ * DOC: Keystore Device
+ *
+ * Keystore is controlled from user-space via ioctl commands to the
+ * /dev/keystore device.
+ *
+ */
+
+/**
+ * DOC: Keystore ioctl structs
+ *
+ * The keystore ioctls pass the following structs from user- to kernel-space.
+ *
+ */
+
+/**
+ * struct ias_keystore_version - The keystore version
+ * @major: Major version number
+ * @minor: Minor version number
+ * @patch: Patch version number
+ *
+ * The keystore API version, following the Apache versioning system.
+ *
+ * Major versions represent large scale changes in the API.
+ * Minor changes return API compatibility with older minor versions.
+ * Patch changes are forwards and backwards compatible.
+ */
+struct ias_keystore_version {
+	/* output */
+	__u32 major;
+	__u32 minor;
+	__u32 patch;
+};
+
+/**
+ * struct ias_keystore_register - Register a keystore client.
+ * @seed_type:       Type of SEED to use for client key generation.
+ * @client_ticket:   Ticket used to identify this client session.
+ *
+ * Register a keystore client. The client will be registered under an
+ * internal client ID which is computed by taking the SHA-256 hash of
+ * the absolute path name.
+ *
+ * On registration a client key is computed by combining the client ID
+ * with either the device or user SEED using HMAC.
+ *
+ * The @seed_type determines whether the keys are wrapped using the
+ * keystore device or user SEED. The choice depends on the type of
+ * data being encrypted. Device keys will be used to encrypt data
+ * associated with the device, whereas user keys are associated
+ * to user data. The device SEED value can only be updated by the
+ * device manufacturer, whereas the user SEED can be reset by a
+ * system user.
+ *
+ * As the client ID is computed from the application path and name,
+ * it is important to maintain the same path across releases.
+ */
+struct ias_keystore_register {
+	/* input */
+	enum keystore_seed_type seed_type;
+
+	/* output */
+	__u8 client_ticket[KEYSTORE_CLIENT_TICKET_SIZE];
+};
+
+/**
+ * struct ias_keystore_unregister - Unregister a keystore client..
+ * @client_ticket:   Ticket used to identify this client session.
+ */
+struct ias_keystore_unregister {
+	/* input */
+	__u8 client_ticket[KEYSTORE_CLIENT_TICKET_SIZE];
+};
+
+/**
+ * struct ias_keystore_wrapped_key_size - Gets size of a wrapped key in bytes.
+ * @key_spec:       The key type to get the size for.
+ * @key_size:       The size of the wrapped key in bytes.
+ * @unwrapped_key_size: Size of the unwrapped key.
+ *
+ * Returns the size of a wrapped key for a given key spec. This
+ * should be called before a wrapped key is generated or imported
+ * in order to allocate memory for the wrapped key buffer.
+ *
+ * The unwrapped key size will also be returned to be used when
+ * importing exisiting keys or retrieving public keys.
+ */
+struct ias_keystore_wrapped_key_size {
+	/* input */
+	__u32 key_spec;
+
+	/* output */
+	__u32 key_size;
+	__u32 unwrapped_key_size;
+};
+
+/**
+ * struct ias_keystore_generate_key - Generate a keystore key
+ * @client_ticket:   Ticket used to identify this client session
+ * @key_spec:        Key type to be generated (enum keystore_key_spec)
+ * @wrapped_key:     The generated key wrapped by keystore
+ *
+ * Keystore will generate a random key according to the given
+ * key-spec and wrap it before returning.
+ * The caller must ensure that wrapped_key points to a buffer with the
+ * correct size for the given key_spec. This size can be calculated
+ * by first calling the ias_wrapped_key_size.
+ */
+struct ias_keystore_generate_key {
+	/* input */
+	__u8 client_ticket[KEYSTORE_CLIENT_TICKET_SIZE];
+	__u32 key_spec;
+
+	/* output */
+	__u8 __user *wrapped_key;
+};
+
+/**
+ * struct ias_keystore_wrap_key - Wrap an existing key
+ * @client_ticket:   Ticket used to identify this client session
+ * @key_spec:        Key type to be generated
+ * @app_key:         The bare application key to be wrapped
+ * @app_key_size:    Size of the bare key.
+ * @wrapped_key:     The generated key wrapped by keystore
+ *
+ * Keystore checks the key spec and size before wrapping it.
+ * The caller must ensure that wrapped_key points to a buffer with the
+ * correct size for the given key_spec. This size can be calculated
+ * by first calling the %KEYSTORE_IOC_WRAPPED_KEYSIZE ioctl.
+ *
+ * Keys are wrapped using the AES-SIV algorithm. AES-SIV was chosen
+ * as it does not require an Initialisation Vector.
+ */
+struct ias_keystore_wrap_key {
+	/* input */
+	__u8 client_ticket[KEYSTORE_CLIENT_TICKET_SIZE];
+	__u32 key_spec;
+	const __u8 __user *app_key;
+	__u32 app_key_size;
+
+	/* output */
+	__u8 __user *wrapped_key;
+};
+
+/**
+ * struct ias_keystore_load_key - Load a key into a slot
+ * @client_ticket:    Ticket used to identify this client session
+ * @wrapped_key:      The wrapped key
+ * @wrapped_key_size: Size of the wrapped key
+ * @slot_id:          The assigned slot
+ *
+ * Loads a wrapped key into the next available slot for
+ * this client ticket.
+ */
+struct ias_keystore_load_key {
+	/* input */
+	__u8 client_ticket[KEYSTORE_CLIENT_TICKET_SIZE];
+	__u8 __user *wrapped_key;
+	__u32 wrapped_key_size;
+
+	/* output */
+	__u32 slot_id;
+};
+
+/**
+ * struct ias_keystore_unload_key - Unload a key from a slot
+ * @client_ticket:    Ticket used to identify this client session
+ * @slot_id:          The assigned slot
+ *
+ * Unloads a key from the given slot.
+ */
+struct ias_keystore_unload_key {
+	/* input */
+	__u8 client_ticket[KEYSTORE_CLIENT_TICKET_SIZE];
+	__u32 slot_id;
+};
+
+/**
+ * struct ias_keystore_crypto_size - Get the size of output buffer.
+ * @algospec:    The encryption algorithm to use.
+ * @input_size:  Size of the input buffer.
+ * @output_size: Size of the output buffer.
+ *
+ * This struct is used by the client to calculate the required size of
+ * an output buffer passed to the Keystore encrypt and decrypt operations.
+ */
+struct ias_keystore_crypto_size {
+	/* input */
+	__u32 algospec;
+	__u32 input_size;
+
+	/* output */
+	__u32 output_size;
+};
+
+/**
+ * struct ias_keystore_encrypt_decrypt - Encrypt or Decrypt using a loaded key
+ * @client_ticket:    Ticket used to identify this client session
+ * @slot_id:          The assigned slot
+ * @algospec:         The encryption algorithm to use
+ * @iv:               The initialisation vector (IV)
+ * @iv_size:          Size of the IV.
+ * @input:            Pointer to the cleartext input
+ * @input_size:       Size of the input data
+ * @output:           Pointer to an output buffer
+ *
+ * Encrypt a block of data using the key stored in the given slot.
+ * The caller must assure that the output points to a buffer with
+ * at enough space. The correct size can be calculated by calling
+ * ias_keystore_crypto_size.
+ */
+struct ias_keystore_encrypt_decrypt {
+	/* input */
+	__u8 client_ticket[KEYSTORE_CLIENT_TICKET_SIZE];
+	__u32 slot_id;
+	__u32 algospec;
+	const __u8 __user *iv;
+	__u32 iv_size;
+	const __u8 __user *input;
+	__u32 input_size;
+
+	/* output */
+	__u8 __user *output;  /* notice: pointer */
+};
+
+/**
+ * DOC: Keystore IOCTLs
+ *
+ * A list of the keystore ioctls can be found here. Each ioctl
+ * is more or less mapped to a corresponding function in
+ * keystore_api_kernel.h.
+ *
+ * Although documented as functions, the ioctls are preprocessor
+ * defines to be used in the ioctl() function.
+ *
+ */
+
+#define KEYSTORE_IOC_MAGIC '7'
+
+/**
+ * KEYSTORE_IOC_VERSION - Keystore version
+ *
+ * Returns the keystore version in a &struct ias_keystore_version
+ */
+#define KEYSTORE_IOC_VERSION\
+	_IOR(KEYSTORE_IOC_MAGIC,   0, struct ias_keystore_version)
+
+/**
+ * KEYSTORE_IOC_REGISTER - Register a client with keystore
+ *
+ * Calls the keystore_register() function with &struct ias_keystore_register.
+ */
+#define KEYSTORE_IOC_REGISTER\
+	_IOWR(KEYSTORE_IOC_MAGIC,  1, struct ias_keystore_register)
+
+/**
+ * KEYSTORE_IOC_REGISTER - Register a client with keystore
+ *
+ * Calls the keystore_unregister() function with
+ * &struct ias_keystore_unregister.
+ */
+#define KEYSTORE_IOC_UNREGISTER\
+	_IOW(KEYSTORE_IOC_MAGIC,   2, struct ias_keystore_unregister)
+
+/**
+ * KEYSTORE_IOC_WRAPPED_KEYSIZE - Gets the wrapped keysize for a given key.
+ *
+ * Calls the keystore_wrapped_key_size() function with
+ * &struct ias_keystore_wrapped_key_size.
+ */
+#define KEYSTORE_IOC_WRAPPED_KEYSIZE\
+	_IOWR(KEYSTORE_IOC_MAGIC,  3, struct ias_keystore_wrapped_key_size)
+
+/**
+ * KEYSTORE_IOC_GENERATE_KEY - Generate a random key and wrap it.
+ *
+ * Calls the keystore_generate_key() function with
+ * &struct ias_keystore_generate_key.
+ */
+#define KEYSTORE_IOC_GENERATE_KEY\
+	_IOW(KEYSTORE_IOC_MAGIC,  4, struct ias_keystore_generate_key)
+
+/**
+ * KEYSTORE_IOC_WRAP_KEY - Wrap the application key.
+ *
+ * Calls the keystore_wrap_key() function with
+ * &struct ias_keystore_wrap_key.
+ */
+#define KEYSTORE_IOC_WRAP_KEY\
+	_IOW(KEYSTORE_IOC_MAGIC,  5, struct ias_keystore_wrap_key)
+
+/**
+ * KEYSTORE_IOC_LOAD_KEY - Unwrap the application key and store in a slot.
+ *
+ * Calls the keystore_load_key() function with
+ * &struct ias_keystore_load_key.
+ */
+#define KEYSTORE_IOC_LOAD_KEY\
+	_IOWR(KEYSTORE_IOC_MAGIC,   6, struct ias_keystore_load_key)
+
+/**
+ * KEYSTORE_IOC_UNLOAD_KEY - Remove a key from a slot
+ *
+ * Calls the keystore_unload_key() function with
+ * &struct ias_keystore_unload_key.
+ */
+#define KEYSTORE_IOC_UNLOAD_KEY\
+	_IOW(KEYSTORE_IOC_MAGIC,   7, struct ias_keystore_unload_key)
+
+/**
+ * KEYSTORE_IOC_ENCRYPT_SIZE - Get the required size of an encrypted buffer.
+ *
+ * Calls the keystore_encrypt_size() function with
+ * &struct ias_keystore_crypto_size.
+ */
+#define KEYSTORE_IOC_ENCRYPT_SIZE\
+	_IOWR(KEYSTORE_IOC_MAGIC,   8, struct ias_keystore_crypto_size)
+
+/**
+ * KEYSTORE_IOC_ENCRYPT - Encrypt plaintext using AppKey/IV according to
+ *                        AlgoSpec.
+ *
+ * Calls the keystore_encrypt() function with
+ * &struct ias_keystore_encrypt_decrypt.
+ */
+#define KEYSTORE_IOC_ENCRYPT\
+	_IOW(KEYSTORE_IOC_MAGIC,   9, struct ias_keystore_encrypt_decrypt)
+
+/**
+ * KEYSTORE_IOC_DECRYPT_SIZE - Get the required size of an decrypted buffer.
+ *
+ * Calls the keystore_decrypt_size() function with
+ * &struct ias_keystore_crypto_size.
+ */
+#define KEYSTORE_IOC_DECRYPT_SIZE\
+	_IOWR(KEYSTORE_IOC_MAGIC,  10, struct ias_keystore_crypto_size)
+
+/**
+ * KEYSTORE_IOC_DECRYPT - Decrypt cyphertext using AppKey/IV according to
+ *                        AlgoSpec.
+ *
+ * Calls the keystore_decrypt() function with
+ * &struct ias_keystore_encrypt_decrypt.
+ */
+#define KEYSTORE_IOC_DECRYPT\
+	_IOW(KEYSTORE_IOC_MAGIC,  11, struct ias_keystore_encrypt_decrypt)
+
+#endif /* _KEYSTORE_API_USER_H_ */
diff --git a/security/Kconfig b/security/Kconfig
index 353cfef71d4e..f07c3d7fd783 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -236,7 +236,7 @@ source "security/apparmor/Kconfig"
 source "security/loadpin/Kconfig"
 source "security/yama/Kconfig"
 source "security/safesetid/Kconfig"
-
+source "security/keystore/Kconfig"
 source "security/integrity/Kconfig"
 
 choice
diff --git a/security/Makefile b/security/Makefile
index c598b904938f..13800f637d52 100644
--- a/security/Makefile
+++ b/security/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_SECURITY_YAMA)		+= yama/
 obj-$(CONFIG_SECURITY_LOADPIN)		+= loadpin/
 obj-$(CONFIG_SECURITY_SAFESETID)       += safesetid/
 obj-$(CONFIG_CGROUP_DEVICE)		+= device_cgroup.o
+obj-$(CONFIG_KEYSTORE)			+= keystore/
 
 # Object integrity file lists
 subdir-$(CONFIG_INTEGRITY)		+= integrity
diff --git a/security/keystore/Kconfig b/security/keystore/Kconfig
new file mode 100644
index 000000000000..27e5ec346cb0
--- /dev/null
+++ b/security/keystore/Kconfig
@@ -0,0 +1,41 @@
+config KEYSTORE
+	tristate "Keystore"
+        depends on INTEL_MEI_DAL
+	default n
+	help
+		An system deals with various keys that need to be stored
+		securely on the platform. Some of the keys are stored in
+		specific embedded hardware but others are required by
+		algorithms running on Linux. The keystore is designed to
+		provide a secure storage solution for such keys. Applications
+		interface is through the char device ioctls on /dev/keystore.
+
+		If in doubt, say "N".
+
+config KEYSTORE_DEBUG
+	bool "Keystore enable additional debug messages"
+	depends on KEYSTORE
+        default n
+	help
+		Provides additional debug prints, hexdumps during keystore
+		operation. Includes hexdump of cryptographic data structures
+		such as public keys.
+
+		Should not be enabled in production as it will expose
+		sensitive information!
+
+		If unsure, select "N".
+
+config DAL_KEYSTORE_APPLET_PATH
+	string "DAL Keystore Applet path"
+	depends on KEYSTORE
+	default "/var/lib/intel/dal/applets/Keystore.pack"
+	help
+		The path for DAL Keystore applet file.
+
+config DAL_KEYSTORE_APPLET_ID
+	string "DAL Keystore Applet UUID"
+	depends on KEYSTORE
+	default "c12452f0adc640a78623708f0f4f0e52"
+	help
+		DAL Keystore applet UUID.
diff --git a/security/keystore/Makefile b/security/keystore/Makefile
new file mode 100644
index 000000000000..2517283817ca
--- /dev/null
+++ b/security/keystore/Makefile
@@ -0,0 +1,22 @@
+#
+# Makefile - Intel Keystore Linux driver
+#
+
+# Keystore module
+obj-$(CONFIG_KEYSTORE) := keystore.o
+
+# Otherwise, select the full file list
+keystore-$(CONFIG_KEYSTORE) +=\
+	keystore_kmod.o\
+	client.o \
+	ioctls.o\
+	mac.o\
+	rdrand.o\
+	api_dal.o\
+	dal_client.o\
+	applet_read.o\
+	dal_context.o\
+	dal_context_safe.o
+
+keystore-$(CONFIG_KEYSTORE_DEBUG) +=\
+	debug.o
diff --git a/security/keystore/api_dal.c b/security/keystore/api_dal.c
new file mode 100644
index 000000000000..d4f083a24cd3
--- /dev/null
+++ b/security/keystore/api_dal.c
@@ -0,0 +1,1041 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#include "keystore_debug.h"
+#include "dal_context_safe.h"
+#include "keystore_client.h"
+#include "keystore_rand.h"
+
+#include "dal_client.h"
+
+#define KEYSPEC_DAL_WRAPPED_KEY (165)
+#define EXCEPTION_SESSION_NOT_PRESENT (-155)
+#define EXCEPTION_KEY_REWRAPPED (-171)
+
+struct dal_key_info key_info = {0};
+
+static int dal_keystore_init(void);
+static int dal_keystore_close(void);
+static void init_key_cache(void);
+static int dal_keystore_install_and_init(void);
+static int handle_command_response(int res, int response_code, int *retry,
+		const uint8_t *client_ticket, const uint8_t *client_id);
+static int pack_int_to_buf(unsigned int i, unsigned char *buf);
+
+static int dal_keystore_init(void)
+{
+	size_t output_len = 0, response_code = 0;
+	int commandId = DAL_KEYSTORE_INIT;
+	uint8_t *out_buf = NULL;
+
+	int res = send_and_receive(commandId, NULL, 0,
+		&out_buf, &output_len, &response_code);
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error in send_and_receive: command id = %d %d\n",
+		__func__, commandId, res);
+		kzfree(out_buf);
+		return -EFAULT;
+	}
+	init_key_cache();
+	kzfree(out_buf);
+
+	return 0;
+}
+
+static int dal_keystore_close(void)
+{
+	close_session();
+
+	return 0;
+}
+
+static int dal_calc_clientid(u8 *client_id, const unsigned int client_id_size)
+{
+	/* Calculate the Client ID */
+	return keystore_calc_clientid(client_id, client_id_size);
+}
+
+static int dal_keystore_install_and_init(void)
+{
+	int res = 0;
+
+	if (install_applet()) {
+		res = -EFAULT;
+		ks_err("install_applet() failed\n");
+		goto ret;
+	}
+	if (dal_keystore_init()) {
+		res = -EFAULT;
+		ks_err("dal_keystore_init() failed\n");
+		goto ret;
+	}
+	ks_debug("dal_keystore_init: success\n");
+
+ret:
+	return res;
+}
+
+static int dal_keystore_register_client(enum keystore_seed_type seed_type,
+		const uint8_t *client_ticket, const uint8_t *client_id)
+{
+	int res = 0;
+	size_t output_len = 0, response_code = 0;
+	int commandId = DAL_KEYSTORE_REGISTER;
+	uint8_t input[KEYSTORE_MAX_CLIENT_ID_SIZE
+				  + KEYSTORE_CLIENT_TICKET_SIZE + 2];
+	uint8_t *out_buf = NULL;
+	size_t index = 0;
+	int retry = 0;
+
+	FUNC_BEGIN;
+
+	if (!client_ticket || !client_id) {
+		res = -EFAULT;
+		goto err;
+	}
+
+	memcpy(input, client_id, sizeof(client_id));
+	index += sizeof(client_id);
+	memcpy(input + index, client_ticket, KEYSTORE_CLIENT_TICKET_SIZE);
+	index += KEYSTORE_CLIENT_TICKET_SIZE;
+	pack_int_to_buf(seed_type, input + index);
+	index += 2;
+
+cmd_retry:
+	res = send_and_receive(commandId, input, index,
+		&out_buf, &output_len, &response_code);
+
+	res = handle_command_response(res, response_code, &retry, NULL, NULL);
+	if (res) {
+		ks_info(KBUILD_MODNAME ": %s Error in send_and_receive: command id = %d %d %d\n",
+					 __func__, commandId, res,
+					 response_code);
+
+		kzfree(out_buf);
+		goto close_session;
+	}
+
+	kzfree(out_buf);
+
+	FUNC_RES(res);
+	return res;
+close_session:
+	dal_keystore_close();
+err:
+	return res;
+}
+
+static int restore_client_session(const uint8_t *client_ticket,
+		const uint8_t *client_id)
+{
+	enum keystore_seed_type seed_type;
+	int res = 0;
+
+	res = dal_ctx_get_client_seed_type(client_ticket,
+			&seed_type, client_id);
+
+	if (res) {
+		ks_info(KBUILD_MODNAME ": %s: Get client seed type failed\n",
+			   __func__);
+		return res;
+	}
+
+	res = dal_keystore_register_client(seed_type, client_ticket, client_id);
+
+	if (res)
+		ks_info(KBUILD_MODNAME ": %s: Client re-register failed\n",
+			   __func__);
+
+	return res;
+}
+
+static int handle_command_response(int res, int response_code, int *retry,
+		const uint8_t *client_ticket, const uint8_t *client_id)
+{
+	if (res == DAL_KDI_STATUS_INTERNAL_ERROR) {
+		*retry = 1;
+		res = dal_keystore_install_and_init();
+		ks_info(KBUILD_MODNAME ": %s install/init status: %d\n",
+				__func__, res);
+		return res;
+	} else if (res == 0 && response_code == EXCEPTION_SESSION_NOT_PRESENT
+				&& client_ticket && client_id) {
+		*retry = 1;
+		res = restore_client_session(client_ticket, client_id);
+		ks_info(KBUILD_MODNAME ": %s restore session status: %d\n",
+				__func__, res);
+		return res;
+	} else if (res == 0 &&
+			response_code == EXCEPTION_KEY_REWRAPPED) {
+		*retry = 0;
+		ks_info(KBUILD_MODNAME ": %s command exception: %d\n",
+				__func__, response_code);
+		return -EAGAIN;
+	} else if (res == 0 && response_code < 0) {
+		*retry = 0;
+		ks_info(KBUILD_MODNAME ": %s command exception: %d\n",
+				__func__, response_code);
+		return response_code;
+	}
+
+	/* falls thru */
+	*retry = 0;
+	ks_info(KBUILD_MODNAME ": %s passing thru status: %d %d\n",
+			__func__, res, response_code);
+	return res;
+}
+
+int dal_keystore_register(enum keystore_seed_type seed_type,
+				uint8_t *client_ticket)
+{
+	uint8_t client_id[KEYSTORE_MAX_CLIENT_ID_SIZE];
+	uint8_t input[KEYSTORE_MAX_CLIENT_ID_SIZE
+				  + KEYSTORE_CLIENT_TICKET_SIZE + 2];
+	int res = 0;
+	size_t output_len = 0, response_code = 0;
+	int commandId = DAL_KEYSTORE_REGISTER;
+	uint8_t *out_buf = NULL;
+	size_t index = 0;
+	int retry = 0;
+
+	FUNC_BEGIN;
+
+	if (!client_ticket) {
+		res = -EFAULT;
+		goto err;
+	}
+
+	if (is_dal_session_created()) {
+		res = dal_keystore_install_and_init();
+		if (res) {
+			ks_err(KBUILD_MODNAME ": %s Applet install and init failed %d\n",
+				 __func__, res);
+			goto close_session;
+		}
+	}
+
+	res = dal_calc_clientid(client_id, sizeof(client_id));
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error calculating client ID: %d\n",
+		       __func__, res);
+		goto close_session;
+	}
+
+	/* randomize a buffer */
+	keystore_get_rdrand(client_ticket, KEYSTORE_CLIENT_TICKET_SIZE);
+
+	memcpy(input, client_id, sizeof(client_id));
+	index += sizeof(client_id);
+	memcpy(input + index, client_ticket, KEYSTORE_CLIENT_TICKET_SIZE);
+	index += KEYSTORE_CLIENT_TICKET_SIZE;
+	pack_int_to_buf(seed_type, input + index);
+	index += 2;
+
+cmd_retry:
+	res = send_and_receive(commandId, input, index,
+		&out_buf, &output_len, &response_code);
+
+	res = handle_command_response(res, response_code, &retry, NULL, NULL);
+
+	if (!res && retry) {
+		response_code = 0;
+		/* It's very unlikely that we slept between applet
+		 * initialization and client registrastion,
+		 * but just in case...
+		 */
+		goto cmd_retry;
+	}
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error in send_and_receive: command id = %d %d\n",
+			 __func__, commandId, res);
+		kzfree(out_buf);
+		goto close_session;
+	}
+
+	/* Add the new client to the context */
+	res = dal_ctx_add_client(client_ticket, seed_type, client_id);
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s: Cannot allocate context\n",
+			   __func__);
+		kzfree(out_buf);
+		goto close_session;
+	}
+
+	kzfree(out_buf);
+
+	FUNC_RES(res);
+	return res;
+close_session:
+	dal_keystore_close();
+err:
+	return res;
+}
+EXPORT_SYMBOL(dal_keystore_register);
+
+int dal_keystore_unregister(const uint8_t *client_ticket)
+{
+	uint8_t input[KEYSTORE_MAX_CLIENT_ID_SIZE
+		+ KEYSTORE_CLIENT_TICKET_SIZE];
+	int res = 0;
+	size_t output_len = 0, response_code = 0;
+	int commandId = DAL_KEYSTORE_UNREGISTER;
+	uint8_t *out_buf = NULL;
+	int retry = 0;
+
+	FUNC_BEGIN;
+	res = dal_calc_clientid(input, KEYSTORE_MAX_CLIENT_ID_SIZE);
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error calculating client ID: %d\n",
+			__func__, res);
+		return res;
+	}
+
+	memcpy(input + KEYSTORE_MAX_CLIENT_ID_SIZE,
+			client_ticket, KEYSTORE_CLIENT_TICKET_SIZE);
+
+	res = send_and_receive(commandId, input, sizeof(input),
+		&out_buf, &output_len, &response_code);
+
+	res = handle_command_response(res, response_code, &retry, NULL, NULL);
+
+	/* DAL Keystore session is reset, just reinitialized the applet */
+	if (!res && retry)
+		response_code = 0;
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error in send_and_receive: command id = %d %d\n",
+				__func__, commandId, res);
+	}
+
+	res = dal_ctx_remove_client(client_ticket);
+
+	if (res)
+		ks_err(KBUILD_MODNAME ": %s: Cannot find context\n",
+				__func__);
+
+	kzfree(out_buf);
+	FUNC_RES(res);
+	return res;
+}
+EXPORT_SYMBOL(dal_keystore_unregister);
+
+static int pack_int_to_buf(unsigned int i, unsigned char *buf)
+{
+	/* integers are represented by 2 bytes currently */
+	if (i >= 0x10000)
+		return -EFAULT;
+	buf[0] = i & 0xFF;
+	buf[1] = (i >> 8) & 0xFF;
+
+	return 0;
+}
+
+static void init_key_cache(void)
+{
+	key_info.keyspec = KEYSPEC_INVALID;
+	key_info.key_size = 0;
+	key_info.wrap_key_size = 0;
+}
+
+static int get_cached_wrapped_key_size(void)
+{
+	if (key_info.keyspec != KEYSPEC_INVALID) {
+		if (key_info.wrap_key_size != 0)
+			return key_info.wrap_key_size;
+	}
+	return -EFAULT;
+}
+
+static int get_cached_key_size(void)
+{
+	if (key_info.keyspec != KEYSPEC_INVALID) {
+		if (key_info.key_size != 0)
+			return key_info.key_size;
+	}
+	return -EFAULT;
+}
+
+static void cache_wrapped_key_size(enum keystore_key_spec keyspec,
+				uint32_t wrap_key_size)
+{
+	key_info.keyspec = keyspec;
+	key_info.wrap_key_size = wrap_key_size;
+}
+
+static void cache_key_size(enum keystore_key_spec keyspec, uint32_t key_size)
+{
+	key_info.keyspec = keyspec;
+	key_info.key_size = key_size;
+}
+
+int dal_keystore_wrapped_key_size(enum keystore_key_spec keyspec,
+			      unsigned int *size,
+			      unsigned int *unwrapped_size)
+{
+	uint8_t client_id[KEYSTORE_MAX_CLIENT_ID_SIZE];
+	int res = 0;
+	size_t output_len = 0, response_code = 0;
+	unsigned char buf[2];
+	int commandId = 0;
+	int key_len = 0;
+	uint8_t *out_buf = NULL;
+	int retry = 0;
+
+	FUNC_BEGIN;
+	res = dal_calc_clientid(client_id, sizeof(client_id));
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error calculating client ID: %d\n",
+			__func__, res);
+		return res;
+	}
+
+	pack_int_to_buf(keyspec, buf);
+	commandId = DAL_KEYSTORE_GET_KEYSIZE;
+
+get_keysize_retry:
+	res = send_and_receive(commandId, buf, 2,
+		&out_buf, &output_len, &response_code);
+
+	res = handle_command_response(res, response_code, &retry, NULL,
+		client_id);
+
+	if (!res && retry) {
+		response_code = 0;
+		goto get_keysize_retry;
+	}
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error in send_and_receive: command id = %d %d\n",
+			__func__, commandId, res);
+		kzfree(out_buf);
+		return res;
+	}
+	key_len = response_code;
+
+	cache_key_size(keyspec, key_len);
+	response_code = 0;
+
+	commandId = DAL_KEYSTORE_WRAP_KEYSIZE;
+
+get_wrap_keysize_retry:
+	res = send_and_receive(commandId, buf, 2,
+		&out_buf, &output_len, &response_code);
+	retry = 0;
+	res = handle_command_response(res, response_code, &retry, NULL,
+		client_id);
+
+	if (!res && retry) {
+		response_code = 0;
+		goto get_wrap_keysize_retry;
+	}
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error in send_and_receive: command id = %d %d\n",
+			__func__, commandId, res);
+		kzfree(out_buf);
+		return res;
+	}
+
+	if (unwrapped_size)
+		*unwrapped_size = key_len;
+	if (size)
+		*size = response_code;
+
+	cache_wrapped_key_size(keyspec, response_code);
+
+	kzfree(out_buf);
+
+	FUNC_RES(res);
+	return res;
+}
+EXPORT_SYMBOL(dal_keystore_wrapped_key_size);
+
+static int dal_get_wrapped_key_size(enum keystore_key_spec keyspec)
+{
+	int res = 0;
+	size_t output_len = 0, response_code = 0;
+	unsigned char buf[2];
+	int commandId = DAL_KEYSTORE_WRAP_KEYSIZE;
+	uint8_t *out_buf = NULL;
+	int retry = 0;
+
+	pack_int_to_buf(keyspec, buf);
+
+cmd_retry:
+	res = send_and_receive(commandId, buf, 2,
+		&out_buf, &output_len, &response_code);
+
+	res = handle_command_response(res, response_code, &retry, NULL, NULL);
+
+	if (!res && retry) {
+		response_code = 0;
+		goto cmd_retry;
+	}
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error in send_and_receive: command id = %d %d\n",
+			__func__, commandId, res);
+		kzfree(out_buf);
+		return res;
+	}
+	cache_wrapped_key_size(keyspec, response_code);
+
+	kzfree(out_buf);
+
+	FUNC_RES(res);
+	return response_code;
+}
+
+int dal_keystore_wrap_key(const uint8_t *client_ticket,
+		      const uint8_t *app_key, unsigned int app_key_size,
+		      enum keystore_key_spec keyspec, uint8_t *wrapped_key)
+{
+	uint8_t client_id[KEYSTORE_MAX_CLIENT_ID_SIZE];
+	int res = 0;
+	size_t response_code = 0;
+	uint8_t input[KEYSTORE_MAX_CLIENT_ID_SIZE + KEYSTORE_CLIENT_TICKET_SIZE
+				+ app_key_size + 2];
+	int commandId = DAL_KEYSTORE_WRAP_KEY;
+	size_t output_len = 0;
+	uint8_t *out_buf = NULL;
+	size_t index = 0;
+	int retry = 0;
+
+	FUNC_BEGIN;
+
+	res = dal_calc_clientid(client_id, KEYSTORE_MAX_CLIENT_ID_SIZE);
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error calculating client ID: %d\n",
+			__func__, res);
+		return res;
+	}
+
+	memcpy(input, client_id, sizeof(client_id));
+	index += sizeof(client_id);
+	memcpy(input + index, client_ticket, KEYSTORE_CLIENT_TICKET_SIZE);
+	index += KEYSTORE_CLIENT_TICKET_SIZE;
+	pack_int_to_buf(keyspec, input + index);
+	index += 2;
+	memcpy(input + index, app_key, app_key_size);
+	index += app_key_size;
+
+cmd_retry:
+	output_len = get_cached_wrapped_key_size();
+
+	res = send_and_receive(commandId, input, sizeof(input),
+		&out_buf, &output_len, &response_code);
+
+	res = handle_command_response(res, response_code, &retry,
+			client_ticket, client_id);
+
+	if (!res && retry) {
+		response_code = 0;
+		goto cmd_retry;
+	}
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error in send_and_receive: command id = %d %d %d\n",
+			__func__, commandId, res, response_code);
+
+		goto exit;
+	}
+	memcpy(wrapped_key, out_buf, output_len);
+
+exit:
+	if (out_buf)
+		kzfree(out_buf);
+
+	FUNC_RES(res);
+	return res;
+}
+EXPORT_SYMBOL(dal_keystore_wrap_key);
+
+int dal_keystore_generate_key(const uint8_t *client_ticket,
+			const enum keystore_key_spec keyspec,
+			uint8_t *wrapped_key)
+{
+	uint8_t client_id[KEYSTORE_MAX_CLIENT_ID_SIZE];
+	int res = 0;
+	size_t response_code = 0;
+	uint8_t input[KEYSTORE_MAX_CLIENT_ID_SIZE
+		+ KEYSTORE_CLIENT_TICKET_SIZE + 2];
+	int commandId = DAL_KEYSTORE_GENERATE_KEY;
+	size_t output_len = 0;
+	uint8_t *out_buf = NULL;
+	size_t index = 0;
+	int retry = 0;
+
+	FUNC_BEGIN;
+
+	res = dal_calc_clientid(client_id, sizeof(client_id));
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error calculating client ID: %d\n",
+			__func__, res);
+		return res;
+	}
+
+	memcpy(input, client_id, sizeof(client_id));
+	index += sizeof(client_id);
+	memcpy(input + index, client_ticket, KEYSTORE_CLIENT_TICKET_SIZE);
+	index += KEYSTORE_CLIENT_TICKET_SIZE;
+	pack_int_to_buf(keyspec, input + index);
+	index += 2;
+
+cmd_retry:
+	output_len = dal_get_wrapped_key_size(keyspec);
+
+	res = send_and_receive(commandId, input, index,
+		&out_buf, &output_len, &response_code);
+
+	res = handle_command_response(res, response_code, &retry,
+			client_ticket, client_id);
+
+	if (!res && retry) {
+		response_code = 0;
+		goto cmd_retry;
+	}
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error in send_and_receive: command id = %d %d\n",
+			__func__, commandId, res);
+		kzfree(out_buf);
+		return res;
+	}
+
+	memcpy(wrapped_key, out_buf, output_len);
+	kzfree(out_buf);
+
+	FUNC_RES(res);
+	return res;
+}
+EXPORT_SYMBOL(dal_keystore_generate_key);
+
+int dal_keystore_load_key(const uint8_t *client_ticket,
+			uint8_t *wrapped_key,
+			unsigned int wrapped_key_size, unsigned int *slot_id)
+{
+	int res = 0;
+	uint8_t client_id[KEYSTORE_MAX_CLIENT_ID_SIZE];
+	size_t output_len = 0;
+	int commandId = DAL_KEYSTORE_LOAD_KEY;
+	size_t response_code = 0;
+	uint8_t *out_buf = NULL;
+	int retry = 0;
+	size_t index = 0;
+
+	FUNC_BEGIN;
+
+	if (!slot_id)
+		return -EFAULT;
+
+	if (wrapped_key_size > DAL_KEYSTORE_MAX_WRAP_KEY_LEN) {
+		ks_err(KBUILD_MODNAME ": %s: wrapped_key_size %u, expected < %u",
+			__func__, wrapped_key_size,
+			DAL_KEYSTORE_MAX_WRAP_KEY_LEN);
+		return -EINVAL;
+	}
+
+	uint8_t input[KEYSTORE_MAX_CLIENT_ID_SIZE
+				  + KEYSTORE_CLIENT_TICKET_SIZE
+				  + wrapped_key_size];
+
+	res = dal_calc_clientid(client_id, KEYSTORE_MAX_CLIENT_ID_SIZE);
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error calculating client ID: %d\n",
+				__func__, res);
+		return res;
+	}
+
+	memcpy(input, client_id, sizeof(client_id));
+	index += sizeof(client_id);
+	memcpy(input + index, client_ticket, KEYSTORE_CLIENT_TICKET_SIZE);
+	index += KEYSTORE_CLIENT_TICKET_SIZE;
+	memcpy(input + index, wrapped_key, wrapped_key_size);
+	index += wrapped_key_size;
+
+cmd_retry:
+	output_len = wrapped_key_size;
+	res = send_and_receive(commandId, input, index,
+			&out_buf, &output_len, &response_code);
+
+	res = handle_command_response(res, response_code, &retry,
+			client_ticket, client_id);
+
+	if (!res && retry) {
+		response_code = 0;
+		goto cmd_retry;
+	}
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error in send_and_receive: command id = %d %d\n",
+				__func__, commandId, res);
+
+		if (res == -EAGAIN && output_len && out_buf) {
+			/* The key was re-wrapped with current SEED
+			 * so client has to update it.
+			 */
+			memcpy(wrapped_key, out_buf, output_len);
+		}
+
+		kzfree(out_buf);
+		return res;
+	}
+
+	res = dal_ctx_add_wrapped_key(client_ticket, KEYSPEC_DAL_WRAPPED_KEY,
+			wrapped_key, wrapped_key_size, slot_id);
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s: Insert wrapped key to slot failed\n",
+				__func__);
+	}
+
+	FUNC_RES(res);
+	return res;
+}
+EXPORT_SYMBOL(dal_keystore_load_key);
+
+int dal_keystore_unload_key(const uint8_t *client_ticket, unsigned int slot_id)
+{
+	int res = 0;
+
+	FUNC_BEGIN;
+
+	res = dal_ctx_remove_wrapped_key(client_ticket, slot_id);
+
+	FUNC_RES(res);
+	return res;
+}
+EXPORT_SYMBOL(dal_keystore_unload_key);
+
+static int dal_encrypt_output_size(enum keystore_algo_spec algo_spec,
+			unsigned int input_size,
+			unsigned int *output_size)
+{
+	if (!output_size)
+		return -EFAULT;
+
+	*output_size = 0;
+
+	switch (algo_spec) {
+	case ALGOSPEC_AES_GCM:
+		*output_size = input_size + DAL_KEYSTORE_GCM_AUTH_SIZE;
+		break;
+	default:
+		ks_err(KBUILD_MODNAME ": Unknown or invalid algo_spec: %u\n",
+		algo_spec);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int dal_keystore_encrypt_size(enum keystore_algo_spec algo_spec,
+			  unsigned int input_size, unsigned int *output_size)
+{
+	int res = 0;
+
+	FUNC_BEGIN;
+	res = dal_encrypt_output_size(algo_spec, input_size, output_size);
+
+	FUNC_RES(res);
+	return res;
+}
+EXPORT_SYMBOL(dal_keystore_encrypt_size);
+
+int dal_keystore_encrypt(const uint8_t *client_ticket, int slot_id,
+			enum keystore_algo_spec algo_spec,
+			const uint8_t *iv, unsigned int iv_size,
+			const uint8_t *input, unsigned int input_size,
+			uint8_t *output)
+{
+	int res = 0;
+	uint8_t client_id[KEYSTORE_MAX_CLIENT_ID_SIZE];
+	uint8_t wrapped_key[DAL_KEYSTORE_MAX_WRAP_KEY_LEN];
+	unsigned int wrapped_key_size = DAL_KEYSTORE_MAX_WRAP_KEY_LEN;
+	enum keystore_key_spec key_spec = KEYSPEC_INVALID;
+	int commandId = DAL_KEYSTORE_ENCRYPT;
+	const size_t in_size = (KEYSTORE_MAX_CLIENT_ID_SIZE
+			+ KEYSTORE_CLIENT_TICKET_SIZE
+			+ DAL_KEYSTORE_MAX_WRAP_KEY_LEN
+			+ DAL_KEYSTORE_GCM_IV_SIZE + input_size + 8);
+	size_t index = 0;
+	size_t output_len = 0;
+	size_t response_code = 0;
+	uint8_t *in = NULL;
+	uint8_t *out_buf = NULL;
+	int retry = 0;
+
+	FUNC_BEGIN;
+
+	in = kmalloc(in_size, GFP_KERNEL);
+	if (!in) {
+		res = -ENOMEM;
+		goto exit;
+	}
+
+	ks_debug(KBUILD_MODNAME
+		": keystore_encrypt slot_id=%d algo_spec=%d iv_size=%u isize=%u\n",
+		slot_id, (int)algo_spec, iv_size, input_size);
+
+	if (!iv || iv_size < DAL_KEYSTORE_GCM_IV_SIZE ||
+		iv_size > KEYSTORE_MAX_IV_SIZE) {
+			ks_err(KBUILD_MODNAME ": Incorrect input values to %s\n",
+				       __func__);
+		return -EINVAL;
+	}
+
+	iv_size = DAL_KEYSTORE_GCM_IV_SIZE;
+
+	res = dal_calc_clientid(client_id, sizeof(client_id));
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error calculating client ID: %d\n",
+			__func__, res);
+		goto exit;
+	}
+
+	memcpy(in, client_id, sizeof(client_id));
+	index += sizeof(client_id);
+	memcpy(in + index, client_ticket, KEYSTORE_CLIENT_TICKET_SIZE);
+	index += KEYSTORE_CLIENT_TICKET_SIZE;
+
+	/* Get the wrapped application key */
+	res = dal_ctx_get_wrapped_key(client_ticket, slot_id, &key_spec,
+			wrapped_key, &wrapped_key_size);
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s: Error %d getting wrapped key.\n",
+			   __func__, res);
+		goto exit;
+	}
+
+	if (key_spec != KEYSPEC_DAL_WRAPPED_KEY ||
+		wrapped_key_size > DAL_KEYSTORE_MAX_WRAP_KEY_LEN) {
+			ks_err(KBUILD_MODNAME ": %s: Invalid key retrived from wrapped key cache.\n",
+				   __func__, res);
+		goto exit;
+	}
+
+	res = pack_int_to_buf(wrapped_key_size, (uint8_t *)(in + index));
+	index += 2;
+	memcpy(in + index, wrapped_key, wrapped_key_size);
+	index += wrapped_key_size;
+	res = pack_int_to_buf(iv_size, (uint8_t *)(in + index));
+	index += 2;
+	memcpy(in + index, iv, iv_size);
+	index += iv_size;
+	res = pack_int_to_buf(input_size, (uint8_t *)(in + index));
+	index += 2;
+	memcpy(in + index, input, input_size);
+	index += input_size;
+
+cmd_retry:
+	res = dal_keystore_encrypt_size(algo_spec, input_size,
+				(unsigned int *)&output_len);
+	if (res) {
+		res = -ENOMEM;
+		goto exit;
+	}
+
+	res = send_and_receive(commandId, in, index,
+		&out_buf, &output_len, &response_code);
+
+	res = handle_command_response(res, response_code, &retry,
+				client_ticket, client_id);
+
+	if (!res && retry) {
+		response_code = 0;
+		goto cmd_retry;
+	}
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error in send_and_receive: command id = %d %d\n",
+			__func__, commandId, res);
+		goto exit;
+	}
+	memcpy(output, out_buf, output_len);
+
+exit:
+	if (in)
+		kzfree(in);
+	if (out_buf)
+		kzfree(out_buf);
+
+	FUNC_RES(res);
+	return res;
+}
+EXPORT_SYMBOL(dal_keystore_encrypt);
+
+static int dal_decrypt_output_size(enum keystore_algo_spec algo_spec,
+			unsigned int input_size,
+			unsigned int *output_size)
+{
+	if (!output_size)
+		return -EFAULT;
+
+	*output_size = 0;
+
+	switch (algo_spec) {
+	case ALGOSPEC_AES_GCM:
+		if (input_size < DAL_KEYSTORE_GCM_AUTH_SIZE)
+			return -EINVAL;
+		*output_size = input_size - DAL_KEYSTORE_GCM_AUTH_SIZE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int dal_keystore_decrypt_size(enum keystore_algo_spec algo_spec,
+		unsigned int input_size, unsigned int *output_size)
+{
+	return dal_decrypt_output_size(algo_spec, input_size, output_size);
+}
+EXPORT_SYMBOL(dal_keystore_decrypt_size);
+
+int dal_keystore_decrypt(const uint8_t *client_ticket, int slot_id,
+			enum keystore_algo_spec algo_spec,
+			const uint8_t *iv, unsigned int iv_size,
+			const uint8_t *input, unsigned int input_size,
+			uint8_t *output)
+{
+	int res = 0;
+	uint8_t client_id[KEYSTORE_MAX_CLIENT_ID_SIZE];
+	uint8_t wrapped_key[DAL_KEYSTORE_MAX_WRAP_KEY_LEN];
+	unsigned int wrapped_key_size = DAL_KEYSTORE_MAX_WRAP_KEY_LEN;
+	enum keystore_key_spec key_spec = KEYSPEC_INVALID;
+	int commandId = DAL_KEYSTORE_DECRYPT;
+	const size_t in_size = (KEYSTORE_MAX_CLIENT_ID_SIZE
+			+ KEYSTORE_CLIENT_TICKET_SIZE
+			+ DAL_KEYSTORE_MAX_WRAP_KEY_LEN
+			+ DAL_KEYSTORE_GCM_IV_SIZE + input_size + 8);
+	size_t index = 0;
+	size_t output_len = 0;
+	size_t response_code = 0;
+	uint8_t *in = NULL;
+	uint8_t *out_buf = NULL;
+	int retry = 0;
+
+	FUNC_BEGIN;
+
+	in = kmalloc(in_size, GFP_KERNEL);
+	if (!in) {
+		res = -ENOMEM;
+		goto exit;
+	}
+
+	ks_debug(KBUILD_MODNAME
+		": keystore_decrypt slot_id=%d algo_spec=%d iv_size=%u isize=%u\n",
+		slot_id, (int)algo_spec, iv_size, input_size);
+
+	if (!iv || iv_size < DAL_KEYSTORE_GCM_IV_SIZE || iv_size > KEYSTORE_MAX_IV_SIZE) {
+		ks_err(KBUILD_MODNAME ": Incorrect input values to %s\n",
+				       __func__);
+		return -EINVAL;
+	}
+
+	iv_size = DAL_KEYSTORE_GCM_IV_SIZE;
+
+	res = dal_calc_clientid(client_id, sizeof(client_id));
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error calculating client ID: %d\n",
+			__func__, res);
+		goto exit;
+	}
+
+	memcpy(in, client_id, sizeof(client_id));
+	index += sizeof(client_id);
+	memcpy(in + index, client_ticket, KEYSTORE_CLIENT_TICKET_SIZE);
+	index += KEYSTORE_CLIENT_TICKET_SIZE;
+
+	/* Get the wrapped application key */
+	res = dal_ctx_get_wrapped_key(client_ticket, slot_id, &key_spec,
+			wrapped_key, &wrapped_key_size);
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s: Error %d getting wrapped key.\n",
+			   __func__, res);
+		goto exit;
+	}
+
+	if (key_spec != KEYSPEC_DAL_WRAPPED_KEY ||
+		wrapped_key_size > DAL_KEYSTORE_MAX_WRAP_KEY_LEN) {
+			ks_err(KBUILD_MODNAME ": %s: Invalid key retrived from wrapped key cache.\n",
+				   __func__, res);
+		goto exit;
+	}
+
+	res = pack_int_to_buf(wrapped_key_size, (uint8_t *)(in + index));
+	index += 2;
+	memcpy(in + index, wrapped_key, wrapped_key_size);
+	index += wrapped_key_size;
+	res = pack_int_to_buf(iv_size, (uint8_t *)(in + index));
+	index += 2;
+	memcpy(in + index, iv, iv_size);
+	index += iv_size;
+	res = pack_int_to_buf(input_size, (uint8_t *)(in + index));
+	index += 2;
+	memcpy(in + index, input, input_size);
+	index += input_size;
+
+cmd_retry:
+	res = dal_keystore_decrypt_size(algo_spec, input_size,
+		(unsigned int *)&output_len);
+	if (res)
+		return res;
+
+	res = send_and_receive(commandId, in, index,
+		&out_buf, &output_len, &response_code);
+
+	res = handle_command_response(res, response_code, &retry,
+				client_ticket, client_id);
+
+	if (!res && retry) {
+		response_code = 0;
+		goto cmd_retry;
+	}
+
+	if (res) {
+		ks_err(KBUILD_MODNAME ": %s Error in send_and_receive: command id = %d %d\n",
+		__func__, commandId, res);
+		goto exit;
+	}
+
+	memcpy(output, out_buf, output_len);
+
+exit:
+	if (in)
+		kzfree(in);
+	if (out_buf)
+		kzfree(out_buf);
+
+	FUNC_RES(res);
+	return res;
+}
+EXPORT_SYMBOL(dal_keystore_decrypt);
diff --git a/security/keystore/api_dal.h b/security/keystore/api_dal.h
new file mode 100644
index 000000000000..a790c0f0cf1a
--- /dev/null
+++ b/security/keystore/api_dal.h
@@ -0,0 +1,139 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#ifndef _DAL_KEYSTORE_API_H_
+#define _DAL_KEYSTORE_API_H_
+
+#include "dal_context.h"
+
+/**
+ * Register a client with DAL Keystore. The client is identified using the
+ * path of the executable of the calling user process.
+ *
+ * A random ticket is generated and returned to the caller.
+ *
+ * Return: 0 if OK or negative error code (see errno.h)
+ */
+int dal_keystore_register(enum keystore_seed_type seed_type,
+			uint8_t *client_ticket);
+
+/**
+ * unregister a client which has registered earlier.
+ *
+ * Return: 0 if OK or negative error code (see errno.h)
+ */
+int dal_keystore_unregister(const uint8_t *client_ticket);
+
+/**
+ * Provides the wrapped key size and key size corresponding to the keyspec.
+ *
+ * Return: 0 if OK or negative error code (see errno.h)
+ */
+int dal_keystore_wrapped_key_size(enum keystore_key_spec keyspec,
+			unsigned int *size,
+			unsigned int *unwrapped_size);
+
+/**
+ * Returns the wrapped key size corresponding to the keyspec.
+ *
+ * Return: negative error code in case of error (see errno.h)
+ */
+int dal_get_wrapped_key_size(enum keystore_key_spec keyspec);
+
+/**
+ * Wraps an application key using DAL Keystore.
+ * application key size and key spec are inputs.
+ *
+ * Return: 0 if OK or negative error code (see errno.h)
+ */
+int dal_keystore_wrap_key(const uint8_t *client_ticket,
+			const uint8_t *app_key, unsigned int app_key_size,
+			enum keystore_key_spec keyspec, uint8_t *wrapped_key);
+
+/**
+ * Generates an application key inside DAL Keystore and returns it
+ * wrapped.
+ * key spec is input.
+ *
+ * Return: 0 if OK or negative error code (see errno.h)
+ */
+int dal_keystore_generate_key(const uint8_t *client_ticket,
+			const enum keystore_key_spec keyspec,
+			uint8_t *wrapped_key);
+
+/**
+ * Loads a wrapped key in DAL Keystore.
+ * id of the loaded key slot is passed back to the caller.
+ *
+ * Return: 0 if OK or negative error code (see errno.h)
+ */
+int dal_keystore_load_key(const uint8_t *client_ticket,
+			uint8_t *wrapped_key,
+			unsigned int wrapped_key_size, unsigned int *slot_id);
+
+/**
+ * Unloads a previously loaded key in DAL Keystore.
+ * id of the loaded key slot is input.
+ *
+ * Return: 0 if OK or negative error code (see errno.h)
+ */
+int dal_keystore_unload_key(const uint8_t *client_ticket, unsigned int slot_id);
+
+/**
+ * Provides the output size corresponding to the input size for encryption.
+ * algo spec and input size are inputs.
+ * output size is passed back to the caller.
+ * Return: 0 if OK or negative error code (see errno.h)
+ */
+int dal_keystore_encrypt_size(enum keystore_algo_spec algo_spec,
+			unsigned int input_size, unsigned int *output_size);
+
+/**
+ * Encrypts application data using DAL Keystore.
+ * slot id, algo spec, initialization vector, input data are
+ * inputs.
+ * encrypted data is passed back to the caller.
+ *
+ * Return: 0 if OK or negative error code (see errno.h)
+ */
+int dal_keystore_encrypt(const uint8_t *client_ticket, int slot_id,
+			enum keystore_algo_spec algo_spec,
+			const uint8_t *iv, unsigned int iv_size,
+			const uint8_t *input, unsigned int input_size,
+			uint8_t *output);
+
+/**
+ * Provides the output size corresponding to the input size for decryption.
+ * algo spec and input size are inputs.
+ * output size is passed back to the caller.
+ * Return: 0 if OK or negative error code (see errno.h)
+ */
+int dal_keystore_decrypt_size(enum keystore_algo_spec algo_spec,
+			unsigned int input_size, unsigned int *output_size);
+
+/**
+ * Decrypts application data using DAL Keystore.
+ * slot id, algo spec, initialization vector, encrypted data are
+ * inputs.
+ * decrypted data is passed back to the caller.
+ *
+ * Return: 0 if OK or negative error code (see errno.h)
+ */
+int dal_keystore_decrypt(const uint8_t *client_ticket, int slot_id,
+			enum keystore_algo_spec algo_spec,
+			const uint8_t *iv, unsigned int iv_size,
+			const uint8_t *input, unsigned int input_size,
+			uint8_t *output);
+#endif /* _DAL_KEYSTORE_API_H_ */
diff --git a/security/keystore/applet_read.c b/security/keystore/applet_read.c
new file mode 100644
index 000000000000..92d2a4bed416
--- /dev/null
+++ b/security/keystore/applet_read.c
@@ -0,0 +1,141 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/crypto.h>
+#include <linux/key-type.h>
+#include <linux/mpi.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+#include "keystore_debug.h"
+
+#define APPLET_MAX_LEN 30000
+
+static int read_applet_data(struct file *file, loff_t offset,
+				char *addr, unsigned long count)
+{
+	char __user *buf = (char __user *)addr;
+	ssize_t ret;
+
+	if (!(file->f_mode & FMODE_READ))
+		return -EBADF;
+
+	ret = kernel_read(file, buf, count, &offset);
+
+	return ret;
+}
+
+static int read_applet_file(struct file *file, u8 **out)
+{
+	loff_t i_size = 0, offset = 0;
+	char *file_buf = 0;
+	u8 *temp = NULL;
+
+	int rc = 0, read = 0, count = 0;
+
+	*out = NULL;
+
+	i_size = i_size_read(file_inode(file));
+	ks_debug(KBUILD_MODNAME ": %s  applet size = %lld\n", __func__, i_size);
+
+	if (i_size == 0)
+		goto out;
+
+	if (i_size > APPLET_MAX_LEN) {
+		ks_err(KBUILD_MODNAME ": %s applet size exceeds maximum\n",
+					__func__);
+		goto out;
+	}
+
+	file_buf = kzalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!file_buf)
+		return -ENOMEM;
+
+	temp = kzalloc(i_size, GFP_KERNEL);
+	if (!temp)
+		return -ENOMEM;
+
+	if (!(file->f_mode & FMODE_READ)) {
+		file->f_mode |= FMODE_READ;
+		read = 1;
+	}
+
+	while (offset < i_size) {
+		int file_buf_len;
+
+		file_buf_len = read_applet_data(file, offset,
+			file_buf, PAGE_SIZE);
+		if (file_buf_len < 0) {
+			rc = file_buf_len;
+			break;
+		}
+		if (file_buf_len == 0)
+			break;
+		memcpy(temp + offset, file_buf, file_buf_len);
+		offset += file_buf_len;
+		count++;
+	}
+
+	if (read)
+		file->f_mode &= ~FMODE_READ;
+	kfree(file_buf);
+
+	if (rc) {
+		kfree(temp);
+		return -EFAULT;
+	}
+	*out = temp;
+	return i_size;
+out:
+	return -EFAULT;
+}
+
+static int lock_read_applet(struct file *file, u8 **out)
+{
+	struct inode *inode = file_inode(file);
+	int ret = 0;
+
+	inode_lock_shared(inode);
+	ret =  read_applet_file(file, out);
+	inode_unlock_shared(inode);
+	return ret;
+}
+
+int read_keystore_applet(const char *filename, u8 **buf, size_t *len)
+{
+	struct file *file = 0;
+	int ret = 0;
+
+	file = filp_open(filename,  O_RDONLY, 0);
+	if (IS_ERR(file)) {
+		ks_err(KBUILD_MODNAME ": %s could not open applet file\n",
+					__func__);
+		return -EBADF;
+	}
+
+	ks_debug(KBUILD_MODNAME ": %s applet file opened\n", __func__);
+	ret = lock_read_applet(file, buf);
+	if (ret <= 0) {
+		ks_err(KBUILD_MODNAME ": %s could not read applet file\n",
+					__func__);
+		return -EBADF;
+	}
+	*len = ret;
+	filp_close(file, NULL);
+	return 0;
+}
diff --git a/security/keystore/client.c b/security/keystore/client.c
new file mode 100644
index 000000000000..b229331303aa
--- /dev/null
+++ b/security/keystore/client.c
@@ -0,0 +1,124 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include <linux/fdtable.h>
+#include <linux/sched/mm.h>
+#include <linux/fs.h>
+#include <linux/fs_struct.h>
+#include <linux/path.h>
+#include <linux/dcache.h>
+
+#include "keystore_client.h"
+#include "keystore_mac.h"
+#include "keystore_debug.h"
+
+#define KERNEL_CLIENTS_ID			"+(!$(%@#%$$)*"
+
+/**
+ * Get the absolute path of current process in the filesystem. This is used
+ * for client authentication purpose.
+ *
+ * Always use the return variable from this function, input variable 'buf'
+ * may not contain the start of the path. In case if kernel was executing
+ * a kernel thread then this function return NULL.
+ *
+ * @param input buf place holder for updating the path
+ * @param input buflen avaialbe space
+ *
+ * @return path of current process, or NULL if it was kernel thread.
+ */
+
+static char *get_current_process_path(char *buf, int buflen)
+{
+	struct file *exe_file = NULL;
+	char *result = NULL;
+	struct mm_struct *mm = NULL;
+
+	mm = get_task_mm(current);
+	if (!mm) {
+		ks_info(KBUILD_MODNAME ": %s error get_task_mm\n", __func__);
+		goto out;
+	}
+
+	down_read(&mm->mmap_sem);
+	exe_file = mm->exe_file;
+
+	if (exe_file)
+		path_get(&exe_file->f_path);
+
+	up_read(&mm->mmap_sem);
+	mmput(mm);
+	if (exe_file) {
+		result = d_path(&exe_file->f_path, buf, buflen);
+		path_put(&exe_file->f_path);
+	}
+out:
+	return result;
+}
+
+int keystore_calc_clientid(u8 *client_id, const unsigned int client_id_size)
+{
+	int res = 0;
+	char *buf = NULL;
+	char *f_path = NULL;
+
+	if (!client_id)
+		return -EINVAL;
+
+	/* alloc mem for pwd##app, use linux defined limits */
+	buf = kmalloc(PATH_MAX + NAME_MAX, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	/* clear the buf */
+	memset(buf, 0, PATH_MAX + NAME_MAX);
+
+	f_path = get_current_process_path(buf, (PATH_MAX + NAME_MAX));
+
+	ks_debug(KBUILD_MODNAME ": %s KSM-Client ABS path: %s\n",
+		 __func__, f_path);
+
+	if (f_path && IS_ERR(f_path)) {
+		/* error case, do not register */
+		ks_err(KBUILD_MODNAME ": Cannot register with keystore - failed client auth\n");
+		res = -EFAULT;
+		goto out_buf;
+	}
+
+	/* f_path is NULL for PF_KTHREAD type */
+	if (!f_path) {
+		ks_info(KBUILD_MODNAME ": %s Kernel client - use default.\n",
+			__func__);
+		f_path = KERNEL_CLIENTS_ID;
+	}
+
+	/* Clear the output buffer */
+	memset(client_id, 0, sizeof(u8) * client_id_size);
+
+	/* calculate sha2 on new cwd - this is new clientid! */
+	keystore_sha256_block(f_path, strlen(f_path),
+			      client_id,
+			      client_id_size);
+
+out_buf:
+	kfree(buf);
+	return res;
+}
diff --git a/security/keystore/dal_client.c b/security/keystore/dal_client.c
new file mode 100644
index 000000000000..92307502d198
--- /dev/null
+++ b/security/keystore/dal_client.c
@@ -0,0 +1,115 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/dal.h>
+#include <linux/printk.h>
+#include "dal_client.h"
+
+#include "keystore_debug.h"
+
+struct dal_hdr_t dal_hdr;
+
+int is_dal_session_created(void)
+{
+	if (dal_hdr.state == DAL_KSM_SESSION_CREATED)
+		return 0;
+	else
+		return -EFAULT;
+}
+
+int create_session(void)
+{
+	int ret = 0;
+
+	ret = dal_create_session(&(dal_hdr.session_handle),
+		CONFIG_DAL_KEYSTORE_APPLET_ID, dal_hdr.acp_pkg,
+		dal_hdr.acp_pkg_len, NULL, 0);
+
+	if (ret != DAL_KDI_SUCCESS) {
+		ks_err(KBUILD_MODNAME ": %s dal_create_session failed\n",
+					__func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+int install_applet(void)
+{
+	int ret = 0;
+	u8 *acp_pkg = NULL;
+	size_t acp_pkg_len = 0;
+
+	dal_hdr.state = DAL_KSM_INIT;
+	ret = read_keystore_applet(CONFIG_DAL_KEYSTORE_APPLET_PATH, &acp_pkg,
+		&acp_pkg_len);
+	if (ret != 0)
+		return ret;
+
+	if (acp_pkg == NULL) {
+		ks_err(KBUILD_MODNAME ": %s acp_pkg is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	ks_debug(KBUILD_MODNAME ": %s acp_pkg_len = %zu\n", __func__,
+				acp_pkg_len);
+	dal_hdr.acp_pkg = acp_pkg;
+	dal_hdr.acp_pkg_len = acp_pkg_len;
+
+	ret = create_session();
+	if (ret != 0)
+		return ret;
+
+	dal_hdr.state = DAL_KSM_SESSION_CREATED;
+	return 0;
+}
+
+int send_and_receive(size_t command_id, const u8 *input, size_t input_len,
+			u8 **output, size_t *output_len, size_t *response_code)
+{
+	int ret = 0;
+
+	/* output_len can not be 0 */
+	ret = dal_send_and_receive(dal_hdr.session_handle,
+	command_id, input, input_len, output, output_len, (int *)response_code);
+
+	if (ret != DAL_KDI_SUCCESS) {
+		ks_err(KBUILD_MODNAME ": %s dal_send_and_receive failed\n",
+					__func__);
+	} else {
+		ks_debug(KBUILD_MODNAME ": %s dal_send_and_receive succeeded\n",
+					__func__);
+	}
+	ks_debug(KBUILD_MODNAME
+		": %s command id = %zu, response code = %zu output_len = %zu\n",
+		__func__, command_id, *response_code, *output_len);
+
+	return ret;
+}
+
+int close_session(void)
+{
+	int ret = 0;
+
+	ret = dal_close_session(dal_hdr.session_handle);
+	if (ret != DAL_KDI_SUCCESS)
+		ks_err(KBUILD_MODNAME ": %s dal_close_session failed\n",
+					__func__);
+
+	dal_hdr.state = DAL_KSM_SESSION_CLOSED;
+
+	return ret;
+}
diff --git a/security/keystore/dal_client.h b/security/keystore/dal_client.h
new file mode 100644
index 000000000000..059c919cfabe
--- /dev/null
+++ b/security/keystore/dal_client.h
@@ -0,0 +1,99 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _DAL_CLIENT_H_
+#define _DAL_CLIENT_H_
+
+#include <linux/dal.h>
+#include <linux/printk.h>
+#include <linux/errno.h>
+#include <security/keystore_api_common.h>
+
+#define DAL_KEYSTORE_GCM_IV_SIZE 12
+#define DAL_KEYSTORE_GCM_AUTH_SIZE 16
+#define DAL_KEYSTORE_MAX_WRAP_KEY_LEN 49
+
+enum dal_state {
+	DAL_KSM_UNINITIALIZED = 0,
+	DAL_KSM_INIT,
+	DAL_KSM_SESSION_CREATED,
+	DAL_KSM_SESSION_CLOSED,
+	DAL_KSM_DEINIT
+};
+
+enum dal_commands {
+	DAL_KEYSTORE_INIT = 1,
+	DAL_KEYSTORE_REGISTER = 2,
+	DAL_KEYSTORE_UNREGISTER = 9,
+	DAL_KEYSTORE_GET_KEYSIZE = 17,
+	DAL_KEYSTORE_WRAP_KEYSIZE = 3,
+	DAL_KEYSTORE_WRAP_KEY = 4,
+	DAL_KEYSTORE_GENERATE_KEY = 18,
+	DAL_KEYSTORE_LOAD_KEY = 5,
+	DAL_KEYSTORE_UNLOAD_KEY = 6,
+	DAL_KEYSTORE_ENCRYPT = 7,
+	DAL_KEYSTORE_DECRYPT = 8
+};
+
+struct dal_hdr_t {
+	enum dal_state state;
+	u64 session_handle;
+	u8 *acp_pkg;
+	size_t acp_pkg_len;
+};
+
+struct dal_key_info {
+	enum keystore_key_spec keyspec;
+	uint32_t key_size;
+	uint32_t wrap_key_size;
+};
+
+/**
+ * Return value indicates whether the a DAL session has
+ * been created using DAL KDI API.
+ * DAL session is created only once.
+ */
+int is_dal_session_created(void);
+
+/**
+ * Reads the DAL Keystore applet from user space.
+ */
+int read_keystore_applet(const char *filename, u8 **buf, size_t *len);
+
+/**
+ * Creats DAL session using DAL KDI API.
+ * DAL session is created only once.
+ */
+int create_session(void);
+
+/**
+ * Installs the DAL Keystore applet using DAL KDI API.
+ */
+int install_applet(void);
+
+
+/**
+ * Sends and receives data from kernel to DAL using DAL KDI API.
+ */
+int send_and_receive(size_t command_id, const u8 *input, size_t input_len,
+		u8 **output, size_t *output_len, size_t *response_code);
+
+/**
+ * Closes DAL session using DAL KDI API.
+ */
+int close_session(void);
+
+#endif /* _DAL_CLIENT_H_ */
diff --git a/security/keystore/dal_context.c b/security/keystore/dal_context.c
new file mode 100644
index 000000000000..96fbf2e2d186
--- /dev/null
+++ b/security/keystore/dal_context.c
@@ -0,0 +1,388 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include "dal_context.h"
+#include "keystore_debug.h"
+
+/* The linked list of DAL contexts. */
+struct list_head dal_contexts = LIST_HEAD_INIT(dal_contexts);
+
+/**
+ * Initialize one context.
+ */
+static void init_context_struct(struct dal_keystore_ctx *ctx)
+{
+	FUNC_BEGIN;
+
+	if (ctx) {
+		/* initialize slots of new context */
+		INIT_LIST_HEAD(&ctx->slots);
+	}
+
+	FUNC_END;
+}
+
+/**
+ * Deinitialize one context.
+ */
+static void deinit_context_struct(struct dal_keystore_ctx *ctx)
+{
+	struct list_head *pos, *q;
+
+	FUNC_BEGIN;
+
+	if (ctx) {
+		/* free all slots */
+		list_for_each_safe(pos, q, &ctx->slots)	{
+			struct dal_keystore_slot *item =
+				list_entry(pos, struct dal_keystore_slot,
+					   list);
+			list_del(pos);
+			kzfree(item);
+		}
+	}
+
+	FUNC_END;
+}
+
+/**
+ * Free all contexts.
+ */
+void dal_keystore_free_contexts(void)
+{
+	struct list_head *pos, *q;
+
+	FUNC_BEGIN;
+
+	list_for_each_safe(pos, q, &dal_contexts) {
+		struct dal_keystore_ctx *item =
+			list_entry(pos, struct dal_keystore_ctx, list);
+
+		deinit_context_struct(item);
+		list_del(pos);
+		kzfree(item);
+	}
+
+	FUNC_END;
+}
+
+/**
+ * Allocate a context structure.
+ *
+ * @return Context structure pointer or NULL if out of memory.
+ */
+struct dal_keystore_ctx *dal_keystore_allocate_context(void)
+{
+	struct dal_keystore_ctx *item = NULL;
+	struct list_head *pos;
+	unsigned int cnt = 0;
+
+	FUNC_BEGIN;
+
+	/* calculate number of clients already registered */
+	list_for_each(pos, &dal_contexts) {
+		cnt++;
+	}
+
+	/* check for maximum number of clients */
+	if (cnt < DAL_KEYSTORE_CLIENTS_MAX) {
+		/* allocate memory */
+		item = kzalloc(sizeof(struct dal_keystore_ctx),
+				GFP_KERNEL);
+		if (item) {
+			init_context_struct(item);
+
+			/* add context to the global list */
+			list_add(&(item->list), &dal_contexts);
+		}
+	}
+
+	FUNC_RES(item);
+
+	return item;
+}
+
+/**
+ * Free the context, searching by context structure.
+ *
+ * @param ctx Pointer to the context structure.
+ *
+ * @return 0 if OK or negative error code (see errno).
+ */
+int dal_keystore_free_context_ctx(struct dal_keystore_ctx *ctx)
+{
+	struct list_head *pos, *q;
+
+	FUNC_BEGIN;
+
+	if (!ctx) {
+		FUNC_RES(-EFAULT);
+		return -EFAULT;
+	}
+
+	list_for_each_safe(pos, q, &dal_contexts) {
+		struct dal_keystore_ctx *item =
+			list_entry(pos, struct dal_keystore_ctx, list);
+
+		if (item == ctx) {
+			deinit_context_struct(item);
+			list_del(pos);
+			kzfree(item);
+			FUNC_RES(0);
+			return 0;
+		}
+	}
+
+	FUNC_RES(-EINVAL);
+
+	return -EINVAL;
+}
+
+/**
+ * Free the context, searching by ClientTicket.
+ *
+ * @param client_ticket The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
+ *
+ * @return 0 if OK or negative error code (see errno).
+ */
+int dal_keystore_free_context_ticket(const void *client_ticket)
+{
+	struct list_head *pos, *q;
+
+	FUNC_BEGIN;
+
+	if (!client_ticket) {
+		FUNC_RES(-EFAULT);
+		return -EFAULT;
+	}
+
+	list_for_each_safe(pos, q, &dal_contexts) {
+		struct dal_keystore_ctx *item =
+			list_entry(pos, struct dal_keystore_ctx, list);
+
+		if (!memcmp(client_ticket, item->client_ticket,
+			    KEYSTORE_CLIENT_TICKET_SIZE)) {
+			deinit_context_struct(item);
+			list_del(pos);
+			kzfree(item);
+			FUNC_RES(0);
+			return 0;
+		}
+	}
+
+	FUNC_RES(-EINVAL);
+
+	return -EINVAL;
+}
+
+/**
+ * Find the context, searching by ClientTicket.
+ *
+ * @param client_ticket The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
+ *
+ * @return Context structure pointer or NULL if not found.
+ */
+struct dal_keystore_ctx *dal_keystore_find_context_ticket(const void *client_ticket)
+{
+	struct list_head *pos;
+
+	FUNC_BEGIN;
+
+	if (!client_ticket) {
+		FUNC_RES(0);
+		return NULL;
+	}
+
+	list_for_each(pos, &dal_contexts) {
+		struct dal_keystore_ctx *item =
+			list_entry(pos, struct dal_keystore_ctx, list);
+
+		if (!memcmp(client_ticket, item->client_ticket,
+					KEYSTORE_CLIENT_TICKET_SIZE)) {
+			FUNC_RES(item);
+			return item;
+		}
+	}
+
+	FUNC_RES(0);
+
+	return NULL;
+}
+
+/**
+ * Allocate a slot structure in the context.
+ *
+ * @param ctx Pointer to the context structure.
+ *
+ * @return Slot structure pointer or NULL if out of memory.
+ */
+struct dal_keystore_slot *dal_keystore_allocate_slot(struct dal_keystore_ctx *ctx)
+{
+	struct dal_keystore_slot *item = NULL;
+	int id = 0;
+
+	FUNC_BEGIN;
+
+	if (!ctx) {
+		FUNC_RES(0);
+		return NULL;
+	}
+
+	/* find the lowest unused slot ID */
+	for (id = 0; id < DAL_KEYSTORE_SLOTS_MAX; id++) {
+		if (!dal_keystore_find_slot_id(ctx, id)) {
+			/* slot with this ID doesn't exist, we can use it now */
+			break;
+		}
+	}
+
+	if (id < DAL_KEYSTORE_SLOTS_MAX) {
+		/* allocate memory */
+		item = kzalloc(sizeof(struct dal_keystore_slot),
+				GFP_KERNEL);
+		if (item) {
+			item->slot_id = id;
+
+			/* add slot to the list inside context */
+			list_add(&(item->list), &ctx->slots);
+		}
+	}
+
+	FUNC_RES(item);
+
+	return item;
+}
+
+/**
+ * Free the slot, searching by slot ID.
+ *
+ * @param ctx Pointer to the context structure.
+ * @param slot_id The slot ID.
+ *
+ * @return 0 if OK or negative error code (see errno).
+ */
+int dal_keystore_free_slot_id(struct dal_keystore_ctx *ctx, int slot_id)
+{
+	struct list_head *pos, *q;
+
+	FUNC_BEGIN;
+
+	if (!ctx) {
+		FUNC_RES(-EFAULT);
+		return -EFAULT;
+	}
+
+	if ((slot_id < 0) || (slot_id >= DAL_KEYSTORE_SLOTS_MAX)) {
+		FUNC_RES(-EINVAL);
+		return -EINVAL;
+	}
+
+	list_for_each_safe(pos, q, &ctx->slots) {
+		struct dal_keystore_slot *item =
+			list_entry(pos, struct dal_keystore_slot, list);
+
+		if (item) {
+			if (item->slot_id == slot_id) {
+				list_del(pos);
+				kzfree(item);
+				FUNC_RES(0);
+				return 0;
+			}
+		}
+	}
+
+	FUNC_RES(-EINVAL);
+
+	return -EINVAL;
+}
+
+/**
+ * Find the slot, searching by slot ID.
+ *
+ * @param ctx Pointer to the context structure.
+ * @param slot_id The slot ID.
+ *
+ * @return Slot structure pointer or NULL if not found.
+ */
+struct dal_keystore_slot *dal_keystore_find_slot_id(struct dal_keystore_ctx *ctx,
+		int slot_id)
+{
+	struct list_head *pos;
+
+	FUNC_BEGIN;
+
+	if (!ctx || (slot_id < 0) || (slot_id >= DAL_KEYSTORE_SLOTS_MAX)) {
+		FUNC_RES(0);
+		return NULL;
+	}
+
+	list_for_each(pos, &ctx->slots) {
+		struct dal_keystore_slot *item =
+			list_entry(pos, struct dal_keystore_slot, list);
+
+		if (item) {
+			if (item->slot_id == slot_id) {
+				FUNC_RES(item);
+				return item;
+			}
+		}
+	}
+
+	FUNC_RES(0);
+	return NULL;
+}
+
+/**
+ * Dump the context contents.
+ *
+ * @param ctx Pointer to the context structure.
+ */
+void dal_keystore_dump_ctx(const struct dal_keystore_ctx *ctx)
+{
+	struct list_head *pos;
+	unsigned int cnt = 0;
+
+	if (!ctx)
+		return;
+
+	ks_info(KBUILD_MODNAME ": Context at 0x%lx\n",
+			(unsigned long) ctx);
+
+	keystore_hexdump("  TICKET", ctx->client_ticket,
+			KEYSTORE_CLIENT_TICKET_SIZE);
+
+	list_for_each(pos, &ctx->slots) {
+		cnt++;
+	}
+	ks_info(KBUILD_MODNAME ":   slots: %u\n", cnt);
+
+	if (cnt > 0) {
+		list_for_each(pos, &ctx->slots) {
+			struct dal_keystore_slot *slot = list_entry(pos,
+					struct dal_keystore_slot, list);
+			ks_info(KBUILD_MODNAME ":    [%u] appKey size=%u\n",
+				slot->slot_id, slot->wrapped_key_size);
+			keystore_hexdump("    ", slot->wrapped_key,
+					slot->wrapped_key_size);
+		}
+	}
+}
diff --git a/security/keystore/dal_context.h b/security/keystore/dal_context.h
new file mode 100644
index 000000000000..0b322dfe7304
--- /dev/null
+++ b/security/keystore/dal_context.h
@@ -0,0 +1,167 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _DAL_CONTEXT_H_
+#define _DAL_CONTEXT_H_
+
+#include <linux/types.h>
+#include <linux/list.h>
+
+#include <security/keystore_api_common.h>
+
+#define DAL_KEYSTORE_MAX_WRAPKEY_SIZE	49
+#define DAL_KEYSTORE_CLIENTS_MAX	256
+#define DAL_KEYSTORE_SLOTS_MAX		256
+
+/**
+ * DOC:  Introduction
+ *
+ * The dal_keystore_context functions provide access
+ * to the keystore client context. (Not thread safe!)
+ *
+ * These functions are used to register clients with a given
+ * client key, and store associated unwrapped application keys.
+ *
+ * Clients should not call into this interface, they should
+ * rather user the higher-level thread-safe dal_context_safe functions.
+ *
+ * A client can register a number of different simultaneous sessions
+ * with keystore, each with a separate client ticket. The client ticket
+ * is simply a unique random array used as a client handle. Each entry in
+ * the context stores this client ticket, together with a client key
+ * and ID. A client (with the same client ID and key) can register
+ * multiple times with different client tickets.
+ *
+ * For each client ticket, the context contains a number of slots
+ * which can be used to load and cache unwrapped application keys.
+ * These keys are used for encryption and decryption of application data.
+ *
+ */
+
+/**
+ * struct dal_keystore_slot - The keystore slot structure.
+ *
+ * @list: Kernel list head for linked list.
+ * @wrapped_key: The application key.
+ * @wrapped_key_size: Size of the application key.
+ * @slot_id: Number identifying the slot.
+ */
+struct dal_keystore_slot {
+	struct list_head list;       /* kernel's list structure */
+
+	enum keystore_key_spec key_spec;
+	uint8_t wrapped_key[DAL_KEYSTORE_MAX_WRAPKEY_SIZE]; /* Wrapped key*/
+	unsigned int wrapped_key_size;   /* AppKey size in bytes */
+	unsigned int slot_id;                 /* SlotID */
+};
+
+/**
+ * struct dal_keystore_ctx - The keystore context structure.
+ *
+ * @list: Kernel list head for linked list.
+ * @client_ticket: The client ticket to register against.
+ * @client_key: The derived client key.
+ * @client_id: The derived client ID
+ * @slots: List of slots associated to this ticket.
+ */
+struct dal_keystore_ctx {
+	struct list_head list;                               /* kernel list */
+
+	uint8_t client_ticket[KEYSTORE_CLIENT_TICKET_SIZE];  /* ClientTicket */
+	uint8_t client_id[KEYSTORE_MAX_CLIENT_ID_SIZE];      /* Client ID */
+	enum keystore_seed_type seed_type;                   /* Seed Type */
+
+	struct list_head slots;                              /* list of slots */
+};
+
+
+/**
+ * dal_keystore_free_contexts() - Free all contexts.
+ */
+void dal_keystore_free_contexts(void);
+
+/**
+ * dal_keystore_allocate_context() - Allocate a context structure.
+ *
+ * Returns: Context structure pointer or NULL if out of memory.
+ */
+struct dal_keystore_ctx *dal_keystore_allocate_context(void);
+
+/**
+ * Free the context, searching by context structure.
+ *
+ * @ctx: Pointer to the context structure.
+ *
+ * Returns: 0 if OK or negative error code (see errno).
+ */
+int dal_keystore_free_context_ctx(struct dal_keystore_ctx *ctx);
+
+/**
+ * Free the context, searching by ClientTicket.
+ *
+ * @client_ticket: The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
+ *
+ * Returns: 0 if OK or negative error code (see errno).
+ */
+int dal_keystore_free_context_ticket(const void *client_ticket);
+
+/**
+ * Find the context, searching by ClientTicket.
+ *
+ * @client_ticket: The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
+ *
+ * Returns: Context structure pointer or NULL if not found.
+ */
+struct dal_keystore_ctx *dal_keystore_find_context_ticket(const void *client_ticket);
+
+/**
+ * Allocate a slot structure in the context.
+ *
+ * @ctx: Pointer to the context structure.
+ *
+ * Returns: Slot structure pointer or NULL if out of memory.
+ */
+struct dal_keystore_slot *dal_keystore_allocate_slot(struct dal_keystore_ctx *ctx);
+
+/**
+ * Free the slot, searching by slot ID.
+ *
+ * @ctx: Pointer to the context structure.
+ * @slot_id: The slot ID.
+ *
+ * Returns: 0 if OK or negative error code (see errno).
+ */
+int dal_keystore_free_slot_id(struct dal_keystore_ctx *ctx, int slot_id);
+
+/**
+ * Find the slot, searching by slot ID.
+ *
+ * @ctx: Pointer to the context structure.
+ * @slot_id: The slot ID.
+ *
+ * Returns: Slot structure pointer or NULL if not found.
+ */
+struct dal_keystore_slot *dal_keystore_find_slot_id(struct dal_keystore_ctx *ctx,
+					    int slot_id);
+
+/**
+ * dal_keystore_dump_ctx() - Dump the context contents.
+ *
+ * @ctx: Pointer to the context structure.
+ */
+void dal_keystore_dump_ctx(const struct dal_keystore_ctx *ctx);
+
+#endif /* _DAL_CONTEXT_H_ */
diff --git a/security/keystore/dal_context_safe.c b/security/keystore/dal_context_safe.c
new file mode 100644
index 000000000000..c7246062900b
--- /dev/null
+++ b/security/keystore/dal_context_safe.c
@@ -0,0 +1,235 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/dcache.h>
+
+#include "dal_context.h"
+#include "dal_context_safe.h"
+#include "keystore_debug.h"
+
+/* The mutex for contexts access synchronization. */
+DEFINE_MUTEX(dal_ctx_mutex);
+
+int dal_ctx_add_client(const uint8_t *client_ticket,
+		enum keystore_seed_type seed_type,
+		const uint8_t *client_id)
+{
+	struct dal_keystore_ctx *ctx;
+	int res = 0;
+
+	if (!client_ticket || !client_id)
+		return -EFAULT;
+
+	mutex_lock(&dal_ctx_mutex);
+
+	/* allocate new context */
+	ctx = dal_keystore_allocate_context();
+	if (!ctx) {
+		res = -ENOMEM;
+		goto unlock_mutex;
+	}
+
+	/* save ClientTicket and ClientKey */
+	memcpy(ctx->client_ticket,
+	       client_ticket, KEYSTORE_CLIENT_TICKET_SIZE);
+	ctx->seed_type = seed_type;
+	memcpy(ctx->client_id,
+	       client_id, KEYSTORE_MAX_CLIENT_ID_SIZE);
+
+unlock_mutex:
+	mutex_unlock(&dal_ctx_mutex);
+	return res;
+}
+
+int dal_ctx_remove_client(const uint8_t *client_ticket)
+{
+	int res = 0;
+
+	if (!client_ticket)
+		return -EFAULT;
+
+	mutex_lock(&dal_ctx_mutex);
+	res = dal_keystore_free_context_ticket(client_ticket);
+	mutex_unlock(&dal_ctx_mutex);
+
+	return res;
+}
+
+int dal_ctx_add_wrapped_key(const uint8_t *client_ticket,
+		    enum keystore_key_spec key_spec,
+		    const uint8_t *wrapped_key, unsigned int wrapped_key_size,
+		    unsigned int *slot_id)
+{
+	int res = 0;
+	struct dal_keystore_ctx *ctx;
+	struct dal_keystore_slot *slot = NULL;
+
+	if (!client_ticket || !wrapped_key || !slot_id)
+		return -EFAULT;
+
+	mutex_lock(&dal_ctx_mutex);
+	ctx = dal_keystore_find_context_ticket(client_ticket);
+	if (!ctx) {
+		res = -EINVAL;
+		goto unlock_mutex;
+	}
+
+	/* allocate new slot */
+	slot = dal_keystore_allocate_slot(ctx);
+	if (!slot) {
+		res = -ENOMEM;
+		goto unlock_mutex;
+	}
+
+	slot->key_spec = key_spec;
+	slot->wrapped_key_size = wrapped_key_size;
+	memcpy(slot->wrapped_key, wrapped_key, wrapped_key_size);
+
+	*slot_id = slot->slot_id;
+
+unlock_mutex:
+	mutex_unlock(&dal_ctx_mutex);
+	return res;
+}
+
+int dal_ctx_get_client_seed_type(const uint8_t *client_ticket,
+		enum keystore_seed_type *seed_type, const uint8_t *client_id)
+{
+	struct dal_keystore_ctx *ctx = NULL;
+	int res = 0;
+
+	if (!client_ticket || !seed_type || !client_id)
+		return -EFAULT;
+
+	/* Cache the client key */
+	mutex_lock(&dal_ctx_mutex);
+	ctx = dal_keystore_find_context_ticket(client_ticket);
+	if (!ctx) {
+		res = -EINVAL;
+		goto unlock_mutex;
+	}
+
+	if (memcmp(client_id, ctx->client_id, KEYSTORE_MAX_CLIENT_ID_SIZE)) {
+		res = -EINVAL;
+		goto unlock_mutex;
+	}
+
+	/* cache context data (the seed type) before releasing the lock */
+	*seed_type = ctx->seed_type;
+
+unlock_mutex:
+	mutex_unlock(&dal_ctx_mutex);
+	return res;
+}
+
+
+int dal_ctx_get_wrapped_key(const uint8_t *client_ticket, unsigned int slot_id,
+		    enum keystore_key_spec *key_spec,
+		    uint8_t *wrapped_key, unsigned int *wrapped_key_size)
+{
+	struct dal_keystore_ctx *ctx = NULL;
+	struct dal_keystore_slot *slot = NULL;
+	int res = 0;
+
+	if (!client_ticket || !key_spec || !wrapped_key_size)
+		return -EFAULT;
+
+	if (slot_id >= DAL_KEYSTORE_SLOTS_MAX)
+		return -EINVAL;
+
+	/* Get the context */
+	mutex_lock(&dal_ctx_mutex);
+	ctx = dal_keystore_find_context_ticket(client_ticket);
+	if (!ctx) {
+		ks_err(KBUILD_MODNAME ": %s: Cannot find context\n", __func__);
+		res = -EINVAL;
+		goto unlock_mutex;
+	}
+
+	/* Get the slot */
+	slot = dal_keystore_find_slot_id(ctx, slot_id);
+
+	if (!slot) {
+		ks_err(KBUILD_MODNAME ": %s: Cannot find slot\n", __func__);
+		res = -EBADSLT;
+		goto unlock_mutex;
+	}
+
+	/* Copy the key spec to start with */
+	*key_spec = slot->key_spec;
+
+	/* If wrapped_key is null, assume the caller wants to know the size */
+	if (!wrapped_key) {
+		*wrapped_key_size = slot->wrapped_key_size;
+		goto unlock_mutex;
+	}
+
+	/* Check buffer size */
+	if (*wrapped_key_size < slot->wrapped_key_size) {
+		ks_err(KBUILD_MODNAME ": %s wrapped_key_size too small\n",
+		       __func__);
+		res = -EINVAL;
+		goto unlock_mutex;
+	}
+
+	memcpy(wrapped_key, slot->wrapped_key, slot->wrapped_key_size);
+	*wrapped_key_size = slot->wrapped_key_size;
+
+unlock_mutex:
+	mutex_unlock(&dal_ctx_mutex);
+	return res;
+}
+
+int dal_ctx_remove_wrapped_key(const uint8_t *client_ticket,
+		unsigned int slot_id)
+{
+	struct dal_keystore_ctx *ctx = NULL;
+	int res = 0;
+
+	if (!client_ticket)
+		return -EFAULT;
+
+	if (slot_id >= DAL_KEYSTORE_SLOTS_MAX)
+		return -EINVAL;
+
+	mutex_lock(&dal_ctx_mutex);
+
+	ctx = dal_keystore_find_context_ticket(client_ticket);
+	if (!ctx) {
+		ks_err(KBUILD_MODNAME ": %s: Cannot find context\n", __func__);
+		res = -EINVAL;
+		goto unlock_mutex;
+	}
+
+	res = dal_keystore_free_slot_id(ctx, slot_id);
+
+unlock_mutex:
+	mutex_unlock(&dal_ctx_mutex);
+	return res;
+}
+
+int dal_ctx_free(void)
+{
+	/* free contexts */
+	mutex_lock(&dal_ctx_mutex);
+	dal_keystore_free_contexts();
+	mutex_unlock(&dal_ctx_mutex);
+
+	return 0;
+}
diff --git a/security/keystore/dal_context_safe.h b/security/keystore/dal_context_safe.h
new file mode 100644
index 000000000000..2085e71b743a
--- /dev/null
+++ b/security/keystore/dal_context_safe.h
@@ -0,0 +1,170 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _DAL_CONTEXT_SAFE_H_
+#define _DAL_CONTEXT_SAFE_H_
+
+#include <linux/types.h>
+#include <linux/list.h>
+
+#include "dal_context.h"
+
+/**
+ * DOC:  Introduction
+ *
+ * The dal_context_safe functions provide thread safe access
+ * to the keystore client context.
+ *
+ * These functions are used to register clients with a
+ * seed type, and store associated wrapped application keys.
+ *
+ * Clients should call into this interface, rather than the
+ * lower-level dal_context functions.
+ */
+
+/**
+ * dal_ctx_add_client() - Register a new client
+ *
+ * @client_ticket: The client ticket to register against. Expected to be an
+ *          array of size %KEYSTORE_CLIENT_TICKET_SIZE.
+ * @seed_type: The seed type used by client to register with DAL KS.
+ *
+ * @client_id: A unique ID for the client, must be an array of
+ *             %KEYSTORE_MAX_CLIENT_ID_SIZE bytes.
+ *
+ * Adds a new client to the keystore context struct in a thread-safe
+ * way.
+ *
+ * Returns: 0 on success or negative errno.
+ *
+ */
+int dal_ctx_add_client(const uint8_t *client_ticket,
+		enum keystore_seed_type seed_type,
+		const uint8_t *client_id);
+
+/**
+ * dal_ctx_remove_client() - Remove a client
+ *
+ * @client_ticket: The client ticket to register against. Expected to be an
+ *          array of size %KEYSTORE_CLIENT_TICKET_SIZE.
+ *
+ * Removes a client from the DAL keystore context and deletes the associated
+ * client ID and wrapped key.
+ *
+ * Returns: 0 on success or negative errno.
+ *
+ */
+int dal_ctx_remove_client(const uint8_t *client_ticket);
+
+/**
+ * dal_ctx_add_wrapped_key() - Add a wrapped application key to context
+ *
+ * @client_ticket: The client ticket to register against. Expected to be an
+ *          array of size %KEYSTORE_CLIENT_TICKET_SIZE.
+ * @key_spec: The Key Spec for this key.
+ * @wrapped_key: A pointer to the application key to be stored.
+ * @wrapped_key_size: Size of @wrapped_key in bytes.
+ * @slot_id: Output the number of slot where the key is stored.
+ *
+ * Adds the given wrapped key to a slot associated to the @client_ticket.
+ *
+ * Returns: 0 on success or negative errno.
+ *
+ */
+int dal_ctx_add_wrapped_key(const uint8_t *client_ticket,
+		    enum keystore_key_spec key_spec,
+		    const uint8_t *wrapped_key,
+		    unsigned int wrapped_key_size,
+		    unsigned int *slot_id);
+
+/**
+ * dal_ctx_get_client_seed_type() - Get the client seed type for
+ * the given ticket.
+ *
+ * @client_ticket: The client ticket to register against. Expected to be an
+ *          array of size %KEYSTORE_CLIENT_TICKET_SIZE.
+ * @seed_type: The client seed type used for registering with DAL Keystore.
+ *              Must be a pointer to %enum keystore_seed_type.
+ * @client_id: A unique ID for the client, must be an array of
+ *             %KEYSTORE_MAX_CLIENT_ID_SIZE bytes.
+ *
+ * Copies the seed type and client ID associated with the @client_ticket
+ * into the buffers pointed to by @seed_type and @client_id respectively.
+ *
+ * The caller is responsible for allocating arrays with the correct length
+ * and ensuring the data are zeroed after use.
+ *
+ * Returns: 0 on success or negative errno.
+ *
+ */
+int dal_ctx_get_client_seed_type(const uint8_t *client_ticket,
+		       enum keystore_seed_type *seed_type,
+		       const uint8_t *client_id);
+
+/**
+ * dal_ctx_get_wrapped_key() - Get a wrapped application key for
+ * the given ticket.
+ *
+ * @client_ticket: The client ticket to register against. Expected to be an
+ *          array of size %KEYSTORE_CLIENT_TICKET_SIZE.
+ * @key_spec: The Key Spec for this key.
+ * @slot_id: The number of the slot where the key is stored.
+ * @wrapped_key: A pointer to the wrapped application key to be stored.
+ * @wrapped_key_size: Size of @wrapped_key in bytes.
+ *
+ * Copies the wrapped key with the @client_ticket in slot @slot_id
+ * into the buffer pointed to by @wrapped_key.
+ *
+ * The size of the buffer should be passed an input in @wrapped_key_size.
+ * If the buffer is large enough, the function will succeed and change
+ * the value of @wrapped_key_size to the size of the wrapped key.
+ * To find out the length of the wrapped key, the function should be
+ * called setting @wrapped_key to NULL. Alternatively, the caller can
+ * statically declare an array of %KEYSTORE_MAX_APPKEY_SIZE bytes.
+ *
+ * The caller is responsible for allocating arrays with the correct length
+ * and ensuring the data are zeroed after use.
+ *
+ * Returns: 0 on success or negative errno.
+ *
+ */
+int dal_ctx_get_wrapped_key(const uint8_t *client_ticket, unsigned int slot_id,
+		    enum keystore_key_spec *key_spec,
+		    uint8_t *wrapped_key, unsigned int *wrapped_key_size);
+
+/**
+ * dal_ctx_remove_wrapped_key() - Remove a wrapped key and free the slot.
+ *
+ * @client_ticket: The client ticket to register against. Expected to be an
+ *          array of size %KEYSTORE_CLIENT_TICKET_SIZE.
+ * @slot_id: The number of the slot where the key is stored.
+ *
+ * Returns: 0 on success or negative errno.
+ */
+int dal_ctx_remove_wrapped_key(const uint8_t *client_ticket,
+		unsigned int slot_id);
+
+/**
+ * dal_ctx_free() - Remove all context information
+ *
+ * Removes all slots and client tickets in the keystore
+ * context, and frees all memory associated to it.
+ *
+ * Returns: 0 on success or negative errno.
+ */
+int dal_ctx_free(void);
+
+#endif /* _DAL_CONTEXT_SAFE_H_ */
diff --git a/security/keystore/debug.c b/security/keystore/debug.c
new file mode 100644
index 000000000000..1e5d4cafbff3
--- /dev/null
+++ b/security/keystore/debug.c
@@ -0,0 +1,69 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include "keystore_debug.h"
+
+/**
+ * Display a block of data hexadecimally.
+ *
+ * @param txt Prefix string to display.
+ * @param ptr Pointer to the block of data.
+ * @param size Size of the block of data in bytes.
+ */
+void keystore_hexdump(const char *txt, const void *ptr, unsigned int size)
+{
+	ks_debug("%s: size: %u (0x%lx)\n", txt, size, (unsigned long)ptr);
+
+	if (ptr && size)
+		print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, ptr, size);
+}
+
+/**
+ * Compare two blocks of data. Show the first block. Show error message and
+ * the second block if different.
+ *
+ * @param name1 First data block name.
+ * @param ptr1 First data block pointer.
+ * @param name2 Second data block name.
+ * @param ptr2 Second data block pointer.
+ * @param size Size of data blocks in bytes.
+ */
+int show_and_compare(const char *name1, const void *ptr1, const char *name2,
+		const void *ptr2, unsigned int size)
+{
+	int res = 0;
+
+	if (!name1 || !ptr1 || !name2 || !ptr2)
+		return -EFAULT;
+
+	res = memcmp(ptr1, ptr2, size);
+
+	ks_debug(KBUILD_MODNAME " Comparing buffers %s and %s\n", name1, name2);
+	keystore_hexdump(name1, ptr1, size);
+	if (res) {
+		ks_debug(KBUILD_MODNAME " Buffers differ!\n");
+		keystore_hexdump(name2, ptr2, size);
+	} else {
+		ks_debug(KBUILD_MODNAME " Buffers are identical.\n");
+	}
+
+	return res ? -1 : 0;
+}
diff --git a/security/keystore/ioctls.c b/security/keystore/ioctls.c
new file mode 100644
index 000000000000..e688ca9d299f
--- /dev/null
+++ b/security/keystore/ioctls.c
@@ -0,0 +1,514 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include <security/keystore_api_user.h>
+
+#include "keystore_debug.h"
+#include "api_dal.h"
+
+/* Universal operation data union */
+union keystore_ops_union {
+	struct ias_keystore_version version;
+	struct ias_keystore_register register_client_type;
+	struct ias_keystore_unregister unregister_client;
+	struct ias_keystore_wrapped_key_size wrapped_key_size;
+	struct ias_keystore_generate_key generate_key;
+	struct ias_keystore_wrap_key wrap_key;
+	struct ias_keystore_load_key load_key;
+	struct ias_keystore_unload_key unload_key;
+	struct ias_keystore_crypto_size crypto_size;
+	struct ias_keystore_encrypt_decrypt encrypt_decrypt;
+};
+
+static unsigned int is_cmd_supported(unsigned int cmd)
+{
+	switch (cmd) {
+	case KEYSTORE_IOC_VERSION:
+	case KEYSTORE_IOC_REGISTER:
+	case KEYSTORE_IOC_UNREGISTER:
+	case KEYSTORE_IOC_WRAPPED_KEYSIZE:
+	case KEYSTORE_IOC_GENERATE_KEY:
+	case KEYSTORE_IOC_WRAP_KEY:
+	case KEYSTORE_IOC_LOAD_KEY:
+	case KEYSTORE_IOC_UNLOAD_KEY:
+	case KEYSTORE_IOC_ENCRYPT_SIZE:
+	case KEYSTORE_IOC_ENCRYPT:
+	case KEYSTORE_IOC_DECRYPT_SIZE:
+	case KEYSTORE_IOC_DECRYPT:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+#if defined(CONFIG_KEYSTORE_DEBUG)
+static unsigned char *getcmdstr(unsigned int cmd)
+{
+	switch (cmd) {
+	case KEYSTORE_IOC_VERSION:
+		return "KEYSTORE_IOC_VERSION";
+	case KEYSTORE_IOC_REGISTER:
+		return "KEYSTORE_IOC_REGISTER";
+	case KEYSTORE_IOC_UNREGISTER:
+		return "KEYSTORE_IOC_UNREGISTER";
+	case KEYSTORE_IOC_WRAPPED_KEYSIZE:
+		return "KEYSTORE_IOC_WRAPPED_KEYSIZE";
+	case KEYSTORE_IOC_GENERATE_KEY:
+		return "KEYSTORE_IOC_GENERATE_KEY";
+	case KEYSTORE_IOC_WRAP_KEY:
+		return "KEYSTORE_IOC_WRAP_KEY";
+	case KEYSTORE_IOC_LOAD_KEY:
+		return "KEYSTORE_IOC_LOAD_KEY";
+	case KEYSTORE_IOC_UNLOAD_KEY:
+		return "KEYSTORE_IOC_UNLOAD_KEY";
+	case KEYSTORE_IOC_ENCRYPT_SIZE:
+		return "KEYSTORE_IOC_ENCRYPT_SIZE";
+	case KEYSTORE_IOC_ENCRYPT:
+		return "KEYSTORE_IOC_ENCRYPT";
+	case KEYSTORE_IOC_DECRYPT_SIZE:
+		return "KEYSTORE_IOC_DECRYPT_SIZE";
+	case KEYSTORE_IOC_DECRYPT:
+		return "KEYSTORE_IOC_DECRYPT";
+	default:
+		return "not-supported";
+	}
+}
+#endif
+
+static int version_op(struct ias_keystore_version *user_data)
+{
+	if (!user_data)
+		return -EFAULT;
+
+	user_data->major = KEYSTORE_VERSION_MAJOR;
+	user_data->minor = KEYSTORE_VERSION_MINOR;
+	user_data->patch = KEYSTORE_VERSION_PATCH;
+
+	return 0;
+}
+
+static int register_op(struct ias_keystore_register *user_data)
+{
+
+	if (!user_data)
+		return -EFAULT;
+
+	return dal_keystore_register(user_data->seed_type,
+		user_data->client_ticket);
+
+}
+
+static int unregister_op(struct ias_keystore_unregister *user_data)
+{
+	if (!user_data)
+		return -EFAULT;
+
+	return dal_keystore_unregister(user_data->client_ticket);
+}
+
+static int wrapped_keysize_op(struct ias_keystore_wrapped_key_size *user_data)
+{
+	if (!user_data)
+		return -EFAULT;
+
+	return dal_keystore_wrapped_key_size(user_data->key_spec,
+		&user_data->key_size,
+		&user_data->unwrapped_key_size);
+}
+
+static int generate_key_op(struct ias_keystore_generate_key *user_data)
+{
+	int res = 0;
+	unsigned int wrapped_key_size = 0;
+	uint8_t *wrapped_key = NULL;
+
+	if (!user_data)
+		return -EFAULT;
+
+	res = dal_keystore_wrapped_key_size(user_data->key_spec,
+			&wrapped_key_size, NULL);
+	if (res)
+		return -EINVAL;
+
+	wrapped_key = kmalloc(wrapped_key_size, GFP_KERNEL);
+	if (!wrapped_key)
+		return -ENOMEM;
+
+	res = dal_keystore_generate_key(user_data->client_ticket,
+		user_data->key_spec, wrapped_key);
+	if (res)
+		goto free_buf;
+
+	res = copy_to_user(user_data->wrapped_key, wrapped_key,
+			   wrapped_key_size);
+
+free_buf:
+	kzfree(wrapped_key);
+	return res;
+}
+
+static int wrap_key_op(struct ias_keystore_wrap_key *user_data)
+{
+	int res = 0;
+	uint8_t *wrapped_key = NULL;
+	uint8_t *app_key = NULL;
+	unsigned int wrapped_key_size;
+	unsigned int unwrapped_key_size;
+
+	if (!user_data)
+		return -EFAULT;
+
+	res = dal_keystore_wrapped_key_size(user_data->key_spec,
+			&wrapped_key_size, &unwrapped_key_size);
+	if (res)
+		return -EINVAL;
+
+	wrapped_key = kmalloc(wrapped_key_size, GFP_KERNEL);
+	app_key = kmalloc(user_data->app_key_size, GFP_KERNEL);
+	if (!wrapped_key || !app_key) {
+		res = -ENOMEM;
+		goto free_buf;
+	}
+
+	res = copy_from_user(app_key, user_data->app_key,
+			     user_data->app_key_size);
+
+	res = dal_keystore_wrap_key(user_data->client_ticket,
+			app_key,
+			user_data->app_key_size,
+			user_data->key_spec,
+			wrapped_key);
+	if (res)
+		goto free_buf;
+
+	res = copy_to_user(user_data->wrapped_key, wrapped_key,
+			   wrapped_key_size);
+
+free_buf:
+	kzfree(wrapped_key);
+	kzfree(app_key);
+	return res;
+}
+
+static int load_key_op(struct ias_keystore_load_key *user_data)
+{
+	int res = 0;
+	uint8_t *wrapped_key = NULL;
+
+	if (!user_data)
+		return -EFAULT;
+
+	wrapped_key = kmalloc(user_data->wrapped_key_size, GFP_KERNEL);
+	if (!wrapped_key)
+		return -ENOMEM;
+
+	res = copy_from_user(wrapped_key,
+			     user_data->wrapped_key,
+			     user_data->wrapped_key_size);
+	if (res) {
+		res = -EINVAL;
+		goto free_buf;
+	}
+
+	res = dal_keystore_load_key(user_data->client_ticket,
+			wrapped_key,
+			user_data->wrapped_key_size,
+			&user_data->slot_id);
+
+	if (res == -EAGAIN) {
+		res = copy_to_user(user_data->wrapped_key, wrapped_key,
+				user_data->wrapped_key_size);
+		if (res == 0)
+			res = -EAGAIN;
+	}
+
+free_buf:
+	kzfree(wrapped_key);
+	return res;
+}
+
+static int unload_key_op(struct ias_keystore_unload_key *user_data)
+{
+	int res = 0;
+
+	if (!user_data)
+		return -EFAULT;
+
+	res = dal_keystore_unload_key(user_data->client_ticket,
+			user_data->slot_id);
+
+	return res;
+}
+
+static int encrypt_size_op(struct ias_keystore_crypto_size *user_data)
+{
+	if (!user_data)
+		return -EFAULT;
+
+	return dal_keystore_encrypt_size(user_data->algospec,
+		user_data->input_size, &user_data->output_size);
+}
+
+static int encrypt_op(struct ias_keystore_encrypt_decrypt *user_data)
+{
+	int res;
+	unsigned int output_size = 0;
+	uint8_t *iv = NULL;
+	uint8_t *input = NULL;
+	uint8_t *output = NULL;
+
+	if (!user_data || !user_data->input || !user_data->output)
+		return -EFAULT;
+
+	if (!user_data->input_size)
+		return -EINVAL;
+
+	res = dal_keystore_encrypt_size(user_data->algospec,
+			user_data->input_size, &output_size);
+	if (res)
+		return res;
+
+	input = kmalloc(user_data->input_size, GFP_KERNEL);
+	output = kmalloc(output_size, GFP_KERNEL);
+	if (!input || !output) {
+		res = -ENOMEM;
+		goto free_buf;
+	}
+
+	res = copy_from_user(input, user_data->input, user_data->input_size);
+	if (res)
+		goto free_buf;
+
+	if (user_data->iv && user_data->iv_size > 0) {
+		iv = kmalloc(user_data->iv_size, GFP_KERNEL);
+		if (!iv) {
+			res = -ENOMEM;
+			goto free_buf;
+		}
+
+		res = copy_from_user(iv, user_data->iv, user_data->iv_size);
+		if (res)
+			goto free_buf;
+	}
+
+	res = dal_keystore_encrypt(user_data->client_ticket,
+			user_data->slot_id,
+			user_data->algospec, iv,
+			user_data->iv_size,
+			input, user_data->input_size, output);
+
+	if (res)
+		goto free_buf;
+
+	res = copy_to_user(user_data->output, output, output_size);
+
+free_buf:
+	kzfree(input);
+	kzfree(output);
+	kzfree(iv);
+
+	return res;
+}
+
+static int decrypt_size_op(struct ias_keystore_crypto_size *user_data)
+{
+	if (!user_data)
+		return -EFAULT;
+
+	return dal_keystore_decrypt_size(user_data->algospec,
+		user_data->input_size, &user_data->output_size);
+}
+
+static int decrypt_op(struct ias_keystore_encrypt_decrypt *user_data)
+{
+	int res;
+	unsigned int output_size = 0;
+	uint8_t *iv = NULL;
+	uint8_t *input = NULL;
+	uint8_t *output = NULL;
+
+	if (!user_data || !user_data->input || !user_data->output)
+		return -EFAULT;
+
+	if (!user_data->input_size)
+		return -EINVAL;
+
+	res = dal_keystore_decrypt_size(user_data->algospec,
+		user_data->input_size, &output_size);
+	if (res)
+		return res;
+
+	input = kmalloc(user_data->input_size, GFP_KERNEL);
+	output = kmalloc(output_size, GFP_KERNEL);
+	if (!input || !output) {
+		res = -ENOMEM;
+		goto free_buf;
+	}
+
+	res = copy_from_user(input, user_data->input, user_data->input_size);
+	if (res)
+		goto free_buf;
+
+	if (user_data->iv && user_data->iv_size > 0) {
+		iv = kmalloc(user_data->iv_size, GFP_KERNEL);
+		if (!iv) {
+			res = -ENOMEM;
+			goto free_buf;
+		}
+
+		res = copy_from_user(iv, user_data->iv, user_data->iv_size);
+		if (res)
+			goto free_buf;
+	}
+
+	res = dal_keystore_decrypt(user_data->client_ticket,
+		user_data->slot_id, user_data->algospec, iv,
+		user_data->iv_size,
+		input, user_data->input_size, output);
+
+	if (res)
+		goto free_buf;
+
+	res = copy_to_user(user_data->output, output, output_size);
+
+free_buf:
+	kzfree(input);
+	kzfree(output);
+	kzfree(iv);
+
+	return res;
+}
+
+/**
+ * keystore_ioctl - the ioctl function
+ *
+ * @param file pointer to file structure
+ * @param cmd command to execute
+ * @param arg user space pointer to arguments structure
+ *
+ * @returns 0 on success, <0 on error
+ */
+long keystore_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	union keystore_ops_union op;
+	unsigned int size;
+	int res = 0;
+
+	FUNC_BEGIN;
+
+	ks_debug(KBUILD_MODNAME ": %s - cmd = 0x%x - %s\n",
+		 __func__, cmd, getcmdstr(cmd));
+
+	/* copy data structure from user space to system */
+	size = _IOC_SIZE(cmd);
+
+	if (!is_cmd_supported(cmd) ||
+	    (size > sizeof(union keystore_ops_union))) {
+		ks_err(KBUILD_MODNAME ": %s - cmd=%u unknown, size:%d, size(keystore_ops_union): %zu\n",
+		       __func__, cmd, size, sizeof(union keystore_ops_union));
+		return -ENOIOCTLCMD;
+	}
+	if (!access_ok(VERIFY_READ, (void *)arg, size)) {
+		ks_err(KBUILD_MODNAME ": %s - cmd=%u no read access\n",
+		       __func__, cmd);
+		return -EFAULT;
+	}
+	if ((_IOC_DIR(cmd) & _IOC_READ) &&
+	    (!access_ok(VERIFY_WRITE, (void *)arg, size))) {
+		ks_err(KBUILD_MODNAME ": %s - cmd=%u no write access\n",
+		       __func__, cmd);
+		return -EFAULT;
+	}
+	if (copy_from_user(&op, (void *)arg, size)) {
+		ks_err(KBUILD_MODNAME ": %s - cannot copy data\n",
+		       __func__);
+		return -EFAULT;
+	}
+
+	switch (cmd) {
+	case KEYSTORE_IOC_VERSION:
+		res = version_op(&op.version);
+	case KEYSTORE_IOC_REGISTER:
+		res = register_op(&op.register_client_type);
+		break;
+
+	case KEYSTORE_IOC_UNREGISTER:
+		res = unregister_op(&op.unregister_client);
+		break;
+
+	case KEYSTORE_IOC_WRAPPED_KEYSIZE:
+		res = wrapped_keysize_op(&op.wrapped_key_size);
+		break;
+
+	case KEYSTORE_IOC_GENERATE_KEY:
+		res = generate_key_op(&op.generate_key);
+		break;
+
+	case KEYSTORE_IOC_WRAP_KEY:
+		res = wrap_key_op(&op.wrap_key);
+		break;
+
+	case KEYSTORE_IOC_LOAD_KEY:
+		res = load_key_op(&op.load_key);
+		break;
+
+	case KEYSTORE_IOC_UNLOAD_KEY:
+		res = unload_key_op(&op.unload_key);
+		break;
+
+	case KEYSTORE_IOC_ENCRYPT_SIZE:
+		res = encrypt_size_op(&op.crypto_size);
+		break;
+
+	case KEYSTORE_IOC_ENCRYPT:
+		res = encrypt_op(&op.encrypt_decrypt);
+		break;
+
+	case KEYSTORE_IOC_DECRYPT_SIZE:
+		res = decrypt_size_op(&op.crypto_size);
+		break;
+
+	case KEYSTORE_IOC_DECRYPT:
+		res = decrypt_op(&op.encrypt_decrypt);
+		break;
+	default:
+		res = -ENOIOCTLCMD;
+		ks_err(KBUILD_MODNAME ": %s - cmd=%u not known\n",
+		       __func__, cmd);
+		break;
+	}
+
+	/* check if OK and we need to return some data in memory block */
+	if ((res >= 0) && (_IOC_DIR(cmd) & _IOC_READ)) {
+		/* then copy data from system to user space */
+		if (copy_to_user((void *)arg, &op, size)) {
+			ks_err(KBUILD_MODNAME ": %s - cannot copy data\n",
+			       __func__);
+			res = -EFAULT;
+		}
+	}
+
+	memset(&op, 0, sizeof(op));
+	FUNC_RES(res);
+	return res;
+}
diff --git a/security/keystore/keystore_client.h b/security/keystore/keystore_client.h
new file mode 100644
index 000000000000..c3e80a6bdca5
--- /dev/null
+++ b/security/keystore/keystore_client.h
@@ -0,0 +1,48 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef KEYSTORE_CLIENT_ID
+#define KEYSTORE_CLIENT_ID
+
+#include <linux/types.h>
+
+/**
+ * DOC: Introduction
+ *
+ * The client operations include anything to do with user-space
+ * client identification and (in the future) authentication.
+ *
+ */
+
+/**
+ * keystore_calc_clientid() - Derive the client ID
+ *
+ * @client_id: output array containing the client ID
+ * @client_id_size: size of the output array
+ * @timeout: timeout parameter for signed manifest caching
+ * @caps: capabilities parameter for signed manifest verification
+ *
+ * Derive the client ID of a client from the path by
+ * calculating SHA-256 on the directory name plus
+ * file name.
+ *
+ * client_id = sha256( path_name + file_name )
+ *
+ * Returns: 0 if OK or negative error code.
+ */
+int keystore_calc_clientid(u8 *client_id, const unsigned int client_id_size);
+
+#endif /* KEYSTORE_CLIENT_ID */
diff --git a/security/keystore/keystore_debug.h b/security/keystore/keystore_debug.h
new file mode 100644
index 000000000000..16cfc9989738
--- /dev/null
+++ b/security/keystore/keystore_debug.h
@@ -0,0 +1,95 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _KEYSTORE_DEBUG_H_
+#define _KEYSTORE_DEBUG_H_
+
+#ifdef CONFIG_KEYSTORE_DEBUG
+
+/**
+ * keystore_hexdump() - Display a block of data hexadecimally.
+ *
+ * @txt: Prefix string to display.
+ * @ptr: Pointer to the block of data.
+ * @size: Size of the block of data in bytes.
+ *
+ * Will only be enabled if the %KEYSTORE_DEBUG config parameter
+ * is activated.
+ */
+void keystore_hexdump(const char *txt, const void *ptr, unsigned int size);
+
+
+/**
+ * show_and_compare() - Compare two blocks of data. Show the first block.
+ * Show error message and the second block if different.
+ *
+ * @name1: First data block name.
+ * @ptr1: First data block pointer.
+ * @name2: Second data block name.
+ * @ptr2: Second data block pointer.
+ * @size: Size of data blocks in bytes.
+ *
+ * Returns: 0 on success or negative error number.
+ */
+int show_and_compare(const char *name1, const void *ptr1,
+		     const char *name2, const void *ptr2,
+		     unsigned int size);
+
+/* Dummy function if debugging is not configured */
+/* Static inline so will be optimised away by compiler */
+#else /* CONFIG_KEYSTORE_DEBUG */
+static inline void keystore_hexdump(const char *txt, const void *ptr,
+				    unsigned int size)
+{
+}
+
+static inline int show_and_compare(const char *name1, const void *ptr1,
+				   const char *name2, const void *ptr2,
+				   unsigned int size)
+{
+	return 0;
+}
+#endif
+
+#define ks_info(...)  pr_info(__VA_ARGS__)
+#define ks_warn(...)  pr_warn(__VA_ARGS__)
+#define ks_err(...)   pr_err(__VA_ARGS__)
+
+#ifdef CONFIG_KEYSTORE_DEBUG
+
+/* Enable output of pr_debug */
+#define DEBUG
+
+#define ks_debug(...) pr_debug(__VA_ARGS__)
+
+#define FUNC_BEGIN   ks_debug(KBUILD_MODNAME ": %s() BEGIN\n", __func__)
+#define FUNC_END     ks_debug(KBUILD_MODNAME ": %s() END\n", __func__)
+#define FUNC_RES(x)  ks_debug(KBUILD_MODNAME ": %s() END, res=%ld\n", \
+			      __func__, (long)(x))
+#define SHOW_LINE    ks_debug(KBUILD_MODNAME ": %s:%u\n", __func__, __LINE__)
+
+#else
+
+#define ks_debug(...)
+
+#define FUNC_BEGIN
+#define FUNC_END
+#define FUNC_RES(x)
+#define SHOW_LINE
+
+#endif
+
+#endif /* _KEYSTORE_DEBUG_H_ */
diff --git a/security/keystore/keystore_ioctl.h b/security/keystore/keystore_ioctl.h
new file mode 100644
index 000000000000..0bdd48a4fcf6
--- /dev/null
+++ b/security/keystore/keystore_ioctl.h
@@ -0,0 +1,33 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _KEYSTORE_IOCTL_H_
+#define _KEYSTORE_IOCTL_H_
+
+#include <linux/fs.h>
+
+/**
+ * keystore_ioctl() - the ioctl function
+ *
+ * @file: pointer to file structure
+ * @cmd: command to execute
+ * @arg: user space pointer to arguments structure
+ *
+ * @returns 0 on success, <0 on error
+ */
+long keystore_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+
+#endif
diff --git a/security/keystore/keystore_kmod.c b/security/keystore/keystore_kmod.c
new file mode 100644
index 000000000000..ef629114adc2
--- /dev/null
+++ b/security/keystore/keystore_kmod.c
@@ -0,0 +1,232 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/cdev.h>
+#include <linux/jiffies.h>
+#include <linux/dal.h>
+#include <linux/workqueue.h>
+
+#include <security/keystore_api_user.h>
+
+#include "keystore_ioctl.h"
+#include "keystore_debug.h"
+#include "api_dal.h"
+
+/**
+ * DAL keystore client parameters
+ */
+#define APPLET_BLACKLIST_COUNT (1)
+#define APPLET_BLACKLIST_MAX_RETRY (5)
+
+
+struct applet_blacklisting_work {
+	struct delayed_work dwork;
+	int  retry;
+	int  applet_uuid_count;
+	char *applet_uuid[APPLET_BLACKLIST_COUNT];
+};
+
+struct applet_blacklisting_work *work_;
+
+/**
+ * keystore_open - the open function
+ *
+ * @param inode pointer to inode structure
+ * @param file pointer to file structure
+ *
+ * @returns 0 on success, <0 on error
+ */
+static int keystore_open(struct inode *inode, struct file *file)
+{
+	ks_debug(KBUILD_MODNAME ": %s\n", __func__);
+	return nonseekable_open(inode, file);
+}
+
+/**
+ * keystore_release - the close function
+ *
+ * @param inode pointer to inode structure
+ * @param file pointer to file structure
+ *
+ * @returns 0 on success, <0 on error
+ */
+static int keystore_release(struct inode *inode, struct file *file)
+{
+	ks_debug(KBUILD_MODNAME ": %s\n", __func__);
+	return 0;
+}
+
+/* The various file operations we support. */
+static const struct file_operations keystore_fops = {
+open:		 keystore_open,
+release :	 keystore_release,
+unlocked_ioctl : keystore_ioctl
+};
+
+static dev_t dev_keystore; /* Structure to set device range */
+static struct class *class_keystore; /* Struct to set device class properties */
+static struct cdev cdev_keystore; /* Structure to create device */
+
+int add_to_blacklist(const char *uuid_str)
+{
+	uuid_t uuid;
+	int ret = 0;
+
+	ret = dal_uuid_parse(uuid_str, &uuid);
+	if (ret != DAL_KDI_SUCCESS) {
+		pr_err(KBUILD_MODNAME ": %s dal_uuid_parse failed\n",
+				__func__);
+	} else {
+		pr_err(KBUILD_MODNAME ": %s dal_uuid_parse succeeded\n",
+				__func__);
+	}
+
+	ret = dal_set_ta_exclusive_access(&uuid);
+	if (ret != DAL_KDI_SUCCESS) {
+		pr_err(KBUILD_MODNAME ": %s dal_set_ta_exclusive_access failed\n",
+				__func__);
+	} else {
+		pr_err(KBUILD_MODNAME ": %s dal_set_ta_exclusive_access succeeded\n",
+				__func__);
+	}
+	return ret;
+}
+
+static void applet_blacklisting_worker(struct work_struct *work)
+{
+	struct applet_blacklisting_work *my_work = container_of(to_delayed_work(work),
+			struct applet_blacklisting_work, dwork);
+
+	int ret = DAL_KDI_SUCCESS;
+	int applet = 0;
+
+	if (my_work->retry ==  APPLET_BLACKLIST_MAX_RETRY)
+		goto exit;
+
+	for ( ; applet < my_work->applet_uuid_count; applet++) {
+		ret = add_to_blacklist(my_work->applet_uuid[applet]);
+
+		if (ret != DAL_KDI_SUCCESS) {
+			my_work->retry++;
+			schedule_delayed_work((struct delayed_work *)my_work,
+					msecs_to_jiffies(200));
+			ks_debug(KBUILD_MODNAME ": Re-scheduling DAL Keystore blacklisting work\n");
+
+			goto end;
+		}
+	}
+
+exit:
+	kfree((void *)my_work);
+end:
+	return;
+}
+
+static void schedule_applet_blacklisting(void)
+{
+	work_ = kmalloc(sizeof(struct applet_blacklisting_work), GFP_KERNEL);
+	if (work_) {
+		ks_debug(KBUILD_MODNAME ": Scheduling DAL Keystore blacklisting work\n");
+
+		work_->applet_uuid_count = APPLET_BLACKLIST_COUNT;
+		work_->retry = 0;
+		work_->applet_uuid[0] = CONFIG_DAL_KEYSTORE_APPLET_ID;
+
+		INIT_DELAYED_WORK((struct delayed_work *)work_,
+				applet_blacklisting_worker);
+		schedule_delayed_work((struct delayed_work *)work_,
+				msecs_to_jiffies(17000));
+	}
+}
+
+static int __init keystore_init(void)
+{
+	int res;
+
+	/* create dynamic node device */
+	res = alloc_chrdev_region(&dev_keystore, 0, 1, "keystore");
+	if (res != 0) {
+		ks_err(KBUILD_MODNAME ": Unable to set range of devices: %d\n",
+		       res);
+		res =  -ENODEV;
+		goto err1;
+	}
+
+	class_keystore = class_create(THIS_MODULE, "keystore");
+	if (class_keystore == NULL) {
+		ks_err(KBUILD_MODNAME ": Unable to create device class\n");
+		res =  -ENODEV;
+		goto err2;
+	}
+
+	if (device_create(class_keystore, NULL, dev_keystore,
+				NULL, "keystore") == NULL) {
+		res =  -ENODEV;
+		goto err3;
+	}
+
+	cdev_init(&cdev_keystore, &keystore_fops);
+	res = cdev_add(&cdev_keystore, dev_keystore, 1);
+	if (res != 0) {
+		ks_err(KBUILD_MODNAME ": Unable create device: %d\n", res);
+		res =  -ENODEV;
+		goto err4;
+	}
+
+	schedule_applet_blacklisting();
+	return 0;
+
+	/* error */
+err4:
+	cdev_del(&cdev_keystore);
+	device_destroy(class_keystore, dev_keystore);
+err3:
+	class_destroy(class_keystore);
+err2:
+	unregister_chrdev_region(dev_keystore, 1);
+err1:
+	return res;
+}
+
+static void __exit keystore_exit(void)
+{
+	/*unset device hook */
+	cdev_del(&cdev_keystore);
+	/*destroy device */
+	device_destroy(class_keystore, dev_keystore);
+	/*unset device class */
+	class_destroy(class_keystore);
+	/*unregister device range */
+	unregister_chrdev_region(dev_keystore, 1);
+
+	dal_keystore_free_contexts();
+}
+
+module_init(keystore_init);
+module_exit(keystore_exit);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_DESCRIPTION("Intel(R) Keystore");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/security/keystore/keystore_mac.h b/security/keystore/keystore_mac.h
new file mode 100644
index 000000000000..1eb82e1aa51f
--- /dev/null
+++ b/security/keystore/keystore_mac.h
@@ -0,0 +1,54 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _KEYSTORE_MAC_H_
+#define _KEYSTORE_MAC_H_
+
+#include <linux/types.h>
+
+#define SHA256_HMAC_SIZE	32
+
+/**
+ * keystore_calc_mac() - Calculate SHA-256 HMAC or AES-128 CMAC.
+ *
+ * @alg_name: Algorithm name ("hmac(sha256)" or "cmac(aes)").
+ * @key: Pointer to the key.
+ * @klen: Key size in bytes.
+ * @data_in: Pointer to the data block.
+ * @dlen: Data block size in bytes.
+ * @hash_out: Pointer to the output buffer.
+ * @outlen: Output buffer size in bytes.
+ *
+ * Returns: 0 if OK or negative error code (see errno).
+ */
+int keystore_calc_mac(const char *alg_name, const char *key, size_t klen,
+		      const char *data_in, size_t dlen,
+		      char *hash_out, size_t outlen);
+
+/**
+ * keystore_sha256_block() - Calculate SHA-256 digest of a data block.
+ *
+ * @data: The data block pointer.
+ * @size: The size of data in bytes.
+ * @result: The result digest pointer.
+ * @result_size: The result digest block size.
+ *
+ * Returns: 0 if OK or negative error code.
+ */
+int keystore_sha256_block(const void *data, unsigned int size,
+			  void *result, unsigned int result_size);
+
+#endif /* _KEYSTORE_MAC_H_ */
diff --git a/security/keystore/keystore_rand.h b/security/keystore/keystore_rand.h
new file mode 100644
index 000000000000..a31da7d39a42
--- /dev/null
+++ b/security/keystore/keystore_rand.h
@@ -0,0 +1,37 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _KEYSTORE_RAND_H_
+#define _KEYSTORE_RAND_H_
+
+#include <linux/types.h>
+
+/**
+ * keystore_get_rdrand() - Fill buffer with random bytes.
+ *
+ * @buf: Pointer to input buffer
+ * @size: Size of input buffer
+ *
+ * Function gets CPU information then checks if CPU support
+ * RDRAND instruction and finally get data as int
+ * from RDRAND register, If CPU does not support
+ * RDRAND ENODATA will be returned.
+ *
+ * Returns: 0 on success or negative error number.
+ */
+int keystore_get_rdrand(uint8_t *buf, int size);
+
+#endif /* _KEYSTORE_RAND_H_ */
diff --git a/security/keystore/mac.c b/security/keystore/mac.c
new file mode 100644
index 000000000000..4f13df6b93d4
--- /dev/null
+++ b/security/keystore/mac.c
@@ -0,0 +1,154 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <crypto/hash.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/scatterlist.h>
+
+#include "keystore_mac.h"
+#include "keystore_debug.h"
+
+int keystore_calc_mac(const char *alg_name, const char *key, size_t klen,
+		      const char *data_in, size_t dlen,
+		      char *hash_out, size_t outlen)
+{
+	struct crypto_ahash *tfm;
+	struct scatterlist sg;
+	struct ahash_request *req;
+	void *hash_buf;
+	int rc;
+
+	if (!alg_name || !key || !data_in || !hash_out)
+		return -EFAULT;
+
+	memset(hash_out, 0, outlen);
+
+	tfm = crypto_alloc_ahash(alg_name, 0, 0);
+	if (IS_ERR(tfm)) {
+		ks_err(KBUILD_MODNAME": crypto_alloc_ahash failed.\n");
+		rc = PTR_ERR(tfm);
+		goto err_tfm;
+	}
+
+	req = ahash_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		ks_err(KBUILD_MODNAME ": failed to allocate request for mac\n");
+		rc = -ENOMEM;
+		goto err_req;
+	}
+
+	if (crypto_ahash_digestsize(tfm) > outlen) {
+		ks_err(KBUILD_MODNAME ": tfm size > result buffer.\n");
+		rc = -EINVAL;
+		goto err_hash_buf;
+	}
+
+	hash_buf = kzalloc(dlen, GFP_KERNEL);
+	if (!hash_buf) {
+		rc = -ENOMEM;
+		goto err_hash_buf;
+	}
+
+	memcpy(hash_buf, data_in, dlen);
+	sg_init_one(&sg, hash_buf, dlen);
+	crypto_ahash_clear_flags(tfm, ~0);
+	rc = crypto_ahash_setkey(tfm, key, klen);
+	if (rc) {
+		ks_err(KBUILD_MODNAME": crypto_ahash_setkey failed\n");
+	} else {
+		char hash_tmp[crypto_ahash_digestsize(tfm)];
+
+		memset(hash_tmp, 0, sizeof(hash_tmp));
+
+		ahash_request_set_crypt(req, &sg, hash_tmp, dlen);
+
+		rc = crypto_ahash_digest(req);
+		if (rc == 0) {
+			/* OK */
+			memcpy(hash_out, hash_tmp, sizeof(hash_tmp));
+		} else {
+			ks_err(KBUILD_MODNAME": crypto_ahash_digest failed\n");
+		}
+	}
+
+	kfree(hash_buf);
+
+err_hash_buf:
+	ahash_request_free(req);
+
+err_req:
+	crypto_free_ahash(tfm);
+
+err_tfm:
+	return rc;
+}
+
+/**
+ * Calculate SHA-256 digest of a data block.
+ *
+ * @param data The data block pointer.
+ * @param size The size of data in bytes.
+ * @param result The result digest pointer.
+ * @param result_size The result digest block size.
+ *
+ * @return 0 if OK or negative error code.
+ */
+int keystore_sha256_block(const void *data, unsigned int size,
+			  void *result, unsigned int result_size)
+{
+	struct crypto_shash *tfm;
+	struct shash_desc *sdesc;
+	int shash_desc_size;
+	int res = 0;
+
+	if (!data || !result)
+		return -EFAULT;
+
+	tfm = crypto_alloc_shash("sha256",
+				CRYPTO_ALG_TYPE_HASH,
+				CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm)) {
+		res = PTR_ERR(tfm);
+		return (res < 0) ? res : -res;
+	}
+
+	shash_desc_size = sizeof(struct shash_desc)
+		+ crypto_shash_descsize(tfm);
+	sdesc = kmalloc(shash_desc_size, GFP_KERNEL);
+	if (!sdesc) {
+		crypto_free_shash(tfm);
+		ks_err("ecc: memory allocation error\n");
+		return -ENOMEM;
+	}
+
+	if (result_size < crypto_shash_digestsize(tfm)) {
+		crypto_free_shash(tfm);
+		return -EINVAL;
+	}
+
+	sdesc->tfm = tfm;
+	sdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;
+
+	crypto_shash_init(sdesc);
+	crypto_shash_update(sdesc, data, size);
+	crypto_shash_final(sdesc, result);
+
+	crypto_free_shash(tfm);
+
+	return 0;
+}
diff --git a/security/keystore/rdrand.c b/security/keystore/rdrand.c
new file mode 100644
index 000000000000..1de3ddfb67be
--- /dev/null
+++ b/security/keystore/rdrand.c
@@ -0,0 +1,83 @@
+/*
+ *
+ * Intel Keystore Linux driver
+ * Copyright (c) 2018, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/cpufeature.h>
+#include <linux/processor.h>
+#include <asm/alternative.h>
+#include <asm/nops.h>
+
+#include "keystore_debug.h"
+
+#define RDRAND_INT	".byte 0x0f,0xc7,0xf0" /*!Address of rdrand register */
+#define RDRAND_RETRY_LOOPS	10
+
+
+#ifdef NORDRAND/*case we compile for machine which does not support rdrand */
+static int rdrand_magic_counter;
+#endif
+
+/**
+ * Function gets CPU information then checks if CPU support RDRAND instruction
+ * and finally get as int from RDRAND register and fill buffer
+ * If CPU does not support RDRAND ENODATA will be return
+ * @param random is pointer to simple data type in case NULL EINVAL will be
+ * returned
+ */
+int keystore_get_rdrand(uint8_t *buf, int size)
+{
+	struct cpuinfo_x86 *c;
+	int i;
+#ifndef NORDRAND
+	int random = 0, ret;
+#endif
+
+	if (!buf)
+		return -EINVAL;
+
+	c = &cpu_data(0);
+	if (c == NULL) {
+		ks_warn("Fail to get CPUINFO\n");
+		return -EINVAL;
+	}
+
+	if (!cpu_has(c, X86_FEATURE_RDRAND)) {
+		ks_warn("CPU does not support RDRAND\n");
+#ifndef NORDRAND/*case we compile for machine which does not support rdrand */
+		return -ENODATA;
+#endif
+	}
+	for (i = 0; i < size; i++) {
+#ifndef NORDRAND/*case we compile for machine which does not support rdrand */
+		alternative_io("movl $0, %0\n\t"
+				ASM_NOP4,
+				"\n1: " RDRAND_INT "\n\t"
+				"jc 2f\n\t"
+				"decl %0\n\t"
+				"jnz 1b\n\t"
+				"2:",
+				X86_FEATURE_RDRAND,
+				ASM_OUTPUT2("=r" (ret), "=a" (random)),
+				"" (RDRAND_RETRY_LOOPS));
+		buf[i] = random;
+#else
+#pragma message "Compiling with out RDRAND support"
+		buf[i] = rdrand_magic_counter++;
+#endif
+	}
+
+	return  0;
+}
-- 
2.17.1

