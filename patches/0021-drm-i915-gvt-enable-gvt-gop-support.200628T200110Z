From 1b67b2931ce0c5fa7e257ffb71cba39ddbd51acf Mon Sep 17 00:00:00 2001
From: Liu Xinyun <xinyun.liu@intel.com>
Date: Tue, 10 Sep 2019 00:22:51 +0800
Subject: [PATCH 21/24] drm/i915/gvt: enable gvt gop support

Reserve 8MB memory block as graphics memory and pass it to Gop driver as
the guest framebuffer. This framebuffer guest physical address starts
from 0xDF000000 and works with fixed display mode 1920x1080@32bpp

Tracked-On: projectacrn/acrn-hypervisor#3624
Co-Developed-by: He Min <min.he@intel.com>
Signed-off-by: Liu Xinyun <xinyun.liu@intel.com>
Reviewed-by: Zhao Yakui <yakui.zhao@intel.com>
Signed-off-by: Xiaoguang Wu <xiaoguang.wu@intel.com>
Reviewed-by: Colin Xu <colin.xu@intel.com>
---
 drivers/gpu/drm/i915/gvt/display.c  | 138 ++++++++++++++++++++++++++++
 drivers/gpu/drm/i915/gvt/display.h  |   3 +
 drivers/gpu/drm/i915/gvt/gtt.c      |  17 ++++
 drivers/gpu/drm/i915/gvt/gvt.h      |   8 ++
 drivers/gpu/drm/i915/gvt/handlers.c |   4 +
 drivers/gpu/drm/i915/gvt/vgpu.c     |   4 +
 drivers/gpu/drm/i915/i915_pvinfo.h  |   6 ++
 7 files changed, 180 insertions(+)

diff --git a/drivers/gpu/drm/i915/gvt/display.c b/drivers/gpu/drm/i915/gvt/display.c
index 6b34f564f39c..84d9b0989860 100644
--- a/drivers/gpu/drm/i915/gvt/display.c
+++ b/drivers/gpu/drm/i915/gvt/display.c
@@ -2708,3 +2708,141 @@ void intel_gvt_init_display(struct intel_gvt *gvt)
 	intel_gvt_init_pipe_info(gvt);
 	intel_gvt_init_ddb(gvt);
 }
+
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+/*
+ * prepare_gop_fb will allocate a arrange of memory, then map them into the
+ * ggtt table of the guest partition in the aperture.
+ */
+static int prepare_gop_fb(struct intel_vgpu *vgpu, u32 size)
+{
+	struct drm_i915_private *dev_priv = vgpu->gvt->dev_priv;
+	struct page **pages = NULL;
+	u32 count, npages = size >> PAGE_SHIFT;
+	struct i915_ggtt *ggtt = &dev_priv->ggtt;
+	struct i915_vma vma;
+	struct drm_mm_node *node = &vgpu->gm.high_gm_node;
+	struct sg_table st;
+	unsigned int cache_level = HAS_LLC(dev_priv) ?
+				I915_CACHE_LLC : I915_CACHE_NONE;
+	int ret = 0;
+
+	pages = kmalloc_array(npages, sizeof(struct page *), GFP_KERNEL);
+	if (!pages)
+		return -ENOMEM;
+
+	for (count = 0; count < npages; count++) {
+		struct page *page = alloc_page(GFP_KERNEL);
+		if (!page) {
+			ret = -ENOMEM;
+			goto free_pgs;
+		}
+		pages[count] = page;
+
+		intel_gvt_hypervisor_map_gfn_to_mfn (vgpu,
+				(GOP_FB_BASE >> PAGE_SHIFT) + count,
+				page_to_pfn(page), 1, true);
+	}
+
+	ret = sg_alloc_table_from_pages(&st, pages, npages,
+			0, npages << PAGE_SHIFT, GFP_KERNEL);
+	if (ret)
+		goto free_pgs;
+
+	if (!dma_map_sg(&dev_priv->drm.pdev->dev, st.sgl, st.nents,
+				PCI_DMA_BIDIRECTIONAL)) {
+		ret = -ENOMEM;
+		goto free_sg;
+	}
+
+	memset(&vma, 0, sizeof(vma));
+	vma.node.start = node->start;
+	vma.node.size = size;
+	vma.pages = &st;
+	ggtt->vm.insert_entries(&ggtt->vm, &vma, cache_level, 0);
+	sg_free_table(&st);
+
+	vgpu->gm.gop_fb_pages = pages;
+	vgpu->gm.gop_fb_size = count;
+	return 0;
+
+free_sg:
+	sg_free_table(&st);
+
+free_pgs:
+	release_pages(pages, count);
+	kfree(pages);
+	return ret;
+}
+
+#define GOP_DISPLAY_WIDTH 1920
+#define GOP_DISPLAY_HEIGHT 1080
+static int setup_gop_display(struct intel_vgpu *vgpu)
+{
+	int ret = 0;
+	unsigned int pipe;
+	struct drm_i915_private *dev_priv = vgpu->gvt->dev_priv;
+	bool found = false;
+	u32 width = GOP_DISPLAY_WIDTH, height = GOP_DISPLAY_HEIGHT;
+	u32 stride, ctl, surf;
+	unsigned long irqflags;
+
+
+	/* we will display the gop output on the first plane the vgpu ownes */
+	for_each_pipe(dev_priv, pipe) {
+		if (vgpu->gvt->pipe_info[pipe].owner == vgpu->id) {
+			found = true;
+			break;
+		}
+	}
+
+	if (!found) {
+		gvt_dbg_dpy("Failed to find owned pipe for %d", vgpu->id);
+		return -ENODEV;
+	}
+
+	/* Sizes are 0 based */
+	stride = width * 4 / 64; /* 32bit per pixel */
+	width--;
+	height--;
+	surf = vgpu->gm.high_gm_node.start;
+	ctl = PLANE_CTL_ENABLE | PLANE_CTL_FORMAT_XRGB_8888;
+	ctl |= PLANE_CTL_PIPE_GAMMA_ENABLE |
+		PLANE_CTL_PIPE_CSC_ENABLE |
+		PLANE_CTL_PLANE_GAMMA_DISABLE;
+	spin_lock_irqsave(&dev_priv->uncore.lock, irqflags);
+	I915_WRITE_FW(PLANE_OFFSET(pipe, 0), 0);
+	I915_WRITE_FW(PLANE_STRIDE(pipe, 0), stride);
+	I915_WRITE_FW(PLANE_SIZE(pipe, 0), (height << 16) | width);
+	I915_WRITE_FW(PLANE_AUX_DIST(pipe, 0), 0xFFFFF000);
+	I915_WRITE_FW(PLANE_AUX_OFFSET(pipe, 0), 0);
+	I915_WRITE_FW(PLANE_POS(pipe, 0), 0);
+	I915_WRITE_FW(PLANE_CTL(pipe, 0), ctl);
+	I915_WRITE_FW(PLANE_SURF(pipe, 0), surf);
+	I915_READ_FW(PLANE_SURF(pipe, 0));
+	spin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);
+	return ret;
+}
+
+#define GOP_FB_SIZE 0x800000  /* 8M FB size */
+int intel_vgpu_g2v_setup_gop(struct intel_vgpu *vgpu)
+{
+	int ret = 0;
+
+	if (vgpu->gm.gop_fb_pages)
+		goto Done;
+
+	ret = prepare_gop_fb(vgpu, GOP_FB_SIZE);
+	if (ret) {
+		gvt_dbg_dpy("gop prepared failed %d\n", ret);
+		goto Done;
+	}
+
+	ret = setup_gop_display(vgpu);
+	if (ret) {
+		gvt_dbg_dpy("gop display setup failed %d\n", ret);
+	}
+Done:
+	return 0;
+}
+#endif
diff --git a/drivers/gpu/drm/i915/gvt/display.h b/drivers/gpu/drm/i915/gvt/display.h
index 8bdc6013f1e0..2f525c2a3b16 100644
--- a/drivers/gpu/drm/i915/gvt/display.h
+++ b/drivers/gpu/drm/i915/gvt/display.h
@@ -261,4 +261,7 @@ void intel_gvt_flush_pipe_color(struct intel_gvt *gvt, enum pipe pipe,
 
 int pipe_is_enabled(struct intel_vgpu *vgpu, enum pipe pipe);
 
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+int intel_vgpu_g2v_setup_gop(struct intel_vgpu *vgpu);
+#endif
 #endif
diff --git a/drivers/gpu/drm/i915/gvt/gtt.c b/drivers/gpu/drm/i915/gvt/gtt.c
index 7a21f755b0fb..c6a02f0da16c 100644
--- a/drivers/gpu/drm/i915/gvt/gtt.c
+++ b/drivers/gpu/drm/i915/gvt/gtt.c
@@ -2523,6 +2523,19 @@ static void intel_vgpu_destroy_ggtt_mm(struct intel_vgpu *vgpu)
 	}
 }
 
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+static void clean_gvt_gop(struct intel_vgpu *vgpu)
+{
+	int i;
+	for (i = 0; i < vgpu->gm.gop_fb_size; i++)
+		intel_gvt_hypervisor_map_gfn_to_mfn(vgpu,
+			(GOP_FB_BASE >> PAGE_SHIFT) + i,
+			page_to_pfn(vgpu->gm.gop_fb_pages[i]), 1, false);
+
+	release_pages(vgpu->gm.gop_fb_pages, vgpu->gm.gop_fb_size);
+	kfree(vgpu->gm.gop_fb_pages);
+}
+#endif
 /**
  * intel_vgpu_clean_gtt - clean up per-vGPU graphics memory virulization
  * @vgpu: a vGPU
@@ -2537,6 +2550,10 @@ void intel_vgpu_clean_gtt(struct intel_vgpu *vgpu)
 {
 	intel_vgpu_destroy_all_ppgtt_mm(vgpu);
 	intel_vgpu_destroy_ggtt_mm(vgpu);
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+	if (vgpu->gm.gop_fb_pages)
+		clean_gvt_gop(vgpu);
+#endif
 	release_scratch_page_tree(vgpu);
 }
 
diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 61baa2d05498..69e4c7f978ff 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -81,6 +81,10 @@ struct intel_vgpu_gm {
 	u64 hidden_sz;
 	struct drm_mm_node low_gm_node;
 	struct drm_mm_node high_gm_node;
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+	struct page **gop_fb_pages;
+	u32 gop_fb_size;
+#endif
 };
 
 #define INTEL_GVT_MAX_NUM_FENCES 32
@@ -117,6 +121,10 @@ struct intel_vgpu_irq {
 		       INTEL_GVT_EVENT_MAX);
 };
 
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+#define GOP_FB_BASE	0xDF000000
+#endif
+
 struct intel_vgpu_opregion {
 	bool mapped;
 	void *va;
diff --git a/drivers/gpu/drm/i915/gvt/handlers.c b/drivers/gpu/drm/i915/gvt/handlers.c
index aae9bd092709..8e733882cd6d 100644
--- a/drivers/gpu/drm/i915/gvt/handlers.c
+++ b/drivers/gpu/drm/i915/gvt/handlers.c
@@ -1798,6 +1798,10 @@ static int handle_g2v_notification(struct intel_vgpu *vgpu, int notification)
 	case VGT_G2V_EXECLIST_CONTEXT_DESTROY:
 	case 1:	/* Remove this in guest driver. */
 		break;
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+	case VGT_G2V_GOP_SETUP:
+		return intel_vgpu_g2v_setup_gop(vgpu);
+#endif
 	default:
 		gvt_vgpu_err("Invalid PV notification %d\n", notification);
 	}
diff --git a/drivers/gpu/drm/i915/gvt/vgpu.c b/drivers/gpu/drm/i915/gvt/vgpu.c
index 05e24d9695f6..2881ace75d1f 100644
--- a/drivers/gpu/drm/i915/gvt/vgpu.c
+++ b/drivers/gpu/drm/i915/gvt/vgpu.c
@@ -48,6 +48,10 @@ void populate_pvinfo_page(struct intel_vgpu *vgpu)
 	vgpu_vreg_t(vgpu, vgtif_reg(vgt_caps)) |= VGT_CAPS_HWSP_EMULATION;
 	vgpu_vreg_t(vgpu, vgtif_reg(vgt_caps)) |= VGT_CAPS_HUGE_GTT;
 
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+	vgpu_vreg_t(vgpu, vgtif_reg(vgt_caps)) |= VGT_CAPS_GOP_SUPPORT;
+#endif
+
 	vgpu_vreg_t(vgpu, vgtif_reg(avail_rs.mappable_gmadr.base)) =
 		vgpu_aperture_gmadr_base(vgpu);
 	vgpu_vreg_t(vgpu, vgtif_reg(avail_rs.mappable_gmadr.size)) =
diff --git a/drivers/gpu/drm/i915/i915_pvinfo.h b/drivers/gpu/drm/i915/i915_pvinfo.h
index 683e97ac2430..217c9fca820d 100644
--- a/drivers/gpu/drm/i915/i915_pvinfo.h
+++ b/drivers/gpu/drm/i915/i915_pvinfo.h
@@ -48,6 +48,9 @@ enum vgt_g2v_type {
 	VGT_G2V_PPGTT_L4_PAGE_TABLE_DESTROY,
 	VGT_G2V_EXECLIST_CONTEXT_CREATE,
 	VGT_G2V_EXECLIST_CONTEXT_DESTROY,
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+	VGT_G2V_GOP_SETUP,
+#endif
 	VGT_G2V_MAX,
 };
 
@@ -57,6 +60,9 @@ enum vgt_g2v_type {
 #define VGT_CAPS_FULL_PPGTT		BIT(2)
 #define VGT_CAPS_HWSP_EMULATION		BIT(3)
 #define VGT_CAPS_HUGE_GTT		BIT(4)
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_ACRN_GVT)
+#define VGT_CAPS_GOP_SUPPORT		BIT(5)
+#endif
 
 struct vgt_if {
 	u64 magic;		/* VGT_MAGIC */
-- 
2.17.1

