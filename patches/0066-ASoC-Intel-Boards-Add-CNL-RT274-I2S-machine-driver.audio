From bbdd194ca48456b0c1a3af663d1b3964a119a628 Mon Sep 17 00:00:00 2001
From: Guneshwor Singh <guneshwor.o.singh@intel.com>
Date: Wed, 23 Nov 2016 19:05:46 +0530
Subject: [PATCH 066/154] ASoC: Intel: Boards: Add CNL RT274 I2S machine driver

Add the CNL I2S machine driver using Realtek ALC274 codec
in I2S mode.

Change-Id: Ife808f52d69e73a8156130c446a3ab0602fff63d
Signed-off-by: Guneshwor Singh <guneshwor.o.singh@intel.com>
Reviewed-on:
Reviewed-by: Kale, Sanyog R <sanyog.r.kale@intel.com>
Reviewed-by: Kp, Jeeja <jeeja.kp@intel.com>
Tested-by: Avati, Santosh Kumar <santosh.kumar.avati@intel.com>

ASoC: Intel: board: Add id_table in cnl_rt274

ICL and CNL use the same machine driver with rt274 codec.
Hence added id_table to facilitate this.

ASoC: Intel: board: Enable deepbuffer capture in cnl_rt274

ASoC: Intel: board: Add support for dynamic FE dai link in cnl_rt274 machine

FE dai links now come from topology, so remove them from machine driver.
Additionally register ops to initialize dai link. Rate constraint is
not required as rates will come from topology. So remove the startup
ops as well which sets the rate constraint.

ASoC: Intel: board: Add SSP0 codec-codec link

ASoC: Intel: boards: Remove SSP1-codec dai link from cnl_rt274 machine

Since NHLT does not have SSP1 endpoint, remove it from the dai link
definitions

ASoC: Intel: Boards: Replace codec to component in RT274 machine driver

As the framework is changed in kernel 4.17 version,
replace codec variable with component and use component specific
function to set jack.
---
 sound/soc/intel/boards/Kconfig     |  16 ++
 sound/soc/intel/boards/Makefile    |   2 +
 sound/soc/intel/boards/cnl_rt274.c | 293 +++++++++++++++++++++++++++++
 3 files changed, 311 insertions(+)
 create mode 100644 sound/soc/intel/boards/cnl_rt274.c

diff --git a/sound/soc/intel/boards/Kconfig b/sound/soc/intel/boards/Kconfig
index 5407d217228e..a0a4a1a58af7 100644
--- a/sound/soc/intel/boards/Kconfig
+++ b/sound/soc/intel/boards/Kconfig
@@ -370,6 +370,22 @@ config SND_SOC_INTEL_GLK_RT5682_MAX98357A_MACH
 
 endif ## SND_SOC_INTEL_GLK || (SND_SOC_SOF_GEMINILAKE  && SND_SOC_SOF_HDA_LINK)
 
+if SND_SOC_INTEL_CNL
+
+config SND_SOC_INTEL_CNL_RT274_MACH
+	tristate "Cannonlake with RT274 I2S mode"
+	depends on MFD_INTEL_LPSS && I2C && ACPI
+	select SND_SOC_RT274
+	select SND_SOC_DMIC
+	select SND_SOC_HDAC_HDMI
+	help
+	  This adds support for ASoC machine driver for Cannonlake platform
+	  with RT274 I2S audio codec.
+	  Say Y or m if you have such a device. This is a recommended option.
+	  If unsure select "N".
+
+endif ## SND_SOC_INTEL_CNL
+
 if SND_SOC_INTEL_SKYLAKE_HDAUDIO_CODEC || SND_SOC_SOF_HDA_AUDIO_CODEC
 
 config SND_SOC_INTEL_SKL_HDA_DSP_GENERIC_MACH
diff --git a/sound/soc/intel/boards/Makefile b/sound/soc/intel/boards/Makefile
index 451b3bd7d9c5..86195693a25b 100644
--- a/sound/soc/intel/boards/Makefile
+++ b/sound/soc/intel/boards/Makefile
@@ -26,6 +26,7 @@ snd-soc-skl_rt286-objs := skl_rt286.o
 snd-soc-skl_hda_dsp-objs := skl_hda_dsp_generic.o skl_hda_dsp_common.o
 snd-skl_nau88l25_max98357a-objs := skl_nau88l25_max98357a.o
 snd-soc-skl_nau88l25_ssm4567-objs := skl_nau88l25_ssm4567.o
+snd-soc-cnl-rt274-objs := cnl_rt274.o
 
 obj-$(CONFIG_SND_SOC_INTEL_SOF_RT5682_MACH) += snd-soc-sof_rt5682.o
 obj-$(CONFIG_SND_SOC_INTEL_HASWELL_MACH) += snd-soc-sst-haswell.o
@@ -54,3 +55,4 @@ obj-$(CONFIG_SND_SOC_INTEL_SKL_RT286_MACH) += snd-soc-skl_rt286.o
 obj-$(CONFIG_SND_SOC_INTEL_SKL_NAU88L25_MAX98357A_MACH) += snd-skl_nau88l25_max98357a.o
 obj-$(CONFIG_SND_SOC_INTEL_SKL_NAU88L25_SSM4567_MACH) += snd-soc-skl_nau88l25_ssm4567.o
 obj-$(CONFIG_SND_SOC_INTEL_SKL_HDA_DSP_GENERIC_MACH) += snd-soc-skl_hda_dsp.o
+obj-$(CONFIG_SND_SOC_INTEL_CNL_RT274_MACH) += snd-soc-cnl-rt274.o
diff --git a/sound/soc/intel/boards/cnl_rt274.c b/sound/soc/intel/boards/cnl_rt274.c
new file mode 100644
index 000000000000..a081a62d4d1f
--- /dev/null
+++ b/sound/soc/intel/boards/cnl_rt274.c
@@ -0,0 +1,293 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// cnl_rt274.c  --  ASOC Machine driver for CNL
+//
+// Copyright (C) 2016 Intel Corp
+// Author: Guneshwor Singh <guneshwor.o.singh@intel.com>
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/async.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/acpi.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include <linux/input.h>
+
+#include "../../codecs/rt274.h"
+
+static struct snd_soc_jack cnl_headset;
+
+/* Headset jack detection DAPM pins */
+static struct snd_soc_jack_pin cnl_headset_pins[] = {
+	{
+		.pin = "Mic Jack",
+		.mask = SND_JACK_MICROPHONE,
+	},
+	{
+		.pin = "Headphone Jack",
+		.mask = SND_JACK_HEADPHONE,
+	},
+};
+
+static const struct snd_kcontrol_new cnl_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Headphone Jack"),
+	SOC_DAPM_PIN_SWITCH("Mic Jack"),
+};
+
+static const struct snd_soc_dapm_widget cnl_rt274_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_MIC("Mic Jack", NULL),
+	SND_SOC_DAPM_MIC("SoC DMIC", NULL),
+};
+
+static const struct snd_soc_pcm_stream dai_params_codec = {
+	.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	.rate_min = 48000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 2,
+};
+
+static int cnl_dmic_fixup(struct snd_soc_pcm_runtime *rtd,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_interval *channels = hw_param_interval(params,
+						SNDRV_PCM_HW_PARAM_CHANNELS);
+	channels->min = channels->max = 2;
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_route cnl_map[] = {
+	{"Headphone Jack", NULL, "HPO Pin"},
+	{"MIC", NULL, "Mic Jack"},
+	{"DMic", NULL, "SoC DMIC"},
+	{"DMIC01 Rx", NULL, "Capture"},
+	{"dmic01_hifi", NULL, "DMIC01 Rx"},
+
+	/* ssp2 path */
+	{"Dummy Playback", NULL, "ssp2 Tx"},
+	{"ssp2 Tx", NULL, "ssp2_out"},
+
+	{"ssp2 Rx", NULL, "Dummy Capture"},
+	{"ssp2_in", NULL, "ssp2 Rx"},
+
+	/* ssp1 path */
+	{"Dummy Playback", NULL, "ssp1 Tx"},
+	{"ssp1 Tx", NULL, "ssp1_out"},
+
+	{"AIF1 Playback", NULL, "ssp0 Tx"},
+	{"ssp0 Tx", NULL, "codec1_out"},
+	{"ssp0 Tx", NULL, "codec0_out"},
+
+	{"ssp0 Rx", NULL, "AIF1 Capture"},
+	{"codec0_in", NULL, "ssp0 Rx"},
+};
+
+static int cnl_rt274_init(struct snd_soc_pcm_runtime *runtime)
+{
+	int ret;
+	struct snd_soc_component *component = runtime->codec_dai->component;
+	struct snd_soc_card *card = runtime->card;
+	struct snd_soc_dai *codec_dai = runtime->codec_dai;
+
+	ret = snd_soc_card_jack_new(runtime->card, "Headset",
+		SND_JACK_HEADSET, &cnl_headset,
+		cnl_headset_pins, ARRAY_SIZE(cnl_headset_pins));
+
+	if (ret)
+		return ret;
+
+	snd_soc_component_set_jack(component, &cnl_headset, NULL);
+
+	/* TDM 4 slots 24 bit, set Rx & Tx bitmask to 4 active slots */
+	ret = snd_soc_dai_set_tdm_slot(codec_dai, 0xF, 0xF, 4, 24);
+	if (ret < 0) {
+		dev_err(runtime->dev, "can't set codec pcm format %d\n", ret);
+		return ret;
+	}
+
+	card->dapm.idle_bias_off = true;
+
+	return 0;
+}
+
+static int cnl_be_fixup(struct snd_soc_pcm_runtime *rtd,
+			    struct snd_pcm_hw_params *params)
+{
+	struct snd_interval *rate = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval *channels = hw_param_interval(params,
+						SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	rate->min = rate->max = 48000;
+	channels->min = channels->max = 2;
+	snd_mask_none(hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT));
+	snd_mask_set(hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT),
+			(unsigned int __force)SNDRV_PCM_FORMAT_S24_LE);
+
+	return 0;
+}
+
+#define CNL_FREQ_OUT 19200000
+
+static int rt274_hw_params(struct snd_pcm_substream *substream,
+				   struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int ret, ratio = 100;
+
+	snd_soc_dai_set_bclk_ratio(codec_dai, ratio);
+
+	ret = snd_soc_dai_set_pll(codec_dai, 0, RT274_PLL2_S_BCLK,
+				  ratio * params_rate(params), CNL_FREQ_OUT);
+	if (ret != 0) {
+		dev_err(rtd->dev, "Failed to enable PLL2 with Ref Clock Loop: %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, RT274_SCLK_S_PLL2, CNL_FREQ_OUT,
+				     SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		dev_err(rtd->dev, "set codec sysclk failed: %d\n", ret);
+
+	return ret;
+}
+
+static struct snd_soc_ops rt274_ops = {
+	.hw_params = rt274_hw_params,
+};
+
+#if IS_ENABLED(CONFIG_SND_SOC_INTEL_CNL_FPGA)
+static const char pname[] = "0000:02:18.0";
+static const char cname[] = "rt274.0-001c";
+#else
+static const char pname[] = "0000:00:1f.3";
+static const char cname[] = "i2c-INT34C2:00";
+#endif
+
+static struct snd_soc_dai_link cnl_rt274_msic_dailink[] = {
+	/* back ends */
+	{
+		.name = "SSP0-Codec",
+		.id = 1,
+		.cpu_dai_name = "SSP0 Pin",
+		.codec_name = cname,
+		.codec_dai_name = "rt274-aif1",
+		.platform_name = pname,
+		.be_hw_params_fixup = cnl_be_fixup,
+		.ignore_suspend = 1,
+		.no_pcm = 1,
+		.dai_fmt = SND_SOC_DAIFMT_DSP_A |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS,
+		.dpcm_playback = 1,
+		.dpcm_capture = 1,
+		.init = cnl_rt274_init,
+		.ops = &rt274_ops,
+	},
+	{
+		.name = "dmic01",
+		.id = 2,
+		.cpu_dai_name = "DMIC01 Pin",
+		.codec_name = "dmic-codec",
+		.codec_dai_name = "dmic-hifi",
+		.platform_name = pname,
+		.ignore_suspend = 1,
+		.no_pcm = 1,
+		.dpcm_capture = 1,
+		.be_hw_params_fixup = cnl_dmic_fixup,
+	},
+	/* codec-codec link */
+	{
+		.name = "CNL SSP0-Loop Port",
+		.stream_name = "CNL SSP0-Loop",
+		.cpu_dai_name = "SSP0 Pin",
+		.platform_name = pname,
+		.codec_name = cname,
+		.codec_dai_name = "rt274-aif1",
+		.params = &dai_params_codec,
+		.dai_fmt = SND_SOC_DAIFMT_DSP_A |
+			SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+	},
+	/* Probe DAI links */
+	{
+		.name = "Compress Probe Playback",
+		.stream_name = "Probe Playback",
+		.cpu_dai_name = "Probe Injection0 CPU DAI",
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.platform_name = pname,
+		.init = NULL,
+		.ignore_suspend = 1,
+		.nonatomic = 1,
+	},
+	{
+		.name = "Compress Probe Capture",
+		.stream_name = "Probe Capture",
+		.cpu_dai_name = "Probe Extraction CPU DAI",
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.platform_name = pname,
+		.init = NULL,
+		.ignore_suspend = 1,
+		.nonatomic = 1,
+	},
+};
+
+static int
+cnl_add_dai_link(struct snd_soc_card *card, struct snd_soc_dai_link *link)
+{
+       link->platform_name = pname;
+       link->nonatomic = 1;
+
+       return 0;
+}
+
+/* SoC card */
+static struct snd_soc_card snd_soc_card_cnl = {
+	.name = "cnl-audio",
+	.dai_link = cnl_rt274_msic_dailink,
+	.num_links = ARRAY_SIZE(cnl_rt274_msic_dailink),
+	.dapm_widgets = cnl_rt274_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(cnl_rt274_widgets),
+	.dapm_routes = cnl_map,
+	.num_dapm_routes = ARRAY_SIZE(cnl_map),
+	.controls = cnl_controls,
+	.num_controls = ARRAY_SIZE(cnl_controls),
+	.add_dai_link = cnl_add_dai_link,
+};
+
+static int snd_cnl_rt274_mc_probe(struct platform_device *pdev)
+{
+	snd_soc_card_cnl.dev = &pdev->dev;
+	return devm_snd_soc_register_card(&pdev->dev, &snd_soc_card_cnl);
+}
+
+static const struct platform_device_id cnl_board_ids[] = {
+	{ .name = "cnl_rt274" },
+	{ }
+};
+
+static struct platform_driver snd_cnl_rt274_driver = {
+	.driver = {
+		.name = "cnl_rt274",
+		.pm = &snd_soc_pm_ops,
+	},
+	.probe = snd_cnl_rt274_mc_probe,
+	.id_table = cnl_board_ids,
+};
+
+module_platform_driver(snd_cnl_rt274_driver);
+
+MODULE_AUTHOR("Guneshwor Singh <guneshwor.o.singh@intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:cnl_rt274");
-- 
2.17.1

