From 202c5130d686fd34bef983b459095e0cd05ddce2 Mon Sep 17 00:00:00 2001
From: Voon Weifeng <weifeng.voon@intel.com>
Date: Thu, 7 Nov 2019 16:32:38 +0800
Subject: [PATCH 088/113] HOTFIX: net: stmmac: added phy ingress and egress
 path latency

Phy path latency will contribute to the total link path delay.
Hence, the actual tx hw timestamp will be the tx hw timestamp by MAC
subtract the phy tx path latency. On other hand, the actual rx hw timestamp
will be the rx hw timestamp by MAC add with the phy rx path latency.
The EHL new platform data phy path latency values are based on the
Marvell 88E1512 PHY.

Signed-off-by: Voon Weifeng <weifeng.voon@intel.com>
---
 .../net/ethernet/stmicro/stmmac/stmmac_main.c | 29 +++++++++++++++++++
 .../net/ethernet/stmicro/stmmac/stmmac_pci.c  |  8 +++++
 include/linux/stmmac.h                        |  7 +++++
 3 files changed, 44 insertions(+)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 3ee3d9a20c85..34cd8bca9dd1 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -421,6 +421,7 @@ static void stmmac_get_tx_hwtstamp(struct stmmac_priv *priv,
 {
 	struct skb_shared_hwtstamps shhwtstamp;
 	bool found = false;
+	u64 adjust = 0;
 	u64 ns = 0;
 
 	if (!priv->hwts_tx_en)
@@ -439,6 +440,19 @@ static void stmmac_get_tx_hwtstamp(struct stmmac_priv *priv,
 	}
 
 	if (found) {
+		switch (priv->speed) {
+		case SPEED_10:
+			adjust = priv->plat->phy_tx_latency_10;
+			break;
+		case SPEED_100:
+			adjust = priv->plat->phy_tx_latency_100;
+			break;
+		case SPEED_1000:
+			adjust = priv->plat->phy_tx_latency_1000;
+			break;
+		}
+
+		ns += adjust;
 		memset(&shhwtstamp, 0, sizeof(struct skb_shared_hwtstamps));
 		shhwtstamp.hwtstamp = ns_to_ktime(ns);
 
@@ -462,6 +476,7 @@ static void stmmac_get_rx_hwtstamp(struct stmmac_priv *priv, struct dma_desc *p,
 {
 	struct skb_shared_hwtstamps *shhwtstamp = NULL;
 	struct dma_desc *desc = p;
+	u64 adjust = 0;
 	u64 ns = 0;
 
 	if (!priv->hwts_rx_en)
@@ -473,6 +488,20 @@ static void stmmac_get_rx_hwtstamp(struct stmmac_priv *priv, struct dma_desc *p,
 	/* Check if timestamp is available */
 	if (stmmac_get_rx_timestamp_status(priv, p, np, priv->adv_ts)) {
 		stmmac_get_timestamp(priv, desc, priv->adv_ts, &ns);
+
+		switch (priv->speed) {
+		case SPEED_10:
+			adjust = priv->plat->phy_rx_latency_10;
+			break;
+		case SPEED_100:
+			adjust = priv->plat->phy_rx_latency_100;
+			break;
+		case SPEED_1000:
+			adjust = priv->plat->phy_rx_latency_1000;
+			break;
+		}
+
+		ns -= adjust;
 		netdev_dbg(priv->dev, "get valid RX hw timestamp %llu\n", ns);
 		shhwtstamp = skb_hwtstamps(skb);
 		memset(shhwtstamp, 0, sizeof(struct skb_shared_hwtstamps));
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
index b14a57fa29cf..080737107092 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -292,6 +292,14 @@ static int ehl_common_data(struct pci_dev *pdev,
 	plat->rx_queues_to_use = 8;
 	plat->tx_queues_to_use = 8;
 
+	/* TX and RX PHY latency (ns) */
+	plat->phy_tx_latency_10 = 6066;
+	plat->phy_tx_latency_100 = 657;
+	plat->phy_tx_latency_1000 = 224;
+	plat->phy_rx_latency_10 = 2130;
+	plat->phy_rx_latency_100 = 362;
+	plat->phy_rx_latency_1000 = 231;
+
 	ret = intel_mgbe_common_data(pdev, plat);
 	if (ret)
 		return ret;
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
index 936e4f3579f4..3e7b485e9852 100644
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -226,5 +226,12 @@ struct plat_stmmacenet_data {
 	bool has_safety_feat;
 	bool is_hfpga;
 	bool ehl_ao_wa;
+	/* TX and RX PHY latency (ns) */
+	u64 phy_tx_latency_1000;
+	u64 phy_tx_latency_100;
+	u64 phy_tx_latency_10;
+	u64 phy_rx_latency_1000;
+	u64 phy_rx_latency_100;
+	u64 phy_rx_latency_10;
 };
 #endif
-- 
2.17.1

