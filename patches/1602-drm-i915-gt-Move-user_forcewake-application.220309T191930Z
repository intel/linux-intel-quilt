From 6f24c1256204aa122222bf89c571355a8c62af53 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 1 Nov 2019 14:10:08 +0000
Subject: [PATCH 1602/4530] drm/i915/gt: Move user_forcewake application to GT

We already track the debugfs user_forcewake on the GT, so it is natural
to pull the suspend/resume handling under gt/ as well.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Reviewed-by: Andi Shyti <andi.shyti@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20191101141009.15581-3-chris@chris-wilson.co.uk
(cherry picked from commit 9ab3fe2d7dc39b088591b0121f041cbfd6bb1ef8)
Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
---
 drivers/gpu/drm/i915/gem/i915_gem_pm.c | 22 ----------------------
 drivers/gpu/drm/i915/gt/intel_gt_pm.c  | 22 ++++++++++++++++++++++
 2 files changed, 22 insertions(+), 22 deletions(-)

diff --git a/drivers/gpu/drm/i915/gem/i915_gem_pm.c b/drivers/gpu/drm/i915/gem/i915_gem_pm.c
index 64dd04ae3d57..6779ab34101b 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_pm.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_pm.c
@@ -11,24 +11,6 @@
 
 #include "i915_drv.h"
 
-static void user_forcewake(struct intel_gt *gt, bool suspend)
-{
-	int count = atomic_read(&gt->user_wakeref);
-
-	/* Inside suspend/resume so single threaded, no races to worry about. */
-	if (likely(!count))
-		return;
-
-	intel_gt_pm_get(gt);
-	if (suspend) {
-		GEM_BUG_ON(count > atomic_read(&gt->wakeref.count));
-		atomic_sub(count, &gt->wakeref.count);
-	} else {
-		atomic_add(count, &gt->wakeref.count);
-	}
-	intel_gt_pm_put(gt);
-}
-
 void i915_gem_suspend(struct drm_i915_private *i915)
 {
 	GEM_TRACE("\n");
@@ -36,8 +18,6 @@ void i915_gem_suspend(struct drm_i915_private *i915)
 	intel_wakeref_auto(&i915->ggtt.userfault_wakeref, 0);
 	flush_workqueue(i915->wq);
 
-	user_forcewake(&i915->gt, true);
-
 	/*
 	 * We have to flush all the executing contexts to main memory so
 	 * that they can saved in the hibernation image. To ensure the last
@@ -132,8 +112,6 @@ void i915_gem_resume(struct drm_i915_private *i915)
 	if (intel_gt_resume(&i915->gt))
 		goto err_wedged;
 
-	user_forcewake(&i915->gt, false);
-
 out_unlock:
 	intel_uncore_forcewake_put(&i915->uncore, FORCEWAKE_ALL);
 	return;
diff --git a/drivers/gpu/drm/i915/gt/intel_gt_pm.c b/drivers/gpu/drm/i915/gt/intel_gt_pm.c
index 1679f4f78d65..11661de8c40b 100644
--- a/drivers/gpu/drm/i915/gt/intel_gt_pm.c
+++ b/drivers/gpu/drm/i915/gt/intel_gt_pm.c
@@ -18,6 +18,24 @@
 #include "intel_rps.h"
 #include "intel_wakeref.h"
 
+static void user_forcewake(struct intel_gt *gt, bool suspend)
+{
+	int count = atomic_read(&gt->user_wakeref);
+
+	/* Inside suspend/resume so single threaded, no races to worry about. */
+	if (likely(!count))
+		return;
+
+	intel_gt_pm_get(gt);
+	if (suspend) {
+		GEM_BUG_ON(count > atomic_read(&gt->wakeref.count));
+		atomic_sub(count, &gt->wakeref.count);
+	} else {
+		atomic_add(count, &gt->wakeref.count);
+	}
+	intel_gt_pm_put(gt);
+}
+
 static int __gt_unpark(struct intel_wakeref *wf)
 {
 	struct intel_gt *gt = container_of(wf, typeof(*gt), wakeref);
@@ -210,6 +228,8 @@ int intel_gt_resume(struct intel_gt *gt)
 
 	intel_uc_resume(&gt->uc);
 
+	user_forcewake(gt, false);
+
 	intel_uncore_forcewake_put(gt->uncore, FORCEWAKE_ALL);
 	intel_gt_pm_put(gt);
 
@@ -233,6 +253,8 @@ void intel_gt_suspend(struct intel_gt *gt)
 {
 	intel_wakeref_t wakeref;
 
+	user_forcewake(gt, true);
+
 	/* We expect to be idle already; but also want to be independent */
 	wait_for_idle(gt);
 
-- 
2.17.1

