From b92c89a27378385dec09d084f1925c23936f7016 Mon Sep 17 00:00:00 2001
From: Fenghua Yu <fenghua.yu@intel.com>
Date: Tue, 13 Nov 2018 15:54:28 -0800
Subject: [PATCH 4/7] x86/bus_lock: Set rate limit for bus lock

A user can generate multiple bus locks to degrade the whole system
performance. To mitigate the issue, the kernel can set rate limit for bus
locks generated by the user (not just by the process) via a kernel
option:
	split_lock_detect=ratelimit:N
It limits bus lock rate to N per second for non-root users. The root
is rate limited for bus lock.

Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
---
 arch/x86/kernel/cpu/intel.c | 48 +++++++++++++++++++++++++++++++++++--
 1 file changed, 46 insertions(+), 2 deletions(-)

diff --git a/arch/x86/kernel/cpu/intel.c b/arch/x86/kernel/cpu/intel.c
index 750bc77dfe0f..781956e964cd 100644
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@ -10,6 +10,7 @@
 #include <linux/thread_info.h>
 #include <linux/init.h>
 #include <linux/uaccess.h>
+#include <linux/delay.h>
 
 #include <asm/cpufeature.h>
 #include <asm/msr.h>
@@ -41,6 +42,7 @@ enum split_lock_detect_state {
 	sld_off = 0,
 	sld_warn,
 	sld_fatal,
+	sld_ratelimit,
 };
 
 /*
@@ -997,13 +999,30 @@ static const struct {
 	{ "off",	sld_off   },
 	{ "warn",	sld_warn  },
 	{ "fatal",	sld_fatal },
+	{ "ratelimit:", sld_ratelimit },
 };
 
+static unsigned long bld_ratelimit __read_mostly;
+
 static inline bool match_option(const char *arg, int arglen, const char *opt)
 {
-	int len = strlen(opt);
+	int len = strlen(opt), ratelimit;
+
+	if (strncmp(arg, opt, len))
+		return false;
+
+	/*
+	 * Min ratelimit is 1 bus lock/sec.
+	 * Max ratelimit is 1000000 bus locks/sec.
+	 */
+	if (sscanf(arg, "ratelimit:%d", &ratelimit) == 1 &&
+	    ratelimit > 0 && ratelimit <= USEC_PER_SEC) {
+		bld_ratelimit = ratelimit;
 
-	return len == arglen && !strncmp(arg, opt, len);
+		return true;
+	}
+
+	return len == arglen;
 }
 
 static bool split_lock_verify_msr(bool on)
@@ -1082,6 +1101,15 @@ static void sld_update_msr(bool on)
 
 static void split_lock_init(void)
 {
+	/*
+	 * #DB for bus lock handles ratelimit and #AC for split lock is
+	 * disabled.
+	 */
+	if (sld_state == sld_ratelimit) {
+		split_lock_verify_msr(false);
+		return;
+	}
+
 	if (cpu_model_supports_sld)
 		split_lock_verify_msr(sld_state != sld_off);
 }
@@ -1118,6 +1146,8 @@ bool handle_guest_split_lock(unsigned long ip)
 }
 EXPORT_SYMBOL_GPL(handle_guest_split_lock);
 
+static struct ratelimit_state global_bld_ratelimit;
+
 static void bus_lock_init(void)
 {
 	u64 val;
@@ -1139,6 +1169,9 @@ static void bus_lock_init(void)
 	rdmsrl(MSR_IA32_DEBUGCTLMSR, val);
 	val |= DEBUGCTLMSR_BUS_LOCK_DETECT;
 	wrmsrl(MSR_IA32_DEBUGCTLMSR, val);
+
+	ratelimit_state_init(&global_bld_ratelimit, HZ, bld_ratelimit);
+	ratelimit_set_flags(&global_bld_ratelimit, RATELIMIT_MSG_ON_RELEASE);
 }
 
 bool handle_user_split_lock(struct pt_regs *regs, long error_code)
@@ -1161,6 +1194,13 @@ void handle_bus_lock(struct pt_regs *regs)
 	case sld_fatal:
 		force_sig_fault(SIGBUS, BUS_ADRALN, NULL);
 		break;
+	case sld_ratelimit:
+		/* Enforce no more than bld_ratelimit bus locks/sec. */
+		while (!__ratelimit(&global_bld_ratelimit)) {
+			usleep_range(USEC_PER_SEC / bld_ratelimit,
+				     USEC_PER_SEC / bld_ratelimit);
+		}
+		break;
 	}
 }
 
@@ -1259,6 +1299,10 @@ static void sld_state_show(void)
 				" from non-WB" : "");
 		}
 		break;
+	case sld_ratelimit:
+		if (boot_cpu_has(X86_FEATURE_BUS_LOCK_DETECT))
+			pr_info("#DB: setting rate limit to %lu/sec per user on non-root user-space bus_locks\n", bld_ratelimit);
+		break;
 	}
 }
 
-- 
2.27.0

