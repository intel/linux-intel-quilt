From 8e18a997f56fac783363aa3fa27c2a576fcdae31 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Noralf=20Tr=C3=B8nnes?= <noralf@tronnes.org>
Date: Fri, 19 Jul 2019 17:59:10 +0200
Subject: [PATCH 0785/1606] drm/tinydrm: Remove tinydrm_spi_max_transfer_size()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

spi-bcm2835 can handle >64kB buffers now so there is no need to check
->max_dma_len. The tinydrm_spi_max_transfer_size() max_len argument is
not used by any callers, so not needed.

Then we have the spi_max module parameter. It was added because
staging/fbtft has support for it and there was a report that someone used
it to set a small buffer size to avoid popping on a USB soundcard on a
Raspberry Pi. In hindsight it shouldn't have been added, I should have
waited for it to become a problem first. I don't know it anyone is
actually using it, but since tinydrm_spi_transfer() is being moved to
mipi-dbi, I'm taking the opportunity to remove it. I'll add it back to
mipi-dbi if someone complains.

With that out of the way, spi_max_transfer_size() can be used instead.

The chosen 16kB buffer size for Type C Option 1 (9-bit) interface is
somewhat arbitrary, but a bigger buffer will have a miniscule impact on
transfer speed, so it's probably fine.

Acked-by: Sam Ravnborg <sam@ravnborg.org>
Signed-off-by: Noralf Tr√∏nnes <noralf@tronnes.org>
Link: https://patchwork.freedesktop.org/patch/msgid/20190719155916.62465-6-noralf@tronnes.org
---
 .../gpu/drm/tinydrm/core/tinydrm-helpers.c    | 37 +------------------
 drivers/gpu/drm/tinydrm/mipi-dbi.c            | 10 +----
 include/drm/tinydrm/tinydrm-helpers.h         |  1 -
 3 files changed, 3 insertions(+), 45 deletions(-)

diff --git a/drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c b/drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c
index 272616a246cd..af5bec8861de 100644
--- a/drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c
+++ b/drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c
@@ -18,41 +18,8 @@
 #include <drm/drm_rect.h>
 #include <drm/tinydrm/tinydrm-helpers.h>
 
-static unsigned int spi_max;
-module_param(spi_max, uint, 0400);
-MODULE_PARM_DESC(spi_max, "Set a lower SPI max transfer size");
-
 #if IS_ENABLED(CONFIG_SPI)
 
-/**
- * tinydrm_spi_max_transfer_size - Determine max SPI transfer size
- * @spi: SPI device
- * @max_len: Maximum buffer size needed (optional)
- *
- * This function returns the maximum size to use for SPI transfers. It checks
- * the SPI master, the optional @max_len and the module parameter spi_max and
- * returns the smallest.
- *
- * Returns:
- * Maximum size for SPI transfers
- */
-size_t tinydrm_spi_max_transfer_size(struct spi_device *spi, size_t max_len)
-{
-	size_t ret;
-
-	ret = min(spi_max_transfer_size(spi), spi->master->max_dma_len);
-	if (max_len)
-		ret = min(ret, max_len);
-	if (spi_max)
-		ret = min_t(size_t, ret, spi_max);
-	ret &= ~0x3;
-	if (ret < 4)
-		ret = 4;
-
-	return ret;
-}
-EXPORT_SYMBOL(tinydrm_spi_max_transfer_size);
-
 /**
  * tinydrm_spi_transfer - SPI transfer helper
  * @spi: SPI device
@@ -75,21 +42,19 @@ int tinydrm_spi_transfer(struct spi_device *spi, u32 speed_hz,
 			 struct spi_transfer *header, u8 bpw, const void *buf,
 			 size_t len)
 {
+	size_t max_chunk = spi_max_transfer_size(spi);
 	struct spi_transfer tr = {
 		.bits_per_word = bpw,
 		.speed_hz = speed_hz,
 	};
 	struct spi_message m;
 	u16 *swap_buf = NULL;
-	size_t max_chunk;
 	size_t chunk;
 	int ret = 0;
 
 	if (WARN_ON_ONCE(bpw != 8 && bpw != 16))
 		return -EINVAL;
 
-	max_chunk = tinydrm_spi_max_transfer_size(spi, 0);
-
 	if (bpw == 16 && !spi_is_bpw_supported(spi, 16)) {
 		tr.bits_per_word = 8;
 		if (tinydrm_machine_little_endian()) {
diff --git a/drivers/gpu/drm/tinydrm/mipi-dbi.c b/drivers/gpu/drm/tinydrm/mipi-dbi.c
index 99509d16b037..ae31a5c9aa1b 100644
--- a/drivers/gpu/drm/tinydrm/mipi-dbi.c
+++ b/drivers/gpu/drm/tinydrm/mipi-dbi.c
@@ -964,15 +964,9 @@ static int mipi_dbi_typec3_command(struct mipi_dbi *mipi, u8 *cmd,
 int mipi_dbi_spi_init(struct spi_device *spi, struct mipi_dbi *mipi,
 		      struct gpio_desc *dc)
 {
-	size_t tx_size = tinydrm_spi_max_transfer_size(spi, 0);
 	struct device *dev = &spi->dev;
 	int ret;
 
-	if (tx_size < 16) {
-		DRM_ERROR("SPI transmit buffer too small: %zu\n", tx_size);
-		return -EINVAL;
-	}
-
 	/*
 	 * Even though it's not the SPI device that does DMA (the master does),
 	 * the dma mask is necessary for the dma_alloc_wc() in
@@ -1001,8 +995,8 @@ int mipi_dbi_spi_init(struct spi_device *spi, struct mipi_dbi *mipi,
 			mipi->swap_bytes = true;
 	} else {
 		mipi->command = mipi_dbi_typec1_command;
-		mipi->tx_buf9_len = tx_size;
-		mipi->tx_buf9 = devm_kmalloc(dev, tx_size, GFP_KERNEL);
+		mipi->tx_buf9_len = SZ_16K;
+		mipi->tx_buf9 = devm_kmalloc(dev, mipi->tx_buf9_len, GFP_KERNEL);
 		if (!mipi->tx_buf9)
 			return -ENOMEM;
 	}
diff --git a/include/drm/tinydrm/tinydrm-helpers.h b/include/drm/tinydrm/tinydrm-helpers.h
index dca75de3a359..10b35375a009 100644
--- a/include/drm/tinydrm/tinydrm-helpers.h
+++ b/include/drm/tinydrm/tinydrm-helpers.h
@@ -41,7 +41,6 @@ int tinydrm_display_pipe_init(struct drm_device *drm,
 			      const struct drm_display_mode *mode,
 			      unsigned int rotation);
 
-size_t tinydrm_spi_max_transfer_size(struct spi_device *spi, size_t max_len);
 int tinydrm_spi_transfer(struct spi_device *spi, u32 speed_hz,
 			 struct spi_transfer *header, u8 bpw, const void *buf,
 			 size_t len);
-- 
2.17.1

