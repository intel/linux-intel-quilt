From 96be1aead23b739c0b2913296b1d5adb0e23d752 Mon Sep 17 00:00:00 2001
From: "Vineetha G. Jaya Kumaran" <vineetha.g.jaya.kumaran@intel.com>
Date: Sun, 24 May 2020 19:30:58 +0800
Subject: [PATCH 06/27] net: phy: add callback for custom EEE configuration to
 struct phy_driver

This callback can be used if the generic EEE configuration flow
cannot be used for a particular PHY device.

Signed-off-by: Vineetha G. Jaya Kumaran <vineetha.g.jaya.kumaran@intel.com>
---
 drivers/net/phy/intel-gpy.c | 35 +++++++++++++++++++++++++++++++++++
 drivers/net/phy/phy.c       |  3 +++
 include/linux/phy.h         |  3 +++
 3 files changed, 41 insertions(+)

diff --git a/drivers/net/phy/intel-gpy.c b/drivers/net/phy/intel-gpy.c
index 3420129de18a..03b1a41cb3a7 100644
--- a/drivers/net/phy/intel-gpy.c
+++ b/drivers/net/phy/intel-gpy.c
@@ -41,6 +41,40 @@
 /* WA for Q-SPEC GPY115 PHY ID */
 #define INTEL_PHY_ID_GPY115_C22		0x67C9DE00
 
+static int gpy_set_eee(struct phy_device *phydev, struct ethtool_eee *data)
+{
+	int cap, old_adv, adv = 0, ret;
+
+	cap = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);
+	if (cap < 0)
+		return cap;
+
+	old_adv = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV);
+	if (old_adv < 0)
+		return old_adv;
+
+	if (data->eee_enabled) {
+		adv = !data->advertised ? cap :
+		      ethtool_adv_to_mmd_eee_adv_t(data->advertised) & cap;
+		adv &= ~phydev->eee_broken_modes;
+	}
+
+	if (old_adv != adv) {
+		ret = phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, adv);
+		if (ret < 0)
+			return ret;
+
+		/* C45 access to restart autonegotiation is not supported
+		 * in the GPY PHYs, hence use C22 access for this.
+		 */
+		ret = genphy_restart_aneg(phydev);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
 static int gpy_soft_reset(struct phy_device *phydev)
 {
 	int ret;
@@ -290,6 +324,7 @@ static struct phy_driver intel_gpy_drivers[] = {
 		.name		= "INTEL(R) Ethernet Network Connection GPY",
 		.get_features	= genphy_c45_pma_read_abilities,
 		.aneg_done	= genphy_c45_aneg_done,
+		.set_eee	= gpy_set_eee,
 		.soft_reset	= gpy_soft_reset,
 		.ack_interrupt	= gpy_ack_interrupt,
 		.did_interrupt	= gpy_did_interrupt,
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index a8d06d8b0e55..554a99ec569e 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -1137,6 +1137,9 @@ int phy_ethtool_set_eee(struct phy_device *phydev, struct ethtool_eee *data)
 	if (!phydev->drv)
 		return -EIO;
 
+	if (phydev->drv->set_eee)
+		return phydev->drv->set_eee(phydev, data);
+
 	/* Get Supported EEE */
 	cap = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);
 	if (cap < 0)
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 2ea8640492c9..8f326c312295 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -631,6 +631,9 @@ struct phy_driver {
 			    struct ethtool_tunable *tuna,
 			    const void *data);
 	int (*set_loopback)(struct phy_device *dev, bool enable);
+
+	/* Set EEE properties */
+	int (*set_eee)(struct phy_device *phydev, struct ethtool_eee *data);
 };
 #define to_phy_driver(d) container_of(to_mdio_common_driver(d),		\
 				      struct phy_driver, mdiodrv)
-- 
2.17.1

