From d75c278ffb870d5649111561804f5596e5bff152 Mon Sep 17 00:00:00 2001
From: florent pirou <florent.pirou@intel.com>
Date: Thu, 30 May 2024 03:26:34 -0700
Subject: [PATCH 07/20] Revert "spi: Remove unused function
 spi_busnum_to_master()"

This reverts commit bdc7ca008e1f5539e891187032cb2cbbc3decb5e.

Signed-off-by: florent pirou <florent.pirou@intel.com>
---
 Documentation/spi/spi-summary.rst |  8 +++++++
 drivers/spi/spi.c                 | 35 +++++++++++++++++++++++++++++++
 include/linux/spi/spi.h           |  1 +
 3 files changed, 44 insertions(+)

diff --git a/Documentation/spi/spi-summary.rst b/Documentation/spi/spi-summary.rst
index 6e21e6f86912..6dafcec7f171 100644
--- a/Documentation/spi/spi-summary.rst
+++ b/Documentation/spi/spi-summary.rst
@@ -333,6 +333,14 @@ certainly includes SPI devices hooked up through the card connectors!
 Non-static Configurations
 ^^^^^^^^^^^^^^^^^^^^^^^^^
 
+Developer boards often play by different rules than product boards, and one
+example is the potential need to hotplug SPI devices and/or controllers.
+
+For those cases you might need to use spi_busnum_to_master() to look
+up the spi bus master, and will likely need spi_new_device() to provide the
+board info based on the board that was hotplugged.  Of course, you'd later
+call at least spi_unregister_device() when that board is removed.
+
 When Linux includes support for MMC/SD/SDIO/DataFlash cards through SPI, those
 configurations will also be dynamic.  Fortunately, such devices all support
 basic device identification probes, so they should hotplug normally.
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 26db9c13310f..553ae41a7a03 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3505,6 +3505,41 @@ static inline void __spi_mark_suspended(struct spi_controller *ctlr)
 	mutex_unlock(&ctlr->bus_lock_mutex);
 }
 
+static int __spi_controller_match(struct device *dev, const void *data)
+{
+	struct spi_controller *ctlr;
+	const u16 *bus_num = data;
+
+	ctlr = container_of(dev, struct spi_controller, dev);
+	return ctlr->bus_num == *bus_num;
+}
+
+/**
+ * spi_busnum_to_master - look up master associated with bus_num
+ * @bus_num: the master's bus number
+ * Context: can sleep
+ *
+ * This call may be used with devices that are registered after
+ * arch init time.  It returns a refcounted pointer to the relevant
+ * spi_controller (which the caller must release), or NULL if there is
+ * no such master registered.
+ *
+ * Return: the SPI master structure on success, else NULL.
+ */
+struct spi_controller *spi_busnum_to_master(u16 bus_num)
+{
+	struct device		*dev;
+	struct spi_controller	*ctlr = NULL;
+
+	dev = class_find_device(&spi_master_class, NULL, &bus_num,
+				__spi_controller_match);
+	if (dev)
+		ctlr = container_of(dev, struct spi_controller, dev);
+	/* reference got in class_find_device */
+	return ctlr;
+}
+EXPORT_SYMBOL_GPL(spi_busnum_to_master);
+
 static inline void __spi_mark_resumed(struct spi_controller *ctlr)
 {
 	mutex_lock(&ctlr->bus_lock_mutex);
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 9820a3d3b699..8b4db5de47b3 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -916,6 +916,7 @@ static inline int acpi_spi_count_resources(struct acpi_device *adev)
 	return 0;
 }
 #endif
+extern struct spi_controller *spi_busnum_to_master(u16 busnum);
 
 /*
  * SPI resource management while processing a SPI message
-- 
2.34.1

