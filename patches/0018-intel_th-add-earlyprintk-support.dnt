From acb5f251fc0d573342d40eae45cfb11e6ab5f576 Mon Sep 17 00:00:00 2001
From: Yann Fouassier <yann.fouassier@intel.com>
Date: Fri, 29 May 2015 11:12:35 +0200
Subject: [PATCH 18/62] intel_th: add earlyprintk support

Enable trace hub earlyprintk with cmdline parameter. Specify the
software trace hub bar address and channel:
    earlyprintk=intelth,0x<sw_bar>:<chan>[,keep].

Signed-off-by: Yann Fouassier <yann.fouassier@intel.com>
Signed-off-by: Laurent FERT <laurent.fert@intel.com>
Signed-off-by: Tian, Baofeng
---
 arch/x86/include/asm/early_intel_th.h     | 20 +++++
 arch/x86/kernel/early_printk.c            |  7 ++
 drivers/hwtracing/intel_th/Kconfig        | 11 +++
 drivers/hwtracing/intel_th/Makefile       |  3 +
 drivers/hwtracing/intel_th/early_printk.c | 98 +++++++++++++++++++++++
 5 files changed, 139 insertions(+)
 create mode 100644 arch/x86/include/asm/early_intel_th.h
 create mode 100644 drivers/hwtracing/intel_th/early_printk.c

diff --git a/arch/x86/include/asm/early_intel_th.h b/arch/x86/include/asm/early_intel_th.h
new file mode 100644
index 000000000000..bf93609995c8
--- /dev/null
+++ b/arch/x86/include/asm/early_intel_th.h
@@ -0,0 +1,20 @@
+/*
+ * early_intel_th.h: Intel Trace Hub early printk
+ *
+ * (C) Copyright 2015 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _ASM_X86_EARLY_INTEL_TH_H
+#define _ASM_X86_EARLY_INTEL_TH_H
+
+#ifdef CONFIG_INTEL_TH_EARLY_PRINTK
+extern struct console intel_th_early_console;
+extern void early_intel_th_init(const char *);
+#endif /* CONFIG_INTEL_TH_EARLY_PRINTK */
+
+#endif /* _ASM_X86_EARLY_INTEL_TH_H */
+
diff --git a/arch/x86/kernel/early_printk.c b/arch/x86/kernel/early_printk.c
index 5e801c8c8ce7..f65d32c7040c 100644
--- a/arch/x86/kernel/early_printk.c
+++ b/arch/x86/kernel/early_printk.c
@@ -22,6 +22,7 @@
 #include <linux/efi.h>
 #include <asm/efi.h>
 #include <asm/pci_x86.h>
+#include <asm/early_intel_th.h>
 
 /* Simple VGA output */
 #define VGABASE		(__ISA_IO_base + 0xb8000)
@@ -387,6 +388,12 @@ static int __init setup_early_printk(char *buf)
 		if (!strncmp(buf, "xdbc", 4))
 			early_xdbc_parse_parameter(buf + 4);
 #endif
+#ifdef CONFIG_INTEL_TH_EARLY_PRINTK
+		if (!strncmp(buf, "intelth", 7)) {
+			early_intel_th_init(buf + 7);
+			early_console_register(&intel_th_early_console, keep);
+		}
+#endif
 
 		buf++;
 	}
diff --git a/drivers/hwtracing/intel_th/Kconfig b/drivers/hwtracing/intel_th/Kconfig
index ca0527d588e9..4fdf936dc04b 100644
--- a/drivers/hwtracing/intel_th/Kconfig
+++ b/drivers/hwtracing/intel_th/Kconfig
@@ -82,4 +82,15 @@ config INTEL_TH_DEBUG
 	help
 	  Say Y here to enable debugging.
 
+config INTEL_TH_EARLY_PRINTK
+	bool "Intel TH early printk console"
+	depends on INTEL_TH=y
+	default n
+	---help---
+	  Enables early printk console.
+	  When the early printk console is enabled in the kernel
+	  command line, kernel log messages are sent to Intel TH
+	  (hence they are aggregated with the other trace messages
+	  from the platform).
+
 endif
diff --git a/drivers/hwtracing/intel_th/Makefile b/drivers/hwtracing/intel_th/Makefile
index d9252fa8d9ca..d72530116664 100644
--- a/drivers/hwtracing/intel_th/Makefile
+++ b/drivers/hwtracing/intel_th/Makefile
@@ -20,3 +20,6 @@ intel_th_msu-y			:= msu.o
 
 obj-$(CONFIG_INTEL_TH_PTI)	+= intel_th_pti.o
 intel_th_pti-y			:= pti.o
+
+obj-$(CONFIG_INTEL_TH_EARLY_PRINTK) += intel_th_early_printk.o
+intel_th_early_printk-y		:= early_printk.o
\ No newline at end of file
diff --git a/drivers/hwtracing/intel_th/early_printk.c b/drivers/hwtracing/intel_th/early_printk.c
new file mode 100644
index 000000000000..bbcb9f89161d
--- /dev/null
+++ b/drivers/hwtracing/intel_th/early_printk.c
@@ -0,0 +1,98 @@
+#include <linux/console.h>
+#include <asm/fixmap.h>
+#include <asm/early_intel_th.h>
+#include "sth.h"
+
+static unsigned long sth_phys_addr;
+
+void early_intel_th_init(const char *s)
+{
+	size_t n;
+	unsigned long addr, chan;
+	char buf[32] = {0, };
+	char *match, *next;
+
+	/* Expect ,0x<sw_bar>:<channel>[,keep] */
+	if (*s == ',')
+		++s;
+	if (strncmp(s, "0x", 2))
+		goto fail;
+
+	n = strcspn(s, ",");
+	if (n > sizeof(buf) - 1)
+		goto fail;
+	strncpy(buf, s, n);
+	next = buf;
+
+	/* Get sw_bar */
+	match = strsep(&next, ":");
+	if (!match)
+		goto fail;
+
+	if (kstrtoul(match, 16, &addr))
+		goto fail;
+
+	/* Get channel */
+	if (kstrtoul(next, 0, &chan))
+		goto fail;
+
+	sth_phys_addr = addr + chan * sizeof(struct intel_th_channel);
+	return;
+
+fail:
+	pr_err("%s invalid parameter %s", __func__, s);
+}
+
+static void intel_th_early_write(struct console *con, const char *buf,
+				 unsigned len)
+{
+	struct intel_th_channel *channel;
+	const u8 *p = buf;
+	const u32 sven_header = 0x01000242;
+
+	if (WARN_ON_ONCE(!sth_phys_addr))
+		return;
+
+	/* Software can send messages to Intel TH by writing to an MMIO space
+	 * that is divided in several Master/Channel regions.
+	 * Write directly to the address provided through the cmdline.
+	 */
+	set_fixmap_nocache(FIX_EARLYCON_MEM_BASE, sth_phys_addr);
+	channel = (struct intel_th_channel *)
+		(__fix_to_virt(FIX_EARLYCON_MEM_BASE) +
+		 (sth_phys_addr & (PAGE_SIZE - 1)));
+
+	/* Add hardcoded SVEN header
+	 *  type: DEBUG_STRING
+	 *  severity: SVEN_SEVERITY_NORMAL
+	 *  length: payload size
+	 *  subtype: SVEN_DEBUGSTR_Generic
+	 */
+	iowrite32(sven_header, &channel->DnTS);
+	iowrite16(len, &channel->Dn);
+
+	while (len) {
+		if (len >= 4) {
+			iowrite32(*(u32 *)p, &channel->Dn);
+			p += 4;
+			len -= 4;
+		} else if (len >= 2) {
+			iowrite16(*(u16 *)p, &channel->Dn);
+			p += 2;
+			len -= 2;
+		} else {
+			iowrite8(*(u8 *)p, &channel->Dn);
+			p += 1;
+			len -= 1;
+		}
+	}
+
+	iowrite32(0, &channel->FLAG);
+}
+
+struct console intel_th_early_console = {
+	.name = "earlyintelth",
+	.write = intel_th_early_write,
+	.flags = CON_PRINTBUFFER,
+	.index = -1,
+};
-- 
2.19.1

