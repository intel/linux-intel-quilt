From cc5a4076fa5d06a42d04e47862f7edc07ccfbc64 Mon Sep 17 00:00:00 2001
From: "Wong, Vincent Por Yin" <vincent.por.yin.wong@intel.com>
Date: Sat, 10 Aug 2019 21:11:03 +0800
Subject: [PATCH 102/104] net: xdp: add per-packet time-based scheduling
 support for stmmac

- Enable per-packet transmit timestamp specification in xdp_desc using
stmmac driver as the first supported driver

Signed-off-by: Wong, Vincent Por Yin <vincent.por.yin.wong@intel.com>
---
 drivers/net/ethernet/stmicro/stmmac/stmmac.h  |  4 +-
 .../net/ethernet/stmicro/stmmac/stmmac_main.c |  8 +--
 .../net/ethernet/stmicro/stmmac/stmmac_xsk.c  |  7 ++
 include/uapi/linux/if_xdp.h                   |  1 +
 samples/bpf/xdpsock_user.c                    | 66 ++++++++++++++++++-
 5 files changed, 79 insertions(+), 7 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index d7e331c9f222..2849a899e8a3 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -312,7 +312,9 @@ void stmmac_txrx_ring_enable(struct stmmac_priv *priv, u16 qid);
 void stmmac_txrx_ring_disable(struct stmmac_priv *priv, u16 qid);
 void stmmac_free_tx_buffer(struct stmmac_priv *priv, u32 queue, int i);
 int stmmac_xsk_async_xmit(struct net_device *dev, u32 qid);
-
+/* Forward declaration */
+int stmmac_set_tbs_launchtime(struct stmmac_priv *priv, struct dma_desc *desc,
+			      u64 txtime);
 #if IS_ENABLED(CONFIG_STMMAC_SELFTESTS)
 void stmmac_selftest_run(struct net_device *dev,
 			 struct ethtool_test *etest, u64 *buf);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index a3d2bfeeee6f..a107c2c6255f 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -2841,13 +2841,13 @@ static void stmmac_configure_cbs(struct stmmac_priv *priv)
 	}
 }
 
-static int stmmac_set_tbs_launchtime(struct stmmac_priv *priv,
-				     struct dma_desc *desc,
-				     u64 tx_time)
+int stmmac_set_tbs_launchtime(struct stmmac_priv *priv,
+			      struct dma_desc *desc,
+			      u64 tx_time)
 {
 	struct dma_enhanced_tx_desc *enhtxdesc;
 	u32 launchtime_ns;
-	u8 launchtime_s;
+	u32 launchtime_s;
 
 	enhtxdesc = container_of(desc, struct dma_enhanced_tx_desc, basic);
 	launchtime_ns = do_div(tx_time, NSEC_PER_SEC);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
index 09c29f174946..7b151b5d5fcc 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
@@ -708,6 +708,13 @@ bool stmmac_xdp_xmit_zc(struct stmmac_tx_queue *tx_q, unsigned int budget)
 
 		stmmac_set_desc_addr(priv, tx_desc, dma);
 
+		if (stmmac_enabled_xdp(priv) && desc.txtime > 0) {
+			if (stmmac_set_tbs_launchtime(priv, tx_desc,
+						      desc.txtime)) {
+				netdev_warn(priv->dev, "Launch time setting failed\n");
+			}
+		}
+
 		/* Prepare the descriptor and set the own bit too */
 		stmmac_prepare_tx_desc(priv,
 				       tx_desc,
diff --git a/include/uapi/linux/if_xdp.h b/include/uapi/linux/if_xdp.h
index faaa5ca2a117..8457121f0f99 100644
--- a/include/uapi/linux/if_xdp.h
+++ b/include/uapi/linux/if_xdp.h
@@ -79,6 +79,7 @@ struct xdp_desc {
 	__u64 addr;
 	__u32 len;
 	__u32 options;
+	__u64 txtime;
 };
 
 /* UMEM descriptor is __u64 */
diff --git a/samples/bpf/xdpsock_user.c b/samples/bpf/xdpsock_user.c
index 93eaaf7239b2..04f08762a34f 100644
--- a/samples/bpf/xdpsock_user.c
+++ b/samples/bpf/xdpsock_user.c
@@ -67,6 +67,8 @@ static int opt_ifindex;
 static int opt_queue;
 static int opt_poll;
 static int opt_interval = 1;
+static int opt_txtime;
+static int opt_period_ns = 250000;
 static u32 opt_xdp_bind_flags;
 static int opt_xsk_frame_size = XSK_UMEM__DEFAULT_FRAME_SIZE;
 static __u32 prog_id;
@@ -352,6 +354,8 @@ static struct option long_options[] = {
 	{"zero-copy", no_argument, 0, 'z'},
 	{"copy", no_argument, 0, 'c'},
 	{"frame-size", required_argument, 0, 'f'},
+	{"txtime", no_argument, 0, 'T'},
+	{"period_ns", required_argument, 0, 'P'},
 	{0, 0, 0, 0}
 };
 
@@ -372,6 +376,8 @@ static void usage(const char *prog)
 		"  -z, --zero-copy      Force zero-copy mode.\n"
 		"  -c, --copy           Force copy mode.\n"
 		"  -f, --frame-size=n   Set the frame size (must be a power of two, default is %d).\n"
+		"  -T, --txtime		Specify transmit time in each packet\n"
+		"  -P, --period_ns=n	Set transmit time period (default 250us)\n"
 		"\n";
 	fprintf(stderr, str, prog, XSK_UMEM__DEFAULT_FRAME_SIZE);
 	exit(EXIT_FAILURE);
@@ -384,7 +390,7 @@ static void parse_command_line(int argc, char **argv)
 	opterr = 0;
 
 	for (;;) {
-		c = getopt_long(argc, argv, "Frtli:q:psSNn:czf:", long_options,
+		c = getopt_long(argc, argv, "FrtTli:q:psSNn:czf:", long_options,
 				&option_index);
 		if (c == -1)
 			break;
@@ -430,6 +436,12 @@ static void parse_command_line(int argc, char **argv)
 		case 'f':
 			opt_xsk_frame_size = atoi(optarg);
 			break;
+		case 'T':
+			opt_txtime = 1;
+			break;
+		case 'P':
+			opt_period_ns = atoi(optarg);
+			break;
 		default:
 			usage(basename(argv[0]));
 		}
@@ -571,17 +583,49 @@ static void rx_drop_all(void)
 	}
 }
 
+/* Get the current time and convert to nanoseconds */
+static u64 get_time_nanosec(clockid_t clkid)
+{
+	struct timespec now;
+
+	clock_gettime(clkid, &now);
+	return now.tv_sec * 1000000000 + now.tv_nsec;
+}
+
+/* Get the current time in seconds */
+static u64 get_time_sec(clockid_t clkid)
+{
+	struct timespec now;
+
+	clock_gettime(clkid, &now);
+	return now.tv_sec * 1000000000;
+}
+
+static u64 txtime_curtime_delta(u64 txtime, clockid_t clkid)
+{
+	u64 curtime;
+
+	curtime = get_time_nanosec(clkid);
+	return (txtime - curtime);
+}
+
 static void tx_only(struct xsk_socket_info *xsk)
 {
 	int timeout, ret, nfds = 1;
 	struct pollfd fds[nfds + 1];
 	u32 idx, frame_nb = 0;
+	u64 tx_timestamp = 0;
 
 	memset(fds, 0, sizeof(fds));
 	fds[0].fd = xsk_socket__fd(xsk->xsk);
 	fds[0].events = POLLOUT;
 	timeout = 1000; /* 1sn */
 
+	if (opt_txtime) {
+		/* Initialize the first packet to 0.5s to the future*/
+		tx_timestamp = get_time_sec(CLOCK_TAI) + 500000000;
+	}
+
 	for (;;) {
 		if (opt_poll) {
 			ret = poll(fds, nfds, timeout);
@@ -594,13 +638,31 @@ static void tx_only(struct xsk_socket_info *xsk)
 
 		if (xsk_ring_prod__reserve(&xsk->tx, BATCH_SIZE, &idx) ==
 		    BATCH_SIZE) {
-			unsigned int i;
+			unsigned int i, j;
 
 			for (i = 0; i < BATCH_SIZE; i++) {
 				xsk_ring_prod__tx_desc(&xsk->tx, idx + i)->addr
 					= (frame_nb + i) * opt_xsk_frame_size;
 				xsk_ring_prod__tx_desc(&xsk->tx, idx + i)->len =
 					sizeof(pkt_data) - 1;
+
+				j = idx + i;
+
+				if (opt_txtime) {
+					tx_timestamp += opt_period_ns;
+
+					/* Don't transmit beyond 3 seconds */
+					if (txtime_curtime_delta(tx_timestamp,
+								 CLOCK_TAI)
+						> 3000000000)
+						return;
+
+					xsk_ring_prod__tx_desc(&xsk->tx, j)
+						->txtime = tx_timestamp;
+				} else {
+					xsk_ring_prod__tx_desc(&xsk->tx, j)
+						->txtime = 0;
+				}
 			}
 
 			xsk_ring_prod__submit(&xsk->tx, BATCH_SIZE);
-- 
2.17.1

