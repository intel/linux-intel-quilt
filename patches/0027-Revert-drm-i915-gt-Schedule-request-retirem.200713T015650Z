From 89e6c056f3076641486519375f7bf280bf833223 Mon Sep 17 00:00:00 2001
From: Junxiao Chang <junxiao.chang@intel.com>
Date: Mon, 13 Jul 2020 11:15:57 +0800
Subject: [PATCH 27/27] Revert "drm/i915/gt: Schedule request retirement when
 timeline idles"

This reverts commit e1b7653ddbd129f0ab56088784d69a26d86a18c9.

Signed-off-by: Junxiao Chang <junxiao.chang@intel.com>
---
 drivers/gpu/drm/i915/gt/intel_engine_cs.c     |  8 +-
 drivers/gpu/drm/i915/gt/intel_engine_types.h  |  8 --
 drivers/gpu/drm/i915/gt/intel_gt_requests.c   | 75 -------------------
 drivers/gpu/drm/i915/gt/intel_gt_requests.h   |  7 --
 drivers/gpu/drm/i915/gt/intel_lrc.c           |  9 ---
 drivers/gpu/drm/i915/gt/intel_timeline.c      |  1 -
 .../gpu/drm/i915/gt/intel_timeline_types.h    |  3 -
 7 files changed, 3 insertions(+), 108 deletions(-)

diff --git a/drivers/gpu/drm/i915/gt/intel_engine_cs.c b/drivers/gpu/drm/i915/gt/intel_engine_cs.c
index f7ce232d0bc7..f8113bc756c6 100644
--- a/drivers/gpu/drm/i915/gt/intel_engine_cs.c
+++ b/drivers/gpu/drm/i915/gt/intel_engine_cs.c
@@ -28,13 +28,13 @@
 
 #include "i915_drv.h"
 
-#include "intel_context.h"
+#include "gt/intel_gt.h"
+
 #include "intel_engine.h"
 #include "intel_engine_pm.h"
 #include "intel_engine_pool.h"
 #include "intel_engine_user.h"
-#include "intel_gt.h"
-#include "intel_gt_requests.h"
+#include "intel_context.h"
 #include "intel_lrc.h"
 #include "intel_reset.h"
 #include "intel_ring.h"
@@ -616,7 +616,6 @@ static int intel_engine_setup_common(struct intel_engine_cs *engine)
 	intel_engine_init_execlists(engine);
 	intel_engine_init_cmd_parser(engine);
 	intel_engine_init__pm(engine);
-	intel_engine_init_retire(engine);
 
 	intel_engine_pool_init(&engine->pool);
 
@@ -839,7 +838,6 @@ void intel_engine_cleanup_common(struct intel_engine_cs *engine)
 
 	cleanup_status_page(engine);
 
-	intel_engine_fini_retire(engine);
 	intel_engine_pool_fini(&engine->pool);
 	intel_engine_fini_breadcrumbs(engine);
 	intel_engine_cleanup_cmd_parser(engine);
diff --git a/drivers/gpu/drm/i915/gt/intel_engine_types.h b/drivers/gpu/drm/i915/gt/intel_engine_types.h
index 58db78e2bf81..1e03d2433747 100644
--- a/drivers/gpu/drm/i915/gt/intel_engine_types.h
+++ b/drivers/gpu/drm/i915/gt/intel_engine_types.h
@@ -451,14 +451,6 @@ struct intel_engine_cs {
 
 	struct intel_engine_execlists execlists;
 
-	/*
-	 * Keep track of completed timelines on this engine for early
-	 * retirement with the goal of quickly enabling powersaving as
-	 * soon as the engine is idle.
-	 */
-	struct intel_timeline *retire;
-	struct work_struct retire_work;
-
 	/* status_notifier: list of callbacks for context-switch changes */
 	struct atomic_notifier_head context_status_notifier;
 
diff --git a/drivers/gpu/drm/i915/gt/intel_gt_requests.c b/drivers/gpu/drm/i915/gt/intel_gt_requests.c
index 32a8dddfa787..b73229a84d85 100644
--- a/drivers/gpu/drm/i915/gt/intel_gt_requests.c
+++ b/drivers/gpu/drm/i915/gt/intel_gt_requests.c
@@ -4,8 +4,6 @@
  * Copyright Â© 2019 Intel Corporation
  */
 
-#include <linux/workqueue.h>
-
 #include "i915_drv.h" /* for_each_engine() */
 #include "i915_request.h"
 #include "intel_gt.h"
@@ -31,79 +29,6 @@ static void flush_submission(struct intel_gt *gt)
 		intel_engine_flush_submission(engine);
 }
 
-static void engine_retire(struct work_struct *work)
-{
-	struct intel_engine_cs *engine =
-		container_of(work, typeof(*engine), retire_work);
-	struct intel_timeline *tl = xchg(&engine->retire, NULL);
-
-	do {
-		struct intel_timeline *next = xchg(&tl->retire, NULL);
-
-		/*
-		 * Our goal here is to retire _idle_ timelines as soon as
-		 * possible (as they are idle, we do not expect userspace
-		 * to be cleaning up anytime soon).
-		 *
-		 * If the timeline is currently locked, either it is being
-		 * retired elsewhere or about to be!
-		 */
-		if (mutex_trylock(&tl->mutex)) {
-			retire_requests(tl);
-			mutex_unlock(&tl->mutex);
-		}
-		intel_timeline_put(tl);
-
-		GEM_BUG_ON(!next);
-		tl = ptr_mask_bits(next, 1);
-	} while (tl);
-}
-
-static bool add_retire(struct intel_engine_cs *engine,
-		       struct intel_timeline *tl)
-{
-	struct intel_timeline *first;
-
-	/*
-	 * We open-code a llist here to include the additional tag [BIT(0)]
-	 * so that we know when the timeline is already on a
-	 * retirement queue: either this engine or another.
-	 *
-	 * However, we rely on that a timeline can only be active on a single
-	 * engine at any one time and that add_retire() is called before the
-	 * engine releases the timeline and transferred to another to retire.
-	 */
-
-	if (READ_ONCE(tl->retire)) /* already queued */
-		return false;
-
-	intel_timeline_get(tl);
-	first = READ_ONCE(engine->retire);
-	do
-		tl->retire = ptr_pack_bits(first, 1, 1);
-	while (!try_cmpxchg(&engine->retire, &first, tl));
-
-	return !first;
-}
-
-void intel_engine_add_retire(struct intel_engine_cs *engine,
-			     struct intel_timeline *tl)
-{
-	if (add_retire(engine, tl))
-		schedule_work(&engine->retire_work);
-}
-
-void intel_engine_init_retire(struct intel_engine_cs *engine)
-{
-	INIT_WORK(&engine->retire_work, engine_retire);
-}
-
-void intel_engine_fini_retire(struct intel_engine_cs *engine)
-{
-	flush_work(&engine->retire_work);
-	GEM_BUG_ON(engine->retire);
-}
-
 long intel_gt_retire_requests_timeout(struct intel_gt *gt, long timeout)
 {
 	struct intel_gt_timelines *timelines = &gt->timelines;
diff --git a/drivers/gpu/drm/i915/gt/intel_gt_requests.h b/drivers/gpu/drm/i915/gt/intel_gt_requests.h
index d626fb115386..bd31cbce47e0 100644
--- a/drivers/gpu/drm/i915/gt/intel_gt_requests.h
+++ b/drivers/gpu/drm/i915/gt/intel_gt_requests.h
@@ -7,9 +7,7 @@
 #ifndef INTEL_GT_REQUESTS_H
 #define INTEL_GT_REQUESTS_H
 
-struct intel_engine_cs;
 struct intel_gt;
-struct intel_timeline;
 
 long intel_gt_retire_requests_timeout(struct intel_gt *gt, long timeout);
 static inline void intel_gt_retire_requests(struct intel_gt *gt)
@@ -17,11 +15,6 @@ static inline void intel_gt_retire_requests(struct intel_gt *gt)
 	intel_gt_retire_requests_timeout(gt, 0);
 }
 
-void intel_engine_init_retire(struct intel_engine_cs *engine);
-void intel_engine_add_retire(struct intel_engine_cs *engine,
-			     struct intel_timeline *tl);
-void intel_engine_fini_retire(struct intel_engine_cs *engine);
-
 int intel_gt_wait_for_idle(struct intel_gt *gt, long timeout);
 
 void intel_gt_init_requests(struct intel_gt *gt);
diff --git a/drivers/gpu/drm/i915/gt/intel_lrc.c b/drivers/gpu/drm/i915/gt/intel_lrc.c
index 024cc387d545..88b2bc35eb5a 100644
--- a/drivers/gpu/drm/i915/gt/intel_lrc.c
+++ b/drivers/gpu/drm/i915/gt/intel_lrc.c
@@ -142,7 +142,6 @@
 #include "intel_engine_pm.h"
 #include "intel_gt.h"
 #include "intel_gt_pm.h"
-#include "intel_gt_requests.h"
 #include "intel_lrc_reg.h"
 #include "intel_mocs.h"
 #include "intel_reset.h"
@@ -1155,14 +1154,6 @@ __execlists_schedule_out(struct i915_request *rq,
 {
 	struct intel_context * const ce = rq->hw_context;
 
-	/*
-	 * If we have just completed this context, the engine may now be
-	 * idle and we want to re-enter powersaving.
-	 */
-	if (list_is_last(&rq->link, &ce->timeline->requests) &&
-	    i915_request_completed(rq))
-		intel_engine_add_retire(engine, ce->timeline);
-
 	intel_engine_context_out(engine);
 	execlists_context_status_change(rq, INTEL_CONTEXT_SCHEDULE_OUT);
 	intel_gt_pm_put(engine->gt);
diff --git a/drivers/gpu/drm/i915/gt/intel_timeline.c b/drivers/gpu/drm/i915/gt/intel_timeline.c
index 9b800b2d3ba7..16a9e88d93de 100644
--- a/drivers/gpu/drm/i915/gt/intel_timeline.c
+++ b/drivers/gpu/drm/i915/gt/intel_timeline.c
@@ -277,7 +277,6 @@ void intel_timeline_fini(struct intel_timeline *timeline)
 {
 	GEM_BUG_ON(atomic_read(&timeline->pin_count));
 	GEM_BUG_ON(!list_empty(&timeline->requests));
-	GEM_BUG_ON(timeline->retire);
 
 	if (timeline->hwsp_cacheline)
 		cacheline_free(timeline->hwsp_cacheline);
diff --git a/drivers/gpu/drm/i915/gt/intel_timeline_types.h b/drivers/gpu/drm/i915/gt/intel_timeline_types.h
index d87781b2bc6b..98d9ee166379 100644
--- a/drivers/gpu/drm/i915/gt/intel_timeline_types.h
+++ b/drivers/gpu/drm/i915/gt/intel_timeline_types.h
@@ -66,9 +66,6 @@ struct intel_timeline {
 	 */
 	struct i915_active_fence last_request;
 
-	/** A chain of completed timelines ready for early retirement. */
-	struct intel_timeline *retire;
-
 	/**
 	 * We track the most recent seqno that we wait on in every context so
 	 * that we only have to emit a new await and dependency on a more
-- 
2.17.1

