From 2875418d50919ba82516144b1b199ad981a802e3 Mon Sep 17 00:00:00 2001
From: Muhammad Husaini Zulkifli <muhammad.husaini.zulkifli@intel.com>
Date: Fri, 17 Jul 2020 03:02:20 +0800
Subject: [PATCH 43/45] spi: dw: Add Microwire Interfaces support for Keem Bay
 SOC

Add microwire interfaces using half duplex protocol which uses
a control word transmitted from serial master to target slave.
Support for non-sequential and sequential transfer mode.

Signed-off-by: Muhammad Husaini Zulkifli <muhammad.husaini.zulkifli@intel.com>
---
 drivers/spi/spi-dw-mmio.c |  13 ++++
 drivers/spi/spi-dw.c      | 124 +++++++++++++++++++++++++++++++++++---
 drivers/spi/spi-dw.h      |  27 ++++++++-
 3 files changed, 153 insertions(+), 11 deletions(-)

diff --git a/drivers/spi/spi-dw-mmio.c b/drivers/spi/spi-dw-mmio.c
index f0e164011b19..3e5f22027bc8 100644
--- a/drivers/spi/spi-dw-mmio.c
+++ b/drivers/spi/spi-dw-mmio.c
@@ -188,6 +188,7 @@ static int dw_spi_mmio_probe(struct platform_device *pdev)
 	struct dw_spi *dws;
 	int ret;
 	int num_cs;
+	int ssi_type;
 
 	dwsmmio = devm_kzalloc(&pdev->dev, sizeof(struct dw_spi_mmio),
 			GFP_KERNEL);
@@ -236,6 +237,18 @@ static int dw_spi_mmio_probe(struct platform_device *pdev)
 
 	dws->num_cs = num_cs;
 
+	ssi_type = SSI_MOTO_SPI;
+	device_property_read_u32(&pdev->dev, "dw,ssi-type", &ssi_type);
+	dws->type = ssi_type;
+
+	/* Property used for Microwire IP */
+	device_property_read_u32(&pdev->dev, "dw,ssi-mdd", &dws->mdd);
+	device_property_read_u32(&pdev->dev, "dw,ssi-cfs", &dws->dw_ssi_cfs);
+	device_property_read_u32(&pdev->dev, "dw,ssi-mwmod", &dws->mwmod);
+	device_property_read_u32(&pdev->dev, "dw,ssi-cword", &dws->rcv_cword);
+	if (of_property_read_bool(pdev->dev.of_node, "cont-non-sequential"))
+		dws->cont_non_sequential = true;
+
 	init_func = device_get_match_data(&pdev->dev);
 	if (init_func) {
 		ret = init_func(pdev, dwsmmio);
diff --git a/drivers/spi/spi-dw.c b/drivers/spi/spi-dw.c
index e6c996ba591c..5c7b71233607 100644
--- a/drivers/spi/spi-dw.c
+++ b/drivers/spi/spi-dw.c
@@ -121,6 +121,49 @@ static inline void dw_spi_debugfs_remove(struct dw_spi *dws)
 }
 #endif /* CONFIG_DEBUG_FS */
 
+static void dw_spi_microwire_reg_update(struct spi_controller *master,
+				struct spi_transfer *transfer)
+{
+	struct dw_spi *dws = spi_controller_get_devdata(master);
+	u32 ctrlr1	= 0;
+	u32 mwcr	= 0;
+	u16 txlevel	= 0;
+	u8 imask	= 0;
+
+	/* MWCR [0] Microwire Transfer Mode */
+	if (dws->mwmod == SSI_SEQUENTIAL_TRANSFER)
+		mwcr = 1 << DW_SPI_MWCR_MWMOD_OFFSET;
+
+	/* MWCR [1] Microwire Control */
+	mwcr |= (dws->mdd) << DW_SPI_MWCR_MDD_OFFSET;
+
+	dw_writel(dws, DW_SPI_MWCR, mwcr);
+
+	if (dws->mdd == SSI_TRANSMIT_DATA) {
+		/* TXFTLR [5:0] Transmit FIFO Threshold */
+		txlevel = min_t(u16, dws->fifo_len / 2,
+			dws->len / dws->n_bytes);
+		dw_writel(dws, DW_SPI_TXFTLR, txlevel);
+
+		/* IMR Interrupt Mask Register */
+		imask |= SPI_INT_TXEI | SPI_INT_TXOI |
+			 SPI_INT_RXUI | SPI_INT_RXOI;
+
+	} else {
+		/* IMR Interrupt Mask Register */
+		imask |= SPI_INT_TXEI | SPI_INT_TXOI | SPI_INT_RXFI |
+			 SPI_INT_RXUI | SPI_INT_RXOI;
+
+		/* CTRL1 NDF [15:0] Number of Data Frames */
+		if (dws->mwmod == SSI_SEQUENTIAL_TRANSFER) {
+			ctrlr1 |= (dws->len - 1) << DW_SPI_CTRLR1_NDF_OFFSET;
+			dw_writel(dws, DW_SPI_CTRLR1, ctrlr1);
+		}
+	}
+
+	spi_umask_intr(dws, imask);
+}
+
 void dw_spi_set_cs(struct spi_device *spi, bool enable)
 {
 	struct dw_spi *dws = spi_controller_get_devdata(spi->controller);
@@ -221,6 +264,24 @@ static void int_error_stop(struct dw_spi *dws, const char *msg)
 	spi_finalize_current_transfer(dws->master);
 }
 
+static void microwire_ssi_write_control_word(struct dw_spi *dws)
+{
+	u16 txw = 0;
+
+	if (dws->dw_ssi_cfs >= 1 && dws->dw_ssi_cfs <= 8)
+		txw = (u8)(dws->rcv_cword);
+	else
+		txw = (u16)(dws->rcv_cword);
+
+	if (dws->cont_non_sequential) {
+		/* For cont-non-sequential will write more control words */
+		dw_write_io_reg(dws, DW_SPI_DR, txw);
+		dw_write_io_reg(dws, DW_SPI_DR, txw);
+	} else {
+		dw_write_io_reg(dws, DW_SPI_DR, txw);
+	}
+}
+
 static irqreturn_t interrupt_transfer(struct dw_spi *dws)
 {
 	u16 irq_status = dw_readl(dws, DW_SPI_ISR);
@@ -232,6 +293,34 @@ static irqreturn_t interrupt_transfer(struct dw_spi *dws)
 		return IRQ_HANDLED;
 	}
 
+	if (dws->type == SSI_NS_MICROWIRE) {
+		if (dws->mdd == SSI_TRANSMIT_DATA) {
+			if (irq_status & SPI_INT_TXEI) {
+				spi_mask_intr(dws, SPI_INT_TXEI);
+				dw_writer(dws);
+				spi_finalize_current_transfer(dws->master);
+				return IRQ_HANDLED;
+			}
+		} else {
+			if (irq_status & SPI_INT_TXEI) {
+				spi_mask_intr(dws, SPI_INT_TXEI);
+				microwire_ssi_write_control_word(dws);
+			} else if (irq_status & SPI_INT_RXFI) {
+				spi_mask_intr(dws, SPI_INT_RXFI);
+				dw_reader(dws);
+				spi_umask_intr(dws, SPI_INT_RXFI);
+
+				if (dws->rx_end == dws->rx) {
+					spi_mask_intr(dws, SPI_INT_RXFI);
+					spi_finalize_current_transfer(
+						dws->master);
+					return IRQ_HANDLED;
+				}
+			}
+		}
+		return IRQ_HANDLED;
+	}
+
 	dw_reader(dws);
 	if (dws->rx_end == dws->rx) {
 		spi_mask_intr(dws, SPI_INT_TXEI);
@@ -289,6 +378,7 @@ u32 dw_spi_update_cr0_v1_01a(struct spi_controller *master,
 			     struct spi_device *spi,
 			     struct spi_transfer *transfer)
 {
+	struct dw_spi *dws = spi_controller_get_devdata(master);
 	struct chip_data *chip = spi_get_ctldata(spi);
 	u32 cr0;
 
@@ -312,6 +402,10 @@ u32 dw_spi_update_cr0_v1_01a(struct spi_controller *master,
 	/* CTRLR0[13] Shift Register Loop */
 	cr0 |= ((spi->mode & SPI_LOOP) ? 1 : 0) << DWC_SSI_CTRLR0_SRL_OFFSET;
 
+	/* CTRLR0[19:16] Control Frame size */
+	if (dws->type == SSI_NS_MICROWIRE)
+		cr0 |= (dws->dw_ssi_cfs - 1) << DWC_SPI_CTRLR0_CFS_OFFSET;
+
 	return cr0;
 }
 EXPORT_SYMBOL_GPL(dw_spi_update_cr0_v1_01a);
@@ -376,14 +470,19 @@ static int dw_spi_transfer_one(struct spi_controller *master,
 			return ret;
 		}
 	} else {
-		txlevel = min_t(u16, dws->fifo_len / 2, dws->len / dws->n_bytes);
-		dw_writel(dws, DW_SPI_TXFTLR, txlevel);
-
-		/* Set the interrupt mask */
-		imask |= SPI_INT_TXEI | SPI_INT_TXOI |
-			 SPI_INT_RXUI | SPI_INT_RXOI;
-		spi_umask_intr(dws, imask);
-
+		/* update microwire required register */
+		if (dws->type == SSI_NS_MICROWIRE) {
+			dw_spi_microwire_reg_update(master, transfer);
+		} else {
+			txlevel = min_t(u16, dws->fifo_len / 2,
+				dws->len / dws->n_bytes);
+			dw_writel(dws, DW_SPI_TXFTLR, txlevel);
+
+			/* Set the interrupt mask */
+			imask |= SPI_INT_TXEI | SPI_INT_TXOI |
+				 SPI_INT_RXUI | SPI_INT_RXOI;
+			spi_umask_intr(dws, imask);
+		}
 		dws->transfer_handler = interrupt_transfer;
 	}
 
@@ -409,6 +508,7 @@ static void dw_spi_handle_err(struct spi_controller *master,
 /* This may be called twice for each spi dev */
 static int dw_spi_setup(struct spi_device *spi)
 {
+	struct dw_spi *dws = spi_controller_get_devdata(spi->controller);
 	struct chip_data *chip;
 
 	/* Only alloc on first setup */
@@ -420,6 +520,7 @@ static int dw_spi_setup(struct spi_device *spi)
 		spi_set_ctldata(spi, chip);
 	}
 
+	chip->type = dws->type;
 	chip->tmode = SPI_TMOD_TR;
 
 	return 0;
@@ -473,7 +574,6 @@ int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
 		return -ENOMEM;
 
 	dws->master = master;
-	dws->type = SSI_MOTO_SPI;
 	dws->dma_inited = 0;
 	dws->dma_addr = (dma_addr_t)(dws->paddr + DW_SPI_DR);
 	spin_lock_init(&dws->buf_lock);
@@ -500,7 +600,11 @@ int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
 	master->max_speed_hz = dws->max_freq;
 	master->dev.of_node = dev->of_node;
 	master->dev.fwnode = dev->fwnode;
-	master->flags = SPI_MASTER_GPIO_SS;
+	if (dws->type == SSI_NS_MICROWIRE)
+		master->flags =  SPI_CONTROLLER_HALF_DUPLEX |
+				 SPI_MASTER_GPIO_SS;
+	else
+		master->flags = SPI_MASTER_GPIO_SS;
 	master->auto_runtime_pm = true;
 
 	if (dws->set_cs)
diff --git a/drivers/spi/spi-dw.h b/drivers/spi/spi-dw.h
index 94d6726eab3a..0110ede8da02 100644
--- a/drivers/spi/spi-dw.h
+++ b/drivers/spi/spi-dw.h
@@ -59,6 +59,7 @@
 #define SPI_CFS_OFFSET			12
 
 /* Bit fields in CTRLR0 based on DWC_ssi_databook.pdf v1.01a */
+#define DWC_SPI_CTRLR0_CFS_OFFSET	16
 #define DWC_SSI_CTRLR0_SRL_OFFSET	13
 #define DWC_SSI_CTRLR0_TMOD_OFFSET	10
 #define DWC_SSI_CTRLR0_TMOD_MASK	GENMASK(11, 10)
@@ -67,6 +68,13 @@
 #define DWC_SSI_CTRLR0_FRF_OFFSET	6
 #define DWC_SSI_CTRLR0_DFS_OFFSET	0
 
+/* Bit fields in MWCR based on DWC_ssi_databook.pdf v1.01a */
+#define DW_SPI_MWCR_MDD_OFFSET			1
+#define DW_SPI_MWCR_MWMOD_OFFSET		0
+
+/* Bit fields in CTRLR1 based on DWC_ssi_databook.pdf v1.01a */
+#define DW_SPI_CTRLR1_NDF_OFFSET	0
+
 /* Bit fields in SR, 7 bits */
 #define SR_MASK				0x7f		/* cover 7 bits */
 #define SR_BUSY				(1 << 0)
@@ -98,6 +106,16 @@ enum dw_ssi_type {
 	SSI_NS_MICROWIRE,
 };
 
+enum dw_ssi_ctrl {
+	SSI_RECEIVES_DATA = 0,
+	SSI_TRANSMIT_DATA,
+};
+
+enum dw_ssi_mwmod {
+	SSI_NON_SEQUENTIAL_TRANSFER = 0,
+	SSI_SEQUENTIAL_TRANSFER,
+};
+
 struct dw_spi;
 struct dw_spi_dma_ops {
 	int (*dma_init)(struct dw_spi *dws);
@@ -111,7 +129,14 @@ struct dw_spi_dma_ops {
 
 struct dw_spi {
 	struct spi_controller	*master;
-	enum dw_ssi_type	type;
+	enum			dw_ssi_type	type;
+
+	/* Start of Microwire property */
+	enum			dw_ssi_ctrl	mdd;
+	int			dw_ssi_cfs;
+	enum			dw_ssi_mwmod	mwmod;
+	bool			cont_non_sequential;
+	int			rcv_cword;
 
 	void __iomem		*regs;
 	unsigned long		paddr;
-- 
2.17.1

