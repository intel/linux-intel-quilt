From 52c914711719cfb5067c2a76112541f6d28e34a7 Mon Sep 17 00:00:00 2001
From: "Wong, Vincent Por Yin" <vincent.por.yin.wong@intel.com>
Date: Thu, 26 Dec 2019 11:45:20 +0800
Subject: [PATCH 12/31] REVERTME: net: stmmac: introduce AF_XDP ZC TX HW
 timestamps

This is a temporary solution as it uses trace_printk as a means to
log tx timestamps. Future implementation should use xdp_frame's
data_meta to let user applications retrieve it directly.

Signed-off-by: Wong, Vincent Por Yin <vincent.por.yin.wong@intel.com>
Signed-off-by: Voon Weifeng <weifeng.voon@intel.com>
Signed-off-by: Tan, Tee Min <tee.min.tan@intel.com>
---
 .../net/ethernet/stmicro/stmmac/stmmac_xsk.c  | 67 +++++++++++++++++++
 1 file changed, 67 insertions(+)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
index cbbecb63afd5..076d2d0448d0 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
@@ -771,6 +771,9 @@ static bool stmmac_xmit_zc(struct stmmac_tx_queue *xdp_q, unsigned int budget)
 			}
 		}
 
+		if (unlikely(priv->hwts_all))
+			stmmac_enable_tx_timestamp(priv, tx_desc);
+
 		stmmac_prepare_tx_desc(priv, tx_desc, /* Tx descriptor */
 				       1, /* is first descriptor */
 				       desc.len,
@@ -794,6 +797,62 @@ static bool stmmac_xmit_zc(struct stmmac_tx_queue *xdp_q, unsigned int budget)
 	return !!budget && work_done;
 }
 
+/**
+ * stmmac_xdp_read_tx_status - Reads the tx status and retrieve timestamps.
+ * @priv: driver private structure
+ * @queue: TX XDP queue
+ * @entry: entry to be read
+ *
+ **/
+static void stmmac_xdp_read_tx_status(struct stmmac_priv *priv, u32 queue,
+				       u32 entry)
+{
+	struct stmmac_tx_queue *tx_q = get_tx_queue(priv, queue);
+	int retry_attempt = 0, limit = 10;
+	struct dma_desc *p;
+	u64 tx_hwtstamp = 0;
+	int status;
+
+	if (priv->extend_desc)
+		p = (struct dma_desc *)(tx_q->dma_etx + entry);
+	else if (priv->enhanced_tx_desc)
+		p = &(tx_q->dma_enhtx + entry)->basic;
+	else
+		p = tx_q->dma_tx + entry;
+
+	status = stmmac_tx_status(priv, &priv->dev->stats,
+			&priv->xstats, p, priv->ioaddr);
+
+	/* Check if the descriptor is owned by the DMA */
+	if (unlikely(status & tx_dma_own)) {
+		/* Attempt to retry to guarantee timestamps are retrieved. */
+		while(retry_attempt < limit) {
+			udelay(1);
+			status = stmmac_tx_status(priv, &priv->dev->stats,
+						  &priv->xstats, p,
+						  priv->ioaddr);
+
+			if ((status & tx_dma_own) &&
+			    (retry_attempt == limit))
+				return;
+			else if (!(status & tx_dma_own))
+				break;
+			else
+				retry_attempt++;
+		}
+	}
+
+	/* Make sure descriptor fields are read after reading the own bit.*/
+	dma_rmb();
+
+	/* Just consider the last segment and ...*/
+	if (likely(!(status & tx_not_ls))) {
+		stmmac_get_tx_hwtstamp(priv, p, &tx_hwtstamp);
+		if (tx_hwtstamp)
+			trace_printk("XDP TX HW TS %llu\n", tx_hwtstamp);
+	}
+}
+
 /**
  * stmac_clean_xdp_tx_buffer - Frees and unmaps an XDP Tx entry
  * @priv: driver private structure
@@ -838,6 +897,14 @@ int stmmac_xdp_tx_clean(struct stmmac_priv *priv, int budget, u32 queue)
 	entry = xdp_q->dirty_tx;
 
 	for (i = 0; i < completed_frames; i++) {
+
+		/* To increase efficiency, we only read the status register
+		 * if user requests for timestamps. Future work can include
+		 * tx statistics in here.
+		 */
+		if (priv->hwts_all)
+			stmmac_xdp_read_tx_status(priv, queue, entry);
+
 		if (xdp_q->xdpf[entry])
 			stmac_clean_xdp_tx_buffer(priv, queue, entry);
 		else
-- 
2.17.1

