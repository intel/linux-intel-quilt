From b0591c17e2c69cb3f0c951d9c4fe7ecc44005c41 Mon Sep 17 00:00:00 2001
From: Liu Xinyun <xinyun.liu@intel.com>
Date: Wed, 18 Sep 2019 23:53:23 +0800
Subject: [PATCH 49/91] Revert "drm/i915/gvt: preliminary per ring scheduler"

To bring back non-context registers save/restore, per-ring scheduler
should be reverted.

This reverts commit 3b8744f541ee84b87615b8e72b67337dc3d564b3.

Tracked-On: projectacrn/acrn-hypervisor#3830
Signed-off-by: Liu Xinyun <xinyun.liu@intel.com>
Reviewed-by: Zhao Yakui <yakui.zhao@intel.com>
---
 drivers/gpu/drm/i915/gvt/gvt.h          |   2 +-
 drivers/gpu/drm/i915/gvt/sched_policy.c | 212 +++++++++---------------
 drivers/gpu/drm/i915/gvt/scheduler.c    |  17 +-
 drivers/gpu/drm/i915/gvt/scheduler.h    |   6 +-
 drivers/gpu/drm/i915/gvt/vgpu.c         |   7 +-
 5 files changed, 92 insertions(+), 152 deletions(-)

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index c821c2861ec5..e881bbdd87f8 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -202,7 +202,7 @@ struct intel_vgpu {
 	 * scheduler structure. So below 2 vgpu data are protected
 	 * by sched_lock, not vgpu_lock.
 	 */
-	void *sched_data[I915_NUM_ENGINES];
+	void *sched_data;
 	struct vgpu_sched_ctl sched_ctl;
 
 	struct intel_vgpu_fence fence;
diff --git a/drivers/gpu/drm/i915/gvt/sched_policy.c b/drivers/gpu/drm/i915/gvt/sched_policy.c
index f5127e07570b..4fac40d26549 100644
--- a/drivers/gpu/drm/i915/gvt/sched_policy.c
+++ b/drivers/gpu/drm/i915/gvt/sched_policy.c
@@ -34,11 +34,15 @@
 #include "i915_drv.h"
 #include "gvt.h"
 
-static bool vgpu_has_pending_workload(struct intel_vgpu *vgpu,
-                                       enum intel_engine_id ring_id)
+static bool vgpu_has_pending_workload(struct intel_vgpu *vgpu)
 {
-	if (!list_empty(workload_q_head(vgpu, ring_id)))
-		return true;
+	enum intel_engine_id i;
+	struct intel_engine_cs *engine;
+
+	for_each_engine(engine, vgpu->gvt->dev_priv, i) {
+		if (!list_empty(workload_q_head(vgpu, i)))
+			return true;
+	}
 
 	return false;
 }
@@ -64,12 +68,11 @@ struct gvt_sched_data {
 	struct intel_gvt *gvt;
 	struct hrtimer timer;
 	unsigned long period;
-	struct list_head lru_runq_head[I915_NUM_ENGINES];
+	struct list_head lru_runq_head;
 	ktime_t expire_time;
 };
 
-static void vgpu_update_timeslice(struct intel_vgpu *vgpu, ktime_t cur_time,
-				enum intel_engine_id ring_id)
+static void vgpu_update_timeslice(struct intel_vgpu *vgpu, ktime_t cur_time)
 {
 	ktime_t delta_ts;
 	struct vgpu_sched_data *vgpu_data;
@@ -77,7 +80,7 @@ static void vgpu_update_timeslice(struct intel_vgpu *vgpu, ktime_t cur_time,
 	if (!vgpu || vgpu == vgpu->gvt->idle_vgpu)
 		return;
 
-	vgpu_data = vgpu->sched_data[ring_id];
+	vgpu_data = vgpu->sched_data;
 	delta_ts = ktime_sub(cur_time, vgpu_data->sched_in_time);
 	vgpu_data->sched_time = ktime_add(vgpu_data->sched_time, delta_ts);
 	vgpu_data->left_ts = ktime_sub(vgpu_data->left_ts, delta_ts);
@@ -87,13 +90,12 @@ static void vgpu_update_timeslice(struct intel_vgpu *vgpu, ktime_t cur_time,
 #define GVT_TS_BALANCE_PERIOD_MS 100
 #define GVT_TS_BALANCE_STAGE_NUM 10
 
-static void gvt_balance_timeslice(struct gvt_sched_data *sched_data,
-					enum intel_engine_id ring_id)
+static void gvt_balance_timeslice(struct gvt_sched_data *sched_data)
 {
 	struct vgpu_sched_data *vgpu_data;
 	struct list_head *pos;
-	static uint64_t stage_check[I915_NUM_ENGINES];
-	int stage = stage_check[ring_id]++ % GVT_TS_BALANCE_STAGE_NUM;
+	static uint64_t stage_check;
+	int stage = stage_check++ % GVT_TS_BALANCE_STAGE_NUM;
 
 	/* The timeslice accumulation reset at stage 0, which is
 	 * allocated again without adding previous debt.
@@ -102,12 +104,12 @@ static void gvt_balance_timeslice(struct gvt_sched_data *sched_data,
 		int total_weight = 0;
 		ktime_t fair_timeslice;
 
-		list_for_each(pos, &sched_data->lru_runq_head[ring_id]) {
+		list_for_each(pos, &sched_data->lru_runq_head) {
 			vgpu_data = container_of(pos, struct vgpu_sched_data, lru_list);
 			total_weight += vgpu_data->sched_ctl.weight;
 		}
 
-		list_for_each(pos, &sched_data->lru_runq_head[ring_id]) {
+		list_for_each(pos, &sched_data->lru_runq_head) {
 			vgpu_data = container_of(pos, struct vgpu_sched_data, lru_list);
 			fair_timeslice = ktime_divns(ms_to_ktime(GVT_TS_BALANCE_PERIOD_MS),
 						     total_weight) * vgpu_data->sched_ctl.weight;
@@ -116,7 +118,7 @@ static void gvt_balance_timeslice(struct gvt_sched_data *sched_data,
 			vgpu_data->left_ts = vgpu_data->allocated_ts;
 		}
 	} else {
-		list_for_each(pos, &sched_data->lru_runq_head[ring_id]) {
+		list_for_each(pos, &sched_data->lru_runq_head) {
 			vgpu_data = container_of(pos, struct vgpu_sched_data, lru_list);
 
 			/* timeslice for next 100ms should add the left/debt
@@ -127,63 +129,62 @@ static void gvt_balance_timeslice(struct gvt_sched_data *sched_data,
 	}
 }
 
-static void try_to_schedule_next_vgpu(struct intel_gvt *gvt,
-                                       enum intel_engine_id ring_id)
+static void try_to_schedule_next_vgpu(struct intel_gvt *gvt)
 {
 	struct intel_gvt_workload_scheduler *scheduler = &gvt->scheduler;
+	enum intel_engine_id i;
+	struct intel_engine_cs *engine;
 	struct vgpu_sched_data *vgpu_data;
 	ktime_t cur_time;
 
 	/* no need to schedule if next_vgpu is the same with current_vgpu,
 	 * let scheduler chose next_vgpu again by setting it to NULL.
 	 */
-	if (scheduler->next_vgpu[ring_id] ==
-			scheduler->current_vgpu[ring_id]) {
-		scheduler->next_vgpu[ring_id] = NULL;
+	if (scheduler->next_vgpu == scheduler->current_vgpu) {
+		scheduler->next_vgpu = NULL;
 		return;
 	}
 
-	/* no target to schedule */
-	if (!scheduler->next_vgpu[ring_id])
-		return;
 	/*
 	 * after the flag is set, workload dispatch thread will
 	 * stop dispatching workload for current vgpu
 	 */
-	scheduler->need_reschedule[ring_id] = true;
+	scheduler->need_reschedule = true;
 
 	/* still have uncompleted workload? */
-	if (scheduler->current_workload[ring_id])
-		return;
+	for_each_engine(engine, gvt->dev_priv, i) {
+		if (scheduler->current_workload[i])
+			return;
+	}
 
 	cur_time = ktime_get();
-	vgpu_update_timeslice(scheduler->current_vgpu[ring_id], cur_time, ring_id);
-	vgpu_data = scheduler->next_vgpu[ring_id]->sched_data[ring_id];
+	vgpu_update_timeslice(scheduler->current_vgpu, cur_time);
+	vgpu_data = scheduler->next_vgpu->sched_data;
 	vgpu_data->sched_in_time = cur_time;
 
 	/* switch current vgpu */
-	scheduler->current_vgpu[ring_id] = scheduler->next_vgpu[ring_id];
-	scheduler->next_vgpu[ring_id] = NULL;
+	scheduler->current_vgpu = scheduler->next_vgpu;
+	scheduler->next_vgpu = NULL;
 
-	scheduler->need_reschedule[ring_id] = false;
+	scheduler->need_reschedule = false;
 
 	/* wake up workload dispatch thread */
-	wake_up(&scheduler->waitq[ring_id]);
+	for_each_engine(engine, gvt->dev_priv, i)
+		wake_up(&scheduler->waitq[i]);
 }
 
-static struct intel_vgpu *find_busy_vgpu(struct gvt_sched_data *sched_data,
-                                               enum intel_engine_id ring_id)
+static struct intel_vgpu *find_busy_vgpu(struct gvt_sched_data *sched_data)
 {
 	struct vgpu_sched_data *vgpu_data;
 	struct intel_vgpu *vgpu = NULL;
-	struct list_head *head = &sched_data->lru_runq_head[ring_id];
+	struct list_head *head = &sched_data->lru_runq_head;
 	struct list_head *pos;
 
 	/* search a vgpu with pending workload */
 	list_for_each(pos, head) {
 
 		vgpu_data = container_of(pos, struct vgpu_sched_data, lru_list);
-		if (!vgpu_has_pending_workload(vgpu_data->vgpu, ring_id))
+		if (!vgpu_has_pending_workload(vgpu_data->vgpu))
 			continue;
 
 		if (vgpu_data->pri_sched) {
@@ -207,8 +208,7 @@ static struct intel_vgpu *find_busy_vgpu(struct gvt_sched_data *sched_data,
 /* in nanosecond */
 #define GVT_DEFAULT_TIME_SLICE 1000000
 
-static void tbs_sched_func(struct gvt_sched_data *sched_data,
-		enum intel_engine_id ring_id)
+static void tbs_sched_func(struct gvt_sched_data *sched_data)
 {
 	struct intel_gvt *gvt = sched_data->gvt;
 	struct intel_gvt_workload_scheduler *scheduler = &gvt->scheduler;
@@ -216,34 +216,31 @@ static void tbs_sched_func(struct gvt_sched_data *sched_data,
 	struct intel_vgpu *vgpu = NULL;
 
 	/* no active vgpu or has already had a target */
-	if (list_empty(&sched_data->lru_runq_head[ring_id])
-			|| scheduler->next_vgpu[ring_id])
+	if (list_empty(&sched_data->lru_runq_head) || scheduler->next_vgpu)
 		goto out;
 
-	vgpu = find_busy_vgpu(sched_data, ring_id);
+	vgpu = find_busy_vgpu(sched_data);
 	if (vgpu) {
-		scheduler->next_vgpu[ring_id] = vgpu;
-		vgpu_data = vgpu->sched_data[ring_id];
+		scheduler->next_vgpu = vgpu;
+		vgpu_data = vgpu->sched_data;
 		if (!vgpu_data->pri_sched) {
 			/* Move the last used vGPU to the tail of lru_list */
 			list_del_init(&vgpu_data->lru_list);
 			list_add_tail(&vgpu_data->lru_list,
-				      &sched_data->lru_runq_head[ring_id]);
+				      &sched_data->lru_runq_head);
 		}
 	} else {
-		scheduler->next_vgpu[ring_id] = gvt->idle_vgpu;
+		scheduler->next_vgpu = gvt->idle_vgpu;
 	}
 out:
-	if (scheduler->next_vgpu[ring_id])
-		try_to_schedule_next_vgpu(gvt, ring_id);
+	if (scheduler->next_vgpu)
+		try_to_schedule_next_vgpu(gvt);
 }
 
 void intel_gvt_schedule(struct intel_gvt *gvt)
 {
 	struct gvt_sched_data *sched_data = gvt->scheduler.sched_data;
 	ktime_t cur_time;
-	enum intel_engine_id i;
-	struct intel_engine_cs *engine;
 
 	mutex_lock(&gvt->sched_lock);
 	cur_time = ktime_get();
@@ -251,19 +248,15 @@ void intel_gvt_schedule(struct intel_gvt *gvt)
 	if (test_and_clear_bit(INTEL_GVT_REQUEST_SCHED,
 				(void *)&gvt->service_request)) {
 		if (cur_time >= sched_data->expire_time) {
-			for_each_engine(engine, gvt->dev_priv, i)
-				gvt_balance_timeslice(sched_data, i);
+			gvt_balance_timeslice(sched_data);
 			sched_data->expire_time = ktime_add_ms(
 				cur_time, GVT_TS_BALANCE_PERIOD_MS);
 		}
 	}
 	clear_bit(INTEL_GVT_REQUEST_EVENT_SCHED, (void *)&gvt->service_request);
 
-	for_each_engine(engine, gvt->dev_priv, i) {
-		vgpu_update_timeslice(gvt->scheduler.current_vgpu[i],
-				cur_time, i);
-		tbs_sched_func(sched_data, i);
-	}
+	vgpu_update_timeslice(gvt->scheduler.current_vgpu, cur_time);
+	tbs_sched_func(sched_data);
 
 	mutex_unlock(&gvt->sched_lock);
 }
@@ -283,9 +276,6 @@ static enum hrtimer_restart tbs_timer_fn(struct hrtimer *timer_data)
 
 static int tbs_sched_init(struct intel_gvt *gvt)
 {
-	enum intel_engine_id i;
-	struct intel_engine_cs *engine;
-
 	struct intel_gvt_workload_scheduler *scheduler =
 		&gvt->scheduler;
 
@@ -295,9 +285,7 @@ static int tbs_sched_init(struct intel_gvt *gvt)
 	if (!data)
 		return -ENOMEM;
 
-	for_each_engine(engine, gvt->dev_priv, i)
-		INIT_LIST_HEAD(&data->lru_runq_head[i]);
-
+	INIT_LIST_HEAD(&data->lru_runq_head);
 	hrtimer_init(&data->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
 	data->timer.function = tbs_timer_fn;
 	data->period = GVT_DEFAULT_TIME_SLICE;
@@ -323,29 +311,18 @@ static void tbs_sched_clean(struct intel_gvt *gvt)
 static int tbs_sched_init_vgpu(struct intel_vgpu *vgpu)
 {
 	struct vgpu_sched_data *data;
-	enum intel_engine_id i;
-	struct intel_engine_cs *engine;
 
-	for_each_engine(engine, vgpu->gvt->dev_priv, i) {
-		data = kzalloc(sizeof(*data), GFP_KERNEL);
-		if (!data)
-			goto err;
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
 
-		data->sched_ctl.weight = vgpu->sched_ctl.weight;
-		data->vgpu = vgpu;
-		INIT_LIST_HEAD(&data->lru_list);
+	data->sched_ctl.weight = vgpu->sched_ctl.weight;
+	data->vgpu = vgpu;
+	INIT_LIST_HEAD(&data->lru_list);
 
-		vgpu->sched_data[i] = data;
-	}
+	vgpu->sched_data = data;
 
 	return 0;
-
-err:
-	for (; i >= 0; i--) {
-		kfree(vgpu->sched_data[i]);
-		vgpu->sched_data[i] = NULL;
-	}
-	return -ENOMEM;
 }
 
 static void tbs_sched_clean_vgpu(struct intel_vgpu *vgpu)
@@ -353,13 +330,8 @@ static void tbs_sched_clean_vgpu(struct intel_vgpu *vgpu)
 	struct intel_gvt *gvt = vgpu->gvt;
 	struct gvt_sched_data *sched_data = gvt->scheduler.sched_data;
 
-	enum intel_engine_id i;
-	struct intel_engine_cs *engine;
-
-	for_each_engine(engine, vgpu->gvt->dev_priv, i) {
-		kfree(vgpu->sched_data[i]);
-		vgpu->sched_data[i] = NULL;
-	}
+	kfree(vgpu->sched_data);
+	vgpu->sched_data = NULL;
 
 	/* this vgpu id has been removed */
 	if (idr_is_empty(&gvt->vgpu_idr))
@@ -369,42 +341,31 @@ static void tbs_sched_clean_vgpu(struct intel_vgpu *vgpu)
 static void tbs_sched_start_schedule(struct intel_vgpu *vgpu)
 {
 	struct gvt_sched_data *sched_data = vgpu->gvt->scheduler.sched_data;
+	struct vgpu_sched_data *vgpu_data = vgpu->sched_data;
 	ktime_t now;
-	struct vgpu_sched_data *vgpu_data;
-	enum intel_engine_id i;
-	struct intel_engine_cs *engine;
 
-	for_each_engine(engine, vgpu->gvt->dev_priv, i) {
-		vgpu_data = vgpu->sched_data[i];
-		if (!list_empty(&vgpu_data->lru_list))
-			continue;
+	if (!list_empty(&vgpu_data->lru_list))
+		return;
 
-		now = ktime_get();
-		vgpu_data->pri_time = ktime_add(now,
+	now = ktime_get();
+	vgpu_data->pri_time = ktime_add(now,
 					ktime_set(GVT_SCHED_VGPU_PRI_TIME, 0));
-		vgpu_data->pri_sched = true;
+	vgpu_data->pri_sched = true;
 
-		list_add(&vgpu_data->lru_list, &sched_data->lru_runq_head[i]);
-		vgpu_data->active = true;
-	}
+	list_add(&vgpu_data->lru_list, &sched_data->lru_runq_head);
 
 	if (!hrtimer_active(&sched_data->timer))
 		hrtimer_start(&sched_data->timer, ktime_add_ns(ktime_get(),
 			sched_data->period), HRTIMER_MODE_ABS);
+	vgpu_data->active = true;
 }
 
 static void tbs_sched_stop_schedule(struct intel_vgpu *vgpu)
 {
-	struct vgpu_sched_data *vgpu_data;
-	enum intel_engine_id i;
-	struct intel_engine_cs *engine;
-
-	for_each_engine(engine, vgpu->gvt->dev_priv, i) {
-		vgpu_data = vgpu->sched_data[i];
+	struct vgpu_sched_data *vgpu_data = vgpu->sched_data;
 
-		list_del_init(&vgpu_data->lru_list);
-		vgpu_data->active = false;
-	}
+	list_del_init(&vgpu_data->lru_list);
+	vgpu_data->active = false;
 }
 
 static struct intel_gvt_sched_policy_ops tbs_schedule_ops = {
@@ -462,16 +423,10 @@ void intel_vgpu_clean_sched_policy(struct intel_vgpu *vgpu)
 
 void intel_vgpu_start_schedule(struct intel_vgpu *vgpu)
 {
-	struct vgpu_sched_data *vgpu_data;
-	struct intel_engine_cs *engine;
-	enum intel_engine_id i;
+	struct vgpu_sched_data *vgpu_data = vgpu->sched_data;
 
 	mutex_lock(&vgpu->gvt->sched_lock);
-	for_each_engine(engine, vgpu->gvt->dev_priv, i) {
-		vgpu_data = vgpu->sched_data[i];
-		if (vgpu_data->active)
-			continue;
-
+	if (!vgpu_data->active) {
 		gvt_dbg_core("vgpu%d: start schedule\n", vgpu->id);
 		vgpu->gvt->scheduler.sched_ops->start_schedule(vgpu);
 	}
@@ -489,26 +444,23 @@ void intel_vgpu_stop_schedule(struct intel_vgpu *vgpu)
 {
 	struct intel_gvt_workload_scheduler *scheduler =
 		&vgpu->gvt->scheduler;
-	struct vgpu_sched_data *vgpu_data;
-	enum intel_engine_id i;
-	struct intel_engine_cs *engine;
+	struct vgpu_sched_data *vgpu_data = vgpu->sched_data;
+
+	if (!vgpu_data->active)
+		return;
 
 	gvt_dbg_core("vgpu%d: stop schedule\n", vgpu->id);
 
 	mutex_lock(&vgpu->gvt->sched_lock);
 	scheduler->sched_ops->stop_schedule(vgpu);
 
-	for_each_engine(engine, vgpu->gvt->dev_priv, i) {
-		vgpu_data = vgpu->sched_data[i];
-
-		if (scheduler->next_vgpu[i] == vgpu)
-			scheduler->next_vgpu[i] = NULL;
+	if (scheduler->next_vgpu == vgpu)
+		scheduler->next_vgpu = NULL;
 
-		if (scheduler->current_vgpu[i] == vgpu) {
-			/* stop workload dispatching */
-			scheduler->need_reschedule[i] = true;
-			scheduler->current_vgpu[i] = NULL;
-		}
+	if (scheduler->current_vgpu == vgpu) {
+		/* stop workload dispatching */
+		scheduler->need_reschedule = true;
+		scheduler->current_vgpu = NULL;
 	}
 
 	mutex_unlock(&vgpu->gvt->sched_lock);
diff --git a/drivers/gpu/drm/i915/gvt/scheduler.c b/drivers/gpu/drm/i915/gvt/scheduler.c
index 975c75f243d6..7ebbcd22c024 100644
--- a/drivers/gpu/drm/i915/gvt/scheduler.c
+++ b/drivers/gpu/drm/i915/gvt/scheduler.c
@@ -775,23 +775,17 @@ static struct intel_vgpu_workload *pick_next_workload(
 	 * no current vgpu / will be scheduled out / no workload
 	 * bail out
 	 */
-	if (!scheduler->current_vgpu[ring_id]) {
+	if (!scheduler->current_vgpu) {
 		gvt_dbg_sched("ring id %d stop - no current vgpu\n", ring_id);
 		goto out;
 	}
 
-	if (!scheduler->current_vgpu[ring_id]->active) {
-		gvt_dbg_sched("ring id %d stop - vgpu not active\n", ring_id);
-		goto out;
-	}
-
-	if (scheduler->need_reschedule[ring_id]) {
+	if (scheduler->need_reschedule) {
 		gvt_dbg_sched("ring id %d stop - will reschedule\n", ring_id);
 		goto out;
 	}
 
-	if (list_empty(workload_q_head(scheduler->current_vgpu[ring_id],
-					ring_id)))
+	if (list_empty(workload_q_head(scheduler->current_vgpu, ring_id)))
 		goto out;
 
 	/*
@@ -812,8 +806,7 @@ static struct intel_vgpu_workload *pick_next_workload(
 	 * schedule out a vgpu.
 	 */
 	scheduler->current_workload[ring_id] = container_of(
-			workload_q_head(scheduler->current_vgpu[ring_id],
-				ring_id)->next,
+			workload_q_head(scheduler->current_vgpu, ring_id)->next,
 			struct intel_vgpu_workload, list);
 
 	workload = scheduler->current_workload[ring_id];
@@ -1001,7 +994,7 @@ static void complete_current_workload(struct intel_gvt *gvt, int ring_id)
 	atomic_dec(&s->running_workload_num);
 	wake_up(&scheduler->workload_complete_wq);
 
-	if (gvt->scheduler.need_reschedule[ring_id])
+	if (gvt->scheduler.need_reschedule)
 		intel_gvt_request_service(gvt, INTEL_GVT_REQUEST_EVENT_SCHED);
 
 	mutex_unlock(&gvt->sched_lock);
diff --git a/drivers/gpu/drm/i915/gvt/scheduler.h b/drivers/gpu/drm/i915/gvt/scheduler.h
index 3cec02d2ac1a..043c2ff07a7c 100644
--- a/drivers/gpu/drm/i915/gvt/scheduler.h
+++ b/drivers/gpu/drm/i915/gvt/scheduler.h
@@ -37,10 +37,10 @@
 #define _GVT_SCHEDULER_H_
 
 struct intel_gvt_workload_scheduler {
-	struct intel_vgpu *current_vgpu[I915_NUM_ENGINES];
-	struct intel_vgpu *next_vgpu[I915_NUM_ENGINES];
+	struct intel_vgpu *current_vgpu;
+	struct intel_vgpu *next_vgpu;
 	struct intel_vgpu_workload *current_workload[I915_NUM_ENGINES];
-	bool need_reschedule[I915_NUM_ENGINES];
+	bool need_reschedule;
 
 	spinlock_t mmio_context_lock;
 	/* can be null when owner is host */
diff --git a/drivers/gpu/drm/i915/gvt/vgpu.c b/drivers/gpu/drm/i915/gvt/vgpu.c
index fa66cabaab77..d1ee64508528 100644
--- a/drivers/gpu/drm/i915/gvt/vgpu.c
+++ b/drivers/gpu/drm/i915/gvt/vgpu.c
@@ -557,8 +557,6 @@ void intel_gvt_reset_vgpu_locked(struct intel_vgpu *vgpu, bool dmlr,
 	struct intel_gvt *gvt = vgpu->gvt;
 	struct intel_gvt_workload_scheduler *scheduler = &gvt->scheduler;
 	unsigned int resetting_eng = dmlr ? ALL_ENGINES : engine_mask;
-	enum intel_engine_id i;
-	struct intel_engine_cs *engine;
 	bool enable_pvmmio = vgpu_vreg_t(vgpu, vgtif_reg(enable_pvmmio));
 
 	gvt_dbg_core("------------------------------------------\n");
@@ -572,10 +570,7 @@ void intel_gvt_reset_vgpu_locked(struct intel_vgpu *vgpu, bool dmlr,
 	 * The current_vgpu will set to NULL after stopping the
 	 * scheduler when the reset is triggered by current vgpu.
 	 */
-	for_each_engine_masked(engine, gvt->dev_priv, resetting_eng, i) {
-		if (scheduler->current_vgpu[i] != NULL)
-			continue;
-
+	if (scheduler->current_vgpu == NULL) {
 		mutex_unlock(&vgpu->vgpu_lock);
 		intel_gvt_wait_vgpu_idle(vgpu);
 		mutex_lock(&vgpu->vgpu_lock);
-- 
2.17.1

