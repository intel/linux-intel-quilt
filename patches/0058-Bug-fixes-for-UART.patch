From ab8cba14176a65c118552e3fe36e47231b5cc2da Mon Sep 17 00:00:00 2001
From: Aman Kumar <aman.kumar@intel.com>
Date: Tue, 9 Mar 2021 11:03:01 +0530
Subject: [PATCH 058/109] Bug fixes for UART

Signed-off-by: Aman Kumar <aman.kumar@intel.com>
---
 drivers/tty/serial/8250/8250_dw.c   | 92 ++++++++++++++++++++++++++++-
 drivers/tty/serial/8250/8250_port.c | 14 ++++-
 include/linux/serial_core.h         |  1 +
 3 files changed, 103 insertions(+), 4 deletions(-)

diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
index 08d201e1f414..d4b9a2152441 100644
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -51,6 +51,7 @@ struct dw8250_data {
 
 	unsigned int		skip_autocfg:1;
 	unsigned int		uart_16550_compatible:1;
+	unsigned int            use_iir_rdi:1;
 };
 
 static inline struct dw8250_data *to_dw8250_data(struct dw8250_port_data *data)
@@ -260,7 +261,8 @@ static int dw8250_handle_irq(struct uart_port *p)
 
 		spin_unlock_irqrestore(&p->lock, flags);
 	}
-
+	if (d->use_iir_rdi)
+		p->iir_rdi = true;
 	if (serial8250_handle_irq(p, iir))
 		return 1;
 
@@ -315,6 +317,87 @@ static int dw8250_clk_notifier_cb(struct notifier_block *nb,
 }
 
 
+static void dw8250_set_termios_keembay(struct uart_port *p,
+				       struct ktermios *termios,
+				       struct ktermios *old)
+{
+	unsigned int baud = tty_termios_baud_rate(termios);
+	struct dw8250_data *d = p->private_data;
+	long rate, new_rate;
+	int ret;
+
+	if (IS_ERR(d->clk))
+		goto out;
+
+	if (baud == 0)
+		goto out;
+
+	/*
+	 * Intel Keem Bay SoC ARM Trusted Firmware provides a limited
+	 * number of discrete clock rates. The clock rate is selected based
+	 * on equations given in DW_apb_uart_db_v4.01a_Oct2016.pdf page 55.
+	 *
+	 * (1) baud_rate = (baudclk) / (16 * DIVISOR)
+	 * (2) DIVISOR   = (baudclk) / (16 * baud_rate)
+	 * (3) baudclk   = baud_rate * 16 * DIVISOR
+	 *
+	 * where DIVISOR is number in hexadecimal to program DLL and DLH
+	 *
+	 * Percentage ERROR = |baud_rate - baud_rate_selected| * 100 / baud_rate
+	 */
+	rate = clk_get_rate(d->clk);
+
+	switch (baud) {
+	/* This is the best clock rate available for 2M, 3M and 4M, 4% error. */
+	case 4000000:
+	case 3000000:
+	case 2000000:
+	case 460800:
+	case 230400:
+		new_rate = 200000000;
+		break;
+	case 3500000:
+	case 2500000:
+		new_rate = 280000000;
+		break;
+	case 1152000:
+	case 576000:
+		new_rate = 500000000;
+		break;
+	case 1000000:
+	case 921600:
+		new_rate = 400000000;
+		break;
+	case 1500000:
+	case 500000:
+	case 50 ... 115200:
+		new_rate = 24000000;
+		break;
+	default:
+		goto out;
+	}
+
+	if (rate != new_rate) {
+		clk_disable_unprepare(d->clk);
+		ret = clk_set_rate(d->clk, new_rate);
+		clk_prepare_enable(d->clk);
+
+		if (!ret)
+			p->uartclk = new_rate;
+	}
+
+	/* TO BE REMOVED */
+	pr_info("%s: baud= %d rate= %ld, new_rate= %ld, obtained rate= %ld\n",
+		__func__, baud, rate, new_rate, clk_get_rate(d->clk));
+
+out:
+	p->status &= ~UPSTAT_AUTOCTS;
+	if (termios->c_cflag & CRTSCTS)
+		p->status |= UPSTAT_AUTOCTS;
+
+	serial8250_do_set_termios(p, termios, old);
+}
+
 static void dw8250_set_termios(struct uart_port *p, struct ktermios *termios,
 			       struct ktermios *old)
 {
@@ -401,9 +484,15 @@ static void dw8250_quirks(struct uart_port *p, struct dw8250_data *data)
 			p->serial_in = dw8250_serial_in32be;
 			p->serial_out = dw8250_serial_out32be;
 		}
+
 		if (of_device_is_compatible(np, "marvell,armada-38x-uart"))
 			p->serial_out = dw8250_serial_out38x;
 
+		if (of_device_is_compatible(np, "intel,keembay-uart")) {
+			data->use_iir_rdi = true;
+			p->set_termios = dw8250_set_termios_keembay;
+		}
+
 	} else if (acpi_dev_present("APMC0D08", NULL, -1)) {
 		p->iotype = UPIO_MEM32;
 		p->regshift = 2;
@@ -687,6 +776,7 @@ static const struct of_device_id dw8250_of_match[] = {
 	{ .compatible = "cavium,octeon-3860-uart" },
 	{ .compatible = "marvell,armada-38x-uart" },
 	{ .compatible = "renesas,rzn1-uart" },
+	{ .compatible = "intel,keembay-uart" },
 	{ /* Sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, dw8250_of_match);
diff --git a/drivers/tty/serial/8250/8250_port.c b/drivers/tty/serial/8250/8250_port.c
index 0f384b845045..f15529cc8bd6 100644
--- a/drivers/tty/serial/8250/8250_port.c
+++ b/drivers/tty/serial/8250/8250_port.c
@@ -1903,9 +1903,17 @@ int serial8250_handle_irq(struct uart_port *port, unsigned int iir)
 	    !(port->read_status_mask & UART_LSR_DR))
 		skip_rx = true;
 
-	if (status & (UART_LSR_DR | UART_LSR_BI) && !skip_rx) {
-		if (!up->dma || handle_rx_dma(up, iir))
-			status = serial8250_rx_chars(up, status);
+	if (port->iir_rdi) {
+		if (status & (UART_LSR_DR | UART_LSR_BI) &&
+		    iir & UART_IIR_RDI) {
+			if (!up->dma || handle_rx_dma(up, iir))
+				status = serial8250_rx_chars(up, status);
+		}
+	} else {
+		if (status & (UART_LSR_DR | UART_LSR_BI)) {
+			if (!up->dma || handle_rx_dma(up, iir))
+				status = serial8250_rx_chars(up, status);
+		}
 	}
 	serial8250_modem_status(up);
 	if ((!up->dma || up->dma->tx_err) && (status & UART_LSR_THRE) &&
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index c9c8fd5ab613..3ba5b2564968 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -141,6 +141,7 @@ struct uart_port {
 	unsigned char		regshift;		/* reg offset shift */
 	unsigned char		iotype;			/* io access style */
 	unsigned char		quirks;			/* internal quirks */
+	unsigned int		iir_rdi;
 
 #define UPIO_PORT		(SERIAL_IO_PORT)	/* 8b I/O port access */
 #define UPIO_HUB6		(SERIAL_IO_HUB6)	/* Hub6 ISA card */
-- 
2.25.1

