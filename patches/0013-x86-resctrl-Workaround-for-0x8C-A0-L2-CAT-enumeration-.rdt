From 0f24993b1ed9dc94320e90a86050223ba2d8f012 Mon Sep 17 00:00:00 2001
From: Reinette Chatre <reinette.chatre@intel.com>
Date: Fri, 21 Jun 2019 18:43:06 -0700
Subject: [PATCH 13/13] x86/resctrl: Workaround for 0x8C A0 L2 CAT enumeration
 issues

0x8C A-step hardware returns two pieces of incorrect information during L2
CAT CPUID enumeration. Work around these temporarily.

 When enumerating the properties of L2 CAT the "shareable bits" reported
 by platform, reflecting the portions of L2 cache that other hardware
 entities can allocate into, is incorrectly reported to be the entire
 supported CBM.
 This is especially an issue for cache pseudo-locking since no
 pseudo-lock region can be allocated on a portion of cache if another
 hardware entity could posssibly allocate into it.

 The number of CLOS supported by the system is incorrectly reported to
 be 9 instead of 8.

This will not be upstreamed since the hardware will report correct data
starting with B-step.

Signed-off-by: Reinette Chatre <reinette.chatre@intel.com>
---
 arch/x86/kernel/cpu/resctrl/core.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/arch/x86/kernel/cpu/resctrl/core.c b/arch/x86/kernel/cpu/resctrl/core.c
index cb48fd45b245..b6adc0c51d20 100644
--- a/arch/x86/kernel/cpu/resctrl/core.c
+++ b/arch/x86/kernel/cpu/resctrl/core.c
@@ -346,6 +346,24 @@ static void rdt_get_cache_alloc_cfg(int idx, struct rdt_resource *r)
 	r->data_width = (r->cache.cbm_len + 3) / 4;
 	r->alloc_capable = true;
 	r->alloc_enabled = true;
+	/*
+	 * FIXME: REMOVE ME
+	 * These workarounds are needed for 0x8C A0. Workarounds are safe
+	 * to run on all platforms since no L2 cache supporting CAT
+	 * has shareable bits set and no current platform supports 9 CLOSids.
+	 */
+	if (idx == 2) {
+		if (r->cache.shareable_bits != 0x0) {
+			pr_warn("Overriding L2 shareable bits (was 0x%X)\n",
+				r->cache.shareable_bits);
+			r->cache.shareable_bits = 0x0;
+		}
+		if (r->num_closid == 9) {
+			pr_warn("Overriding COS_MAX, retrieved edx.split.cos_max  = %u, but marking num clos as %u (without adding 1)\n",
+				edx.split.cos_max, edx.split.cos_max);
+			r->num_closid = edx.split.cos_max;
+		}
+	}
 }
 
 static void rdt_get_cdp_config(int level, int type)
-- 
2.22.0.545.g9c9b961d7e

