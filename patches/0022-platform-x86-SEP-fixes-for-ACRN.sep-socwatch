From 2cf923868f01547cf5ceb167ec4000fe43b07f57 Mon Sep 17 00:00:00 2001
From: Manisha Chinthapally <manisha.chinthapally@intel.com>
Date: Wed, 30 Jan 2019 13:58:55 -0800
Subject: [PATCH 22/22] platform/x86 :SEP fixes for ACRN

Get profiling status info

In remote or acrn based collections, it is necessary to know if all the samples generated is copied to the host.
So, added an IOCTL to collect important statistical data like samples logged, dropped etc

Tracked-On: PKT-1717
Signed-off-by: Manisha Chinthapally <manisha.chinthapally@intel.com>

SEP Bug fix to prevent Vtune crash with event multiplexing

SEP doesn't support Multiplexing of events for ACRN.
Vtune/SEP crashes when MUX events are provided,
Fixed the issue by exiting gracefully instead of crashing.

Tracked-on: PKT-1745
Signed-off-by: Lim, Min Yeol <min.yeol.lim@intel.com>
Signed-off-by: Manisha Chinthapally <manisha.chinthapally@intel.com>

SEP Bug Fix for VMM symbol resolution

VMM symbol is not loading correctly in Vtune.
This patch fix symbol loading issue and
changed the macro name from OS_ID_ACORN to OS_ID_ACRN

Tracked-on: PKT-1745
Signed-off-by: Lim, Min Yeol <min.yeol.lim@intel.com>
Signed-off-by: Manisha <manisha.chinthapally@intel.com>

SEP Error handling based on acrn hypercall return code

SEP hypercalls to acrn hypervisor return,
0 for success and -EINVAL for all failure cases.
So, if acrn_hypercall fails print error message and handle it appropriately

Tracked-on: PKT-1745
Signed-off-by: Manisha Chinthapally <manisha.chinthapally@intel.com>
---
 drivers/platform/x86/sepdk/inc/lwpmudrv.h     |   6 +
 .../x86/sepdk/include/lwpmudrv_defines.h      |   2 +-
 .../x86/sepdk/include/lwpmudrv_struct.h       |   5 +-
 drivers/platform/x86/sepdk/sep/linuxos.c      |   6 +-
 drivers/platform/x86/sepdk/sep/lwpmudrv.c     | 165 ++++++++++++++++--
 drivers/platform/x86/sepdk/sep/perfver4.c     |  20 ++-
 drivers/platform/x86/sepdk/sep/utility.c      |   9 +-
 7 files changed, 183 insertions(+), 30 deletions(-)
 mode change 100755 => 100644 drivers/platform/x86/sepdk/sep/lwpmudrv.c

diff --git a/drivers/platform/x86/sepdk/inc/lwpmudrv.h b/drivers/platform/x86/sepdk/inc/lwpmudrv.h
index ae8a3aee26a1..d682ab632127 100644
--- a/drivers/platform/x86/sepdk/inc/lwpmudrv.h
+++ b/drivers/platform/x86/sepdk/inc/lwpmudrv.h
@@ -545,6 +545,12 @@ struct profiling_pcpuid {
 	uint32_t ecx;
 	uint32_t edx;
 };
+
+struct profiling_status {
+	uint32_t samples_logged;
+	uint32_t samples_dropped;
+};
+
 #endif
 
 #endif
diff --git a/drivers/platform/x86/sepdk/include/lwpmudrv_defines.h b/drivers/platform/x86/sepdk/include/lwpmudrv_defines.h
index 8346ea72d587..0120aeea9631 100644
--- a/drivers/platform/x86/sepdk/include/lwpmudrv_defines.h
+++ b/drivers/platform/x86/sepdk/include/lwpmudrv_defines.h
@@ -511,7 +511,7 @@ extern "C" {
 #define OS_ID_MODEM 1
 #define OS_ID_ANDROID 2
 #define OS_ID_SECVM 3
-#define OS_ID_ACORN 0xFFFF
+#define OS_ID_ACRN 0xFFFF
 
 #define PERF_HW_VER4 (5)
 #if defined(__cplusplus)
diff --git a/drivers/platform/x86/sepdk/include/lwpmudrv_struct.h b/drivers/platform/x86/sepdk/include/lwpmudrv_struct.h
index 629750152fdb..6afb2ac8839d 100644
--- a/drivers/platform/x86/sepdk/include/lwpmudrv_struct.h
+++ b/drivers/platform/x86/sepdk/include/lwpmudrv_struct.h
@@ -1475,7 +1475,8 @@ struct DRV_SETUP_INFO_NODE_S {
 			U64 matrix_inaccessible : 1;
 			U64 page_table_isolation : 2;
 			U64 pebs_ignored_by_pti : 1;
-			U64 reserved1 : 47;
+			U64 core_event_mux_unavailable : 1;
+			U64 reserved1 : 46;
 		} s1;
 	} u1;
 	U64 reserved2;
@@ -1495,6 +1496,8 @@ struct DRV_SETUP_INFO_NODE_S {
 	((info)->u1.s1.page_table_isolation)
 #define DRV_SETUP_INFO_pebs_ignored_by_pti(info)                               \
 	((info)->u1.s1.pebs_ignored_by_pti)
+#define DRV_SETUP_INFO_core_event_mux_unavailable(info)                        \
+	((info)->u1.s1.core_event_mux_unavailable)
 
 #define DRV_SETUP_INFO_PTI_DISABLED 0
 #define DRV_SETUP_INFO_PTI_KPTI 1
diff --git a/drivers/platform/x86/sepdk/sep/linuxos.c b/drivers/platform/x86/sepdk/sep/linuxos.c
index 1f877e6e4bc8..3ef35ac66b49 100755
--- a/drivers/platform/x86/sepdk/sep/linuxos.c
+++ b/drivers/platform/x86/sepdk/sep/linuxos.c
@@ -161,7 +161,9 @@ static S32 linuxos_Load_Image_Notify_Routine(char *name, U64 base, U32 size,
 	MODULE_RECORD_parent_pid(mra) = parent_pid;
 	MODULE_RECORD_osid(mra) = osid;
 	MODULE_RECORD_pid_rec_index(mra) = pid;
-
+	if (osid == OS_ID_ACRN) {
+		MODULE_RECORD_unknown_load_address(mra) = 1;
+	}
 	if (kernel_modules) {
 		MODULE_RECORD_tsc(mra) = 0;
 		MR_unloadTscSet(mra, (U64)(0xffffffffffffffffLL));
@@ -328,7 +330,7 @@ static S32 linuxos_Map_Kernel_Modules(void)
 	linuxos_Load_Image_Notify_Routine(
 		"VMM", 0x0, (U32)0xffffffffffffffffLL, 0, 0, 0,
 		LOPTS_1ST_MODREC | LOPTS_GLOBAL_MODULE | LOPTS_EXE, exec_mode,
-		-1, MR_SEG_NUM, 1, OS_ID_ACORN);
+		-1, MR_SEG_NUM, 1, OS_ID_ACRN);
 #endif
 
 	for (modules = (struct list_head *)(THIS_MODULE->list.prev);
diff --git a/drivers/platform/x86/sepdk/sep/lwpmudrv.c b/drivers/platform/x86/sepdk/sep/lwpmudrv.c
old mode 100755
new mode 100644
index 8ae975b9a833..f3efb9b0eab2
--- a/drivers/platform/x86/sepdk/sep/lwpmudrv.c
+++ b/drivers/platform/x86/sepdk/sep/lwpmudrv.c
@@ -2677,8 +2677,13 @@ static VOID lwpmudrv_Read_MSR(PVOID param)
 
 	BUG_ON(!virt_addr_valid(msr_list));
 
-	acrn_hypercall2(HC_PROFILING_OPS, PROFILING_MSR_OPS,
-			virt_to_phys(msr_list));
+	if (acrn_hypercall2(HC_PROFILING_OPS, PROFILING_MSR_OPS,
+			virt_to_phys(msr_list)) != OS_SUCCESS) {
+		SEP_DRV_LOG_ERROR(
+			"[ACRN][HC:MSR_OPS][%s]: returned with error",
+			__func__);
+		goto cleanup;
+	}
 
 	for (cpu_idx = 0; cpu_idx < GLOBAL_STATE_num_cpus(driver_state);
 	     cpu_idx++) {
@@ -2686,6 +2691,7 @@ static VOID lwpmudrv_Read_MSR(PVOID param)
 		MSR_DATA_value(this_node) = msr_list[cpu_idx].entries[0].value;
 	}
 
+cleanup:
 	msr_list = CONTROL_Free_Memory(msr_list);
 #endif
 
@@ -2845,9 +2851,12 @@ static VOID lwpmudrv_Write_MSR(PVOID param)
 
 	BUG_ON(!virt_addr_valid(msr_list));
 
-	acrn_hypercall2(HC_PROFILING_OPS, PROFILING_MSR_OPS,
-			virt_to_phys(msr_list));
-
+	if (acrn_hypercall2(HC_PROFILING_OPS, PROFILING_MSR_OPS,
+			virt_to_phys(msr_list)) != OS_SUCCESS) {
+		SEP_DRV_LOG_ERROR(
+			"[ACRN][HC:MSR_OPS][%s]: returned with error",
+			__func__);
+	}
 	msr_list = CONTROL_Free_Memory(msr_list);
 #endif
 
@@ -4100,9 +4109,16 @@ static OS_STATUS lwpmudrv_Start(void)
 		BUG_ON(!virt_addr_valid(control));
 		control->collector_id = COLLECTOR_SEP;
 
-		acrn_hypercall2(HC_PROFILING_OPS, PROFILING_GET_CONTROL_SWITCH,
+		status = acrn_hypercall2(HC_PROFILING_OPS,
+				PROFILING_GET_CONTROL_SWITCH,
 				virt_to_phys(control));
-
+		if (status != OS_SUCCESS) {
+			SEP_DRV_LOG_ERROR_FLOW_OUT(
+			"[ACRN][HC:GET_CONTROL_SWITCH][%s]: Failed to get control switch info",
+			__func__);
+			control = CONTROL_Free_Memory(control);
+			return status;
+		}
 		SEP_DRV_LOG_TRACE("ACRN profiling collection running 0x%llx\n",
 				control->switches);
 
@@ -4115,10 +4131,19 @@ static OS_STATUS lwpmudrv_Start(void)
 			control->switches |= (1 << CORE_PMU_COUNTING);
 		}
 
-		acrn_hypercall2(HC_PROFILING_OPS, PROFILING_SET_CONTROL_SWITCH,
+		status = acrn_hypercall2(HC_PROFILING_OPS,
+				PROFILING_SET_CONTROL_SWITCH,
 				virt_to_phys(control));
+
 		control = CONTROL_Free_Memory(control);
 
+		if (status != OS_SUCCESS) {
+			SEP_DRV_LOG_ERROR_FLOW_OUT(
+			"[ACRN][HC:SET_CONTROL_SWITCH][%s]: Failed to set control switch info",
+			__func__);
+			return status;
+		}
+
 		lwpmudrv_ACRN_Flush_Start_Timer();
 #endif
 
@@ -4145,6 +4170,7 @@ static OS_STATUS lwpmudrv_Start(void)
 	}
 
 	SEP_DRV_LOG_FLOW_OUT("Return value: %d", status);
+
 	return status;
 }
 
@@ -4235,6 +4261,7 @@ static OS_STATUS lwpmudrv_Prepare_Stop(void)
 #if !defined(DRV_SEP_ACRN_ON)
 	CONTROL_Invoke_Parallel(lwpmudrv_Pause_Op, NULL);
 #else
+
 	control = (struct profiling_control *)CONTROL_Allocate_Memory(
 		sizeof(struct profiling_control));
 	if (control == NULL) {
@@ -4246,8 +4273,12 @@ static OS_STATUS lwpmudrv_Prepare_Stop(void)
 	BUG_ON(!virt_addr_valid(control));
 	control->collector_id = COLLECTOR_SEP;
 
-	acrn_hypercall2(HC_PROFILING_OPS, PROFILING_GET_CONTROL_SWITCH,
-			virt_to_phys(control));
+	if (acrn_hypercall2(HC_PROFILING_OPS, PROFILING_GET_CONTROL_SWITCH,
+			virt_to_phys(control)) != OS_SUCCESS) {
+		SEP_DRV_LOG_ERROR(
+		"[ACRN][HC:GET_CONTROL_SWITCH][%s]: Failed to get control info",
+		__func__);
+	}
 
 	SEP_DRV_LOG_TRACE("ACRN profiling collection running 0x%llx\n",
 			control->switches);
@@ -4259,10 +4290,13 @@ static OS_STATUS lwpmudrv_Prepare_Stop(void)
 		control->switches &= ~(1 << CORE_PMU_COUNTING);
 	}
 
-	acrn_hypercall2(HC_PROFILING_OPS, PROFILING_SET_CONTROL_SWITCH,
-			virt_to_phys(control));
+	if (acrn_hypercall2(HC_PROFILING_OPS, PROFILING_SET_CONTROL_SWITCH,
+			virt_to_phys(control)) != OS_SUCCESS) {
+		SEP_DRV_LOG_ERROR(
+		"[ACRN][HC:SET_CONTROL_SWITCH][%s]: Failed to set control info",
+		__func__);
+	}
 	control = CONTROL_Free_Memory(control);
-
 	lwpmudrv_ACRN_Flush_Stop_Timer();
         SEP_DRV_LOG_TRACE("Calling final PMI_Buffer_Handler\n");
 
@@ -5953,6 +5987,83 @@ static OS_STATUS lwpmudrv_Control_Driver_Log(IOCTL_ARGS args)
 	return OS_SUCCESS;
 }
 
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn          U64 lwpmudrv_Get_Sample_Drop_Info
+ *
+ * @brief       Get the information of dropped samples
+ *
+ * @param arg   Pointer to the IOCTL structure
+ *
+ * @return      status
+ *
+ * <I>Special Notes:</I>
+ *              <NONE>
+ */
+static OS_STATUS lwpmudrv_Get_Sample_Drop_Info(IOCTL_ARGS args)
+{
+	U32 size;
+	static SAMPLE_DROP_INFO_NODE req_sample_drop_info;
+#if defined(DRV_SEP_ACRN_ON)
+	U32 i;
+	struct profiling_status *stats = NULL;
+#endif
+	size = 0;
+	if (args->buf_drv_to_usr == NULL) {
+		return OS_INVALID;
+	}
+	if (args->len_drv_to_usr != sizeof(SAMPLE_DROP_INFO_NODE)) {
+		return OS_INVALID;
+	}
+
+	memset((char *)&req_sample_drop_info, 0, sizeof(SAMPLE_DROP_INFO_NODE));
+#if defined(DRV_SEP_ACRN_ON)
+	stats = (struct profiling_status *)CONTROL_Allocate_Memory(
+		GLOBAL_STATE_num_cpus(driver_state)*sizeof(struct profiling_status));
+
+	if (stats == NULL) {
+		SEP_PRINT_ERROR("lwpmudrv_Start: Unable to allocate memory\n");
+		return OS_NO_MEM;
+	}
+	memset(stats, 0, GLOBAL_STATE_num_cpus(driver_state)*
+		sizeof(struct profiling_status));
+
+	if (acrn_hypercall2(HC_PROFILING_OPS, PROFILING_GET_STATUS,
+		virt_to_phys(stats)) != OS_SUCCESS) {
+		stats = CONTROL_Free_Memory(stats);
+		SEP_DRV_LOG_ERROR_FLOW_OUT(
+		"[ACRN][HC:GET_STATUS][%s]: Failed to get sample drop info",
+		__func__);
+		return OS_INVALID;
+	}
+
+	for (i = 0; i < GLOBAL_STATE_num_cpus(driver_state)
+		&& size < MAX_SAMPLE_DROP_NODES; i++) {
+		if (stats[i].samples_logged || stats[i].samples_dropped) {
+			SAMPLE_DROP_INFO_drop_info(
+				&req_sample_drop_info, size).os_id = OS_ID_ACRN;
+			SAMPLE_DROP_INFO_drop_info(
+				&req_sample_drop_info, size).cpu_id = i;
+			SAMPLE_DROP_INFO_drop_info(
+				&req_sample_drop_info, size).sampled = stats[i].samples_logged;
+			SAMPLE_DROP_INFO_drop_info(
+				&req_sample_drop_info, size).dropped = stats[i].samples_dropped;
+			size++;
+		}
+	}
+
+	stats = CONTROL_Free_Memory(stats);
+#endif
+	SAMPLE_DROP_INFO_size(&req_sample_drop_info) = size;
+
+	if (copy_to_user((void __user *)args->buf_drv_to_usr,
+		&req_sample_drop_info, args->len_drv_to_usr)) {
+		return OS_FAULT;
+	}
+
+	return OS_SUCCESS;
+}
+
 /* ------------------------------------------------------------------------- */
 /*!
  * @fn          U64 lwpmudrv_Get_Drv_Setup_Info
@@ -6110,6 +6221,9 @@ static OS_STATUS lwpmudrv_Get_Drv_Setup_Info(IOCTL_ARGS args)
 			DRV_SETUP_INFO_PTI_KPTI;
 	}
 #endif
+#if defined(DRV_SEP_ACRN_ON)
+	DRV_SETUP_INFO_core_event_mux_unavailable(&req_drv_setup_info) = 1;
+#endif
 
 	SEP_DRV_LOG_TRACE("DRV_SETUP_INFO nmi_mode %d.",
 			  DRV_SETUP_INFO_nmi_mode(&req_drv_setup_info));
@@ -6295,9 +6409,13 @@ static OS_STATUS lwpmudrv_Get_Num_Of_Vms(IOCTL_ARGS args)
 
 	BUG_ON(!virt_addr_valid(vm_info_list));
 
-	acrn_hypercall2(HC_PROFILING_OPS, PROFILING_GET_VMINFO,
-			virt_to_phys(vm_info_list));
-
+	if (acrn_hypercall2(HC_PROFILING_OPS, PROFILING_GET_VMINFO,
+			virt_to_phys(vm_info_list)) != OS_SUCCESS) {
+		SEP_DRV_LOG_ERROR_FLOW_OUT(
+		"[ACRN][HC:GET_VMINFO][%s]: Failed to get VM info",
+		__func__);
+		return OS_INVALID;
+	}
 	vm_map.num_vms = 0;
 	for (i = 0; i < vm_info_list->num_vms; i++) {
 		if (vm_info_list->vm_list[i].num_vcpus != 0) {
@@ -6684,7 +6802,7 @@ static IOCTL_OP_TYPE lwpmu_Service_IOCTL(IOCTL_USE_INODE struct file *filp,
 		break;
 
 	case DRV_OPERATION_SET_OSID:
-		SEP_DRV_LOG_TRACE("LWPMUDRV_IOCTL_SET_OSID\n");
+		SEP_DRV_LOG_TRACE("DRV_OPERATION_IOCTL_SET_OSID\n");
 		status = lwpmudrv_Set_OSID(&local_args);
 		break;
 
@@ -6797,6 +6915,11 @@ static IOCTL_OP_TYPE lwpmu_Service_IOCTL(IOCTL_USE_INODE struct file *filp,
 		status = lwpmudrv_Flush();
 		break;
 
+	case DRV_OPERATION_GET_SAMPLE_DROP_INFO:
+		SEP_PRINT_DEBUG("DRV_OPERATION_IOCTL_GET_SAMPLE_DROP_INFO\n");
+		status = lwpmudrv_Get_Sample_Drop_Info(&local_args);
+		break;
+
 	case DRV_OPERATION_SET_EMON_BUFFER_DRIVER_HELPER:
 		SEP_DRV_LOG_TRACE(
 			"DRV_OPERATION_SET_EMON_BUFFER_DRIVER_HELPER.");
@@ -7216,8 +7339,14 @@ static int lwpmu_Load(void)
 
 	BUG_ON(!virt_addr_valid(vm_info_list));
 
-	acrn_hypercall2(HC_PROFILING_OPS, PROFILING_GET_VMINFO,
+	status = acrn_hypercall2(HC_PROFILING_OPS, PROFILING_GET_VMINFO,
 			virt_to_phys(vm_info_list));
+	if (status != OS_SUCCESS) {
+		SEP_DRV_LOG_ERROR_FLOW_OUT(
+		"[ACRN][HC:GET_VMINFO][%s]: Failed to get VM information",
+		__func__);
+		return OS_INVALID;
+	}
 #endif
 
 #if !defined(CONFIG_XEN_HAVE_VPMU)
diff --git a/drivers/platform/x86/sepdk/sep/perfver4.c b/drivers/platform/x86/sepdk/sep/perfver4.c
index ae8fa717f4bf..7995c3d20f49 100755
--- a/drivers/platform/x86/sepdk/sep/perfver4.c
+++ b/drivers/platform/x86/sepdk/sep/perfver4.c
@@ -409,9 +409,12 @@ static VOID perfver4_Write_PMU(VOID *param)
 
 	BUG_ON(!virt_addr_valid(pmi_config));
 
-	acrn_hypercall2(HC_PROFILING_OPS, PROFILING_CONFIG_PMI,
-			virt_to_phys(pmi_config));
-
+	if (acrn_hypercall2(HC_PROFILING_OPS, PROFILING_CONFIG_PMI,
+			virt_to_phys(pmi_config)) != OS_SUCCESS) {
+		SEP_DRV_LOG_ERROR(
+			"[ACRN][HC:CONFIG_PMI][%s]: Failed to write PMI config info",
+			__func__);
+	}
 	pmi_config = CONTROL_Free_Memory(pmi_config);
 #endif
 
@@ -767,9 +770,14 @@ static void perfver4_Read_PMU_Data(PVOID param)
 
 		BUG_ON(!virt_addr_valid(msr_list));
 
-		acrn_hypercall2(HC_PROFILING_OPS, PROFILING_MSR_OPS,
-				virt_to_phys(msr_list));
-
+		if (acrn_hypercall2(HC_PROFILING_OPS, PROFILING_MSR_OPS,
+				virt_to_phys(msr_list)) != OS_SUCCESS) {
+			msr_list = CONTROL_Free_Memory(msr_list);
+			SEP_DRV_LOG_ERROR_FLOW_OUT(
+			"[ACRN][HC:MSR_OPS][%s]: MSR operation failed",
+			__func__);
+			return;
+		}
 		for (cpu_idx = 0; cpu_idx < GLOBAL_STATE_num_cpus(driver_state);
 		     cpu_idx++) {
 			pcpu = &pcb[cpu_idx];
diff --git a/drivers/platform/x86/sepdk/sep/utility.c b/drivers/platform/x86/sepdk/sep/utility.c
index cc4f0cba5e9e..65fa379ff0a8 100755
--- a/drivers/platform/x86/sepdk/sep/utility.c
+++ b/drivers/platform/x86/sepdk/sep/utility.c
@@ -126,8 +126,13 @@ VOID UTILITY_Read_Cpuid(U64 cpuid_function, U64 *rax_value,
 
 		BUG_ON(!virt_addr_valid(&pcpuid));
 
-		acrn_hypercall2(HC_PROFILING_OPS, PROFILING_GET_PCPUID,
-				virt_to_phys(&pcpuid));
+		if (acrn_hypercall2(HC_PROFILING_OPS, PROFILING_GET_PCPUID,
+				virt_to_phys(&pcpuid)) != OS_SUCCESS) {
+			SEP_DRV_LOG_ERROR_FLOW_OUT(
+				"[ACRN][HC:GET_PCPUID][%s]: Failed to get CPUID info",
+				__func__);
+			return;
+		}
 
 		if (rax_value != NULL) {
 			*rax_value = pcpuid.eax;
-- 
2.17.1

