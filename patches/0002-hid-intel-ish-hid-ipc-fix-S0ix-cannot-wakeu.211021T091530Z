From 2347725680a27d8f206f97bec068a8b4be6a907d Mon Sep 17 00:00:00 2001
From: Even Xu <even.xu@intel.com>
Date: Wed, 13 Oct 2021 10:02:47 +0800
Subject: [PATCH 2/3] hid: intel-ish-hid: ipc: fix S0ix cannot wakeup issue

After implementation RTD3 on EHL, IPC device will be put into D3,
so need to add wake capability from D3 to let IPC device can wake
system from S0ix.

Signed-off-by: Even Xu <even.xu@intel.com>
---
 drivers/hid/intel-ish-hid/ipc/ipc.c     | 10 ++++--
 drivers/hid/intel-ish-hid/ipc/pci-ish.c | 42 +++++++++++++++----------
 2 files changed, 34 insertions(+), 18 deletions(-)

diff --git a/drivers/hid/intel-ish-hid/ipc/ipc.c b/drivers/hid/intel-ish-hid/ipc/ipc.c
index a8a0d9b1372d..416e09c13244 100644
--- a/drivers/hid/intel-ish-hid/ipc/ipc.c
+++ b/drivers/hid/intel-ish-hid/ipc/ipc.c
@@ -1081,11 +1081,14 @@ int ish_notify_d0(struct ishtp_device *dev)
 
 	dev->d0_flag = POWER_NOTIFY_WAIT;
 
+wait:
 	ret = wait_event_interruptible_timeout(dev->d0_wait,
 			(dev->d0_flag != POWER_NOTIFY_WAIT),
 			msecs_to_jiffies(WAIT_FOR_D0_RTD3_ACK_MS));
+	if (ret < 0)
+		goto wait;
 
-	if (!ret || dev->d0_flag == POWER_NOTIFY_WAIT) {
+	if (dev->d0_flag == POWER_NOTIFY_WAIT) {
 		dev_err(dev->devc, "wait fw back to d0 timeout\n");
 		return -EBUSY;
 	} else if (dev->d0_flag == POWER_NOTIFY_NOT_READY) {
@@ -1106,11 +1109,14 @@ int ish_notify_rtd3(struct ishtp_device *dev)
 
 	dev->rtd3_flag = POWER_NOTIFY_WAIT;
 
+wait:
 	ret = wait_event_interruptible_timeout(dev->rtd3_wait,
 			(dev->rtd3_flag != POWER_NOTIFY_WAIT),
 			msecs_to_jiffies(WAIT_FOR_D0_RTD3_ACK_MS));
+	if (ret < 0)
+		goto wait;
 
-	if (!ret || dev->rtd3_flag == POWER_NOTIFY_WAIT) {
+	if (dev->rtd3_flag == POWER_NOTIFY_WAIT) {
 		dev_err(dev->devc, "wait fw enter RTD3 timeout\n");
 		return -EBUSY;
 	} else if (dev->rtd3_flag == POWER_NOTIFY_NOT_READY) {
diff --git a/drivers/hid/intel-ish-hid/ipc/pci-ish.c b/drivers/hid/intel-ish-hid/ipc/pci-ish.c
index 164da26fba6e..958e4c0532c6 100644
--- a/drivers/hid/intel-ish-hid/ipc/pci-ish.c
+++ b/drivers/hid/intel-ish-hid/ipc/pci-ish.c
@@ -79,14 +79,10 @@ static int ish_init(struct ishtp_device *dev)
 {
 	int ret;
 
-	/* during initializaion, runtime suspend is forbidden */
-	pm_runtime_forbid(dev->devc);
-
 	/* Set the state of ISH HW to start */
 	ret = ish_hw_start(dev);
 	if (ret) {
 		dev_err(dev->devc, "ISH: hw start failed.\n");
-		pm_runtime_allow(dev->devc);
 		return ret;
 	}
 
@@ -94,12 +90,9 @@ static int ish_init(struct ishtp_device *dev)
 	ret = ishtp_start(dev);
 	if (ret) {
 		dev_err(dev->devc, "ISHTP: Protocol init failed.\n");
-		pm_runtime_allow(dev->devc);
 		return ret;
 	}
 
-	pm_runtime_allow(dev->devc);
-
 	return 0;
 }
 
@@ -227,8 +220,11 @@ static int ish_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	init_waitqueue_head(&ishtp->rtd3_wait);
 
 	/* Enable PME for EHL */
-	if (pdev->device == EHL_Ax_DEVICE_ID)
+	if (pdev->device == EHL_Ax_DEVICE_ID) {
+		pci_d3cold_disable(pdev);
+		device_init_wakeup(dev, true);
 		enable_pme_wake(pdev);
+	}
 
 	ret = ish_init(ishtp);
 	if (ret)
@@ -283,19 +279,24 @@ static void __maybe_unused ish_resume_handler(struct work_struct *work)
 	uint32_t fwsts = dev->ops->get_fw_status(dev);
 	int ret;
 
-	if (ish_should_leave_d0i3(pdev) && !dev->suspend_flag
-			&& IPC_IS_ISH_ILUP(fwsts)) {
+	if (ish_should_leave_d0i3(pdev) && !dev->suspend_flag) {
 		disable_irq_wake(pdev->irq);
 
 		ish_set_host_ready(dev);
 
-		ishtp_send_resume(dev);
+		/* Send D0 notify to call fw back */
+		if (dev->pdev->device == EHL_Ax_DEVICE_ID)
+			ish_notify_d0(dev);
 
-		/* Waiting to get resume response */
-		if (dev->resume_flag)
-			ret = wait_event_interruptible_timeout(dev->resume_wait,
-				!dev->resume_flag,
-				msecs_to_jiffies(WAIT_FOR_RESUME_ACK_MS));
+		if (IPC_IS_ISH_ILUP(fwsts)) {
+			ishtp_send_resume(dev);
+
+			/* Waiting to get resume response */
+			if (dev->resume_flag)
+				ret = wait_event_interruptible_timeout(dev->resume_wait,
+					!dev->resume_flag,
+					msecs_to_jiffies(WAIT_FOR_RESUME_ACK_MS));
+		}
 
 		/*
 		 * If the flag is not cleared, something is wrong with ISH FW.
@@ -356,6 +357,15 @@ static int __maybe_unused ish_suspend(struct device *device)
 			 */
 			if (dev->pdev->device != EHL_Ax_DEVICE_ID)
 				pci_save_state(pdev);
+			else {
+				/* For no Sx suspend case, need send RTD3 notify to keep
+				 * wake capability */
+				int ret = ish_notify_rtd3(dev);
+				if (ret)
+					return ret;
+
+				pci_wake_from_d3(pdev, true);
+			}
 
 			enable_irq_wake(pdev->irq);
 		}
-- 
2.17.1

