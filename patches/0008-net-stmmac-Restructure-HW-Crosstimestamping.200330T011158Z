From 5e2e6a71d5bd8f37bb6d5ffff5bd9e617cbfed56 Mon Sep 17 00:00:00 2001
From: "Wong, Vee Khee" <vee.khee.wong@intel.com>
Date: Thu, 19 Mar 2020 19:13:43 +0800
Subject: [PATCH 8/9] net: stmmac: Restructure HW Crosstimestamping to use MAC
 ISR

Update the implementation of HW crosstimestamping to use the MAC
interrupt service routine instead of polling for TSIS bit in the
MAC_Timestamp_Interrut_Status register to be set. Also, remove
unnecessary checking of MDIO Interrupt enabled.

Signed-off-by: Wong, Vee Khee <vee.khee.wong@intel.com>
Signed-off-by: Voon Weifeng <weifeng.voon@intel.com>
---
 drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c   |  6 ++++--
 drivers/net/ethernet/stmicro/stmmac/stmmac.h        |  1 +
 .../net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c   |  5 +++++
 drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c    |  1 +
 drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c    | 13 ++++++-------
 include/linux/stmmac.h                              |  3 ++-
 6 files changed, 19 insertions(+), 10 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
index 07e849f0a890..e31e2ae0aca9 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
@@ -28,9 +28,8 @@ static void dwmac4_core_init(struct mac_device_info *hw,
 	void __iomem *ioaddr = hw->pcsr;
 	u32 value = readl(ioaddr + GMAC_CONFIG);
 	int mtu = dev->mtu;
-#ifdef CONFIG_STMMAC_NETWORK_PROXY
 	struct stmmac_priv *priv = netdev_priv(dev);
-
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
 	if (!priv->networkproxy_exit) {
 #endif
 		value |= GMAC_CORE_INIT;
@@ -75,6 +74,9 @@ static void dwmac4_core_init(struct mac_device_info *hw,
 		value |= GMAC_INT_FPE_EN;
 
 	writel(value, ioaddr + GMAC_INT_EN);
+
+	if (GMAC_INT_DEFAULT_ENABLE & GMAC_INT_TSIE)
+		init_waitqueue_head(&priv->tstamp_busy_wait);
 }
 
 void dwmac4_mac_start_tx(void __iomem *ioaddr)
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index 5928c83c00e5..5e896e80beb5 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -189,6 +189,7 @@ struct stmmac_priv {
 	struct device *device;
 	struct mac_device_info *hw;
 	int (*hwif_quirks)(struct stmmac_priv *priv);
+	wait_queue_head_t tstamp_busy_wait;
 	struct mutex lock;
 	int hwts_all;
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c
index 8946001ed0a1..6bdc65df6df6 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c
@@ -204,6 +204,11 @@ static void tstamp_interrupt(struct stmmac_priv *priv)
 	u64 ptp_time;
 	int i;
 
+	if (priv->plat->int_snapshot_en) {
+		wake_up(&priv->tstamp_busy_wait);
+		return;
+	}
+
 	tsync_int = readl(priv->ioaddr + GMAC_INT_STATUS) &
 			  GMAC_INT_TSIE;
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
index 46965fa94b78..7d35d662fa82 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -312,6 +312,7 @@ static int intel_mgbe_common_data(struct pci_dev *pdev,
 
 	plat->int_snapshot_num = AUX_SNAPSHOT1;
 	plat->ext_snapshot_num = AUX_SNAPSHOT0;
+	plat->int_snapshot_en = 0;
 	plat->ext_snapshot_en = 0;
 
 	return 0;
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c
index 71ffa3060422..19518edceced 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c
@@ -219,9 +219,10 @@ static int stmmac_get_syncdevicetime(ktime_t *device,
 	u32 acr_value;
 	u64 art_time;
 	u64 ptp_time;
-	u32 v;
 	int i;
 
+	priv->plat->int_snapshot_en = 1;
+
 	/* Enable Internal snapshot trigger */
 	acr_value = readl(ptpaddr + PTP_ACR);
 	acr_value &= ~PTP_ACR_MASK;
@@ -259,12 +260,8 @@ static int stmmac_get_syncdevicetime(ktime_t *device,
 	writel(gpio_value, ioaddr + GMAC_GPIO_STATUS);
 
 	/* Time sync done Indication - Interrupt method */
-	if (priv->hw->mdio_intr_en) {
-		if (!wait_event_timeout(priv->hw->mdio_busy_wait,
-					stmmac_cross_ts_isr(priv), HZ / 100))
-			return -ETIMEDOUT;
-	} else if (readl_poll_timeout(priv->ioaddr + GMAC_INT_STATUS, v,
-				     (v & GMAC_INT_TSIE), 100, 10000))
+	if (!wait_event_timeout(priv->tstamp_busy_wait,
+				stmmac_cross_ts_isr(priv), HZ / 100))
 		return -ETIMEDOUT;
 
 	num_snapshot = (readl(ioaddr + GMAC_TIMESTAMP_STATUS) &
@@ -283,6 +280,8 @@ static int stmmac_get_syncdevicetime(ktime_t *device,
 		*system = convert_art_to_tsc(art_time);
 	}
 
+	priv->plat->int_snapshot_en = 0;
+
 	/* In the case of PSE Local ART, it might be running different frequency
 	 * compared to the PMC ART, so we will need to perform a multiplication
 	 * to match the PMC ART frequency.
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
index 6391537b6c86..d5f0c4900451 100644
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -233,8 +233,9 @@ struct plat_stmmacenet_data {
 	bool has_art;
 	int pmc_art_to_pse_art_ratio;
 	int int_snapshot_num;
+	bool int_snapshot_en;
 	int ext_snapshot_num;
-	int ext_snapshot_en;
+	bool ext_snapshot_en;
 	bool has_safety_feat;
 	bool is_hfpga;
 	bool is_pse;
-- 
2.17.1

