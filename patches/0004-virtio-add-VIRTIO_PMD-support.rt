From 400f6a452764b1ec485f56932b1013fa6f7bae86 Mon Sep 17 00:00:00 2001
From: Jian Jun Chen <jian.jun.chen@intel.com>
Date: Thu, 6 Jun 2019 02:18:23 +0000
Subject: [PATCH 04/20] virtio: add VIRTIO_PMD support

add polling mode support to virtio framework by using
timer to poll the availability of virtqueues. If
CONFIG_VIRTIO_PMD is enabled, the following virtio
devices will use polling mode instead of interrupt mode:
virtio-blk/virtio-net/virtio-console/virtio-input/virtio-rng

Tracked-On: projectacrn/acrn-hypervisor#3237
Signed-off-by: Gao Junhao <junhao.gao@intel.com>
Signed-off-by: Jian Jun Chen <jian.jun.chen@intel.com>
Reviewed-by: Zhao Yakui <yakui.zhao@intel.com>
Signed-off-by: florent pirou <florent.pirou@intel.com>
---
 drivers/block/virtio_blk.c          |  3 ++
 drivers/char/hw_random/virtio-rng.c |  3 ++
 drivers/char/virtio_console.c       |  3 ++
 drivers/net/virtio_net.c            |  3 ++
 drivers/virtio/Kconfig              |  9 ++++
 drivers/virtio/virtio.c             | 79 +++++++++++++++++++++++++++++
 drivers/virtio/virtio_input.c       |  3 ++
 drivers/virtio/virtio_ring.c        | 58 +++++++++++++++++----
 include/linux/virtio.h              | 21 ++++++++
 include/linux/virtio_config.h       | 11 ++++
 10 files changed, 183 insertions(+), 10 deletions(-)

diff --git a/drivers/block/virtio_blk.c b/drivers/block/virtio_blk.c
index fd6c565f8a50..d5f362e06284 100644
--- a/drivers/block/virtio_blk.c
+++ b/drivers/block/virtio_blk.c
@@ -1650,6 +1650,9 @@ static struct virtio_driver virtio_blk = {
 	.feature_table_size_legacy	= ARRAY_SIZE(features_legacy),
 	.driver.name			= KBUILD_MODNAME,
 	.id_table			= id_table,
+#ifdef CONFIG_VIRTIO_PMD
+	.polling_mode			= true,
+#endif
 	.probe				= virtblk_probe,
 	.remove				= virtblk_remove,
 	.config_changed			= virtblk_config_changed,
diff --git a/drivers/char/hw_random/virtio-rng.c b/drivers/char/hw_random/virtio-rng.c
index dd998f4fe4f2..4f7b78e0f8a3 100644
--- a/drivers/char/hw_random/virtio-rng.c
+++ b/drivers/char/hw_random/virtio-rng.c
@@ -246,6 +246,9 @@ static const struct virtio_device_id id_table[] = {
 static struct virtio_driver virtio_rng_driver = {
 	.driver.name =	KBUILD_MODNAME,
 	.id_table =	id_table,
+#ifdef CONFIG_VIRTIO_PMD
+	.polling_mode = true,
+#endif
 	.probe =	virtrng_probe,
 	.remove =	virtrng_remove,
 	.scan =		virtrng_scan,
diff --git a/drivers/char/virtio_console.c b/drivers/char/virtio_console.c
index abcfdd3c2918..39e65389b04a 100644
--- a/drivers/char/virtio_console.c
+++ b/drivers/char/virtio_console.c
@@ -2167,6 +2167,9 @@ static struct virtio_driver virtio_console = {
 	.feature_table_size = ARRAY_SIZE(features),
 	.driver.name =	KBUILD_MODNAME,
 	.id_table =	id_table,
+#ifdef CONFIG_VIRTIO_PMD
+	.polling_mode =	true,
+#endif
 	.probe =	virtcons_probe,
 	.remove =	virtcons_remove,
 	.config_changed = config_intr,
diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 0408c21bb122..0b1e33d8df88 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -6959,6 +6959,9 @@ static struct virtio_driver virtio_net_driver = {
 	.driver.name =	KBUILD_MODNAME,
 	.id_table =	id_table,
 	.validate =	virtnet_validate,
+#ifdef CONFIG_VIRTIO_PMD
+	.polling_mode =	true,
+#endif
 	.probe =	virtnet_probe,
 	.remove =	virtnet_remove,
 	.config_changed = virtnet_config_changed,
diff --git a/drivers/virtio/Kconfig b/drivers/virtio/Kconfig
index 42a48ac763ee..ac2631410cf0 100644
--- a/drivers/virtio/Kconfig
+++ b/drivers/virtio/Kconfig
@@ -188,4 +188,13 @@ config VIRTIO_DEBUG
 
 	  If unsure, say N.
 
+config VIRTIO_PMD
+	bool "Enable polling mode for virtio devices"
+	default n
+	depends on VIRTIO
+	help
+	 This option enables polling mode for virtio devices including
+	 virtio-net, virtio-blk, virtio-console and virtio-input devices.
+
+	 If unsure, say 'N'.
 endif # VIRTIO_MENU
diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c
index b9095751e43b..27b94d79dd9a 100644
--- a/drivers/virtio/virtio.c
+++ b/drivers/virtio/virtio.c
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 #include <linux/virtio.h>
 #include <linux/spinlock.h>
+#include <linux/virtio_ring.h>
 #include <linux/virtio_config.h>
 #include <linux/virtio_anchor.h>
 #include <linux/module.h>
@@ -71,6 +72,13 @@ static struct attribute *virtio_dev_attrs[] = {
 };
 ATTRIBUTE_GROUPS(virtio_dev);
 
+#ifdef CONFIG_VIRTIO_PMD
+static unsigned long virtio_polling_interval = 10000000UL;
+module_param(virtio_polling_interval, ulong, 0644);
+MODULE_PARM_DESC(virtio_polling_interval,
+	"virtio polling interval in ns. (default: 10000000)");
+#endif
+
 static inline int virtio_id_match(const struct virtio_device *dev,
 				  const struct virtio_device_id *id)
 {
@@ -267,6 +275,48 @@ void virtio_reset_device(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_reset_device);
 
+#ifdef CONFIG_VIRTIO_PMD
+static enum hrtimer_restart virtio_handle_polling_timer(struct hrtimer *t)
+{
+	struct virtio_device *dev = container_of(t, struct virtio_device,
+						 hr_timer);
+
+	virtio_poll_virtqueues(dev);
+	/* virtio_config_changed(dev); */
+	hrtimer_start(&dev->hr_timer, ns_to_ktime(virtio_polling_interval),
+		      HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+static inline void virtio_init_polling_timer(struct virtio_device *dev)
+{
+	if (virtio_polling_mode_enabled(dev)) {
+		hrtimer_init(&dev->hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		(dev->hr_timer).function = virtio_handle_polling_timer;
+	}
+}
+
+void virtio_start_polling_timer(struct virtio_device *dev)
+{
+	if (virtio_polling_mode_enabled(dev)) {
+		hrtimer_start(&dev->hr_timer,
+			ns_to_ktime(virtio_polling_interval), HRTIMER_MODE_REL);
+		dev_notice(&dev->dev, "start polling timer: %lu\n",
+			virtio_polling_interval);
+	}
+}
+EXPORT_SYMBOL_GPL(virtio_start_polling_timer);
+
+void virtio_stop_polling_timer(struct virtio_device *dev)
+{
+	if (virtio_polling_mode_enabled(dev)) {
+		hrtimer_cancel(&dev->hr_timer);
+		dev_notice(&dev->dev, "stop polling timer\n");
+	}
+}
+EXPORT_SYMBOL_GPL(virtio_stop_polling_timer);
+#endif
+
 static int virtio_dev_probe(struct device *_d)
 {
 	int err, i;
@@ -282,6 +332,13 @@ static int virtio_dev_probe(struct device *_d)
 	/* Figure out what features the device supports. */
 	device_features = dev->config->get_features(dev);
 
+#ifdef CONFIG_VIRTIO_PMD
+	if (virtio_polling_mode_enabled(dev)) {
+		device_features &= ~VIRTIO_F_NOTIFY_ON_EMPTY;
+		device_features &= ~VIRTIO_RING_F_EVENT_IDX;
+	}
+#endif
+
 	/* Figure out what features the driver supports. */
 	driver_features = 0;
 	for (i = 0; i < drv->feature_table_size; i++) {
@@ -338,6 +395,10 @@ static int virtio_dev_probe(struct device *_d)
 	if (err)
 		goto err;
 
+#ifdef CONFIG_VIRTIO_PMD
+	virtio_init_polling_timer(dev);
+#endif
+
 	err = drv->probe(dev);
 	if (err)
 		goto err;
@@ -354,6 +415,9 @@ static int virtio_dev_probe(struct device *_d)
 	return 0;
 
 err:
+#ifdef CONFIG_VIRTIO_PMD
+	virtio_stop_polling_timer(dev);
+#endif
 	virtio_add_status(dev, VIRTIO_CONFIG_S_FAILED);
 	return err;
 
@@ -366,6 +430,9 @@ static void virtio_dev_remove(struct device *_d)
 
 	virtio_config_core_disable(dev);
 
+#ifdef CONFIG_VIRTIO_PMD
+	virtio_stop_polling_timer(dev);
+#endif
 	drv->remove(dev);
 
 	/* Driver should have reset device. */
@@ -482,6 +549,10 @@ int register_virtio_device(struct virtio_device *dev)
 	INIT_LIST_HEAD(&dev->vqs);
 	spin_lock_init(&dev->vqs_list_lock);
 
+#ifdef CONFIG_VIRTIO_PMD
+	spin_lock_init(&dev->vq_lock);
+#endif
+
 	/* We always start by resetting the device, in case a previous
 	 * driver messed it up.  This also tests that code path a little. */
 	virtio_reset_device(dev);
@@ -535,6 +606,10 @@ int virtio_device_freeze(struct virtio_device *dev)
 
 	virtio_config_core_disable(dev);
 
+#ifdef CONFIG_VIRTIO_PMD
+	virtio_stop_polling_timer(dev);
+#endif
+
 	dev->failed = dev->config->get_status(dev) & VIRTIO_CONFIG_S_FAILED;
 
 	if (drv && drv->freeze) {
@@ -590,6 +665,10 @@ int virtio_device_restore(struct virtio_device *dev)
 	if (!(dev->config->get_status(dev) & VIRTIO_CONFIG_S_DRIVER_OK))
 		virtio_device_ready(dev);
 
+#ifdef CONFIG_VIRTIO_PMD
+	virtio_start_polling_timer(dev);
+#endif
+
 	virtio_config_core_enable(dev);
 
 	return 0;
diff --git a/drivers/virtio/virtio_input.c b/drivers/virtio/virtio_input.c
index a5d63269f20b..3742d3b91eb3 100644
--- a/drivers/virtio/virtio_input.c
+++ b/drivers/virtio/virtio_input.c
@@ -398,6 +398,9 @@ static struct virtio_driver virtio_input_driver = {
 	.feature_table       = features,
 	.feature_table_size  = ARRAY_SIZE(features),
 	.id_table            = id_table,
+#ifdef CONFIG_VIRTIO_PMD
+	.polling_mode        = true,
+#endif
 	.probe               = virtinput_probe,
 	.remove              = virtinput_remove,
 #ifdef CONFIG_PM_SLEEP
diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c
index 147926c8bae0..bffb79e3c113 100644
--- a/drivers/virtio/virtio_ring.c
+++ b/drivers/virtio/virtio_ring.c
@@ -914,13 +914,20 @@ static unsigned int virtqueue_enable_cb_prepare_split(struct virtqueue *_vq)
 	/* Depending on the VIRTIO_RING_F_EVENT_IDX feature, we need to
 	 * either clear the flags bit or point the event index at the next
 	 * entry. Always do both to keep code simple. */
-	if (vq->split.avail_flags_shadow & VRING_AVAIL_F_NO_INTERRUPT) {
-		vq->split.avail_flags_shadow &= ~VRING_AVAIL_F_NO_INTERRUPT;
-		if (!vq->event)
-			vq->split.vring.avail->flags =
-				cpu_to_virtio16(_vq->vdev,
+#ifdef CONFIG_VIRTIO_PMD
+	if (!virtio_polling_mode_enabled(_vq->vdev)) {
+#endif
+		if (vq->split.avail_flags_shadow & VRING_AVAIL_F_NO_INTERRUPT) {
+			vq->split.avail_flags_shadow &=
+				~VRING_AVAIL_F_NO_INTERRUPT;
+			if (!vq->event)
+				vq->split.vring.avail->flags =
+					cpu_to_virtio16(_vq->vdev,
 						vq->split.avail_flags_shadow);
+		}
+#ifdef CONFIG_VIRTIO_PMD
 	}
+#endif
 	vring_used_event(&vq->split.vring) = cpu_to_virtio16(_vq->vdev,
 			last_used_idx = vq->last_used_idx);
 	END_USE(vq);
@@ -947,13 +954,20 @@ static bool virtqueue_enable_cb_delayed_split(struct virtqueue *_vq)
 	/* Depending on the VIRTIO_RING_F_USED_EVENT_IDX feature, we need to
 	 * either clear the flags bit or point the event index at the next
 	 * entry. Always update the event index to keep code simple. */
-	if (vq->split.avail_flags_shadow & VRING_AVAIL_F_NO_INTERRUPT) {
-		vq->split.avail_flags_shadow &= ~VRING_AVAIL_F_NO_INTERRUPT;
-		if (!vq->event)
-			vq->split.vring.avail->flags =
-				cpu_to_virtio16(_vq->vdev,
+#ifdef CONFIG_VIRTIO_PMD
+	if (!virtio_polling_mode_enabled(_vq->vdev)) {
+#endif
+		if (vq->split.avail_flags_shadow & VRING_AVAIL_F_NO_INTERRUPT) {
+			vq->split.avail_flags_shadow &=
+				~VRING_AVAIL_F_NO_INTERRUPT;
+			if (!vq->event)
+				vq->split.vring.avail->flags =
+					cpu_to_virtio16(_vq->vdev,
 						vq->split.avail_flags_shadow);
+		}
+#ifdef CONFIG_VIRTIO_PMD
 	}
+#endif
 	/* TODO: tune this threshold */
 	bufs = (u16)(vq->split.avail_idx_shadow - vq->last_used_idx) * 3 / 4;
 
@@ -1009,7 +1023,11 @@ static void virtqueue_vring_init_split(struct vring_virtqueue_split *vring_split
 	vring_split->avail_idx_shadow = 0;
 
 	/* No callback?  Tell other side not to bother us. */
+#ifdef CONFIG_VIRTIO_PMD
+	if (!vq->vq.callback && virtio_polling_mode_enabled(vdev)) {
+#else
 	if (!vq->vq.callback) {
+#endif
 		vring_split->avail_flags_shadow |= VRING_AVAIL_F_NO_INTERRUPT;
 		if (!vq->event)
 			vring_split->vring.avail->flags = cpu_to_virtio16(vdev,
@@ -2611,6 +2629,7 @@ static struct virtqueue *__vring_new_virtqueue(unsigned int index,
 {
 	struct vring_virtqueue *vq;
 	int err;
+	bool disable_cb = (callback == NULL);
 
 	if (virtio_has_feature(vdev, VIRTIO_F_RING_PACKED))
 		return NULL;
@@ -2642,6 +2661,11 @@ static struct virtqueue *__vring_new_virtqueue(unsigned int index,
 		!context;
 	vq->event = virtio_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX);
 
+#ifdef CONFIG_VIRTIO_PMD
+	if (!disable_cb && virtio_polling_mode_enabled(vdev))
+		disable_cb = true;
+#endif
+
 	if (virtio_has_feature(vdev, VIRTIO_F_ORDER_PLATFORM))
 		vq->weak_barriers = false;
 
@@ -3254,5 +3278,19 @@ void virtqueue_dma_sync_single_range_for_device(struct virtqueue *_vq,
 }
 EXPORT_SYMBOL_GPL(virtqueue_dma_sync_single_range_for_device);
 
+#ifdef CONFIG_VIRTIO_PMD
+void virtio_poll_virtqueues(struct virtio_device *dev)
+{
+	struct virtqueue *_vq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->vq_lock, flags);
+	list_for_each_entry(_vq, &dev->vqs, list)
+		vring_interrupt(0, _vq);  /* parameter irq is not used */
+	spin_unlock_irqrestore(&dev->vq_lock, flags);
+}
+EXPORT_SYMBOL_GPL(virtio_poll_virtqueues);
+#endif
+
 MODULE_DESCRIPTION("Virtio ring implementation");
 MODULE_LICENSE("GPL");
diff --git a/include/linux/virtio.h b/include/linux/virtio.h
index d791d47eb00e..e41f750ac432 100644
--- a/include/linux/virtio.h
+++ b/include/linux/virtio.h
@@ -105,6 +105,9 @@ int virtqueue_resize(struct virtqueue *vq, u32 num,
 int virtqueue_reset(struct virtqueue *vq,
 		    void (*recycle)(struct virtqueue *vq, void *buf),
 		    void (*recycle_done)(struct virtqueue *vq));
+#ifdef CONFIG_VIRTIO_PMD
+void virtio_poll_virtqueues(struct virtio_device *dev);
+#endif
 
 struct virtio_admin_cmd {
 	__le16 opcode;
@@ -155,6 +158,10 @@ struct virtio_device {
 	struct dentry *debugfs_dir;
 	u64 debugfs_filter_features;
 #endif
+#ifdef CONFIG_VIRTIO_PMD
+	spinlock_t vq_lock;
+	struct hrtimer hr_timer;
+#endif
 };
 
 #define dev_to_virtio(_dev)	container_of_const(_dev, struct virtio_device, dev)
@@ -212,6 +219,9 @@ struct virtio_driver {
 	unsigned int feature_table_size;
 	const unsigned int *feature_table_legacy;
 	unsigned int feature_table_size_legacy;
+#ifdef CONFIG_VIRTIO_PMD
+	bool polling_mode;
+#endif
 	int (*validate)(struct virtio_device *dev);
 	int (*probe)(struct virtio_device *dev);
 	void (*scan)(struct virtio_device *dev);
@@ -227,6 +237,17 @@ struct virtio_driver {
 #define register_virtio_driver(drv) \
 	__register_virtio_driver(drv, THIS_MODULE)
 int __register_virtio_driver(struct virtio_driver *drv, struct module *owner);
+
+#ifdef CONFIG_VIRTIO_PMD
+void virtio_start_polling_timer(struct virtio_device *dev);
+void virtio_stop_polling_timer(struct virtio_device *dev);
+static inline bool virtio_polling_mode_enabled(struct virtio_device *dev)
+{
+	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
+
+	return drv->polling_mode;
+}
+#endif
 void unregister_virtio_driver(struct virtio_driver *drv);
 
 /* module_virtio_driver() - Helper macro for drivers that don't do
diff --git a/include/linux/virtio_config.h b/include/linux/virtio_config.h
index 169c7d367fac..deb49f02bab5 100644
--- a/include/linux/virtio_config.h
+++ b/include/linux/virtio_config.h
@@ -297,6 +297,17 @@ void virtio_device_ready(struct virtio_device *dev)
 	 * we won't lose any notification.
 	 */
 	dev->config->set_status(dev, status | VIRTIO_CONFIG_S_DRIVER_OK);
+
+#ifdef CONFIG_VIRTIO_PMD
+	/*
+	 * In polling mode, virtqueue interrupts are disabled from the
+	 * beginning. we must make sure the polling timer is started
+	 * just after the virtqueue is ready. When vring_create_virtqueue
+	 * is called the virtqueues are not ready. Start polling timer
+	 * when status is changed to DRIVER_OK is a good chance then.
+	 */
+	virtio_start_polling_timer(dev);
+#endif
 }
 
 static inline
-- 
2.34.1

