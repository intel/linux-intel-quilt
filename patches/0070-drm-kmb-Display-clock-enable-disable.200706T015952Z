From 394def21ea8ed1768edc97968286af24ca77b3d3 Mon Sep 17 00:00:00 2001
From: Anitha Chrisanthus <anitha.chrisanthus@intel.com>
Date: Fri, 23 Aug 2019 02:34:11 -0700
Subject: [PATCH 070/131] drm/kmb: Display clock enable/disable

Get clock info from DT and enable it during initialization.
Also changed name of the driver to "kmb,display" to match other
entries in the DT.

v2: fixed error in clk_disable

Signed-off-by: Anitha Chrisanthus <anitha.chrisanthus@intel.com>
Reviewed-by: Bob Paauwe <bob.j.paauwe@intel.com>
---
 drivers/gpu/drm/kmb/kmb_drv.c | 42 +++++++++++++++++++++++++++++++++--
 1 file changed, 40 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/kmb/kmb_drv.c b/drivers/gpu/drm/kmb/kmb_drv.c
index 28cc9a2d26ba..62ea67d18ccb 100644
--- a/drivers/gpu/drm/kmb/kmb_drv.c
+++ b/drivers/gpu/drm/kmb/kmb_drv.c
@@ -32,6 +32,7 @@
 #include <linux/of_graph.h>
 #include <linux/of_reserved_mem.h>
 #include <linux/pm_runtime.h>
+#include <linux/clk.h>
 #include <drm/drm.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc.h>
@@ -51,6 +52,25 @@
 /*IRQ handler*/
 static irqreturn_t kmb_isr(int irq, void *arg);
 
+static struct clk *clk_lcd;
+static struct clk *clk_mipi;
+
+static int kmb_display_clk_enable(void)
+{
+	clk_prepare_enable(clk_lcd);
+	clk_prepare_enable(clk_mipi);
+	return 0;
+}
+
+static int kmb_display_clk_disable(void)
+{
+	if (clk_lcd)
+		clk_disable_unprepare(clk_lcd);
+	if (clk_mipi)
+		clk_disable_unprepare(clk_mipi);
+	return 0;
+}
+
 static int kmb_load(struct drm_device *drm, unsigned long flags)
 {
 	struct kmb_drm_private *dev_p = drm->dev_private;
@@ -172,6 +192,19 @@ static int kmb_load(struct drm_device *drm, unsigned long flags)
 		goto setup_fail;
 	}
 
+	/* enable display clocks*/
+	clk_lcd = clk_get(&pdev->dev, "clk_lcd");
+	if (!clk_lcd) {
+		DRM_ERROR("clk_get() failed clk_lcd\n");
+		goto setup_fail;
+	}
+	clk_mipi = clk_get(&pdev->dev, "clk_mipi");
+	if (!clk_mipi) {
+		DRM_ERROR("clk_get() failed clk_mipi\n");
+		goto setup_fail;
+	}
+	kmb_display_clk_enable();
+
 	ret = drm_irq_install(drm, platform_get_irq(pdev, 0));
 	if (ret < 0) {
 		DRM_ERROR("failed to install IRQ handler\n");
@@ -398,6 +431,11 @@ static void kmb_drm_unbind(struct device *dev)
 	of_reserved_mem_device_release(drm->dev);
 	drm_mode_config_cleanup(drm);
 
+	/*release clks */
+	kmb_display_clk_disable();
+	clk_put(clk_lcd);
+	clk_put(clk_mipi);
+
 	drm_dev_put(drm);
 	drm->dev_private = NULL;
 	dev_set_drvdata(dev, NULL);
@@ -436,8 +474,8 @@ static int kmb_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct of_device_id kmb_of_match[] = {
-	{.compatible = "lcd"},
+static const struct of_device_id  kmb_of_match[] = {
+	{.compatible = "kmb,display"},
 	{},
 };
 
-- 
2.17.1

