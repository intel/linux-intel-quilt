From 6d471e283379c598cd3e1d6da2145565608705f8 Mon Sep 17 00:00:00 2001
From: Cliff Cai <cliff.cai@intel.com>
Date: Fri, 11 Jan 2019 03:50:35 +0000
Subject: [PATCH 7/9] keystore: add application authentication feature

The authentication feature will read the application corresponding
manifest file from user space and verify it before allowing the
application to access keystore.

Change-Id: Id89665c50508fb0b4b079721d0572dba438ac4de
Tracked-On: PKT-1668
Signed-off-by: Cliff Cai <cliff.cai@intel.com>
Signed-off-by: Zhou Furong <furong.zhou@intel.com>
---
 security/keystore/Kconfig                     |  21 +
 security/keystore/Makefile                    |  12 +
 security/keystore/api_dal.c                   |  13 +-
 security/keystore/appauth/app_auth.h          |  66 ++
 security/keystore/appauth/file_hash_verify.c  | 255 ++++++
 security/keystore/appauth/key_setup.c         |  96 ++
 security/keystore/appauth/manifest_cache.c    | 148 +++
 security/keystore/appauth/manifest_cache.h    |  56 ++
 security/keystore/appauth/manifest_parser.c   | 181 ++++
 security/keystore/appauth/manifest_parser.h   | 195 ++++
 security/keystore/appauth/manifest_read.c     | 107 +++
 .../keystore/appauth/manifest_sanity_check.c  | 227 +++++
 security/keystore/appauth/manifest_verify.c   | 204 +++++
 security/keystore/appauth/manifest_verify.h   |  28 +
 security/keystore/appauth/sign_verify.c       | 225 +++++
 security/keystore/client.c                    |  77 +-
 security/keystore/keystore_client.h           |   5 +
 security/keystore/oemkey/Kconfig              |  53 ++
 security/keystore/oemkey/Makefile             |   3 +
 security/keystore/oemkey/abl.h                |  55 ++
 security/keystore/oemkey/abl_cmdline.c        |  57 ++
 security/keystore/oemkey/abl_cmdline.h        |  28 +
 security/keystore/oemkey/abl_param.c          | 248 ++++++
 security/keystore/oemkey/manifest.c           | 839 ++++++++++++++++++
 security/keystore/oemkey/manifest.h           | 260 ++++++
 25 files changed, 3456 insertions(+), 3 deletions(-)
 create mode 100644 security/keystore/appauth/app_auth.h
 create mode 100644 security/keystore/appauth/file_hash_verify.c
 create mode 100644 security/keystore/appauth/key_setup.c
 create mode 100644 security/keystore/appauth/manifest_cache.c
 create mode 100644 security/keystore/appauth/manifest_cache.h
 create mode 100644 security/keystore/appauth/manifest_parser.c
 create mode 100644 security/keystore/appauth/manifest_parser.h
 create mode 100644 security/keystore/appauth/manifest_read.c
 create mode 100644 security/keystore/appauth/manifest_sanity_check.c
 create mode 100644 security/keystore/appauth/manifest_verify.c
 create mode 100644 security/keystore/appauth/manifest_verify.h
 create mode 100644 security/keystore/appauth/sign_verify.c
 create mode 100644 security/keystore/oemkey/Kconfig
 create mode 100644 security/keystore/oemkey/Makefile
 create mode 100644 security/keystore/oemkey/abl.h
 create mode 100644 security/keystore/oemkey/abl_cmdline.c
 create mode 100644 security/keystore/oemkey/abl_cmdline.h
 create mode 100644 security/keystore/oemkey/abl_param.c
 create mode 100644 security/keystore/oemkey/manifest.c
 create mode 100644 security/keystore/oemkey/manifest.h

diff --git a/security/keystore/Kconfig b/security/keystore/Kconfig
index 27e5ec346cb0..e1fb964dfd11 100644
--- a/security/keystore/Kconfig
+++ b/security/keystore/Kconfig
@@ -26,6 +26,27 @@ config KEYSTORE_DEBUG
 
 		If unsure, select "N".
 
+config APPLICATION_AUTH
+	bool "Application Auth using signed manifest"
+	depends on KEYSTORE && MANIFEST
+        default n
+	help
+		Enables authentication of keystore clients and other
+		applications using a signed manifest. In keystore
+		the manifest is verified during client registration.
+
+		If unsure, select "N".
+
+config APPLICATION_AUTH_MANIFEST_ROOT
+	string "Application Auth Manifest Root Directory"
+	depends on APPLICATION_AUTH
+	default "/opt/ias/etc/manifest"
+	help
+		The root directory for signed manifests of application
+		auth clients.
+
+source security/keystore/oemkey/Kconfig
+
 config DAL_KEYSTORE_APPLET_PATH
 	string "DAL Keystore Applet path"
 	depends on KEYSTORE
diff --git a/security/keystore/Makefile b/security/keystore/Makefile
index 2517283817ca..4dd30dde2987 100644
--- a/security/keystore/Makefile
+++ b/security/keystore/Makefile
@@ -5,6 +5,8 @@
 # Keystore module
 obj-$(CONFIG_KEYSTORE) := keystore.o
 
+obj-$(CONFIG_MANIFEST) += oemkey/
+
 # Otherwise, select the full file list
 keystore-$(CONFIG_KEYSTORE) +=\
 	keystore_kmod.o\
@@ -20,3 +22,13 @@ keystore-$(CONFIG_KEYSTORE) +=\
 
 keystore-$(CONFIG_KEYSTORE_DEBUG) +=\
 	debug.o
+
+keystore-$(CONFIG_APPLICATION_AUTH) +=\
+	appauth/file_hash_verify.o\
+	appauth/key_setup.o\
+	appauth/manifest_cache.o\
+	appauth/manifest_parser.o\
+	appauth/manifest_read.o\
+	appauth/manifest_verify.o\
+	appauth/manifest_sanity_check.o\
+	appauth/sign_verify.o
diff --git a/security/keystore/api_dal.c b/security/keystore/api_dal.c
index 5db0a7ea7e10..3a6b1c24de26 100644
--- a/security/keystore/api_dal.c
+++ b/security/keystore/api_dal.c
@@ -22,7 +22,9 @@
 #include "dal_context_safe.h"
 #include "keystore_client.h"
 #include "keystore_rand.h"
-
+#ifdef CONFIG_APPLICATION_AUTH
+#include "appauth/manifest_verify.h"
+#endif
 #include "dal_client.h"
 
 #define KEYSPEC_DAL_WRAPPED_KEY (165)
@@ -70,7 +72,14 @@ static int dal_keystore_close(void)
 static int dal_calc_clientid(u8 *client_id, const unsigned int client_id_size)
 {
 	/* Calculate the Client ID */
-	return keystore_calc_clientid(client_id, client_id_size);
+#ifdef CONFIG_APPLICATION_AUTH
+		return keystore_calc_clientid(client_id, client_id_size,
+						MANIFEST_CACHE_TTL,
+						MANIFEST_DEFAULT_CAPS);
+#else
+		return keystore_calc_clientid(client_id, client_id_size);
+#endif
+
 }
 
 static int dal_keystore_install_and_init(void)
diff --git a/security/keystore/appauth/app_auth.h b/security/keystore/appauth/app_auth.h
new file mode 100644
index 000000000000..966811ae7780
--- /dev/null
+++ b/security/keystore/appauth/app_auth.h
@@ -0,0 +1,66 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporatio. */
+#ifndef _APP_AUTH_H_
+#define _APP_AUTH_H_
+
+#include <linux/file.h>
+#include <linux/crypto.h>
+#include <linux/key-type.h>
+#include <linux/mpi.h>
+#include <linux/kernel.h>
+#include <linux/sched/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <crypto/hash.h>
+#include <crypto/hash_info.h>
+#include <crypto/public_key.h>
+#include <keys/asymmetric-type.h>
+#include <keys/system_keyring.h>
+#include <keys/asymmetric-subtype.h>
+#include "../../integrity/ima/ima.h"
+#include "../../crypto/asymmetric_keys/x509_parser.h"
+#include "manifest_verify.h"
+#include "../keystore_debug.h"
+
+#define  DEBUG_APPAUTH  APP_AUTH
+#define  DEBUG_APPAUTH_STR  "APP_AUTH"
+#define  APP_AUTH_DIGEST_MAX 64
+#define  manifest_hash_algo  HASH_ALGO_SHA1
+#define  manifest_default_hash_algo  HASH_ALGO_SHA1
+#define  default_sig_hash_algo HASH_ALGO_SHA256
+#define  KEYID_MAX_LEN 64
+/* maximum size of any files in the application */
+#define  MAX_FILE_SIZE (64 * 1024 * 1024)
+/* maximum length of the application manifest file */
+#define  MANIFEST_MAX_LEN 5000
+
+struct appauth_digest {
+	int algo;
+	unsigned int len;
+	unsigned char digest[APP_AUTH_DIGEST_MAX];
+};
+
+struct crypto_shash *appauth_alloc_tfm(enum hash_algo algo);
+
+void appauth_free_tfm(struct crypto_shash *tfm);
+
+int appauth_kernel_read(struct file *file, loff_t offset,
+				char *addr, unsigned long count);
+int read_manifest(const char *filename, char **manifest_buf, int *manifest_len);
+
+char *get_exe_name(char **buf);
+
+void debug_public_key(struct public_key *key);
+
+void appauth_free_buf(char **manifest_buf);
+
+int compute_file_hash(const char *filename, uint8_t *digest,
+					uint8_t digest_algo_id);
+
+const char *get_keyid_from_cert(struct x509_certificate *cert);
+
+int verify_manifest(const char *sig, const char *cert, const char *data,
+				int sig_len, int cert_len, int data_len);
+
+int manifest_sanity_check(char *manifest_buf, uint16_t manifest_len);
+#endif /* _APP_AUTH_H_ */
diff --git a/security/keystore/appauth/file_hash_verify.c b/security/keystore/appauth/file_hash_verify.c
new file mode 100644
index 000000000000..027771f90685
--- /dev/null
+++ b/security/keystore/appauth/file_hash_verify.c
@@ -0,0 +1,255 @@
+// SPDX-License-Identifier: GPL-2.0
+// Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporation.
+#include "app_auth.h"
+#include "manifest_parser.h"
+
+/**
+ * Allocates the crypto shash structure.
+ *
+ * @param algo         - hash algorithm.
+ *
+ * @return the pointer to the tfm.
+ */
+struct crypto_shash *appauth_alloc_tfm(enum hash_algo algo)
+{
+	struct crypto_shash *tfm = NULL;
+	int rc;
+
+	if (algo < 0 || algo >= HASH_ALGO__LAST)
+		algo = manifest_default_hash_algo;
+
+	tfm = crypto_alloc_shash(hash_algo_name[algo], 0, 0);
+	if (IS_ERR(tfm)) {
+		rc = PTR_ERR(tfm);
+		ks_err("Can not allocate %s (reason: %d)\n",
+				hash_algo_name[algo], rc);
+	}
+
+	return tfm;
+}
+
+/**
+ * Frees the crypto shash structure.
+ *
+ * @param tfm         - address of crypto shash structure.
+ *
+ */
+void appauth_free_tfm(struct crypto_shash *tfm)
+{
+	crypto_free_shash(tfm);
+}
+
+/**
+ * Reads specified number of bytes from the file.
+ *
+ * @param file         - file structure.
+ * @param offset       - offset in the file.
+ * @param addr         - address of the buffer.
+ * @param count        - size of the buffer .
+ *
+ * @return 0 if success or error code.
+ */
+int appauth_kernel_read(struct file *file, loff_t offset,
+				char *addr, unsigned long count)
+{
+	char __user *buf = (char __user *)addr;
+	ssize_t ret;
+
+	if (!(file->f_mode & FMODE_READ))
+		return -EBADF;
+
+	ret = kernel_read(file, buf, count, &offset);
+
+	return ret;
+}
+
+/**
+ * Calculate the hash of the file and store the result in 'hash'.
+ *
+ * @param file         - file structure.
+ * @param hash         - pointer to appauth_digest.
+ * @param tfm          - pointer to crypto shash structure.
+ *
+ * @return 0 if success or error code.
+ */
+static int appauth_calc_file_hash_tfm(struct file *file,
+		struct appauth_digest *hash, struct crypto_shash *tfm)
+{
+	loff_t i_size, offset = 0;
+	char *file_buf;
+	SHASH_DESC_ON_STACK(shash, tfm);
+	int rc, read = 0, count = 0;
+
+	if (!file || !hash)
+		return -EFAULT;
+
+	shash->tfm = tfm;
+	if (!shash->tfm)
+		return -EFAULT;
+	shash->flags = 0;
+
+	hash->len = crypto_shash_digestsize(tfm);
+
+	rc = crypto_shash_init(shash);
+	if (rc != 0) {
+		ks_err("DEBUG_APPAUTH: crypto_shash_init() failed\n");
+		return -HASH_FAILURE;
+	}
+
+	i_size = i_size_read(file_inode(file));
+	ks_debug("DEBUG_APPAUTH: file size = %lld\n", i_size);
+
+	if (i_size == 0)
+		goto out;
+
+	file_buf = kzalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!file_buf)
+		return -ENOMEM;
+
+	if (!(file->f_mode & FMODE_READ)) {
+		file->f_mode |= FMODE_READ;
+		read = 1;
+	}
+
+	while (offset < i_size) {
+		int file_buf_len;
+
+		file_buf_len = appauth_kernel_read(file, offset,
+						file_buf, PAGE_SIZE);
+		if (file_buf_len < 0) {
+			rc = file_buf_len;
+			break;
+		}
+		if (file_buf_len == 0)
+			break;
+		offset += file_buf_len;
+		count++;
+
+		rc = crypto_shash_update(shash, file_buf, file_buf_len);
+		if (rc)
+			break;
+	}
+	ks_debug("DEBUG_APPAUTH: count = %d\n", count);
+	if (read)
+		file->f_mode &= ~FMODE_READ;
+	kfree(file_buf);
+out:
+	if (!rc)
+		rc = crypto_shash_final(shash, hash->digest);
+	if (rc)
+		return -HASH_FAILURE;
+	return rc;
+}
+
+/**
+ * Calculate the hash of the file and store the result in 'hash'.
+ * Allocates and frees crypto tfm.
+ *
+ * @param file         - file structure.
+ * @param hash         - pointer to appauth_digest.
+ *
+ * @return 0 if success or error code (see enum APP_AUTH_ERROR).
+ */
+static int appauth_calc_file_shash(struct file *file,
+		struct appauth_digest *hash)
+{
+	struct crypto_shash *tfm;
+	int ret = 0;
+
+	if (!file || !hash)
+		return -EFAULT;
+
+	tfm = appauth_alloc_tfm(hash->algo);
+	if (IS_ERR(tfm)) {
+		ks_err("DEBUG_APPAUTH: appauth_alloc_tfm failed\n");
+		return -HASH_FAILURE;
+	}
+	ks_debug("DEBUG_APPAUTH: appauth_alloc_tfm succeeded\n");
+	ret = appauth_calc_file_hash_tfm(file, hash, tfm);
+
+	appauth_free_tfm(tfm);
+
+	return ret;
+}
+
+/**
+ * Calculate the hash of the file and store the result in 'hash'.
+ * Locks the file inode.
+ *
+ * @param file         - file structure.
+ * @param hash         - pointer to appauth_digest.
+ *
+ * @return 0 if success or error code (see enum APP_AUTH_ERROR).
+ */
+static int process_file(struct file *file, struct appauth_digest *hash)
+{
+	int result = 0;
+
+	ks_debug("DEBUG_APPAUTH: appauth_calc_file_shash() started\n");
+	ks_debug("DEBUG_APPAUTH: calling mutex_lock\n");
+	mutex_lock(&(file->f_pos_lock));
+	result = appauth_calc_file_shash(file, hash);
+	mutex_unlock(&(file->f_pos_lock));
+	ks_debug("DEBUG_APPAUTH: appauth_calc_file_shash() finished\n");
+	keystore_hexdump("", hash->digest, hash_digest_size[hash->algo]);
+	return result;
+}
+
+/**
+ * Converts the hash id to kernel crypto hash id's.
+ *
+ * @param digest_algo_id - hash id used in manifest file.
+ *
+ * @returns converted hash id, HASH_ALGO_SHA1 is the default.
+ */
+static int convert_hash_id(uint8_t digest_algo_id)
+{
+	if (DIGEST_ALGO_MD5)
+		return HASH_ALGO_MD5;
+	else if (DIGEST_ALGO_SHA1)
+		return HASH_ALGO_SHA1;
+	else if (DIGEST_ALGO_SHA224)
+		return HASH_ALGO_SHA224;
+	else if (DIGEST_ALGO_SHA384)
+		return HASH_ALGO_SHA384;
+	else if (DIGEST_ALGO_SHA512)
+		return HASH_ALGO_SHA512;
+	else
+		return HASH_ALGO_SHA1;
+}
+
+/**
+ * Computes the file hash and compares against the digest in the manifest.
+ *
+ * @param filename       - absolute path of the file.
+ * @param digest         - file digest presnt in the manifest file.
+ * @param digest_algo_id - hash id used in manifest file.
+ *
+ * @return 0,if success or error code.
+ */
+int compute_file_hash(const char *filename, uint8_t *digest,
+					    uint8_t digest_algo_id)
+{
+	struct file *file = 0;
+	struct appauth_digest hash;
+	int ret = 0;
+
+	file = filp_open(filename,  O_RDONLY, 0);
+
+	if (IS_ERR(file)) {
+		ks_err("DEBUG_APPAUTH: filp_open failed\n");
+		return -EBADF;
+	}
+	ks_debug("DEBUG_APPAUTH: filp_open succeeded\n");
+	hash.algo = convert_hash_id(digest_algo_id);
+	ret = process_file(file, &hash);
+	filp_close(file, NULL);
+	if (ret < 0)
+		return ret;
+	ks_debug("DEBUG_APPAUTH: digest read from manifest:\n");
+	keystore_hexdump("", digest, hash_digest_size[hash.algo]);
+	if (!memcmp(hash.digest, digest, hash_digest_size[hash.algo]))
+		return 0;
+
+	return -HASH_FAILURE;
+}
diff --git a/security/keystore/appauth/key_setup.c b/security/keystore/appauth/key_setup.c
new file mode 100644
index 000000000000..8c7f6d85211c
--- /dev/null
+++ b/security/keystore/appauth/key_setup.c
@@ -0,0 +1,96 @@
+// SPDX-License-Identifier: GPL-2.0
+// Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporatio.
+#include "app_auth.h"
+
+#ifdef CONFIG_KEYSTORE_DEBUG
+/**
+ * Prints the public key in hex form.
+ *
+ * @param key    - public key to be printed.
+ *
+ */
+void debug_public_key(struct public_key *key)
+{
+	ks_debug("DEBUG_APPAUTH: Public key\n");
+	keystore_hexdump("", key->key, key->keylen);
+}
+#else
+void debug_public_key(struct public_key *key)
+{
+}
+#endif
+
+
+
+/**
+ * Provides the process file path.
+ *
+ * @param buf    -  The buffer to store the file path.
+ * @param buflen -  The size of the buffer.
+ *
+ * @returns the address of the file path.
+ */
+static char *get_exe_path(char *buf, int buflen)
+{
+	struct file *exe_file = NULL;
+	char *result = NULL;
+	struct mm_struct *mm = NULL;
+
+	mm = get_task_mm(current);
+	if (!mm) {
+		ks_info(KBUILD_MODNAME ": %s error get_task_mm\n", __func__);
+		goto out;
+	}
+
+	down_read(&mm->mmap_sem);
+	exe_file = mm->exe_file;
+
+	if (exe_file)
+		path_get(&exe_file->f_path);
+
+	up_read(&mm->mmap_sem);
+	mmput(mm);
+	if (exe_file) {
+		result = d_path(&exe_file->f_path, buf, buflen);
+		path_put(&exe_file->f_path);
+	}
+out:
+	return result;
+}
+
+/**
+ * Provides the process file path.
+ * Performs error check on the retrieved path.
+ *
+ * @param buf    -  The buffer to store the file path.
+ *
+ * @returns the address of the file path if success or nul otherwise.
+ */
+char *get_exe_name(char **buf)
+{
+	char *f_path = NULL;
+
+	/* alloc mem for pwd##app, use linux defined limits */
+	*buf = kmalloc(PATH_MAX + NAME_MAX, GFP_KERNEL);
+	if (*buf != NULL) {
+		/* clear the buf */
+		memset(*buf, 0, PATH_MAX + NAME_MAX);
+
+		f_path = get_exe_path(*buf,
+					(PATH_MAX + NAME_MAX));
+
+		if (!f_path)
+			return NULL;
+
+		/* check if it was an error */
+		if (f_path && IS_ERR(f_path)) {
+			/* error case, do not register */
+			ks_err(KBUILD_MODNAME "%s failed\n", __func__);
+			return NULL;
+		}
+		ks_debug(KBUILD_MODNAME "absolute path of exe: %s\n", f_path);
+	} else
+		return NULL;
+
+	return f_path;
+}
diff --git a/security/keystore/appauth/manifest_cache.c b/security/keystore/appauth/manifest_cache.c
new file mode 100644
index 000000000000..9f50b77a8adf
--- /dev/null
+++ b/security/keystore/appauth/manifest_cache.c
@@ -0,0 +1,148 @@
+// SPDX-License-Identifier: GPL-2.0
+// Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporation.
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include "manifest_cache.h"
+
+/* The linked list of cache entries. */
+static struct list_head mf_cache = LIST_HEAD_INIT(mf_cache);
+
+/**
+ * Allocate a cache entry.
+ *
+ * @return Cache entry structure pointer or NULL if out of memory.
+ */
+static struct mf_cache_entry *mf_allocate_cache_entry(void)
+{
+	struct mf_cache_entry *item = NULL;
+	struct list_head *pos, *q;
+	unsigned int cnt = 0;
+
+	/* calculate number of cache entries in use */
+	list_for_each_safe(pos, q, &mf_cache) {
+		item = list_entry(pos, struct mf_cache_entry, list);
+		if (ktime_ms_delta(ktime_get(), item->expiry) >= 0) {
+			list_del(pos);
+			kzfree(item);
+		} else
+			cnt++;
+	}
+
+	/* check for maximum number of clients */
+	if (cnt < MAX_CACHE_MANIFEST_ENTRIES) {
+		/* allocate memory */
+		item = kzalloc(sizeof(struct mf_cache_entry),
+				GFP_KERNEL);
+		if (item)
+			list_add(&(item->list), &mf_cache);
+	}
+
+	return item;
+}
+
+/**
+ * Find non-expired app in cache or remove the expired one.
+ *
+ * @param app_name Application name.
+ *
+ * @return remaining time if found or negative error code (see errno).
+ */
+int mf_find_in_cache(const char *app_name)
+{
+	struct list_head *pos, *q;
+	struct mf_cache_entry *item;
+
+	if (!app_name)
+		return -EFAULT;
+
+	list_for_each_safe(pos, q, &mf_cache) {
+		item = list_entry(pos, struct mf_cache_entry, list);
+		if (!strcmp(app_name, item->app_name)) {
+			long long delta = ktime_ms_delta(ktime_get(),
+					item->expiry);
+
+			if (delta >= 0) {
+				list_del(pos);
+				kzfree(item);
+				return -ESRCH;
+			} else
+				return (int) ((-delta + 999) / 1000);
+		}
+	}
+
+	return -ESRCH;
+}
+
+/**
+ * Add app to cache or update time to live if app already
+ * exists in cache.
+ *
+ * @param app_name Application name.
+ * @param time_to_live Time to live in cache (in seconds).
+ *
+ * @return 0 if OK or negative error code (see errno).
+ */
+int mf_add_to_cache(const char *app_name, uint64_t ttl)
+{
+	struct list_head *pos, *q;
+	struct mf_cache_entry *item;
+
+	if (!app_name)
+		return -EFAULT;
+
+	if (!*app_name || strlen(app_name) >= MAX_APP_NAME_SIZE)
+		return -EINVAL;
+
+	list_for_each_safe(pos, q, &mf_cache) {
+		item = list_entry(pos, struct mf_cache_entry, list);
+		if (!strcmp(app_name, item->app_name))
+			goto found;
+	}
+
+	item = mf_allocate_cache_entry();
+	if (!item)
+		return -ENOMEM;
+
+	strcpy(item->app_name, app_name);
+
+found:
+	item->expiry = ktime_add_ms(ktime_get(), ttl * 1000);
+	return 0;
+}
+
+/**
+ * Delete all cache entries.
+ */
+void mf_clear_cache(void)
+{
+	struct list_head *pos, *q;
+	struct mf_cache_entry *item;
+
+	list_for_each_safe(pos, q, &mf_cache) {
+		item = list_entry(pos, struct mf_cache_entry, list);
+		list_del(pos);
+		kzfree(item);
+	}
+}
+
+/**
+ * Dump cache contents
+ */
+void mf_dump_cache(void)
+{
+	struct list_head *pos;
+	struct mf_cache_entry *item;
+	long long delta;
+
+	list_for_each(pos, &mf_cache) {
+		item = list_entry(pos, struct mf_cache_entry, list);
+		delta = ktime_ms_delta(ktime_get(), item->expiry);
+		pr_info(KBUILD_MODNAME ": cache: app=%s ttl=%d sec\n",
+				item->app_name, (int) ((-delta + 999) / 1000));
+	}
+}
+/* end of file */
diff --git a/security/keystore/appauth/manifest_cache.h b/security/keystore/appauth/manifest_cache.h
new file mode 100644
index 000000000000..458323dcaec3
--- /dev/null
+++ b/security/keystore/appauth/manifest_cache.h
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporatio. */
+#ifndef _MANIFEST_CACHE_H_
+#define _MANIFEST_CACHE_H_
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/ktime.h>
+
+#define MAX_APP_NAME_SIZE             255
+#define MAX_CACHE_MANIFEST_ENTRIES    1000
+
+/**
+ * struct mf_cache_entry - The manifest cache entry structure.
+ *
+ * @list: Kernel list head for linked list.
+ * @app_name: Application name.
+ * @expiry: Expiration time.
+ */
+struct mf_cache_entry {
+	struct list_head list;
+	char app_name[MAX_APP_NAME_SIZE];
+	ktime_t expiry;
+};
+
+/**
+ * Find non-expired app in cache or remove the expired one.
+ *
+ * @param app_name Application name.
+ *
+ * @return remaining time if found or negative error code (see errno).
+ */
+int mf_find_in_cache(const char *app_name);
+
+/**
+ * Add app to cache or update time to live if app already
+ * exists in cache.
+ *
+ * @param app_name Application name.
+ * @param time_to_live Time to live in cache (in seconds).
+ *
+ * @return 0 if OK or negative error code (see errno).
+ */
+int mf_add_to_cache(const char *app_name, uint64_t ttl);
+
+/**
+ * Delete all cache entries.
+ */
+void mf_clear_cache(void);
+
+/**
+ * Dump cache contents
+ */
+void mf_dump_cache(void);
+
+#endif /* _MANIFEST_CACHE_H_ */
diff --git a/security/keystore/appauth/manifest_parser.c b/security/keystore/appauth/manifest_parser.c
new file mode 100644
index 000000000000..abe9faf5de11
--- /dev/null
+++ b/security/keystore/appauth/manifest_parser.c
@@ -0,0 +1,181 @@
+// SPDX-License-Identifier: GPL-2.0
+// Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporation.
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/string.h>
+#else
+#include <string.h>
+#include <stdio.h>
+#endif
+
+#include "manifest_parser.h"
+#include "app_auth.h"
+
+#define MAX_CHUNKS 10
+
+const uint8_t digest_len[] = {
+	20, /* sha1   */
+	28, /* sha224 */
+	32, /* sha256 */
+	48, /* sha384 */
+	64  /* sha512 */
+};
+
+struct mf_envelope {
+	uint8_t version;
+	uint16_t len;
+	uint8_t data[];
+} __packed;
+
+struct mf_chunk {
+	uint8_t type;
+	uint16_t len;
+	uint8_t data[];
+} __packed;
+
+static const struct mf_chunk *mf_get_chunk(const uint8_t *mf,
+		uint8_t chunk_type)
+{
+	const struct mf_envelope *env = (const struct mf_envelope *) mf;
+
+	if (env) {
+		uint16_t i, pos = 0;
+
+		for (i = 0; pos < env->len && i < MAX_CHUNKS; i++) {
+			const struct mf_chunk *chunk =
+				(const struct mf_chunk *) (env->data + pos);
+			if (chunk->type == chunk_type) {
+				if (pos + chunk->len + 3 <= env->len + 1)
+					return chunk;
+				else
+					return NULL;
+			}
+			pos += chunk->len + 3;
+		}
+	}
+	return NULL;
+}
+
+static const uint8_t *mf_get_chunk_data(const uint8_t *mf,
+		uint8_t chunk_type, size_t *len)
+{
+	const struct mf_chunk *chunk = mf_get_chunk(mf, chunk_type);
+
+	if (len) {
+		*len = 0;
+		if (chunk) {
+			*len = chunk->len;
+			return chunk->data;
+		}
+	}
+	return NULL;
+}
+
+uint8_t mf_get_version(const uint8_t *mf)
+{
+	const struct mf_envelope *env = (const struct mf_envelope *) mf;
+
+	return env ? env->version : 0;
+}
+
+const char *mf_get_name(const uint8_t *mf)
+{
+	size_t len = 0;
+	const uint8_t *data = mf_get_chunk_data(mf, TYPE_MANIFEST_NAME, &len);
+
+	if (data && len < 256) {
+		const char *name = (const char *) data;
+
+		if (strlen(name) + 1 == len)
+			return name;
+	}
+	return NULL;
+}
+
+const struct mf_app_data *mf_get_app_data(const uint8_t *mf)
+{
+	size_t len = 0;
+	const struct mf_app_data *data = (const struct mf_app_data *)
+			mf_get_chunk_data(mf, TYPE_MANIFEST_DATA, &len);
+	if (data) {
+		const char *name = (const char *) data->app_name;
+
+		if (strlen(name) + 1 == data->app_name_len)
+			return data;
+	}
+	return NULL;
+}
+
+int mf_init_file_list_ctx(const uint8_t *mf,
+		struct mf_files_ctx *ctx)
+{
+	if (ctx) {
+		size_t len = 0;
+		const struct mf_app_data *data = (const struct mf_app_data *)
+			mf_get_chunk_data(mf, TYPE_MANIFEST_DATA, &len);
+		if (data) {
+			ctx->num_files_left = data->num_files;
+			ctx->bytes_left = len - 8 - data->app_name_len;
+			ctx->next_file =
+			(uint8_t *) (data->app_name + data->app_name_len);
+			ks_debug("DEBUG_APPAUTH: num_files_left = %d\n",
+				 ctx->num_files_left);
+			ks_debug("DEBUG_APPAUTH: bytes_left = %lu\n",
+				 ctx->bytes_left);
+			return ctx->num_files_left;
+		}
+	}
+	return 0;
+}
+
+const char *mf_get_next_file(const uint8_t *mf,
+	struct mf_files_ctx *ctx, uint8_t *digest_algo_id, uint8_t **digest,
+	uint32_t *size)
+{
+	if (ctx && ctx->num_files_left > 0 && ctx->bytes_left > 0 &&
+			ctx->next_file && digest_algo_id && digest) {
+		uint8_t filenamelen = *ctx->next_file;
+		const char *filename = (const char *) (ctx->next_file + 1);
+
+		ks_debug("DEBUG_APPAUTH: filenamelen  = %d\n", filenamelen);
+
+		if (strlen(filename) + 1 == filenamelen) {
+			size_t entry_size;
+			*size =	*((uint32_t *)(ctx->next_file +
+						filenamelen + 1));
+			*digest_algo_id = *((uint8_t *)(ctx->next_file +
+						filenamelen + 5));
+			*digest = ctx->next_file + filenamelen + 6;
+			if (*digest_algo_id >= sizeof(digest_len))
+				return NULL;
+			entry_size = 1 + filenamelen + 5 +
+				digest_len[*digest_algo_id];
+			ctx->num_files_left--;
+			ctx->bytes_left -= entry_size;
+			ctx->next_file += entry_size;
+			return filename;
+		} else
+			return ERR_PTR(-EFAULT);
+	}
+	return NULL;
+}
+
+const uint8_t *mf_get_data(const uint8_t *mf, size_t *len)
+{
+	return mf_get_chunk_data(mf, TYPE_MANIFEST_DATA, len);
+}
+
+const uint8_t *mf_get_public_key(const uint8_t *mf, size_t *len)
+{
+	return mf_get_chunk_data(mf, TYPE_MANIFEST_PUBLIC_KEY, len);
+}
+
+const uint8_t *mf_get_certificate(const uint8_t *mf, size_t *len)
+{
+	return mf_get_chunk_data(mf, TYPE_MANIFEST_CERTIFICATE, len);
+}
+
+const uint8_t *mf_get_signature(const uint8_t *mf, size_t *len)
+{
+	return mf_get_chunk_data(mf, TYPE_MANIFEST_SIGNATURE, len);
+}
diff --git a/security/keystore/appauth/manifest_parser.h b/security/keystore/appauth/manifest_parser.h
new file mode 100644
index 000000000000..aee242b578db
--- /dev/null
+++ b/security/keystore/appauth/manifest_parser.h
@@ -0,0 +1,195 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporatio. */
+#ifndef _MANIFEST_PARSER_H_
+#define _MANIFEST_PARSER_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stddef.h>
+#include <stdint.h>
+#endif
+
+/**
+ * DOC: Introduction
+ *
+ * Parser of binary manifests compiled using signed manifest compiler
+ *
+ */
+
+/**
+ *
+ * Digest algorithms
+ *
+ */
+enum {
+	DIGEST_ALGO_MD5,
+	DIGEST_ALGO_SHA1,
+	DIGEST_ALGO_SHA224,
+	DIGEST_ALGO_SHA256,
+	DIGEST_ALGO_SHA384,
+	DIGEST_ALGO_SHA512,
+};
+
+/**
+ *
+ * Capabilities
+ *
+ */
+enum {
+	CAPABILITY_KEYSTORE = 0x01,
+	CAPABILITY_TPM = 0x02
+};
+
+/**
+ *
+ * Verify types
+ *
+ */
+enum {
+	VERIFY_BOOT,
+	VERIFY_SESSION,
+	VERIFY_API_CALL
+};
+
+enum {
+	TYPE_MANIFEST_NAME = 1,
+	TYPE_MANIFEST_DATA,
+	TYPE_MANIFEST_PUBLIC_KEY,
+	TYPE_MANIFEST_CERTIFICATE,
+	TYPE_MANIFEST_SIGNATURE
+};
+
+/**
+ *
+ * struct mf_app_data - Application data
+ *
+ * @num_files: number of files in the manifest
+ * @verify_type: verify type
+ * @capabilities: capabilities
+ * @app_version: application version
+ * @app_name_len: length of application name
+ * @app_name: application name (path)
+ *
+ */
+struct mf_app_data {
+	uint8_t num_files;
+	uint8_t verify_type;
+	uint16_t capabilities;
+	uint8_t app_version[3];
+	uint8_t app_name_len;
+	const char app_name[];
+} __packed;
+
+/**
+ *
+ * File list parse context
+ *
+ */
+struct mf_files_ctx {
+	uint8_t num_files_left;
+	size_t bytes_left;
+	uint8_t *next_file;
+};
+
+/**
+ *
+ * Digest sizes
+ *
+ */
+extern const uint8_t digest_len[];
+
+/**
+ * mf_get_version() - Get the manifest version
+ *
+ * @mf: binary manifest data
+ *
+ * Returns: manifest version.
+ */
+uint8_t mf_get_version(const uint8_t *mf);
+
+/**
+ * mf_get_name() - Get the manifest name (path)
+ *
+ * @mf: binary manifest data
+ *
+ * Returns: manifest name.
+ */
+const char *mf_get_name(const uint8_t *mf);
+
+/**
+ * mf_get_app_data() - Get the application data
+ *
+ * @mf: binary manifest data
+ *
+ * Returns: application data.
+ */
+const struct mf_app_data *mf_get_app_data(const uint8_t *mf);
+
+/**
+ * mf_init_file_list_ctx() - Initialize file list context
+ *
+ * @mf: binary manifest data
+ * @ctx: pointer to the context variable
+ *
+ * Returns: number of files.
+ */
+int mf_init_file_list_ctx(const uint8_t *mf,
+		struct mf_files_ctx *ctx);
+
+/**
+ * mf_get_next_file() - Get next file from the list
+ *
+ * @mf: binary manifest data
+ * @ctx: pointer to the context variable
+ * @digest_algo_id: pointer to a variable filled with digest algorithm id
+ * @digest: pointer to a buffer filled with file digest
+ * @size: pointer to uint32 filled with file size
+ *
+ * Returns: file name (path) or NULL if no (more) files.
+ */
+const char *mf_get_next_file(const uint8_t *mf,
+	struct mf_files_ctx *ctx, uint8_t *digest_algo_id, uint8_t **digest,
+	uint32_t *size);
+
+/**
+ * mf_get_data() - Get data
+ *
+ * @mf: binary manifest data
+ * @len: pointer to a variable filled with the data length
+ *
+ * Returns: pointer to the data or NULL if not present in the manifest.
+ */
+const uint8_t *mf_get_data(const uint8_t *mf, size_t *len);
+
+/**
+ * mf_get_public_key() - Get public key
+ *
+ * @mf: binary manifest data
+ * @len: pointer to a variable filled with the public key length
+ *
+ * Returns: pointer to the public key or NULL if not present in the manifest.
+ */
+const uint8_t *mf_get_public_key(const uint8_t *mf, size_t *len);
+
+/**
+ * mf_get_certificate() - Get certificate
+ *
+ * @mf: binary manifest data
+ * @len: pointer to a variable filled with the certificate length
+ *
+ * Returns: pointer to the certificate or NULL if not present in the manifest.
+ */
+const uint8_t *mf_get_certificate(const uint8_t *mf, size_t *len);
+
+/**
+ * mf_get_signature() - Get signature
+ *
+ * @mf: binary manifest data
+ * @len: pointer to a variable filled with the signature length
+ *
+ * Returns: pointer to the signature or NULL if not present in the manifest.
+ */
+const uint8_t *mf_get_signature(const uint8_t *mf, size_t *len);
+
+#endif /* _MANIFEST_PARSER_H_ */
diff --git a/security/keystore/appauth/manifest_read.c b/security/keystore/appauth/manifest_read.c
new file mode 100644
index 000000000000..06224b37fa97
--- /dev/null
+++ b/security/keystore/appauth/manifest_read.c
@@ -0,0 +1,107 @@
+// SPDX-License-Identifier: GPL-2.0
+// Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporation.
+#include "app_auth.h"
+
+/**
+ * Reads the manifest file and copy the content to the manifest_buf.
+ *
+ * @param file         - pointer to the file structure for the manifest file.
+ * @param manifest_buf - contain the entire manifest file content.
+ *
+ * @return 0 if success or error code.
+ */
+static int appauth_read_buf(struct file *file, char **manifest_buf)
+{
+	loff_t i_size, offset = 0;
+	int read = 0;
+	int manifest_len = 0;
+
+	i_size = i_size_read(file_inode(file));
+	ks_debug("DEBUG_APPAUTH: file size = %lld\n", i_size);
+
+	if (i_size == 0)
+		goto out;
+
+	if (i_size >= MANIFEST_MAX_LEN) {
+		manifest_len = -1;
+		goto out;
+	}
+
+	*manifest_buf = kzalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!(*manifest_buf))
+		return -ENOMEM;
+
+	if (!(file->f_mode & FMODE_READ)) {
+		file->f_mode |= FMODE_READ;
+		read = 1;
+	}
+
+	manifest_len = appauth_kernel_read(file, offset,
+					*manifest_buf, PAGE_SIZE);
+	ks_debug("DEBUG_APPAUTH: manifest_len = %d\n", manifest_len);
+	if (read)
+		file->f_mode &= ~FMODE_READ;
+out:
+	return manifest_len;
+}
+
+/**
+ * Frees the manifest_buf content.
+ *
+ * @param manifest_buf - contain the entire manifest file content.
+ *
+ */
+void appauth_free_buf(char **manifest_buf)
+{
+	kfree(*manifest_buf);
+	*manifest_buf = NULL;
+}
+
+/**
+ * Reads the manifest file and copy the content to the manifest_buf.
+ * Locks the inode mutex for the file read.
+ *
+ * @param file         - pointer to the file structure for the manifest file.
+ * @param manifest_buf - contain the entire manifest file content.
+ *
+ * @return 0 if success or error code (see enum APP_AUTH_ERROR).
+ */
+int read_file(struct file *file, char **manifest_buf)
+{
+	int manifest_len;
+
+	ks_debug("DEBUG_APPAUTH: calling mutex_lock\n");
+	mutex_lock(&(file->f_pos_lock));
+	manifest_len = appauth_read_buf(file, manifest_buf);
+	mutex_unlock(&(file->f_pos_lock));
+	return manifest_len;
+}
+
+/**
+ * Reads the manifest file and copy the content to the manifest_buf.
+ * Opens the file for reading.
+ *
+ * @param filename     - absolute path of the manifest file.
+ * @param manifest_buf - contain the entire manifest file content.
+ * @param manifest_len - manifest file length.
+ *
+ * @return 0 if success or error code.
+ */
+int read_manifest(const char *filename, char **manifest_buf, int *manifest_len)
+{
+	struct file *file = 0;
+
+	file = filp_open(filename,  O_RDONLY, 0);
+	if (IS_ERR(file)) {
+		ks_err("DEBUG_APPAUTH: filp_open failed\n");
+		return -EBADF;
+	}
+	ks_debug("DEBUG_APPAUTH: filp_open succeeded\n");
+	*manifest_len = read_file(file, manifest_buf);
+	filp_close(file, NULL);
+	if (*manifest_len < 0) {
+		ks_err("DEBUG_APPAUTH: manifest read_file failed (manifest file too big)\n");
+		return -EILSEQ;
+	}
+	return 0;
+}
diff --git a/security/keystore/appauth/manifest_sanity_check.c b/security/keystore/appauth/manifest_sanity_check.c
new file mode 100644
index 000000000000..8fdef048b082
--- /dev/null
+++ b/security/keystore/appauth/manifest_sanity_check.c
@@ -0,0 +1,227 @@
+// SPDX-License-Identifier: GPL-2.0
+// Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporation.
+#include <linux/types.h>
+#include "manifest_parser.h"
+#include "app_auth.h"
+
+/**
+ * Checks the sanity of a particular manifest field.
+ *
+ * @param buf		     - data buffer.
+ * @param max_len            - maximum bytes the manifest field can occuppy.
+ * @param type               - manifest field type.
+ *
+ * @return the bytes the checked field contains,if success or -1 on error.
+ */
+static int type_sanity_check(char *buf, uint16_t *max_len, uint8_t type)
+{
+	uint16_t len = 0;
+	uint16_t remain_len = *max_len;
+	size_t ret = 0;
+
+	if (remain_len == 0)
+		return -1;
+
+	if (*buf != type)
+		return -1;
+	buf++;
+	remain_len--;
+
+	if (remain_len < 2)
+		return -1;
+	len = *((uint16_t *)buf);
+	remain_len -= 2;
+
+	if (remain_len < len)
+		return -1;
+	remain_len -= len;
+	ret = *max_len - remain_len;
+	*max_len = remain_len;
+	return ret;
+}
+
+/**
+ * @param hash_id            - id of the hash algorithm.
+ *
+ * @returns the digest length of the hash algorithm.
+ */
+static uint8_t get_hash_len(uint8_t hash_id)
+{
+	switch (hash_id) {
+	case 1:
+		return 20;
+	case 2:
+		return 28;
+	case 3:
+		return 32;
+	case 4:
+		return 48;
+	case 5:
+		return 64;
+	default:
+		return 20;
+	}
+}
+
+/**
+ * Checks the sanity of manifest fields related to a single file metadata.
+ *
+ * @param buf                - data buffer.
+ * @param max_len            - maximum bytes the manifest field can occuppy.
+ *
+ * @return the bytes the checked field contains,if success or -1 on error.
+ */
+static int file_sanity_check(char *buf, uint16_t max_len)
+{
+	uint16_t index = 0;
+	uint8_t hash_id = 0, hash_len = 0;
+	uint8_t file_name_len = 0;
+
+	if (max_len == 0)
+		return -1;
+
+	file_name_len = buf[index];
+	index++;
+	ks_debug("DEBUG_APPAUTH: file_name_len in manifest = %d\n",
+							file_name_len);
+
+	if ((index + file_name_len + 1) > max_len)
+		return -1;
+
+	index += file_name_len;
+	if (buf[index - 1] != 0)
+		return -1;
+	/* 4 bytes: APPID, 1 byte: version */
+	if ((index + 4 + 1) > max_len)
+		return -1;
+	index += 4;
+
+	/* 1 byte: number of files, 1 byte: file size length */
+	if ((index + 1 + 1) > max_len)
+		return -1;
+
+	hash_id = buf[index];
+	hash_len = get_hash_len(hash_id);
+	index++;
+
+	ks_debug("DEBUG_APPAUTH: file digest len in manifest = %d\n", hash_len);
+	if ((index + hash_len + 1) > max_len)
+		return -1;
+
+	index += hash_len;
+	return index;
+}
+
+/**
+ * Checks the sanity of the content of TYPE_MANIFEST_DATA type.
+ *
+ * @param buf                - data buffer.
+ * @param max_len            - maximum bytes the manifest field can occuppy.
+ *
+ * @return the bytes the checked field contains,if success or -1 on error.
+ */
+static int data_sanity_check(char *buf, uint16_t max_len)
+{
+	uint16_t file_count = 0;
+	uint16_t index = 0;
+	uint8_t app_id_len = 0;
+	int ret = 0;
+	uint16_t i;
+
+	file_count = buf[index];
+	ks_debug("DEBUG_APPAUTH: file_count in manifest = %d\n", file_count);
+	if ((index + 8 + 1) > max_len)
+		return -1;
+	index += 7;
+	app_id_len = buf[index];
+	index++;
+
+	ks_debug("DEBUG_APPAUTH: app_id_len in manifest = %d\n", app_id_len);
+	if ((index + app_id_len + 1) > max_len)
+		return -1;
+
+	if (buf[index + app_id_len - 1] != 0)
+		return -1;
+
+	index += app_id_len;
+	for (i = 0; i < file_count; i++) {
+		ret = file_sanity_check(buf + index, max_len - index - 1);
+		if (ret < 0)
+			return ret;
+		index += ret;
+	}
+	return 0;
+}
+
+/**
+ * Checks the sanity of all the fields in application manifest.
+ *
+ * @param buf                - data buffer.
+ * @param max_len            - maximum bytes the manifest can occuppy.
+ *
+ * @returns 0 on success, or -1 on error.
+ */
+int manifest_sanity_check(char *manifest_buf, uint16_t manifest_len)
+{
+	uint16_t len = 0;
+	char *buf = NULL;
+	uint16_t max_len = 0;
+	uint16_t data_max_len = 0;
+	int index = 0;
+
+	ks_debug("DEBUG_APPAUTH: performing sanity check\n");
+	if (manifest_len < 3)
+		return -1;
+
+	buf = manifest_buf;
+	++buf;
+	len = *(uint8_t *)buf;
+	len += *(uint8_t *)(buf + 1) << 8;
+	ks_debug("DEBUG_APPAUTH: length retrieved = %d\n", len);
+	if (len + 3 != manifest_len)
+		return -1;
+
+	buf += 2;
+	max_len = manifest_len - 3;
+
+	/* TYPE_MANIFEST_NAME */
+	if (max_len == 0)
+		return -1;
+
+	index = type_sanity_check(buf, &max_len, TYPE_MANIFEST_NAME);
+	if (index < 0)
+		return -1;
+	ks_debug("DEBUG_APPAUTH: sanity checked: TYPE_MANIFEST_NAME\n");
+
+	buf += index;
+	if (max_len == 0)
+		return -1;
+	data_max_len = max_len - 3;
+	index = type_sanity_check(buf, &max_len, TYPE_MANIFEST_DATA);
+	if (index < 0)
+		return -1;
+	ks_debug("DEBUG_APPAUTH: sanity checked: TYPE_MANIFEST_DATA\n");
+	if (data_sanity_check(buf + 3, data_max_len) < 0)
+		return -1;
+	ks_debug("DEBUG_APPAUTH: sanity checked: TYPE_MANIFEST_DATA content\n");
+
+	if (max_len == 0)
+		return -1;
+	buf += index;
+	index = type_sanity_check(buf, &max_len, TYPE_MANIFEST_CERTIFICATE);
+	if (index < 0)
+		return -1;
+	ks_debug("DEBUG_APPAUTH: sanity checked: TYPE_MANIFEST_CERTIFICATE\n");
+
+	if (max_len == 0)
+		return -1;
+	buf += index;
+	index = type_sanity_check(buf, &max_len, TYPE_MANIFEST_SIGNATURE);
+	if (index < 0)
+		return -1;
+	ks_debug("DEBUG_APPAUTH: sanity checked: TYPE_MANIFEST_SIGNATURE\n");
+	if (max_len)
+		return -1;
+
+	return 0;
+}
diff --git a/security/keystore/appauth/manifest_verify.c b/security/keystore/appauth/manifest_verify.c
new file mode 100644
index 000000000000..aba3f4bc6341
--- /dev/null
+++ b/security/keystore/appauth/manifest_verify.c
@@ -0,0 +1,204 @@
+// SPDX-License-Identifier: GPL-2.0
+// Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporation.
+#include <linux/string.h>
+#include <linux/slab.h>
+#include "manifest_parser.h"
+#include "manifest_verify.h"
+#include "manifest_cache.h"
+#include "app_auth.h"
+
+/**
+ * Verifies the signature and capabilities in the manifest.
+ *
+ * @param manifest_buf - contain the entire manifest file content.
+ * @param caps - contain required capabilities.
+ *
+ * @return 0,if success or error code (see enum APP_AUTH_ERROR).
+ */
+static int check_signature_and_caps(char *manifest_buf, uint16_t caps)
+{
+	const char *sig = 0, *cert = 0, *data = 0;
+	size_t sig_len = 0, cert_len = 0, data_len = 0;
+	const struct mf_app_data *app_data = NULL;
+	int res = 0;
+
+	cert = mf_get_certificate(manifest_buf, &cert_len);
+	if (!cert) {
+		ks_err("DEBUG_APPAUTH: mf_get_certificate() failed\n");
+		return -MALFORMED_MANIFEST;
+	}
+
+	sig = mf_get_signature(manifest_buf, &sig_len);
+	if (!sig) {
+		ks_err("DEBUG_APPAUTH: mf_get_signature() failed\n");
+		return -MALFORMED_MANIFEST;
+	}
+
+	data = mf_get_data(manifest_buf, &data_len);
+	if (!data) {
+		ks_err("DEBUG_APPAUTH: mf_get_data() failed\n");
+		return -MALFORMED_MANIFEST;
+	}
+
+	app_data = mf_get_app_data(manifest_buf);
+	if (!app_data) {
+		ks_err("DEBUG_APPAUTH: mf_get_app_data() failed\n");
+		return -MALFORMED_MANIFEST;
+	}
+
+	if ((app_data->capabilities & caps) != caps)
+		return -CAPS_FAILURE;
+
+	res = verify_manifest(sig, cert, data, sig_len, cert_len, data_len);
+	if (res < 0) {
+		ks_err("DEBUG_APPAUTH: verify_manifest() failed (res=%d)\n",
+				res);
+		return res;
+	}
+	ks_debug("DEBUG_APPAUTH: verify_manifest() succedded\n");
+	return 0;
+}
+
+/**
+ * Verifies if the manifest contains executable name.
+ *
+ * @param manifest_buf - contain the entire manifest file content.
+ *
+ * @return executable name, if success or NULL.
+ */
+static const char *verify_exe_name(char *manifest_buf)
+{
+	struct mf_files_ctx ctx;
+	const char *filename = 0, *exe_name = 0;
+	uint8_t digest_algo_id;
+	uint8_t *digest = 0;
+	char *buf = 0;
+	bool exe_found = false;
+	uint32_t size = 0;
+
+	mf_init_file_list_ctx(manifest_buf, &ctx);
+
+	exe_name = get_exe_name(&buf);
+	if (!exe_name)
+		return NULL;
+	ks_debug("DEBUG_APPAUTH: get_exe_name(): exe_name = %s\n", exe_name);
+	while (1) {
+		filename = mf_get_next_file(manifest_buf, &ctx,
+					&digest_algo_id, &digest, &size);
+		if (!filename)
+			break;
+
+		ks_debug("DEBUG_APPAUTH: mf_get_next_file: filename = %s\n",
+								filename);
+		if (!memcmp(filename, exe_name, strlen(exe_name))) {
+			ks_debug("DEBUG_APPAUTH: setting exe_found\n");
+			exe_found = true;
+		}
+	}
+	kfree(buf);
+	if (!exe_found)
+		return NULL;
+	return exe_name;
+}
+
+/**
+ * Verifies the application files hashes against the hash values
+ * in the manifest.
+ *
+ * @param manifest_buf - contain the entire manifest file content.
+ *
+ * @return 0,if success or error code (see enum APP_AUTH_ERROR).
+ */
+static int verify_file_hashes(char *manifest_buf)
+{
+	struct mf_files_ctx ctx;
+	const char *filename = 0;
+	uint8_t digest_algo_id;
+	uint8_t *digest = 0;
+	uint32_t size = 0;
+	int ret = 0;
+
+	mf_init_file_list_ctx(manifest_buf, &ctx);
+
+	while (1) {
+		filename = mf_get_next_file(manifest_buf, &ctx,
+					&digest_algo_id, &digest, &size);
+		if (!filename)
+			break;
+		if (IS_ERR(filename)) {
+			ret = -MALFORMED_MANIFEST;
+			break;
+		}
+		if (size > MAX_FILE_SIZE) {
+			ret = -FILE_TOO_BIG;
+			break;
+		}
+		ks_debug("DEBUG_APPAUTH: mf_get_next_file: filename = %s\n",
+								filename);
+		if (compute_file_hash(filename, digest, digest_algo_id)) {
+			ks_err("DEBUG_APPAUTH: compute_file_hash() failed\n");
+			ret = -HASH_FAILURE;
+			break;
+		}
+	}
+	return ret;
+}
+
+/**
+ * Verifies the authenticity of the manifest and the integrity of
+ * the application files.
+ *
+ * @param manifest_file_path - absolute path of the manifrest file.
+ * @param timeout            - expiry time of the verification result.
+ * @param caps               - capability(s) of the calling component.
+ *
+ * @return 0,if success or error code (see enum APP_AUTH_ERROR and/or ERRNO).
+ */
+int verify_manifest_file(char *manifest_file_path,
+						int timeout, uint16_t caps)
+{
+	int ret = 0;
+	char *manifest_buf = 0;
+	int manifest_len = 0;
+	const char *exe_name;
+
+	ret = read_manifest(manifest_file_path, &manifest_buf,
+					&manifest_len);
+	if (ret == -EILSEQ)
+		ret = -FILE_TOO_BIG;
+
+	if (ret < 0)
+		goto out;
+
+	ret = manifest_sanity_check(manifest_buf, (uint16_t)manifest_len);
+	if (ret < 0) {
+		ks_err("DEBUG_APPAUTH: manifest_sanity_check() failed\n");
+		goto out;
+	}
+
+	ret = check_signature_and_caps(manifest_buf, caps);
+	if (ret < 0)
+		goto out;
+
+	exe_name = verify_exe_name(manifest_buf);
+	if (!exe_name) {
+		ret = -EXE_NOT_FOUND;
+		goto out;
+	}
+
+	if (mf_find_in_cache(exe_name) < 0) {
+		ret = verify_file_hashes(manifest_buf);
+		if (ret < 0)
+			goto out;
+		ks_debug("DEBUG_APPAUTH: %s not found in cache\n", exe_name);
+		mf_add_to_cache(exe_name, timeout);
+	} else {
+		ks_debug("DEBUG_APPAUTH: %s found in cache\n", exe_name);
+	}
+	ks_debug("DEBUG_APPAUTH: %s succedded\n", __func__);
+	return NO_ERROR;
+out:
+	ks_err("DEBUG_APPAUTH: %s failed\n", __func__);
+	appauth_free_buf(&manifest_buf);
+	return ret;
+}
diff --git a/security/keystore/appauth/manifest_verify.h b/security/keystore/appauth/manifest_verify.h
new file mode 100644
index 000000000000..d6f1ef063517
--- /dev/null
+++ b/security/keystore/appauth/manifest_verify.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporatio. */
+#ifndef _MANIFEST_VERIFY_H_
+#define _MANIFEST_VERIFY_H_
+
+#include "manifest_parser.h"
+
+#define MANIFEST_CACHE_TTL		300
+#define MANIFEST_DEFAULT_CAPS		(CAPABILITY_KEYSTORE)
+
+enum APP_AUTH_ERROR {
+	NO_ERROR,
+	MALFORMED_MANIFEST = 300,
+	CERTIFICATE_FAILURE,
+	CERTIFICATE_EXPIRED,
+	CAPS_FAILURE,
+	SIGNATURE_FAILURE,
+	EXE_NOT_FOUND,
+	FILE_TOO_BIG,
+	HASH_FAILURE,
+	KEY_LOAD_ERROR,
+	KEY_RETRIEVE_ERROR,
+	KEYID_NOT_FOUND
+};
+
+int verify_manifest_file(char *manifest_file_path,
+					int timeout, uint16_t caps);
+#endif /* _MANIFEST_VERIFY_H_ */
diff --git a/security/keystore/appauth/sign_verify.c b/security/keystore/appauth/sign_verify.c
new file mode 100644
index 000000000000..3112b5ad97d9
--- /dev/null
+++ b/security/keystore/appauth/sign_verify.c
@@ -0,0 +1,225 @@
+// SPDX-License-Identifier: GPL-2.0
+// Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporation.
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/rtc.h>
+#include <linux/time.h>
+#include "../oemkey/manifest.h"
+#include "app_auth.h"
+#include "manifest_verify.h"
+
+#ifdef CONFIG_MANIFEST_HARDCODE
+/* hardcoded manifest has wrong usage bit set
+ * but it is only for testing so does not matter
+ */
+#define ATTESTATION_KEY_USAGE_BIT	40
+#else
+#define ATTESTATION_KEY_USAGE_BIT	47
+#endif
+
+/**
+ * Verifies the signature in the manifest.
+ *
+ * @param key          - public key to verify the signature.
+ * @param hash         - hash of the manifest data.
+ * @param sig          - contain the signature.
+ * @param sig_len      - length of the signature.
+ *
+ * @return 0,if success or error code.
+ */
+static int verify_manifest_signature(struct public_key *key,
+		struct appauth_digest *hash, const char *sig,
+		int sig_len)
+{
+	struct public_key_signature pks;
+	int ret = -ENOMEM;
+
+	debug_public_key(key);
+	memset(&pks, 0, sizeof(pks));
+
+	switch (hash->algo) {
+
+	case HASH_ALGO_SHA1:
+		pks.hash_algo = "sha1";
+		break;
+	case HASH_ALGO_SHA256:
+		pks.hash_algo = "sha256";
+		break;
+	default:
+		ks_err("APPAUTH: wrong algo type\n");
+		return -EINVAL;
+	}
+
+	pks.pkey_algo = "rsa";
+	pks.digest = (u8 *)(hash->digest);
+	pks.digest_size = hash->len;
+	pks.s = (char *)sig;
+	pks.s_size = sig_len;
+
+	ks_debug("DEBUG_APPAUTH: digest value\n");
+	keystore_hexdump("", pks.digest, pks.digest_size);
+	if (pks.s)
+		ret = public_key_verify_signature(key, &pks);
+	return ret;
+}
+
+/**
+ * Calculate the hash of the data and store the result in 'hash'.
+ *
+ * @param hash         - pointer to appauth_digest.
+ * @param tfm          - pointer to crypto shash structure.
+ * @param data         - data to digest.
+ * @param len          - length of the data.
+ *
+ * @return the pointer to the key,if success or NULL otherwise.
+ */
+static int calc_hash_tfm(struct appauth_digest *hash,
+				struct crypto_shash *tfm,
+				const char *data, int len)
+{
+	int rc = 0;
+	SHASH_DESC_ON_STACK(shash, tfm);
+
+	if (!hash || !data)
+		return -EFAULT;
+
+	shash->tfm = tfm;
+	if (!shash->tfm)
+		return -EFAULT;
+	shash->flags = 0;
+
+	hash->len = crypto_shash_digestsize(tfm);
+
+	rc = crypto_shash_init(shash);
+	if (rc != 0) {
+		ks_err("DEBUG_APPAUTH: crypto_shash_init() failed\n");
+		return rc;
+	}
+
+	rc = crypto_shash_update(shash, data, len);
+	if (!rc)
+		rc = crypto_shash_final(shash, hash->digest);
+	return rc;
+}
+
+/**
+ * Allocate crypto hash tfm and compute the hash of the data.
+ *
+ * @param hash         - pointer to appauth_digest.
+ * @param data         - data to digest.
+ * @param len          - length of the data.
+ *
+ * @return the pointer to the key,if success or NULL otherwise.
+ */
+static int calc_shash(struct appauth_digest *hash, const char *data, int len)
+{
+	struct crypto_shash *tfm = NULL;
+	int rc = 0;
+
+	if (!hash || !data)
+		return -EFAULT;
+
+	tfm = appauth_alloc_tfm(hash->algo);
+	if (IS_ERR(tfm)) {
+		ks_err("DEBUG_APPAUTH: appauth_alloc_tfm failed\n");
+		return PTR_ERR(tfm);
+	}
+	ks_debug("DEBUG_APPAUTH: appauth_alloc_tfm succeeded\n");
+	rc = calc_hash_tfm(hash, tfm, data, len);
+
+	appauth_free_tfm(tfm);
+
+	return rc;
+}
+
+/**
+ * Verify certificate validity.
+ *
+ * @param cert         - X509 certificate.
+ *
+ * @return 0,if success or error code.
+ */
+static int verify_cert_validity(struct x509_certificate *cert)
+{
+	struct timespec64 ts;
+
+	getnstimeofday64(&ts);
+
+	ks_debug("DEBUG_APPAUTH: Cert validity period: %lld-%lld, current time: %lld\n",
+		cert->valid_from, cert->valid_to, ts.tv_sec);
+
+	if (ts.tv_sec < cert->valid_from || ts.tv_sec > cert->valid_to)
+		return -EFAULT;
+
+	return 0;
+}
+
+/**
+ * Verifies the certificate and then the signature of the manifest data
+ *
+ * @param sig          - contain the signature.
+ * @param cert         - contain the certificate.
+ * @param data         - contain the data.
+ * @param sig_len      - length of the signature.
+ * @param cert_len     - length of the certificate.
+ * @param data_len     - length of the data.
+ *
+ * @return 0 if success or error code (see enum APP_AUTH_ERROR).
+ */
+int verify_manifest(const char *sig, const char *cert, const char *data,
+			int sig_len, int cert_len, int data_len)
+{
+	struct x509_certificate *x509cert;
+	struct asymmetric_key_id *x509cert_akid_skid;
+	struct appauth_digest hash;
+	int res = 0;
+
+	x509cert = x509_cert_parse((void *)cert, cert_len);
+	if (!x509cert) {
+		ks_err("Manifest cert parse failed\n");
+		return -CERTIFICATE_FAILURE;
+	}
+
+	if (!x509cert->pub) {
+		ks_err("Invalid manifest cert\n");
+		res = -CERTIFICATE_FAILURE;
+		goto exit;
+	}
+
+	x509cert_akid_skid = x509cert->sig->auth_ids[1];
+
+	res = verify_x509_cert_against_manifest_keyring(
+		 x509cert_akid_skid,
+		 ATTESTATION_KEY_USAGE_BIT);
+	if (res != 0) {
+		ks_err("Manifest cert verification failed (%d)\n", res);
+		res = -CERTIFICATE_FAILURE;
+		goto exit;
+	}
+
+	res = verify_cert_validity(x509cert);
+	if (res != 0) {
+		ks_err("Manifest cert validity check failed (%d)\n", res);
+		res = -CERTIFICATE_EXPIRED;
+		goto exit;
+	}
+
+	hash.algo = default_sig_hash_algo;
+	if (calc_shash(&hash, data, data_len) < 0) {
+		ks_err("Manifest signature calculation failed\n");
+		res = -SIGNATURE_FAILURE;
+		goto exit;
+	}
+
+	if (verify_manifest_signature(x509cert->pub, &hash, sig,
+				sig_len) != 0) {
+		ks_err("Manifest signature verification failed\n");
+		res = -SIGNATURE_FAILURE;
+		goto exit;
+	}
+	ks_debug("DEBUG_APPAUTH: Signature verification OK\n");
+
+exit:
+	x509_free_certificate(x509cert);
+	return res;
+}
diff --git a/security/keystore/client.c b/security/keystore/client.c
index b229331303aa..268bacb5e02d 100644
--- a/security/keystore/client.c
+++ b/security/keystore/client.c
@@ -30,6 +30,9 @@
 #include "keystore_mac.h"
 #include "keystore_debug.h"
 
+#ifdef CONFIG_APPLICATION_AUTH
+#include "appauth/manifest_verify.h"
+#endif
 #define KERNEL_CLIENTS_ID			"+(!$(%@#%$$)*"
 
 /**
@@ -74,12 +77,21 @@ static char *get_current_process_path(char *buf, int buflen)
 	return result;
 }
 
+#ifdef CONFIG_APPLICATION_AUTH
+int keystore_calc_clientid(u8 *client_id, const unsigned int client_id_size,
+		int timeout, u16 caps)
+#else
 int keystore_calc_clientid(u8 *client_id, const unsigned int client_id_size)
+#endif
 {
 	int res = 0;
 	char *buf = NULL;
 	char *f_path = NULL;
-
+#ifdef CONFIG_APPLICATION_AUTH
+	char *mbuf = NULL;
+	int mrootlen = PATH_MAX + NAME_MAX +
+		strlen(CONFIG_APPLICATION_AUTH_MANIFEST_ROOT) + 10;
+#endif
 	if (!client_id)
 		return -EINVAL;
 
@@ -87,6 +99,12 @@ int keystore_calc_clientid(u8 *client_id, const unsigned int client_id_size)
 	buf = kmalloc(PATH_MAX + NAME_MAX, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
+#ifdef CONFIG_APPLICATION_AUTH
+	/* alloc mem for manifest path */
+	mbuf = kmalloc(mrootlen, GFP_KERNEL);
+	if (!mbuf)
+		goto out_buf;
+#endif
 
 	/* clear the buf */
 	memset(buf, 0, PATH_MAX + NAME_MAX);
@@ -110,6 +128,60 @@ int keystore_calc_clientid(u8 *client_id, const unsigned int client_id_size)
 		f_path = KERNEL_CLIENTS_ID;
 	}
 
+#ifdef CONFIG_APPLICATION_AUTH
+	strcpy(mbuf, CONFIG_APPLICATION_AUTH_MANIFEST_ROOT);
+	strcat(mbuf, "/");
+	strcat(mbuf, f_path);
+	strcat(mbuf, ".manifest");
+	ks_info(KBUILD_MODNAME ": %s Verifying manifest: %s.\n",
+		__func__, mbuf);
+
+	res = verify_manifest_file(mbuf, timeout, caps);
+	if (res) {
+		/* error case, do not register */
+		ks_err(KBUILD_MODNAME ": Cannot register with keystore - manifest verification failed (res=%d)\n",
+				res);
+		switch (-res) {
+		case MALFORMED_MANIFEST:
+			res = -EINVAL;
+			ks_err(KBUILD_MODNAME ": -> Malformed manifest (check the compiler version)\n");
+			break;
+		case CERTIFICATE_FAILURE:
+			res = -EKEYREJECTED;
+			ks_err(KBUILD_MODNAME ": -> Invalid certificate in the manifest\n");
+			break;
+		case CERTIFICATE_EXPIRED:
+			res = -EKEYEXPIRED;
+			ks_err(KBUILD_MODNAME ": -> Certificate expired (check system date!)\n");
+			break;
+		case CAPS_FAILURE:
+			res = -EKEYREJECTED;
+			ks_err(KBUILD_MODNAME ": -> Capabilities do not match\n");
+			break;
+		case SIGNATURE_FAILURE:
+			res = -EKEYREJECTED;
+			ks_err(KBUILD_MODNAME ": -> Manifest signature verification failed\n");
+			break;
+		case EXE_NOT_FOUND:
+			res = -ENOENT;
+			ks_err(KBUILD_MODNAME ": -> The executable not listed in the manifest\n");
+			break;
+		case FILE_TOO_BIG:
+			res = -EFBIG;
+			ks_err(KBUILD_MODNAME ": -> File too big\n");
+			break;
+		case HASH_FAILURE:
+			res = -EKEYREJECTED;
+			ks_err(KBUILD_MODNAME ": -> Hash calculation failed (or file listed in the manifest is missing)\n");
+			break;
+		default:
+			res = -EFAULT;
+			break;
+		}
+		goto out_buf;
+	}
+#endif
+
 	/* Clear the output buffer */
 	memset(client_id, 0, sizeof(u8) * client_id_size);
 
@@ -119,6 +191,9 @@ int keystore_calc_clientid(u8 *client_id, const unsigned int client_id_size)
 			      client_id_size);
 
 out_buf:
+#ifdef CONFIG_APPLICATION_AUTH
+	kfree(mbuf);
+#endif
 	kfree(buf);
 	return res;
 }
diff --git a/security/keystore/keystore_client.h b/security/keystore/keystore_client.h
index c3e80a6bdca5..80904779fcde 100644
--- a/security/keystore/keystore_client.h
+++ b/security/keystore/keystore_client.h
@@ -43,6 +43,11 @@
  *
  * Returns: 0 if OK or negative error code.
  */
+#ifdef CONFIG_APPLICATION_AUTH
+int keystore_calc_clientid(u8 *client_id, const unsigned int client_id_size,
+		int timeout, u16 caps);
+#else
 int keystore_calc_clientid(u8 *client_id, const unsigned int client_id_size);
+#endif
 
 #endif /* KEYSTORE_CLIENT_ID */
diff --git a/security/keystore/oemkey/Kconfig b/security/keystore/oemkey/Kconfig
new file mode 100644
index 000000000000..7baec3a5ae70
--- /dev/null
+++ b/security/keystore/oemkey/Kconfig
@@ -0,0 +1,53 @@
+
+config MANIFEST
+	tristate "Manifest Provisioning and Verification"
+	default n
+	select KEYS
+	select ASYMMETRIC_KEY_TYPE
+	select ASYMMETRIC_PUBLIC_KEY_SUBTYPE
+	select PUBLIC_KEY_ALGO_RSA
+	select CRYPTO_RSA
+	select MPILIB
+	select X509_CERTIFICATE_PARSER
+	select ABL_PARAMMETERS
+	select ABL_CMDLINE
+	help
+		A module which reads the manifest passed to the kernel
+		by the bootloader. Allows applications to verify digest
+		signatures against the key digest signatures provided
+		by the manifest.
+
+                If in doubt, select "N".
+
+config MANIFEST_HARDCODE
+	bool "Hardcode the manifest"
+        default n
+	depends on MANIFEST
+	help
+                Sets the manifest to fixed values instead
+                of using values passed via the kernel command line.
+
+                WARNING: This is only for testing purposes and should not be used
+                for production as any data encrypted with keystore will be vulnerable
+                to attack.
+
+                If in doubt, select "N".
+
+config ABL_PARAMETERS
+	bool "Retrieve OEM Keys From ABL Parameters"
+        default n
+	help
+		A module which locates the oem keys from abl command line parameters.
+		Manifest module will retrieve the manifest key to verify the public key
+		in manifest file.
+
+		If in double, select "N".
+
+config ABL_CMDLINE
+	bool "Secure command line copy functions"
+        default n
+	help
+		A module which provides secure command line copy functions
+		needed by manifest module.
+
+		If in double, select "N".
diff --git a/security/keystore/oemkey/Makefile b/security/keystore/oemkey/Makefile
new file mode 100644
index 000000000000..fc2263972969
--- /dev/null
+++ b/security/keystore/oemkey/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_MANIFEST) += manifest.o
+obj-$(CONFIG_ABL_CMDLINE) += abl_cmdline.o
+obj-$(CONFIG_ABL_PARAMETERS) += abl_param.o
diff --git a/security/keystore/oemkey/abl.h b/security/keystore/oemkey/abl.h
new file mode 100644
index 000000000000..248c368c8d1c
--- /dev/null
+++ b/security/keystore/oemkey/abl.h
@@ -0,0 +1,55 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporation. */
+#ifndef __SOC_APL_ABL_H__
+#define __SOC_APL_ABL_H__
+
+enum apl_soc_stepping {
+	APL_SOC_STEPPING_A0 = 0x50,
+	APL_SOC_STEPPING_B0,
+	APL_SOC_STEPPING_B1,
+	APL_SOC_STEPPING_D0
+};
+
+/**
+ * struct seed_offset - ABL SEED address holder
+ * @seed:  Array holding the SEED offset locations
+ */
+struct seed_offset {
+	unsigned int    device_seed;
+	unsigned int    user_seed;
+};
+
+/**
+ * struct manifest_offset - ABL MANIFEST address and size holder
+ * @size: Size of manifest
+ * @manifest: Offset for manifest
+ */
+struct manifest_offset {
+	unsigned int    size;
+	unsigned int    offset;
+};
+
+/**
+ * struct hvwer - ABL hardware info
+ * @soc_stepping: Stepping of SoC
+ * @cpu_cores: Number of CPU cores
+ * @cpu_freq: Frequency of CPU
+ * @platform_id: ???
+ * @sku: ???
+ * @memory_total: Total size of available system memory
+ */
+struct hwver {
+	unsigned int	soc_stepping;
+	unsigned int	cpu_cores;
+	unsigned int	cpu_freq;
+	unsigned int	platform_id;
+	unsigned int	sku;
+	unsigned int	memory_total;
+};
+
+int get_apl_hwver(struct hwver *hwver);
+int get_apl_manifest_offsets(struct manifest_offset *moff);
+int get_apl_seed_offsets(struct seed_offset *ksoff);
+int get_apl_seed_list_offsets(struct seed_offset *ksoff);
+
+#endif /* __SOC_APL_ABL_H__ */
diff --git a/security/keystore/oemkey/abl_cmdline.c b/security/keystore/oemkey/abl_cmdline.c
new file mode 100644
index 000000000000..89b81a864cf5
--- /dev/null
+++ b/security/keystore/oemkey/abl_cmdline.c
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: GPL-2.0
+// Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporatio.
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/linkage.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/io.h>
+
+#include "abl_cmdline.h"
+
+static inline ssize_t size_inside_page(unsigned long start,
+					     unsigned long size)
+{
+	unsigned long sz = PAGE_SIZE - (start & (PAGE_SIZE - 1));
+
+	return min(sz, size);
+}
+
+int memcpy_from_ph(void *dest, phys_addr_t p, size_t count)
+{
+	if (!valid_phys_addr_range(p, count))
+		return -EFAULT;
+
+	while (count > 0) {
+		ssize_t sz = size_inside_page(p, count);
+
+		memcpy(dest, __va(p), sz);
+		dest += sz;
+		p += sz;
+		count -= sz;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(memcpy_from_ph);
+
+int memset_ph(phys_addr_t p, int val, size_t count)
+{
+	if (!valid_phys_addr_range(p, count))
+		return -EFAULT;
+
+	while (count > 0) {
+		ssize_t sz = size_inside_page(p, count);
+
+		memset(__va(p), val, sz);
+		p += sz;
+		count -= sz;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(memset_ph);
+
+/* end of file */
diff --git a/security/keystore/oemkey/abl_cmdline.h b/security/keystore/oemkey/abl_cmdline.h
new file mode 100644
index 000000000000..b673a4078afc
--- /dev/null
+++ b/security/keystore/oemkey/abl_cmdline.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporatio. */
+#ifndef _ABL_CMDLINE_H_
+#define _ABL_CMDLINE_H_
+
+/**
+ * memcpy_from_ph() - Copy block of data from physical memory.
+ *
+ * @dest:  Destination address.
+ * @pp:    Address in physical memory.
+ * @count: Number of bytes to copy.
+ *
+ * Return: 0 if OK or negative error code (see errno).
+ */
+int memcpy_from_ph(void *dest, phys_addr_t p, size_t count);
+
+/**
+ * memset_ph() - Copy block of data from physical memory.
+ *
+ * @pp:    Address in physical memory.
+ * @val:   Value to be assigned.
+ * @count: Number of bytes to copy.
+ *
+ * Return: 0 if OK or negative error code (see errno).
+ */
+int memset_ph(phys_addr_t p, int val, size_t count);
+
+#endif /* _ABL_CMDLINE_H_ */
diff --git a/security/keystore/oemkey/abl_param.c b/security/keystore/oemkey/abl_param.c
new file mode 100644
index 000000000000..0c2eea6ce958
--- /dev/null
+++ b/security/keystore/oemkey/abl_param.c
@@ -0,0 +1,248 @@
+// SPDX-License-Identifier: GPL-2.0
+// Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporation.
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include "abl.h"
+
+static struct kobject *sysfs_obj;
+LIST_HEAD(params_list);
+
+struct abl_param {
+	struct list_head list;
+	struct attribute attr;
+	const char *name;
+	const char *value;
+};
+
+#ifdef CONFIG_ABL_PARAM_MAX
+#define MAX_ABL_PARAMS CONFIG_ABL_PARAM_MAX
+#else
+#define MAX_ABL_PARAMS 32
+#endif
+/** When __setup macro will be triggered by kernel memory
+ * allocation is still not initialized, so use statically
+ * defined array to keep parsed params.
+ */
+static struct abl_param params[MAX_ABL_PARAMS];
+static unsigned int num_params;
+
+/* device and user seed */
+#define ABL_SEED		"seed"
+#define ABL_SEED_LIST		"seed_list"
+#define ABL_SEED_FORMAT         "%x,%x"
+#define ABL_RET_DSEED_USEED	2
+
+#define ABL_MANIFEST		"oemkm"
+#define ABL_MANIFEST_FORMAT	"%x@%x"
+#define ABL_RET_SIZE_MANIFEST	2
+
+#define ABL_HWVER		"hwver"
+#define ABL_HWVER_FORMAT	"%x,%d,%d,%x,%d,%d"
+#define ABL_RET_SIZE_HWVER	6
+
+static int get_apl_offsets(const char *tag, struct seed_offset *ksoff)
+{
+	struct abl_param *param;
+	int res = -ENODATA;
+
+	if (!ksoff) {
+		pr_err(KBUILD_MODNAME ": null ptr - ksoff: %p\n", ksoff);
+		return -EFAULT;
+	}
+
+	list_for_each_entry(param, &params_list, list) {
+		if (strcmp(tag, param->name) == 0) {
+			res = sscanf(param->value, ABL_SEED_FORMAT,
+					&ksoff->device_seed,
+					&ksoff->user_seed);
+
+			if (res == ABL_RET_DSEED_USEED)
+				res = 0;
+			break;
+		}
+	}
+
+	return res;
+}
+
+
+int get_apl_seed_offsets(struct seed_offset *ksoff)
+{
+	return get_apl_offsets(ABL_SEED, ksoff);
+}
+EXPORT_SYMBOL_GPL(get_apl_seed_offsets);
+
+int get_apl_seed_list_offsets(struct seed_offset *ksoff)
+{
+	return get_apl_offsets(ABL_SEED_LIST, ksoff);
+}
+EXPORT_SYMBOL_GPL(get_apl_seed_list_offsets);
+
+int get_apl_manifest_offsets(struct manifest_offset *moff)
+{
+	struct abl_param *param;
+	int res = -ENODATA;
+
+	if (!moff) {
+		pr_err(KBUILD_MODNAME ": null ptr - moff: %p\n", moff);
+		return -EFAULT;
+	}
+
+	list_for_each_entry(param, &params_list, list) {
+		if (strcmp(ABL_MANIFEST, param->name) == 0) {
+			res = sscanf(param->value, ABL_MANIFEST_FORMAT,
+					&moff->size,
+					&moff->offset);
+
+			if (res == ABL_RET_SIZE_MANIFEST)
+				res = 0;
+			break;
+		}
+	}
+
+	return res;
+}
+EXPORT_SYMBOL_GPL(get_apl_manifest_offsets);
+
+int get_apl_hwver(struct hwver *hwver)
+{
+	struct abl_param *param;
+	int res = -ENODATA;
+
+	if (!hwver) {
+		pr_err(KBUILD_MODNAME ": null ptr - hwver: %p\n", hwver);
+		return -EFAULT;
+	}
+
+	list_for_each_entry(param, &params_list, list) {
+		if (strcmp(ABL_HWVER, param->name) == 0) {
+			res = sscanf(param->value, ABL_HWVER_FORMAT,
+					&hwver->soc_stepping,
+					&hwver->cpu_cores,
+					&hwver->cpu_freq,
+					&hwver->platform_id,
+					&hwver->sku,
+					&hwver->memory_total);
+
+			if (res == ABL_RET_SIZE_HWVER)
+				res = 0;
+			break;
+		}
+	}
+	return res;
+}
+EXPORT_SYMBOL_GPL(get_apl_hwver);
+
+/**
+ * Generic show function that will print ABL param value
+ */
+static ssize_t show(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	struct abl_param *param;
+
+	list_for_each_entry(param, &params_list, list) {
+		if (strcmp(attr->name, param->name) == 0)
+			return snprintf(buf, PAGE_SIZE, "%s\n", param->value);
+	}
+
+	return -EIO;
+}
+
+static const struct sysfs_ops abl_sysfs_ops = {
+	.show   = show,
+};
+
+static struct kobj_type abl_ktype = {
+	.sysfs_ops = &abl_sysfs_ops
+};
+
+static int init_sysfs(void)
+{
+	int ret = 0;
+
+	sysfs_obj = kzalloc(sizeof(struct kobject), GFP_KERNEL);
+	if (!sysfs_obj)
+		return -ENOMEM;
+
+	kobject_init(sysfs_obj, &abl_ktype);
+
+	ret = kobject_add(sysfs_obj, kernel_kobj, "abl");
+	if (ret) {
+		pr_err(KBUILD_MODNAME ": Cannot add ABL kobject to sysfs\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static int __init abl_cmdline_init(void)
+{
+	int ret = 0;
+	struct abl_param *param;
+
+	/* Register ABL in sysfs under /sys/kernel */
+	ret = init_sysfs();
+	if (ret) {
+		pr_err(KBUILD_MODNAME ": Cannot initialize ABL sysfs\n");
+		return ret;
+	}
+
+	/* Expose all ABL params in sysfs */
+	list_for_each_entry(param, &params_list, list) {
+		param->attr.name = param->name;
+		param->attr.mode = 0444;
+		ret = sysfs_create_file(sysfs_obj, &param->attr);
+		if (ret)
+			pr_err(KBUILD_MODNAME ": Cannot create sysfs file for param %s\n",
+					param->name);
+	}
+
+	pr_info(KBUILD_MODNAME ": Expose ABL parameters to sysfs (/sys/kernel/abl)\n");
+	return 0;
+}
+
+static void __exit abl_cmdline_exit(void)
+{
+
+}
+
+static inline int __init setup_abl_params(char *arg)
+{
+	struct abl_param *param;
+	char *name;
+	char *value;
+
+	if (!arg)
+		return -EINVAL;
+
+	/* All ABL params are in form of ABL.<name>=<value> */
+	name = strsep(&arg, "=");
+	if (!name)
+		return -ENODATA;
+
+	value = strsep(&arg, "=");
+	if (!value)
+		return -ENODATA;
+
+	if (num_params < MAX_ABL_PARAMS) {
+		param = &params[num_params];
+		num_params++;
+
+		INIT_LIST_HEAD(&param->list);
+		param->name = name;
+		param->value = value;
+
+		list_add(&param->list, &params_list);
+	} else {
+		pr_warn(KBUILD_MODNAME ":Exceeded max number of ABL parameters - %d\n",
+				MAX_ABL_PARAMS);
+	}
+
+	return 0;
+}
+__setup("ABL.", setup_abl_params);
+
+module_init(abl_cmdline_init);
+module_exit(abl_cmdline_exit);
+MODULE_LICENSE("GPL");
diff --git a/security/keystore/oemkey/manifest.c b/security/keystore/oemkey/manifest.c
new file mode 100644
index 000000000000..19c1852e3a65
--- /dev/null
+++ b/security/keystore/oemkey/manifest.c
@@ -0,0 +1,839 @@
+// SPDX-License-Identifier: GPL-2.0
+// Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporation.
+#include <crypto/hash.h>
+#include <crypto/public_key.h>
+#include <crypto/internal/rsa.h>
+#include <keys/system_keyring.h>
+#include <keys/asymmetric-type.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/keyctl.h>
+#include <linux/module.h>
+#include <linux/mpi.h>
+#include <linux/scatterlist.h>
+#include <linux/slab.h>
+#include <linux/cred.h>
+#include "abl_cmdline.h"
+#ifndef CONFIG_MANIFEST_HARDCODE
+#include "abl.h"
+#endif
+#include "manifest.h"
+
+#define SHA256_HASH_ALGO	2
+#define SHA256_HASH_SIZE	32
+
+struct manifest_holder {
+	uint32_t size;
+	uint8_t *data;
+};
+
+struct manifest_holder manifest = {0};  /* The manifest */
+
+#ifdef CONFIG_MANIFEST_HARDCODE
+/* return constant key manifest if testing: */
+uint8_t hardcode_manifest[] = {
+	0x0e, 0x00, 0x00, 0x00,
+	0xf0, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x36, 0xc7, 0xfe, 0x3a,
+	0xc7, 0xf4, 0x12, 0x55, 0x93, 0x94, 0x25, 0xca, 0xde, 0x15, 0x17, 0xdd,
+	0xeb, 0xd2, 0x22, 0x44, 0xc9, 0x31, 0x7f, 0x71, 0x15, 0x84, 0xa5, 0x89,
+	0x4a, 0x6c, 0xd3, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x02, 0x20, 0x00, 0x44, 0xfa, 0xa4, 0x0d, 0xd3, 0x3e, 0xb4, 0x85,
+	0x5f, 0x87, 0x77, 0x65, 0x46, 0x59, 0x7e, 0x2b, 0x8d, 0x98, 0xec, 0x41,
+	0xf8, 0xed, 0x88, 0xdb, 0xa0, 0x56, 0xd7, 0x2b, 0x4f, 0x47, 0x6d, 0x45,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
+	0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00,
+	0xd3, 0xba, 0xea, 0x4f, 0x6f, 0xc3, 0xde, 0xdc, 0x07, 0xc7, 0xeb, 0x9b,
+	0x06, 0x86, 0x4f, 0x4c, 0x42, 0xbb, 0xcb, 0xd7, 0xc3, 0xf1, 0xb3, 0x9c,
+	0x27, 0x8d, 0x77, 0xfd, 0x23, 0xc6, 0x65, 0x1a
+};
+
+#endif
+
+struct cred *manifest_keyring_cred;
+struct key *manifest_keyring;
+struct key_manifest_extension key_manifest_extension_data;
+struct key_restriction *restriction;
+
+static void debug_hexdump(const char *txt, const void *ptr, unsigned int size)
+{
+	pr_debug("%s: size: %u (0x%lx)\n", txt, size, (unsigned long) ptr);
+
+	if (ptr && size)
+		print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, ptr, size);
+}
+
+static int check_key_manifest_header(
+		struct key_manifest_extension_hdr *km_hdr)
+{
+	int res = 0;
+
+	if (!km_hdr)
+		return -EINVAL;
+
+	if (km_hdr->ext_type != MANIFEST_KEY_EXTENSION) {
+		pr_err(KBUILD_MODNAME ": Invalid extension type! (Expect %u, got %u)\n",
+			MANIFEST_KEY_EXTENSION, km_hdr->ext_type);
+		return -EILSEQ;
+	}
+
+	if ((km_hdr->reserved_1    != 0) ||
+		(km_hdr->reserved_2[0] != 0) ||
+		(km_hdr->reserved_2[1] != 0)) {
+		pr_err(KBUILD_MODNAME ": Non-zero reserved region!\n");
+			return -EILSEQ;
+	}
+
+
+	return res;
+}
+
+static int parse_key_entry(uint8_t **data,
+		struct key_manifest_entry *entry)
+{
+	int res = 0;
+
+	if (!data || !entry) {
+		pr_err(KBUILD_MODNAME ": Null data pointer provided!\n");
+		return -EINVAL;
+	}
+
+	entry->header = (struct key_manifest_entry_hdr *) *data;
+	*data += sizeof(struct key_manifest_entry_hdr);
+
+	entry->hash = *data;
+	*data += entry->header->hash_size;
+
+	return res;
+}
+
+static int parse_key_manifest(uint8_t **data,
+			      struct key_manifest_extension *kme)
+{
+	uint8_t *end;
+	int res = 0;
+	uint32_t i = 0;
+
+	if (!data || !kme) {
+		pr_err(KBUILD_MODNAME ": Null data pointer provided!\n");
+		return -EINVAL;
+	}
+
+	end = *data;
+	/* First parse the manifest extension header */
+	kme->header = (struct key_manifest_extension_hdr *) *data;
+	*data += sizeof(struct key_manifest_extension_hdr);
+	end += kme->header->ext_length;
+
+	res = check_key_manifest_header(kme->header);
+	if (res < 0) {
+		pr_err(KBUILD_MODNAME ": Invalid key manifest extension header\n");
+		return res;
+	}
+
+	while (*data < end) {
+		if (i > MAX_KEY_ENTRIES) {
+			pr_err(KBUILD_MODNAME ": Not enough space for all key entries!\n");
+			res = -ENOMEM;
+			break;
+		}
+		parse_key_entry(data, &kme->entries[i]);
+		++i;
+	}
+
+	kme->n_entries = i;
+
+	return res;
+}
+
+static struct key *request_asymmetric_key(const char *id)
+{
+	key_ref_t key;
+
+	key = keyring_search(make_key_ref(manifest_keyring, 1),
+			&key_type_asymmetric, id);
+	if (IS_ERR(key)) {
+		switch (PTR_ERR(key)) {
+		case -EACCES:
+		case -ENOTDIR:
+		case -EAGAIN:
+			return ERR_PTR(-ENOKEY);
+		default:
+			return ERR_CAST(key);
+		}
+	}
+
+	return key_ref_to_ptr(key);
+}
+
+static int sha256_digest(const void *data, uint32_t size,
+			  void *result, uint32_t result_size)
+{
+	struct crypto_shash *tfm;
+	struct shash_desc *sdesc;
+	int shash_desc_size;
+	int res = 0;
+
+	if (!data || !result)
+		return -EFAULT;
+
+	tfm = crypto_alloc_shash("sha256",
+				CRYPTO_ALG_TYPE_HASH,
+				CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm)) {
+		res = PTR_ERR(tfm);
+		return (res < 0) ? res : -res;
+	}
+	shash_desc_size = sizeof(struct shash_desc) +
+		crypto_shash_descsize(tfm);
+	sdesc = kmalloc(shash_desc_size, GFP_KERNEL);
+	if (!sdesc) {
+		crypto_free_shash(tfm);
+		return -ENOMEM;
+	}
+
+	if (result_size < crypto_shash_digestsize(tfm)) {
+		crypto_free_shash(tfm);
+		kzfree(sdesc);
+		return -EINVAL;
+	}
+
+	sdesc->tfm = tfm;
+	sdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;
+
+	crypto_shash_init(sdesc);
+	crypto_shash_update(sdesc, data, size);
+	crypto_shash_final(sdesc, result);
+
+	crypto_free_shash(tfm);
+
+	return 0;
+}
+
+static void reverse_memcpy(char *dst, const char *src, size_t n)
+{
+	size_t i;
+
+	for (i = 0; i < n; ++i)
+		dst[n - 1 - i] = src[i];
+}
+
+static int calc_pubkey_digest(struct public_key *pk, uint8_t *digest)
+{
+	struct rsa_key rsa;
+	unsigned int len_e_fixed = 0;
+	unsigned int len_n_fixed = 0;
+	uint8_t *buf;
+	int res = 0;
+
+	if (!pk)
+		return -EFAULT;
+
+	res = rsa_parse_pub_key(&rsa, pk->key, pk->keylen);
+	if (res)
+		return -EINVAL;
+
+	debug_hexdump("RSA.N", rsa.n, rsa.n_sz);
+	debug_hexdump("RSA.E", rsa.e, rsa.e_sz);
+
+	/* mpi_get_buffer returns len_e == 3 and the digest
+	 * must be calculated with the exponent length == 4
+	 */
+	len_e_fixed = rsa.e_sz < 4 ? 4 : rsa.e_sz;
+
+	/* rsa_parse_pub_key() uses ANS.1 encoding, therefore, the
+	 * returned value for the modolus (n) contains a leading
+	 * byte 0x00 that indicates that the integer is a positive
+	 * value. Ignore the sign when populating buf.
+	 */
+
+	if (rsa.n_sz == 0)
+		return -EINVAL;
+
+	len_n_fixed = rsa.n_sz - 1;
+
+	pr_debug(KBUILD_MODNAME ": Size of len_n_fixed = %d\n", len_n_fixed);
+	pr_debug(KBUILD_MODNAME ": Size of len_e_fixed = %d\n", len_e_fixed);
+
+	buf = kmalloc(len_n_fixed + len_e_fixed, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	memset(buf, 0, len_n_fixed + len_e_fixed);
+
+	reverse_memcpy(buf, (rsa.n) + 1, len_n_fixed);
+	memcpy(buf + len_n_fixed, rsa.e, rsa.e_sz);
+
+	debug_hexdump("BUFF", buf, len_n_fixed + len_e_fixed);
+
+	res = sha256_digest(buf, len_n_fixed + len_e_fixed,
+			digest, SHA256_HASH_SIZE);
+	if (res < 0)
+		pr_err(KBUILD_MODNAME ": sha256_digest() error %d in %s\n",
+		       res, __func__);
+
+	kfree(buf);
+
+	return res;
+}
+
+int check_usage_bits(uint32_t *required, uint32_t *available)
+{
+	int i;
+
+	if (!required || !available)
+		return -EFAULT;
+
+	for (i = 0; i < MANIFEST_USAGE_SIZE; i++)
+		if ((required[i] & available[i]) != required[i])
+			return -EACCES;
+
+	return 0;
+}
+
+/**
+ * get_verified_pubkey_from_keyring() - Get key from .manifest_keyring
+ * and check usage bits. All non-zero bits in @required_usage_bits must also
+ * present in manifest usage bits for the given key.
+ * Result of the function is the key or -ENOKEY if the requested
+ * key is not present in the keyring or -ESRCH if the usage bits
+ * do not match.
+ *
+ * @id: Key id (char *) in .manifest_keyring.
+ * @required_usage_bits: Usage bit mask (4 * uint32_t)
+ *
+ * Returns: Pointer to the key if ok or an error pointer.
+ */
+static struct key *get_verified_pubkey_from_keyring(char *id,
+			    uint32_t *required_usage_bits)
+{
+	struct key *pubkey;
+	int res = 0;
+	char hexprefix[MANIFEST_SKID_PREFIX_LEN * 2 + 1];
+	uint32_t usage_bits[MANIFEST_USAGE_SIZE];
+	const char *ptr;
+
+	if (!id || !required_usage_bits)
+		return ERR_PTR(-EFAULT);
+
+	pubkey = request_asymmetric_key(id);
+	if (IS_ERR(pubkey))
+		return ERR_CAST(pubkey);
+
+	if (!pubkey->description)
+		return ERR_PTR(-EFAULT);
+
+	memset(hexprefix, 0, sizeof(hexprefix));
+	bin2hex(hexprefix, MANIFEST_SKID_PREFIX,
+					   MANIFEST_SKID_PREFIX_LEN);
+	ptr = strstr(pubkey->description, hexprefix);
+	if (ptr) {
+		res = hex2bin((char *) usage_bits,
+					  ptr + MANIFEST_SKID_PREFIX_LEN * 2,
+					  MANIFEST_SKID_USAGE_LEN);
+		if (res) {
+			pr_err(KBUILD_MODNAME ":Missing or invalid usage bits hex in key %s\n",
+					pubkey->description);
+			return ERR_PTR(-EINVAL);
+		}
+		if (!check_usage_bits(required_usage_bits, usage_bits))
+			return pubkey;
+	} else {
+		pr_err(KBUILD_MODNAME ":Invalid key description: %s\n",
+				pubkey->description);
+		return ERR_PTR(-EINVAL);
+	}
+
+	return ERR_PTR(-ESRCH);
+}
+
+/**
+ * get_verified_pubkey_from_keyring_by_keyid() - Get key from .manifest_keyring
+ * and check usage bits. All non-zero bits in @required_usage_bits must also
+ * present in manifest usage bits for the given key.
+ * Result of the function is the key or -ENOKEY if the requested
+ * key is not present in the keyring or -ESRCH if the usage bits
+ * do not match.
+ *
+ * @kid: Key id (struct asymmetric_key_id *) in .manifest_keyring.
+ * @required_usage_bits: Usage bit mask (4 * uint32_t)
+ *
+ * Returns: Pointer to the key if ok or an error pointer.
+ */
+static struct key *get_verified_pubkey_from_keyring_by_keyid(
+			     const struct asymmetric_key_id *kid,
+			     uint32_t *required_usage_bits)
+{
+	struct key *pubkey;
+	int res = 0;
+	char hexprefix[MANIFEST_SKID_PREFIX_LEN * 2 + 1];
+	uint32_t usage_bits[MANIFEST_USAGE_SIZE];
+	const char *ptr;
+
+	if (!kid || !required_usage_bits)
+		return ERR_PTR(-EFAULT);
+
+	pubkey = find_asymmetric_key(get_manifest_keyring(),
+				     NULL, kid, false);
+	if (IS_ERR(pubkey))
+		return ERR_CAST(pubkey);
+
+	memset(hexprefix, 0, sizeof(hexprefix));
+	bin2hex(hexprefix, MANIFEST_SKID_PREFIX,
+					   MANIFEST_SKID_PREFIX_LEN);
+	ptr = strstr(pubkey->description, hexprefix);
+	if (ptr) {
+		res = hex2bin((char *) usage_bits,
+					  ptr + MANIFEST_SKID_PREFIX_LEN * 2,
+					  MANIFEST_SKID_USAGE_LEN);
+		if (res) {
+			pr_err(KBUILD_MODNAME ":Missing or invalid usage bits hex in key %s\n",
+					pubkey->description);
+			return ERR_PTR(-EINVAL);
+		}
+		if (!check_usage_bits(required_usage_bits, usage_bits))
+			return pubkey;
+	} else {
+		pr_err(KBUILD_MODNAME ":Invalid key description: %s\n",
+				pubkey->description);
+		return ERR_PTR(-EINVAL);
+	}
+
+	return ERR_PTR(-ESRCH);
+}
+
+int manifest_key_verify_digest(void *digest, unsigned int digest_size,
+			       const void *signature, unsigned int sig_size,
+			       char *keyid, unsigned int usage_bit)
+{
+	int res = 0;
+	uint32_t usage_bits[MANIFEST_USAGE_SIZE];
+	unsigned int usage_word;
+	unsigned int usage_sub_bit;
+	uint8_t *sig_copy = NULL;
+	struct key *manifest_key;
+	struct public_key_signature sig_data;
+
+	if (!digest || !signature)
+		return -EFAULT;
+
+	pr_debug(KBUILD_MODNAME ": Usage bit set: %u\n", usage_bit);
+
+	/* Set the usage bits */
+	memset(usage_bits, 0, sizeof(usage_bits));
+
+	usage_word = usage_bit /
+		(sizeof(((struct key_manifest_entry_hdr *)0)->usage[0]) * 8);
+	usage_sub_bit = usage_bit %
+		(sizeof(((struct key_manifest_entry_hdr *)0)->usage[0]) * 8);
+
+	if (usage_word >= MANIFEST_USAGE_SIZE)
+		return -EINVAL;
+
+	usage_bits[usage_word] = (0x1 << usage_sub_bit);
+
+	/* Get the manifest key */
+	manifest_key = get_verified_pubkey_from_keyring(keyid, usage_bits);
+
+	/* Check manifest error pointer */
+	if (IS_ERR(manifest_key))
+		return PTR_ERR(manifest_key);
+
+	/* construct the signature object */
+	sig_copy = kzalloc(sig_size, GFP_KERNEL);
+	if (!sig_copy)
+		return -ENOMEM;
+
+	memcpy(sig_copy, signature, sig_size);
+	memset(&sig_data, 0, sizeof(sig_data));
+	sig_data.digest = digest;
+	sig_data.digest_size = digest_size;
+	sig_data.hash_algo = "sha256";
+	sig_data.s = sig_copy;
+	sig_data.s_size = sig_size;
+
+	res = verify_signature(manifest_key, &sig_data);
+
+	kzfree(sig_copy);
+	return res;
+}
+
+const struct key_manifest_extension *get_key_manifest_extension_data(void)
+{
+	return &key_manifest_extension_data;
+}
+
+int verify_public_key_against_manifest(struct public_key *pub_key,
+				       uint32_t *required_usage_bits)
+{
+	int i, res = 0;
+	uint8_t digest[SHA256_HASH_SIZE];
+
+	if (!pub_key)
+		return -EFAULT;
+
+	res = calc_pubkey_digest(pub_key, digest);
+	if (res < 0)
+		return res;
+
+	debug_hexdump("KEY DIGEST", digest, sizeof(digest));
+
+	for (i = 0; i < key_manifest_extension_data.n_entries; i++) {
+		const struct key_manifest_entry *entry =
+			&key_manifest_extension_data.entries[i];
+
+		if (entry->header->hash_algo != SHA256_HASH_ALGO ||
+		    entry->header->hash_size != SHA256_HASH_SIZE)
+			continue;
+
+		debug_hexdump("KEY(n) DIGEST", entry->hash, sizeof(digest));
+
+		if (memcmp(digest, entry->hash, sizeof(digest)) == 0) {
+			debug_hexdump("USAGE BITS", entry->header->usage,
+			sizeof(((struct key_manifest_entry_hdr *)0)->usage));
+
+			debug_hexdump("REQUIRED BITS", required_usage_bits,
+			sizeof(((struct key_manifest_entry_hdr *)0)->usage));
+
+			if (!check_usage_bits(required_usage_bits,
+					entry->header->usage))
+				return 0;
+		}
+	}
+
+	return -ESRCH;
+}
+
+int verify_x509_cert_against_manifest_keyring(
+	const struct asymmetric_key_id *kid,
+	unsigned int usage_bit)
+{
+	struct key *pubkey;
+	uint32_t usage_bits[MANIFEST_USAGE_SIZE];
+	unsigned int usage_word;
+	unsigned int usage_sub_bit;
+
+	if (!kid)
+		return -EINVAL;
+
+	/* Set the usage bits */
+	memset(usage_bits, 0, sizeof(usage_bits));
+
+	usage_word = usage_bit /
+		(sizeof(((struct key_manifest_entry_hdr *)0)->usage[0]) * 8);
+	usage_sub_bit = usage_bit %
+		(sizeof(((struct key_manifest_entry_hdr *)0)->usage[0]) * 8);
+
+	if (usage_word >= MANIFEST_USAGE_SIZE)
+		return -EINVAL;
+
+	usage_bits[usage_word] = (0x1 << usage_sub_bit);
+
+	pubkey = get_verified_pubkey_from_keyring_by_keyid(kid, usage_bits);
+	if (IS_ERR(pubkey))
+		return PTR_ERR(pubkey);
+
+	return 0;
+}
+EXPORT_SYMBOL(verify_x509_cert_against_manifest_keyring);
+
+static char keystrbuf[512];
+
+static const char *key_id_to_str(const struct asymmetric_key_id *kid)
+{
+	size_t len = kid->len;
+
+	/* not more than 511 characters plus null terminator */
+	if (len > sizeof(keystrbuf) - 1)
+		len = sizeof(keystrbuf) - 1;
+
+	memset(keystrbuf, 0, sizeof(keystrbuf));
+	memcpy(keystrbuf, kid->data, len);
+	return keystrbuf;
+}
+
+/**
+ * manifest_key_restrict_link_func - Control which keys are accepted into the
+ * manifest keyring.
+ * @dest_keyring: Keyring being linked to.
+ * @type: The type of key being added.
+ * @payload: The payload of the new key.
+ * @trust_keyring: A ring of keys that can be used to vouch for the new cert.
+ *
+ * Accept key if it has been signed by a key already in the keyring
+ * or if it matches a key hash in the OEM key manifest
+ *
+ *
+ *  See: https://lwn.net/Articles/671296/
+ *       https://lwn.net/Articles/678782/
+ */
+static int manifest_key_restrict_link_func(struct key *dest_keyring,
+					   const struct key_type *type,
+					   const union key_payload *payload,
+					   struct key *trust_keyring)
+{
+	const struct public_key_signature *sig;
+	const struct asymmetric_key_ids *kids;
+	const struct asymmetric_key_id *skid;
+	const struct asymmetric_key_id *akid_skid;
+	struct public_key *key; /* candidate key to be added */
+	uint32_t usage_bits[MANIFEST_USAGE_SIZE];
+	int ret;
+
+	pr_devel("==>%s()\n", __func__);
+
+	if (type != &key_type_asymmetric)
+		return -EOPNOTSUPP;
+
+	sig = payload->data[asym_auth];
+	if (!sig)
+		return -ENOPKG;
+
+	key = payload->data[asym_crypto];
+	if (!key)
+		return -ENOPKG;
+
+	/* IDs of the Certificate itself */
+	/* kids->id[0] = cert->id        */
+	/* kids->id[1] = cert->skid      */
+	kids = payload->data[asym_key_ids];
+	if (!kids)
+		return -ENOPKG;
+
+	/* IDs of the certificate used to sign this certificate */
+	akid_skid = sig->auth_ids[1];
+
+	/* First check the subject Key ID matched manifest key prefix */
+	skid = kids->id[1];
+	if (skid->len <= (MANIFEST_SKID_PREFIX_LEN + MANIFEST_SKID_USAGE_LEN) ||
+	    memcmp(skid->data, MANIFEST_SKID_PREFIX, MANIFEST_SKID_PREFIX_LEN))
+		return -EPERM;
+
+	/* Subject Key ID contains manifest key usage bits */
+	memcpy(usage_bits, (skid->data) + MANIFEST_SKID_PREFIX_LEN,
+	       MANIFEST_SKID_USAGE_LEN);
+
+	pr_devel("Cert usage bits: %*phN\n",
+		 MANIFEST_SKID_USAGE_LEN, usage_bits);
+
+	/* Check for a self-signed certificate */
+	if (!akid_skid || asymmetric_key_id_same(skid, akid_skid)) {
+		pr_devel("Checking self signed cert %s...\n",
+			 key_id_to_str(skid));
+
+		ret = public_key_verify_signature(key, sig); /* self signed */
+		if (ret < 0) {
+			pr_err("Cert signature check failed: %d\n", ret);
+			return ret;
+		}
+
+		ret = verify_public_key_against_manifest(key, usage_bits);
+		if (ret < 0) {
+			pr_err("Self signed cert does not match manifest: %d\n",
+			       ret);
+			return ret;
+		}
+
+	} else {
+		/* Certificate must be signed by existing key */
+		struct key *signing_key;
+		uint32_t parent_usage_bits[MANIFEST_USAGE_SIZE];
+		char hexprefix[MANIFEST_SKID_PREFIX_LEN * 2 + 1];
+		char *ptr;
+
+		pr_devel("Verifying non-self signed certificate against %s:\n",
+			 key_id_to_str(akid_skid));
+
+		/* Get the manifest master key from the keyring */
+		signing_key = find_asymmetric_key(dest_keyring,
+						  sig->auth_ids[0],
+						  sig->auth_ids[1],
+						  false);
+		if (IS_ERR(signing_key)) {
+			pr_err("Master key not found in manifest keyring.\n");
+			return -ENOKEY;
+		}
+
+		/* Check the master key */
+		ret = key_validate(signing_key);
+		if (ret) {
+			pr_err("Invalid manifest master key!\n");
+			key_put(signing_key);
+			return ret;
+		}
+
+		/* Check the signature of the candidate certificate */
+		ret = verify_signature(signing_key, sig);
+		if (ret < 0) {
+			pr_err("Invalid key signature.\n");
+			key_put(signing_key);
+			return ret;
+		}
+
+		/* Get usage bits from the primary key description (hex) */
+		pr_devel("Key description: %s\n", signing_key->description);
+		memset(hexprefix, 0, sizeof(hexprefix));
+		bin2hex(hexprefix,
+			MANIFEST_SKID_PREFIX,
+			MANIFEST_SKID_PREFIX_LEN);
+
+		ptr = strstr(signing_key->description, hexprefix);
+		if (!ptr) {
+			key_put(signing_key);
+			return -ENOMEM;
+		}
+		ret = hex2bin((char *) parent_usage_bits,
+			      ptr + MANIFEST_SKID_PREFIX_LEN * 2,
+			      MANIFEST_SKID_USAGE_LEN);
+		if (ret) {
+			pr_err("Missing or invalid usage bits hex in key %s\n",
+			       signing_key->description);
+			key_put(signing_key);
+			return ret;
+		}
+
+		/* Check if usage bits match */
+		ret = check_usage_bits(usage_bits, parent_usage_bits);
+		if (ret) {
+			pr_err("Usage bits do not match master key %s\n",
+			       signing_key->description);
+			key_put(signing_key);
+			return ret;
+		}
+
+		key_put(signing_key);
+	}
+
+	return ret;
+}
+
+static int __init manifest_init(void)
+{
+#ifndef CONFIG_MANIFEST_HARDCODE
+	struct manifest_offset moff;
+#endif
+	struct cred *m_cred;
+	struct key *keyring;
+	int res = 0;
+
+	restriction = NULL;
+	manifest.size = 0;
+
+#ifndef CONFIG_MANIFEST_HARDCODE
+	/* Get key manifest offset from cmdline */
+	res = get_apl_manifest_offsets(&moff);
+	if (res) {
+		pr_err(KBUILD_MODNAME
+		       ": Key manifest info missing in cmdline\n");
+		return res;
+	}
+
+	if (!moff.offset || !moff.size || moff.size > MAX_MANIFEST_SIZE) {
+		pr_err(KBUILD_MODNAME
+		       ": Invalid key manifest info in cmdline\n");
+		return -EINVAL;
+	}
+
+	manifest.data = kmalloc(moff.size, GFP_KERNEL);
+	if (!manifest.data)
+		return -ENOMEM;
+
+	/* copy data from physical memory */
+	res = memcpy_from_ph((uint8_t *) manifest.data,
+			     (phys_addr_t) moff.offset,
+			     (size_t) moff.size);
+	if (res < 0) {
+		pr_err(KBUILD_MODNAME ": memcpy_from_ph error %d, key manifest not available\n",
+			   res);
+		goto err1;
+	}
+
+	manifest.size = moff.size;
+#else
+	pr_info(KBUILD_MODNAME "using hardcoded manifest\n");
+	manifest.size = sizeof(hardcode_manifest);
+
+	manifest.data = kmalloc(manifest.size, GFP_KERNEL);
+	if (!manifest.data)
+		return -ENOMEM;
+
+	memcpy(manifest.data, hardcode_manifest, manifest.size);
+
+#endif
+
+	res = parse_key_manifest(&manifest.data, &key_manifest_extension_data);
+	if (res) {
+		pr_err(KBUILD_MODNAME ": parse_key_manifest() = %d in %s\n",
+		       res, __func__);
+		goto err1;
+	}
+
+	m_cred = prepare_kernel_cred(NULL);
+	if (!m_cred) {
+		res = -ENOMEM;
+		goto err1;
+	}
+
+	restriction = kzalloc(sizeof(struct key_restriction), GFP_KERNEL);
+
+	if (!restriction) {
+		res = -ENOMEM;
+		goto err2;
+	}
+
+	restriction->check = manifest_key_restrict_link_func;
+
+	keyring = keyring_alloc(".manifest_keyring",
+				GLOBAL_ROOT_UID,
+				GLOBAL_ROOT_GID,
+				m_cred,
+				((KEY_POS_ALL & ~KEY_POS_SETATTR) |
+				 KEY_USR_VIEW | KEY_USR_READ |
+				 KEY_USR_WRITE | KEY_USR_SEARCH),
+				KEY_ALLOC_NOT_IN_QUOTA,
+				restriction,
+				NULL);
+
+	if (IS_ERR(keyring)) {
+		res = PTR_ERR(keyring);
+		goto err2;
+	}
+
+	manifest_keyring_cred = m_cred;
+	manifest_keyring = keyring;
+
+	pr_info(KBUILD_MODNAME ": init Completed Successfully\n");
+
+	return res;
+
+err2:
+	put_cred(m_cred);
+
+err1:
+	kfree(restriction);
+
+	kfree(manifest.data);
+	return res;
+}
+
+static void __exit manifest_exit(void)
+{
+	key_put(manifest_keyring);
+	put_cred(manifest_keyring_cred);
+	kfree(manifest.data);
+	kfree(restriction);
+}
+module_init(manifest_init);
+module_exit(manifest_exit);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_DESCRIPTION("Intel(R) Manifest data");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE(KBUILD_MODNAME);
+/* end of file */
diff --git a/security/keystore/oemkey/manifest.h b/security/keystore/oemkey/manifest.h
new file mode 100644
index 000000000000..782969229826
--- /dev/null
+++ b/security/keystore/oemkey/manifest.h
@@ -0,0 +1,260 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Intel Keystore Linux driver, Copyright (c) 2018, Intel Corporation. */
+#ifndef _MANIFEST_H_
+#define _MANIFEST_H_
+
+#include "keys/asymmetric-type.h"
+
+#define MAX_MANIFEST_SIZE           (65536 * 1024)
+
+#define MANIFEST_HEADER_TYPE         0x4
+#define MANIFEST_HEADER_VERSION      0x10000
+#define MANIFEST_HEADER_MAGIC        "$MN2"
+#define MANIFEST_INTEL_VENDOR_ID     0x8086
+
+#define MANIFEST_KEY_EXTENSION      14
+#define MANIFEST_USAGE_SIZE          4
+#define MAX_KEY_ENTRIES            100
+
+/* Key Manifest Extension Usage bits */
+#define KEY_USAGE_CSE_BUP            0
+#define KEY_USAGE_CSE_MAIN           1
+/* Bits 3-31 are reserved for future Intel usage */
+#define KEY_USAGE_BOOT_POLICY       32
+#define KEY_USAGE_IUNIT_BOOTLOADER  33
+#define KEY_USAGE_IUNIT_MAINFW      34
+#define KEY_USAGE_CAVS_IMAGE_0      35
+#define KEY_USAGE_CAVS_IMAGE_1      36
+#define KEY_USAGE_IFWI              37
+#define KEY_USAGE_OS_BOOTLOADER     38
+#define KEY_USAGE_OS_KERNEL         39
+#define KEY_USAGE_OEM_SMIP          40
+#define KEY_USAGE_ISH               41
+/* Bits 42 - 127 are reserved for future OEM usage */
+
+/* SKID related constants */
+#define MANIFEST_SKID_PREFIX        "OEMKEY"
+#define MANIFEST_SKID_PREFIX_LEN    6
+#define MANIFEST_SKID_USAGE_LEN     16
+
+#if !defined(CONFIG_KEYSTORE_OEM_KEY_USAGE_BIT)
+#define CONFIG_KEYSTORE_OEM_KEY_USAGE_BIT 47
+#endif
+#if !defined(CONFIG_KEYSTORE_OEM_KEY_IDENTIFIER)
+#define CONFIG_KEYSTORE_OEM_KEY_IDENTIFIER "OEM: Keystore: 4f454d4b4559000000000080000000000000000000004b657973746f7265"
+#endif
+
+/**
+ * struct manifest_version - Manifest version
+ *
+ * @major:          Major version
+ * @minor:          Minor version
+ * @hotfix:         Hotfix version
+ * @build:          Build number
+ */
+struct manifest_version {
+	uint16_t major;
+	uint16_t minor;
+	uint16_t hotfix;
+	uint16_t build;
+} __packed;
+
+/**
+ * struct manifest_header - Manifest header
+ *
+ * @header_type:     Must be 0x4
+ * @header_length:   In DWORDs; eq 161 for this version
+ * @header_version:  0x10000 for this version
+ * @flags:           Bit 31: Debug Manifest
+ *                   Bits 0-30: reserved, must be 0
+ * @vendor:          0x8086 for Intel
+ * @date:            yyyymmdd in BCD format
+ * @size:            In DWORDs, size of entire manifest
+ *                   Maximum size 2K DWORDs(8KB)
+ * @magic[4]:        Magic number; eq "$MN2" for this ver.
+ * @reserved_1:      Must be zero
+ * @version:         Manifest version
+ * @svn:             Security Version Number
+ * @reserved_2[2]:   Must be zero
+ * @reserved_3[16]:  Must be zero
+ * @modulus_size:    In DWORDs; 64 for pkcs 1.5-2048
+ * @exponent_size:   In DWORDs;  1 for pkcs 1.5-2048
+ */
+struct manifest_header {
+	uint32_t header_type;
+	uint32_t header_length;
+	uint32_t header_version;
+	uint32_t flags;
+	uint32_t vendor;
+	uint32_t date;
+	uint32_t size;
+	uint8_t magic[4];
+	uint32_t reserved_1;
+	struct manifest_version version;
+	uint32_t svn;
+	uint32_t reserved_2[2];
+	uint32_t reserved_3[16];
+	uint32_t modulus_size;
+	uint32_t exponent_size;
+} __packed;
+
+/**
+ * struct manifest - Manifest
+ *
+ * @hdr:             Start of manifest header
+ * @public_key:      Size is hdr->modulus_size
+ * @exponent:        Size is hdr->exponent_size
+ * @signature:       Size is hdr->modulus_size
+ * @extension:       Start of the manifest extension
+ * @extension_size:  Size of the extension in bytes
+ */
+struct manifest {
+	struct manifest_header *hdr;
+	uint32_t  *public_key;
+	uint32_t  *exponent;
+	uint32_t  *signature;
+	uint8_t *extension;
+	uint32_t  extension_size;
+} __packed;
+
+/**
+ * struct key_manifest_extension_hdr - Key manifest extension header
+ *
+ * @ext_type:        Ext. Type = 14 for Key Manifest Extension
+ * @ext_length:      Ext. Length (bytes); (36 + 68*n) n is the num of keys
+ * @type:            Key Manifest Type
+ *                   0  Reserved
+ *                   1  CSE Root of Trust(ROT) Key Manifest
+ *                   2  OEM Key Manifest
+ * @svn:             Key Manifest Security Version Number
+ * @oem_id:          OEM ID (assigned to Tier-A OEMs by Intel)
+ *                   0  Reserved/Not-Used
+ *                   Only least significant 16 bits are used in BXT.
+ * @id:              Key Manifest ID
+ * @reserved_1:      Must be 0
+ * @reserved_2[4]:   Must be 0
+ */
+struct key_manifest_extension_hdr {
+	uint32_t ext_type;
+	uint32_t ext_length;
+	uint32_t type;
+	uint32_t svn;
+	uint16_t oem_id;
+	uint8_t id;
+	uint8_t reserved_1;
+	uint32_t  reserved_2[4];
+} __packed;
+
+/**
+ * struct key_manifest_entry_hdr - Key manifest entry header
+ *
+ * @usage:           Bitmap of usages allows for 128 usages
+ *                   Bits 0-31 are allocated for Intel usages
+ *                   Bits 32-127 are allocated for OEM usages
+ * @reserved_1:      Reserved
+ * @reserved_2:      Reserved
+ * @hash_algo:       Hash algorithm: 0  Reserved, 1  SHA1, 2  SHA256
+ * @hash_size:       Size of Hash in bytes (32 for SHA256)
+ */
+struct key_manifest_entry_hdr {
+	uint32_t usage[MANIFEST_USAGE_SIZE];
+	uint32_t reserved_1[4];
+	uint8_t reserved_2;
+	uint8_t hash_algo;
+	uint16_t hash_size;
+} __packed;
+
+/**
+ * struct key_manifest_entry - Key manifest entry
+ *
+ * @header:          Start of key manifest entry header
+ * @hash:            Key hash
+ */
+struct key_manifest_entry {
+	struct key_manifest_entry_hdr *header;
+	uint8_t *hash;
+} __packed;
+
+/**
+ * struct key_manifest_extension - Key manifest extension
+ *
+ * @header:          Start of key manifest extension header
+ * @n_entries:       Number of key manifest entries
+ * @entries:         Pointer to the key entries
+ */
+struct key_manifest_extension {
+	struct key_manifest_extension_hdr *header;
+	uint32_t n_entries;
+	struct key_manifest_entry entries[MAX_KEY_ENTRIES];
+} __packed;
+
+/**
+ * get_manifest_keyring() - Get manifest keyring.
+ *
+ * Returns: manifest keyring.
+ */
+extern struct key *manifest_keyring;
+static inline struct key *get_manifest_keyring(void)
+{
+	return manifest_keyring;
+}
+
+/**
+ * get_manifest_data() - Get parsed manifest data.
+ *
+ * Returns: parsed manifest data.
+ */
+const struct manifest *get_manifest_data(void);
+
+/**
+ * get_key_manifest_extension_data() - Get parsed key manifest extension data.
+ *
+ * Returns: parsed manifest data.
+ */
+const struct key_manifest_extension *get_key_manifest_extension_data(void);
+
+/**
+ * manifest_key_verify_digest() - Check if a digest has been
+ *                                signed by one of the manifest keys
+ *
+ * @digest: The SHA256 digest of the data to be verified
+ * @digest_size: Size of the digest
+ * @signature Public key signature pointer (raw data, MSB first).
+ * @sig_size: Signature size in bytes.
+ * @keyid: The key identifier in the kernel keyring.
+ * @usage_bit: The usage bit to check against
+ *
+ * Returns: 0 if OK or negative error code (see errno).
+ */
+int manifest_key_verify_digest(void *digest, unsigned int digest_size,
+			       const void *signature, unsigned int sig_size,
+			       char *keyid, unsigned int usage_bit);
+
+/**
+ * check_usage_bits() - Check if all required usage bits
+ * are among available usage bit set.
+ *
+ * @required: The required usage bit set.
+ * @available: The available (provided) usage bit set.
+ *
+ * Returns: 0 if verified OK or negative error code (see errno).
+ */
+int check_usage_bits(uint32_t *required, uint32_t *available);
+
+/**
+ * verify_x509_cert_against_manifest_keyring() - Check if the
+ * certificate is signed by a key present in the
+ * manifest keyring and matches the requested usage bits
+ * with a specific usage bit set.
+ *
+ * @cert: X509 certificate to be verified
+ * @usage_bit: The usage bit to check against
+ *
+ * Returns: 0 if verified OK or negative error code (see errno).
+ */
+int verify_x509_cert_against_manifest_keyring(
+	const struct asymmetric_key_id *kid,
+	unsigned int usage_bit);
+
+
+#endif /* _MANIFEST_H_ */
-- 
2.17.1

