From 43eb298a5105e7055cd7ff291542027d6f17a26d Mon Sep 17 00:00:00 2001
From: "Ch'ng, Seng Guan" <seng.guan.chng@intel.com>
Date: Fri, 23 May 2025 01:32:59 +0000
Subject: [PATCH] drm/xe: Enable OAM SCMI media metric with Tapir application

Enable Observability Architecture Media metric with SCMI registers.

Signed-off-by: Ch'ng, Seng Guan <seng.guan.chng@intel.com>
---
 drivers/gpu/drm/xe/xe_oa.c       | 34 ++++++++++++++++++++++++++++++--
 drivers/gpu/drm/xe/xe_oa.h       |  2 ++
 drivers/gpu/drm/xe/xe_oa_types.h | 12 +++++++++++
 3 files changed, 46 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/xe/xe_oa.c b/drivers/gpu/drm/xe/xe_oa.c
index 346f357b3d1f..490ef3c53a77 100644
--- a/drivers/gpu/drm/xe/xe_oa.c
+++ b/drivers/gpu/drm/xe/xe_oa.c
@@ -2251,6 +2251,30 @@ static int create_dynamic_oa_sysfs_entry(struct xe_oa *oa,
 	return sysfs_create_group(oa->metrics_kobj, &oa_config->sysfs_metric);
 }
 
+/**
+ * xe_oa_store_oa_regs - Store the OA registers
+ * @regs: base register
+ * @xe: xe device structure
+ */
+void xe_oa_store_oa_regs(const struct xe_oa_reg *regs, struct xe_device *xe)
+{
+	if (regs[0].addr.addr >= XE_OAM0_BASE && regs[0].addr.addr < XE_OAM1_BASE) {
+		//OAM0
+		//Need to save the regs content, so able to retrieve
+		//back in function xe_oa_stream_init
+		xe->tiles[0].media_gt->oa.oa_unit->regs =
+					xe->tiles[0].media_gt->oa.oa_unit->regs_oam0;
+	} else if (regs[0].addr.addr >= XE_OAM1_BASE && regs[0].addr.addr < XE_OAM1_LAST) {
+		//OAM1
+		xe->tiles[0].media_gt->oa.oa_unit->regs =
+					xe->tiles[0].media_gt->oa.oa_unit->regs_oam1;
+	} else {
+		xe->tiles[0].media_gt->oa.oa_unit->regs =
+					xe->tiles[0].media_gt->oa.oa_unit->regs_oa;
+	}
+
+}
+
 /**
  * xe_oa_add_config_ioctl - Adds one OA config
  * @dev: @drm_device
@@ -2317,6 +2341,9 @@ int xe_oa_add_config_ioctl(struct drm_device *dev, u64 data, struct drm_file *fi
 	}
 	oa_config->regs = regs;
 
+	/* function call to store the regs.addr*/
+	xe_oa_store_oa_regs(oa_config->regs, xe);
+
 	err = mutex_lock_interruptible(&oa->metrics_lock);
 	if (err)
 		goto reg_err;
@@ -2514,7 +2541,7 @@ static struct xe_oa_regs __oag_regs(void)
 
 static void __xe_oa_init_oa_units(struct xe_gt *gt)
 {
-	const u32 mtl_oa_base[] = { 0x13000 };
+	const u32 oa_oam_base[] = { 0x13000, 0x14000, 0x14800 };
 	int i, num_units = gt->oa.num_oa_units;
 
 	for (i = 0; i < num_units; i++) {
@@ -2524,8 +2551,11 @@ static void __xe_oa_init_oa_units(struct xe_gt *gt)
 			u->regs = __oag_regs();
 			u->type = DRM_XE_OA_UNIT_TYPE_OAG;
 		} else if (GRAPHICS_VERx100(gt_to_xe(gt)) >= 1270) {
-			u->regs = __oam_regs(mtl_oa_base[i]);
+			u->regs = __oam_regs(oa_oam_base[i * 3]);
 			u->type = DRM_XE_OA_UNIT_TYPE_OAM;
+			u->regs_oa = __oam_regs(oa_oam_base[i * 3]);
+			u->regs_oam0 = __oam_regs(oa_oam_base[(i * 3) + 1]);
+			u->regs_oam1 = __oam_regs(oa_oam_base[(i * 3) + 2]);
 		}
 
 		xe_mmio_write32(&gt->mmio, u->regs.oa_ctrl, 0);
diff --git a/drivers/gpu/drm/xe/xe_oa.h b/drivers/gpu/drm/xe/xe_oa.h
index e510826f9efc..ef45e6ad9192 100644
--- a/drivers/gpu/drm/xe/xe_oa.h
+++ b/drivers/gpu/drm/xe/xe_oa.h
@@ -13,6 +13,7 @@ struct drm_file;
 struct xe_device;
 struct xe_gt;
 struct xe_hw_engine;
+struct xe_oa_reg;
 
 int xe_oa_init(struct xe_device *xe);
 int xe_oa_register(struct xe_device *xe);
@@ -21,5 +22,6 @@ int xe_oa_add_config_ioctl(struct drm_device *dev, u64 data, struct drm_file *fi
 int xe_oa_remove_config_ioctl(struct drm_device *dev, u64 data, struct drm_file *file);
 u32 xe_oa_timestamp_frequency(struct xe_gt *gt);
 u16 xe_oa_unit_id(struct xe_hw_engine *hwe);
+void xe_oa_store_oa_regs(const struct xe_oa_reg *regs, struct xe_device *xe);
 
 #endif
diff --git a/drivers/gpu/drm/xe/xe_oa_types.h b/drivers/gpu/drm/xe/xe_oa_types.h
index 52e33c37d5ee..59cd1faadb3c 100644
--- a/drivers/gpu/drm/xe/xe_oa_types.h
+++ b/drivers/gpu/drm/xe/xe_oa_types.h
@@ -16,6 +16,9 @@
 #include "xe_hw_engine_types.h"
 
 #define DEFAULT_XE_OA_BUFFER_SIZE SZ_16M
+#define XE_OAM0_BASE  ((u32)0x394000)
+#define XE_OAM1_BASE  ((u32)0x394800)
+#define XE_OAM1_LAST  ((u32)0x395000)
 
 enum xe_oa_report_header {
 	HDR_32_BIT = 0,
@@ -101,6 +104,15 @@ struct xe_oa_unit {
 	/** @regs: OA registers for programming the OA unit */
 	struct xe_oa_regs regs;
 
+	/** @regs: Storage of OA registers for programming the OA unit */
+	struct xe_oa_regs regs_oa;
+
+	/** @regs: Storage of OA registers for programming the OAM0 unit */
+	struct xe_oa_regs regs_oam0;
+
+	/** @regs: Storage of OA registers for programming the OAM1 unit */
+	struct xe_oa_regs regs_oam1;
+
 	/** @num_engines: number of engines attached to this OA unit */
 	u32 num_engines;
 
-- 
2.43.0

