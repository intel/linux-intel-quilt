From ccf66ec8f6129d46faa26bdef21603621d731b06 Mon Sep 17 00:00:00 2001
From: Hardik T Shah <hardik.t.shah@intel.com>
Date: Tue, 8 Mar 2016 16:00:37 +0530
Subject: [PATCH 011/286] Soundwire squashed commits

SoundWire: Add place holder for the soundwire bus driver header file

This patch creates the place holder file for the SoundWire
bus driver header file.

Change-Id: Ib71bbe10f5988194ee24f3793950a6c079d56aa7
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add #defines to the bus driver

This patch adds the #defines to the SoundWire bus
driver.

Change-Id: Ic4dfa9582aa45c3685aee021c156cfbc3e23d817
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add enum to the SoundWire bus driver

This patch adds the enums for the SoundWire bus driver
header file.

Change-Id: Id9b48b5bacc9137f62099eaa4948390b54d4aac0
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add forward declaration for the data structures.

This patch adds the forward declarations of data
structures for the SoundWire bus driver.

Change-Id: I8d5d8dc885c7c8a28d68bada9d4b270c603ae4e4
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add device_id table for SoundWire bus.

Add device_id table for the soundwire master and slave
devices and driver registration

Change-Id: I3848c9476459215ff1d301af69e2eb3c8934bb60
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add data structures for slave driver and device.

This patch adds the data structure for slave driver
and device registration with SoundWire bus driver.

Change-Id: Ie7f2a0a39fcde3073b560fde41f6c91684975cbe
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add data structures for master driver and device.

This patch adds the data structure for master driver
and device registration with SoundWire bus driver.

Change-Id: I269c3afa0e94979274d0415cfbd0be4c214d1afb
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add message transfer data structure

This patch adds the data structure to do register read/write
using message tranasfer. This is similar to i2c_transfer
on i2c bus.

Change-Id: Id10bd88b4fc02c2283334716c38e28b9af862c6e
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add data structure for stream configuration.

This patch adds data structure for stream configuration between
SoundWire master and slaves.

Change-Id: I3a1d06833c881d9ae6bbea38b61f9adb3d8710a0
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add data structure to support bulk register access

This patch adds data structure to support Bulk Register
Access (BRA)  type of Bulk Transfer Protocol (BTP) between
SoundWire master and slaves devices

Change-Id: I85a22552428d1388245b9bce7b25cb32779fabf4
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add data structure to report slave status

This patch adds data structure to report slave status
to SoundWire bus driver. This is normally called by
master controller driver on slave status change on bus.

Change-Id: I17d51cbcedb4259015632b6fc0207c705178a19e
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add API to register SoundWire master

This patch adds support to register/unregister
SoundWire master controller device and driver.

Change-Id: I17a65171ea337604af5a868eceade65fb6fcaae6
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add API for slave driver registration.

This patch add supports for registering/unregistering
SoundWire slave driver. Slave device is registered
by bus driver on enumeration.

Change-Id: I9853409c4383e8c87ac04df97d506d0d980f760c
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add API for slave read/write

This patch adds API to do register read/write
of slaves using message transfer API. This is
similar to i2c_transfer for i2c.

Change-Id: I7827f8df05db4c7cf264d9b5ea34801f99ab4e48
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add support for stream configuration

This patch adds support for stream configuration APIs
between the SoundWire devices.

Change-Id: I9b24a937923db93e09675f179b0b62921410c2fc
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add API to update the slave status.

This patch adds the bus driver API to update slave
status to bus driver. This is called by master controller
driver, to update slave status to bus driver. Master
controller hardware normally gets interrupt on slave
status change.

Change-Id: I917dbdbfd45f2172967c8637344e76eb17a53310
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add miscellaneous helper functions.

This patch adds the miscellaneous helper functions
to be used by SoundWire master controller and
slave device drivers.

Change-Id: I1be5d3f2e5bb695ae2b409da5e33217120cf0d3e
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add placeholder for bus driver private file

Change-Id: Ib284d063fdc9a653a18114f95feb6c8e73bf46fd
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add #defines to the bus driver private header.

This patch adds the #defines to the bus driver private
header file. This needs to be exposed only between
bus driver source files. These #defines are not
publicly exposed.

Change-Id: Ib6393566cd95648bfdc790d656f71a3ebe8aaff0
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add forward declarations of the data structure.

This patch adds the forward declarations of the data
structures to the soundwire bus driver private header
file.

Change-Id: I8a5dc317eb143ea0192c85d6f2080314e1a89517
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add enums to private header file.

This patch adds the enums for the SoundWire bus
driver private header file.

Change-Id: I0927be849cf02da4637510ef3ae094f1cca247d0
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add data structures to the private header file.

This patch adds data structure for the SoundWire private
header file. These are used between bus driver source
files.

Change-Id: I3187078d4be4ef458825a4e0b211059bfa798835
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add function declarations in private header file.

This patch adds the function declartions, to be used between
SoundWire source files.

Change-Id: Iceff34eafd5406b586cb87206f93012fb05a72c5
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add SoundWire slave register definition file.

This patch adds the register definition file for
SoundWire slaves. MIPI defines the register map
for the SoundWire slave. This file adds the register
map and corresponding bit masks and shift for MIPI
defined optional and mandatory registers for slave.
This file doesnt add any register definition for
vendor specific/implementation defined registers.

Change-Id: Ie531e50482703c6f258ae22c3125d3a1f55e4aea
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add placeholder for SoundWire bus driver core file.

Change-Id: Ifa29b24717986244ef1cf00fb9865bcf14b2287f
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add includes in SoundWire bus driver core file.

This patch adds the includes to the SoundWire bus driver
core file.

Change-Id: I0ee7f8baa3787a248dae7d5d649d409062fb6112
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add globals to bus driver core file

This patch adds the global instance handling all
the buses registered as SoundWire bus.

Change-Id: I278e0e418321db7a2fb0aa4adc0c0d15e8b9677b
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add "sdw" bus type registration with kernel core

This patch adds the bus type registration to kernel. It
also initializes the core data structure as a part of
bus initialization.

Change-Id: I1cc301a7d7dfe4564cacdd6c5ff37db63060d488
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Implement "match" callback for bus driver

This patch implements "match" method for the bus driver
registration.

Change-Id: I9fabdce35c7010b7fb5f8c52ff5eaa917f68dfc4
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add probe method for bus driver

This patch implementes the probe method for bus driver.
It calls the probe of of respective mater/slave driver
matching with device name or id.

Change-Id: Ie1d7bf8c3e4d86f87f534209c4002e3e28d55c01
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add remove method for bus driver

This patch implementes the remove method for bus driver.

Change-Id: Iec7096bfc4bb0017df8006e37018a261d918c514
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add shutdown method for bus driver

This patch implements the shutdown method of the
bus.

Change-Id: I4c910a4784676399a90c691e32ed31c996fd3623
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add PM support to bus driver.

This patch adds PM support to bus driver. This adds both
Runtime PM and Legacy PM support.

Change-Id: I9e34c4c06fe41e5da04ce58e6d335f0f29aca6b8
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add API to register master controller device

This patch adds API to register the master controller
SoundWire device with the bus as bus master.

Change-Id: Id6c7aedb3d7392dcd5672606af5237fccc7d343f
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add API to transfer messages on bus.

This patch adds API to transfer register read/write
messages on bus. This is used to read/write
slave addresses.

Change-Id: Iff011f879118440c38d221ea6153bc9eac10049d
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add support to register slaves on enumeration.

This patch add supports to register slave devices on
enumeration. Master controller driver reports the slave
status to bus driver. Bus driver adds the slaves on
enumeration.

Change-Id: I1b82850f39a15fa18756bb2b28f29bbb1141da4a
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add API to un-register master controller device.

This patch adds API to un-register the master controller
device. On un-registering the master controller device,
all the slaves attached to the bus also gets un-registered.

Change-Id: I08eaf9162b3e7d2b7063e8f33cf5d8d79c9f67b3
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add API to register and un-register master driver

This patch adds API to register and un-register the master
controller driver controlling the master controller device.

Change-Id: I65ffd42c7bd073b0fbb771cb948e24c31f5fa658
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add API to register/un-register slave driver

This patch adds API to register/un-register SoundWire slave
device driver.

Change-Id: I76732b273ec31fcd34bd819a1384cbf482a997fc
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add API to register slave capabilities to bus

This patch adds the API to be used by slave driver to
register the slave capabilties to the bus driver. Bus
driver uses this to setup the slave for stream transfer
over SoundWire interface.

Change-Id: I036f01868a417c31adaa70e929b55b9b782702f9
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add API to alloc and release stream tag.

This patch add the bus driver API to allocate and de-allocate
stream tag. Stream tag is a unique stream identifier for each
audio stream between master and slave. Ports of the masters
and slaves part of the same stream has unique and same stream
tag. All ports of master and slaves belonging to same stream tag
get enabled and disabled together.

Change-Id: Ia59ce7f8bfb4e81125cc5334ba4529b78b8afdd4
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add API to configure and release the stream.

This patch adds API to configure and release the
soundiwre stream. Once the stream tag is assigned,
all the masters and slaves associated with the stream
tag configures the stream. Stream params between the
master and slave should match.

Change-Id: Icdd884d56d09910fcd5e263778362e748f00381c
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add support for masters' and slaves' port config

This patch add supports for configuring the master and
slave port. Once the stream is configure between master and
slave, ports needs to be configured. There may be different
ports getting used between master and slave for same stream.
Port configuration may also differ like master may use
single port to drive stereo stream, but slave may be
receiving L & R channels on 2 different ports. So all the
slaves and masters part of stream tag calls this function
to let bus driver know about its port mapping with stream
configuration.

Change-Id: I466edd9b2b9430437d4c8081ff42e61f74fe25d0
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add API to enable and disable the stream.

This patch implement bus driver API to enable and disable
the stream. All the ports of all the masters and slaves
part of the stream tag gets enabled or disable simultaneously
with bank switch.

Change-Id: Ie205402a78a1e417f49962bacef529f6e9491fac
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add functionality to handle slave alerts

This patch adds the functionality to handle slave alerts.
SoundWire slave devices can generate alert event on the
bus. This patch adds the functionality to handle slave alerts.
It also adds functionality to mark slaves as attached
or un-attached based on its enumeration status.

Change-Id: I69d5af23d891e3ca6684c46ae5f2b5747324b0fe
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add Kconfig and Makefile option

This patch adds the Makefile and Kconfig option
to compile the bus driver.

Change-Id: I47a499e84384c7d0a311b393a64a78b476d6e69e
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Added sdw_bwcalc.c file

sdw_bwcalc.c file is added in drivers/sdw/
directory.
This file will contain APIs which calculates
required bandwidth, clock, frameshape, computes
all transport params for a given port, enable channel
perform bankswitch operations.

Change-Id: Ie954bdff81e0faf5ee711c9c33503c4a4d3d39ec
Signed-off-by: Sanyog Kale <sanyog.r.kale@intel.com>

SoundWire: Added APIs to compute bus params

Added APIs to compute frame shape, hstart/hstop,
block offset & switch bank. This all APIs will
be called from sdw_bus_calc_bw & sdw_bus_calc_bw_dis
API.

Change-Id: I9177e36bda0462ccee2bbcf308b49fc65c217a8f
Signed-off-by: Sanyog Kale <sanyog.r.kale@intel.com>

SoundWire: Added API to configure master/slave params

Added API which sets xport params of master/slave
port and prepare/unprepare, enable/disable channels.
This all APIs will be called from
sdw_bus_calc_bw & sdw_bus_calc_bw_dis API.

Change-Id: I5f94b3a1ebee827634dbc3e1475eeed88a2fc716
Signed-off-by: Sanyog Kale <sanyog.r.kale@intel.com>

SoundWire: Added rest API required for bus params config

Added all internal API's which are called
from child functions.

Change-Id: I652fbe0f52c627875caf0db90624559272bc1131
Signed-off-by: Sanyog Kale <sanyog.r.kale@intel.com>

SoundWire: Added code in bandwidth calculation API's

All the functionality needed to done by
sdw_bus_calc_bw & sdw_bus_calc_bw_dis
API's are added.

Change-Id: Ie833244aea09b30483d9755ec39be5cb35244256
Signed-off-by: Sanyog Kale <sanyog.r.kale@intel.com>

SoundWire: Added code in sdw_bus_bw_init & sdw_mstr_bw_init

All the initializations needed to be done are added
in sdw_bus_bw_init & sdw_mstr_bw_init API's

Change-Id: Id1c05d994e9a737e01e47dc113b57baa05c5f546
Signed-off-by: Sanyog Kale <sanyog.r.kale@intel.com>

SoundWire: API's filled to compute bus params

Below APIs are modified.
sdw_lcm
sdw_get_clock_frmshp
sdw_compute_sys_interval
sdw_compute_hstart_hstop
sdw_compute_blk_subblk_offset
sdw_configure_frmshp_bnkswtch
sdw_get_col_to_num
sdw_get_row_to_num

Change-Id: I02972b4d992194de3bcd87650b945652e3e9f48d
Signed-off-by: Sanyog Kale <sanyog.r.kale@intel.com>

SoundWire: API's filled to configure mstr/slv parameters

Below API's are modified:
sdw_cfg_slv_params
sdw_cfg_mstr_params
sdw_cfg_mstr_slv
sdw_cfg_bs_params

Change-Id: Id4a2695e1a67be2895414b16f9f89d3fe2366c74
Signed-off-by: Sanyog Kale <sanyog.r.kale@intel.com>

SoundWire: API's filled for prep/unprep en/dis channel

Below APIs are modified:
sdw_cfg_slv_prep_unprep
sdw_cfg_mstr_prep_unprep
sdw_prep_unprep_mstr_slv
sdw_cfg_slv_enable_disable
sdw_cfg_mstr_activate_disable
sdw_en_dis_mstr_slv
sdw_en_dis_mstr_slv_state
sdw_dis_chan

Change-Id: Ic41c4d6bbc8765aa883f10e255f6b9fbb8d8ae64
Signed-off-by: Sanyog Kale <sanyog.r.kale@intel.com>

SoundWire:  Add header file for the intel master controller.

This header file has public functions to be used by
ASoC platform driver to expose the data path of the
Intel master controller.

Change-Id: I40c86da2c89c838de69c392ca4a424a3cfb32347
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add private file for Intel SDW controller.

This file adds the register definition for the Intel
SoundWire master controller.

Change-Id: I00830ab1b787f486ad20d8da589528a1869ff1ae
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: CNL: Add SoundWire master controller file.

This patch adds the placeholder file for the Intel
SoundWire master controller.

Change-Id: If16ae98774d576e53007cd6a24d4ba2da7460d3c
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add exit and init functions.

This patch adds the init and exit functions of the
Intel SoundWire master controller driver.

Change-Id: Ia6a67e8c00786befc2e6a2e39051fdb055ec5c39
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Intel: Add the register read/write functions.

This patch adds the register read/write helper functions
used by driver.

Change-Id: I7fc1c07eb885ecd44a9834b09ec78c200aabe5d5
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add probe and remove functionality.

This patch adds the probe and remove functionality to the
driver.

Change-Id: Ieb0bb6ebcec7fba4bbbff41eec9f30b9a544d4e6
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add function to power up and down the link.

Change-Id: Ib47835a83963985282e7669dc0d2857f6e7eb7ca
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add functions to initialize the hardware

This patch add functions to initialize the Intel SoundWire
master controller.

Change-Id: I5f360513022482573f1565d7b8daa36971b29a98
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add port and stream initialization support.

This patch adds the port and stream initialization routine
the SoundWire master controller driver.

Change-Id: I35c69b890e28e904940dbb91057db6c3126980a6
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add support for master controller ops

This patch adds the master controller operations callback
to bus driver. This callbacks are called by bus driver
to controls the bus in device specific way.

Change-Id: I962f89f4e9cc2d689cbea754ea4c5a6d1388edb9
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add function to the clock frequency on bus.

This patch adds the method to be used by bus driver to
set the bus frequency. This is used by bus driver to
increase or decrease the clock frequency based on
bus bandwidth requirement. Bus bandwidth is determined
based on active audio streams on bus.

Change-Id: Ifb2bfbeaea4cb81ae54e859b3ffa76015f8f394b
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add method to set SSP and monitor handover.

This patch adds the controller driver method to set the
Stream Synchronization Point (SSP) and to handover the
bus to monitor. Bus driver SSP method to set the SSP
based on the active stream sample interval. While
monitor handover is used to release the bus ownership
to monitor hardware for debugging.

Change-Id: Ie6d980717009ab4af437ca5fc494f1859d4496fa
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add method to transfer message on bus.

This patch adds the method to transfer message on bus. This
is called by bus driver to accomplish register read/write
on bus in hardware specific way.

Change-Id: I5507652e321db967c165cf84c2c4a8affff3ff4c
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Intel: Add support to configure mater ports.

This method registers the port configuration method
with bus driver. Since SoundWire master controller
register map is not defined by MIPI spec, master controller
provides methods to be used by bus driver for master
controller port setup. Port setup is done by the
bus driver as part of stream setup between
SoundWire devices (Master(s) and Slave(s))

Change-Id: I6592102db8c4625822a795918059fd255fbb4780
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Intel: Implement method to set the port params

This method implements method to set the SoundWire port
params in device specific register map.

Change-Id: I3be29f3fc05ac4f1c2d924201c02db795aca1807
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Intel: Add method to set the transport params

This patch adds the method to set the transport params
of the mater controller port. Since master register map
is not defined by MIPI, bus driver calls the master
controller method to set the calcuated trasport params
based on audio stream configuration.

Change-Id: I208776976a347b5158c17c5f02c48fe885ac1c1a
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add support to activate the port channel.

This method add supports to activate the port channels
of the master controller.

Change-Id: Ia3ace1a3b6038f417ba7ebee2ac7b09b646ad1b8
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add API to allocate port

Intel master controller supports bi-directional port
which can be configured either as Source or Sink ports.
This API provides funtionality to dynamically allocate
ports for audio streaming. It picks up the free port
attaches the ALH stream to it and returns. This is called
by ASoC platform driver for port allocation for streaming.

Change-Id: Id3747f35b0c476ebe3900115f66daad11adb0d10
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add support for ALH stream to port mapping.

This patch adds functionality to allocate the ALH stream and
map it to the master controller. There can be one-to-one mapping from
ALH stream to Port. Function takes care of allocating PCM stream
v/s PDM stream based on the calling function requirement.

Change-Id: Ic39e6977240df905ff2e95bf9d50abbda6246a28
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add the interrupt handler for master controller.

This patch adds the interrupt handler for the Intel master controller.
It reports the slave status to the bus driver.

Change-Id: I1e829c9f830010fe6b6f95a81c81ba48e3b16d79
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Intel: Add the Kconfig and Makefile option.

Change-Id: Ic71ae25526b6a00edd9b562864562481e50b3a0e
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: regmap: Add regmap support for SoundWire bus.

This patch adds support for the SoundWire regmap.

Change-Id: I0d892f2526c8eb4231f6436e1a539f50911fcd5b
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add API to get and put the master module.

This patch implements the API to get and put the
master controller module associated with the bus driver.
It increments the reference count for every get and
decrements for every put.

Change-Id: If4f7917b41852b0696a3485fd5f7fcb4258d200f
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Maxim: Add support for FPGA based maxim slave.

Change-Id: I98154827d88bf87bde49e4d5d704d0e8372fd160
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:CNL: Fix the memory corruption.

This patch fixes the possible memory corruption.
in SoundWire controller driver.

Change-Id: I6a19dac25dee9972fb126a75f159b800c18c075a
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Maxim: Fix the maxim slave compilation.

This patch fixed the Maxim compilation issue. Config
option was not correct in Makefile.

Change-Id: Idfb287d7c1bbec19fa707e277ee4ddbb3b375217
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire:Maxim: Add support for multiple slaves.

This patch adds support for multiple slaves for the
Maxim codec driver.

Change-Id: I27602e393e8ddee589bdaf66f833c7ae0be1cee1
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add support to re-enumerate slave.

Slaves might get un-attached because of the link
going down due to power management or due to the
glitch in clock, where sync is lost. Add support
to re-enumerate the slave with same slave number.

Change-Id: I443d060cf96c7e7df4e05a188079443f71f0af76
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SoundWire: Add power management support to bus driver

1. Add helper functions to support the power management for
both master controller and slave device.
2. Call appropriate runtime PM functions for the master
controller and slave device based n bus APIs.

Change-Id: I6231cd7258c6d6099f486f26a68bb9bb713db9c1
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SDW:Intel: Add support for PM for master controller

Add power management support for the Intel
SoundWire master controller driver.

Change-Id: Ifa6205cfbf6cf7ec6c4b9f7b4e61ef79e4818889
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>

SDW: CNL: Fix the PDM port allocation.

1. Fix the PDM stream allocation.
2. Fix port_ctrl and PDI configuration for PDM stream allocation

Change-Id: I83f09240d6852f9730b003e607c4dae24b76423e
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>
Reviewed-on:
---
 drivers/Kconfig                     |    1 +
 drivers/Makefile                    |    1 +
 drivers/base/regmap/Kconfig         |   11 +
 drivers/base/regmap/Makefile        |    1 +
 drivers/base/regmap/regmap-sdwint.c |  252 +++
 drivers/sdw/Kconfig                 |   17 +
 drivers/sdw/Makefile                |    5 +
 drivers/sdw/sdw.c                   | 2345 ++++++++++++++++++++++++++
 drivers/sdw/sdw_bwcalc.c            | 2366 +++++++++++++++++++++++++++
 drivers/sdw/sdw_cnl.c               | 1583 ++++++++++++++++++
 drivers/sdw/sdw_cnl_priv.h          |  337 ++++
 drivers/sdw/sdw_maxim.c             |  146 ++
 drivers/sdw/sdw_priv.h              |  243 +++
 drivers/soundwire/Kconfig           |    1 +
 include/linux/mod_devicetable.h     |   13 +
 include/linux/regmap.h              |    7 +
 include/linux/sdw/sdw_cnl.h         |   96 ++
 include/linux/sdw/sdw_registers.h   |  157 ++
 include/linux/sdw_bus.h             | 1354 +++++++++++++++
 include/trace/events/sdw.h          |  232 +++
 20 files changed, 9168 insertions(+)
 create mode 100644 drivers/base/regmap/regmap-sdwint.c
 create mode 100644 drivers/sdw/Kconfig
 create mode 100644 drivers/sdw/Makefile
 create mode 100644 drivers/sdw/sdw.c
 create mode 100644 drivers/sdw/sdw_bwcalc.c
 create mode 100644 drivers/sdw/sdw_cnl.c
 create mode 100644 drivers/sdw/sdw_cnl_priv.h
 create mode 100644 drivers/sdw/sdw_maxim.c
 create mode 100644 drivers/sdw/sdw_priv.h
 create mode 100644 include/linux/sdw/sdw_cnl.h
 create mode 100644 include/linux/sdw/sdw_registers.h
 create mode 100644 include/linux/sdw_bus.h
 create mode 100644 include/trace/events/sdw.h

diff --git a/drivers/Kconfig b/drivers/Kconfig
index ab4d43923c4d..5af1a08bff23 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -212,6 +212,7 @@ source "drivers/tee/Kconfig"
 source "drivers/mux/Kconfig"
 
 source "drivers/opp/Kconfig"
+source "drivers/sdw/Kconfig"
 
 source "drivers/visorbus/Kconfig"
 
diff --git a/drivers/Makefile b/drivers/Makefile
index 578f469f72fb..a1a8bf6df4d3 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -186,3 +186,4 @@ obj-$(CONFIG_MULTIPLEXER)	+= mux/
 obj-$(CONFIG_UNISYS_VISORBUS)	+= visorbus/
 obj-$(CONFIG_SIOX)		+= siox/
 obj-$(CONFIG_GNSS)		+= gnss/
+obj-$(CONFIG_SDW)		+= sdw/
diff --git a/drivers/base/regmap/Kconfig b/drivers/base/regmap/Kconfig
index 6ad5ef48b61e..afa9b8459572 100644
--- a/drivers/base/regmap/Kconfig
+++ b/drivers/base/regmap/Kconfig
@@ -49,3 +49,14 @@ config REGMAP_SOUNDWIRE
 config REGMAP_SCCB
 	tristate
 	depends on I2C
+
+config REGMAP_HWSPINLOCK
+	bool
+
+config REGMAP_SDW
+	default n
+	tristate "Regmap support for soundwire"
+	depends on SDW
+	help
+	  Enable this if regmap support is required for
+	  soundwire slave devices.
diff --git a/drivers/base/regmap/Makefile b/drivers/base/regmap/Makefile
index f5b4e8851d00..d78c51ae3da2 100644
--- a/drivers/base/regmap/Makefile
+++ b/drivers/base/regmap/Makefile
@@ -16,3 +16,4 @@ obj-$(CONFIG_REGMAP_IRQ) += regmap-irq.o
 obj-$(CONFIG_REGMAP_W1) += regmap-w1.o
 obj-$(CONFIG_REGMAP_SOUNDWIRE) += regmap-sdw.o
 obj-$(CONFIG_REGMAP_SCCB) += regmap-sccb.o
+obj-$(CONFIG_REGMAP_SDW) += regmap-sdwint.o
diff --git a/drivers/base/regmap/regmap-sdwint.c b/drivers/base/regmap/regmap-sdwint.c
new file mode 100644
index 000000000000..ed8c28db03b8
--- /dev/null
+++ b/drivers/base/regmap/regmap-sdwint.c
@@ -0,0 +1,252 @@
+/*
+ *  regmap-sdw.c - Register map access API - SoundWire support
+ *
+ *  Copyright (C) 2015-2016 Intel Corp
+ *  Author:  Hardik T Shah <hardik.t.shah@intel.com>
+ *
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+#include <linux/regmap.h>
+#include <linux/sdw_bus.h>
+#include <linux/module.h>
+
+#include "internal.h"
+
+#define SDW_SCP_ADDRPAGE1_MASK  0xFF
+#define SDW_SCP_ADDRPAGE1_SHIFT 15
+
+#define SDW_SCP_ADDRPAGE2_MASK  0xFF
+#define SDW_SCP_ADDRPAGE2_SHIFT 22
+
+#define SDW_REGADDR_SHIFT	0x0
+#define SDW_REGADDR_MASK	0xFFFF
+
+#define SDW_MAX_REG_ADDR	65536
+
+static int regmap_sdw_read(void *context,
+			   const void *reg, size_t reg_size,
+			   void *val, size_t val_size)
+{
+	struct device *dev = context;
+	struct sdw_slv *sdw = to_sdw_slave(dev);
+	struct sdw_msg xfer;
+	int ret, scp_addr1, scp_addr2;
+	int reg_command;
+	int reg_addr = *(u32 *)reg;
+	size_t t_val_size = 0, t_size;
+	int offset;
+	u8 *t_val;
+
+	/* All registers are 4 byte on SoundWire bus */
+	if (reg_size != 4)
+		return -ENOTSUPP;
+
+	xfer.slave_addr = sdw->slv_number;
+	xfer.ssp_tag = 0;
+	xfer.flag = SDW_MSG_FLAG_READ;
+	xfer.len = 0;
+	t_val = val;
+
+	offset = 0;
+	reg_command = (reg_addr  >> SDW_REGADDR_SHIFT) &
+					SDW_REGADDR_MASK;
+	if (val_size > SDW_MAX_REG_ADDR)
+		t_size = SDW_MAX_REG_ADDR - reg_command;
+	else
+		t_size = val_size;
+	while (t_val_size < val_size) {
+
+		scp_addr1 = (reg_addr >> SDW_SCP_ADDRPAGE1_SHIFT) &
+				SDW_SCP_ADDRPAGE1_MASK;
+		scp_addr2 = (reg_addr >> SDW_SCP_ADDRPAGE2_SHIFT) &
+				SDW_SCP_ADDRPAGE2_MASK;
+		xfer.addr_page1 = scp_addr1;
+		xfer.addr_page2 = scp_addr2;
+		xfer.addr = reg_command;
+		xfer.len += t_size;
+		xfer.buf = &t_val[offset];
+		ret = sdw_slave_transfer(sdw->mstr, &xfer, 1);
+		if (ret < 0)
+			return ret;
+		else if (ret != 1)
+			return -EIO;
+
+		t_val_size += t_size;
+		offset += t_size;
+		if (val_size -  t_val_size > 65535)
+			t_size = 65535;
+		else
+			t_size = val_size - t_val_size;
+		reg_addr += t_size;
+		reg_command = (reg_addr  >> SDW_REGADDR_SHIFT) &
+					SDW_REGADDR_MASK;
+	}
+	return 0;
+}
+
+static int regmap_sdw_gather_write(void *context,
+			   const void *reg, size_t reg_size,
+			   const void *val, size_t val_size)
+{
+	struct device *dev = context;
+	struct sdw_slv *sdw = to_sdw_slave(dev);
+	struct sdw_msg xfer;
+	int ret, scp_addr1, scp_addr2;
+	int reg_command;
+	int reg_addr = *(u32 *)reg;
+	size_t t_val_size = 0, t_size;
+	int offset;
+	u8 *t_val;
+
+	/* All registers are 4 byte on SoundWire bus */
+	if (reg_size != 4)
+		return -ENOTSUPP;
+
+	if (!sdw)
+		return 0;
+
+	xfer.slave_addr = sdw->slv_number;
+	xfer.ssp_tag = 0;
+	xfer.flag = SDW_MSG_FLAG_WRITE;
+	xfer.len = 0;
+	t_val = (u8 *)val;
+
+	offset = 0;
+	reg_command = (reg_addr  >> SDW_REGADDR_SHIFT) &
+					SDW_REGADDR_MASK;
+	if (val_size > SDW_MAX_REG_ADDR)
+		t_size = SDW_MAX_REG_ADDR - reg_command;
+	else
+		t_size = val_size;
+	while (t_val_size < val_size) {
+
+		scp_addr1 = (reg_addr >> SDW_SCP_ADDRPAGE1_SHIFT) &
+				SDW_SCP_ADDRPAGE1_MASK;
+		scp_addr2 = (reg_addr >> SDW_SCP_ADDRPAGE2_SHIFT) &
+				SDW_SCP_ADDRPAGE2_MASK;
+		xfer.addr_page1 = scp_addr1;
+		xfer.addr_page2 = scp_addr2;
+		xfer.addr = reg_command;
+		xfer.len += t_size;
+		xfer.buf = &t_val[offset];
+		ret = sdw_slave_transfer(sdw->mstr, &xfer, 1);
+		if (ret < 0)
+			return ret;
+		else if (ret != 1)
+			return -EIO;
+
+		t_val_size += t_size;
+		offset += t_size;
+		if (val_size -  t_val_size > 65535)
+			t_size = 65535;
+		else
+			t_size = val_size - t_val_size;
+		reg_addr += t_size;
+		reg_command = (reg_addr  >> SDW_REGADDR_SHIFT) &
+					SDW_REGADDR_MASK;
+	}
+	return 0;
+}
+
+static inline void regmap_sdw_count_check(size_t count, u32 offset)
+{
+	BUG_ON(count <= offset);
+}
+
+static int regmap_sdw_write(void *context, const void *data, size_t count)
+{
+	/* 4-byte register address for the soundwire */
+	unsigned int offset = 4;
+
+	regmap_sdw_count_check(count, offset);
+	return regmap_sdw_gather_write(context, data, 4,
+					data + offset, count - offset);
+}
+
+static struct regmap_bus regmap_sdw = {
+	.write = regmap_sdw_write,
+	.gather_write = regmap_sdw_gather_write,
+	.read = regmap_sdw_read,
+	.reg_format_endian_default = REGMAP_ENDIAN_LITTLE,
+	.val_format_endian_default = REGMAP_ENDIAN_LITTLE,
+};
+
+static int regmap_sdw_config_check(const struct regmap_config *config)
+{
+	/* All register are 8-bits wide as per MIPI Soundwire 1.0 Spec */
+	if (config->val_bits != 8)
+		return -ENOTSUPP;
+	/* Registers are 32 bit in size, based on SCP_ADDR1 and SCP_ADDR2
+	 * implementation address range may vary in slave.
+	 */
+	if (config->reg_bits != 32)
+		return -ENOTSUPP;
+	/* SoundWire register address are contiguous. */
+	if (config->reg_stride != 0)
+		return -ENOTSUPP;
+	if (config->pad_bits != 0)
+		return -ENOTSUPP;
+
+
+	return 0;
+}
+
+/**
+ * regmap_init_sdwint(): Initialise register map
+ *
+ * @sdw: Device that will be interacted with
+ * @config: Configuration for register map
+ *
+ * The return value will be an ERR_PTR() on error or a valid pointer to
+ * a struct regmap.
+ */
+struct regmap *regmap_init_sdwint(struct sdw_slv *sdw,
+			       const struct regmap_config *config)
+{
+	int ret;
+
+	ret = regmap_sdw_config_check(config);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return regmap_init(&sdw->dev, &regmap_sdw, &sdw->dev, config);
+}
+EXPORT_SYMBOL_GPL(regmap_init_sdwint);
+
+
+/**
+ * devm_regmap_init_sdwint(): Initialise managed register map
+ *
+ * @sdw Device that will be interacted with
+ * @config: Configuration for register map
+ *
+ * The return value will be an ERR_PTR() on error or a valid pointer
+ * to a struct regmap.  The regmap will be automatically freed by the
+ * device management code.
+ */
+struct regmap *devm_regmap_init_sdwint(struct sdw_slv *sdw,
+				    const struct regmap_config *config)
+{
+	int ret;
+
+	ret = regmap_sdw_config_check(config);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return devm_regmap_init(&sdw->dev, &regmap_sdw, &sdw->dev, config);
+}
+EXPORT_SYMBOL_GPL(devm_regmap_init_sdwint);
+
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/sdw/Kconfig b/drivers/sdw/Kconfig
new file mode 100644
index 000000000000..90e954c392e0
--- /dev/null
+++ b/drivers/sdw/Kconfig
@@ -0,0 +1,17 @@
+menuconfig SDW
+	tristate "SoundWire bus support"
+	help
+	  SoundWire interface is typically used for transporting data
+	  related to audio functions.
+menuconfig SDW_CNL
+	tristate "Intel SoundWire master controller support"
+	depends on SDW
+	help
+	  Intel SoundWire master controller driver
+menuconfig SDW_MAXIM_SLAVE
+	bool "SoundWire Slave for the Intel CNL FPGA"
+	depends on SDW
+	help
+	  SoundWire Slave on FPGA platform for Intel CNL IP
+	  Mostly N for all the cases other than CNL Slave FPGA
+
diff --git a/drivers/sdw/Makefile b/drivers/sdw/Makefile
new file mode 100644
index 000000000000..184682a88a1a
--- /dev/null
+++ b/drivers/sdw/Makefile
@@ -0,0 +1,5 @@
+sdw_bus-objs := sdw.o sdw_bwcalc.o
+
+obj-$(CONFIG_SDW)			+= sdw_bus.o
+obj-$(CONFIG_SDW_CNL)			+= sdw_cnl.o
+obj-$(CONFIG_SDW_MAXIM_SLAVE)		+= sdw_maxim.o
diff --git a/drivers/sdw/sdw.c b/drivers/sdw/sdw.c
new file mode 100644
index 000000000000..6a1ff5e59401
--- /dev/null
+++ b/drivers/sdw/sdw.c
@@ -0,0 +1,2345 @@
+/*
+ *  sdw.c - SoundWire Bus driver implementation
+ *
+ *  Copyright (C) 2015-2016 Intel Corp
+ *  Author:  Hardik T Shah <hardik.t.shah@intel.com>
+ *
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/completion.h>
+#include <linux/idr.h>
+#include <linux/delay.h>
+#include <linux/rtmutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/pm_domain.h>
+#include <linux/pm.h>
+#include <linux/mod_devicetable.h>
+#include <linux/sdw_bus.h>
+#include <linux/sdw/sdw_registers.h>
+#include "sdw_priv.h"
+
+#define sdw_slave_attr_gr NULL
+#define sdw_mstr_attr_gr NULL
+
+#define CREATE_TRACE_POINTS
+#include <trace/events/sdw.h>
+
+/* Global instance handling all the SoundWire buses */
+struct sdw_core sdw_core;
+
+static void sdw_slave_release(struct device *dev)
+{
+	kfree(to_sdw_slave(dev));
+}
+
+static void sdw_mstr_release(struct device *dev)
+{
+	struct sdw_master *mstr = to_sdw_master(dev);
+
+	complete(&mstr->slv_released);
+}
+
+static struct device_type sdw_slv_type = {
+	.groups		= sdw_slave_attr_gr,
+	.release	= sdw_slave_release,
+};
+
+static struct device_type sdw_mstr_type = {
+	.groups		= sdw_mstr_attr_gr,
+	.release	= sdw_mstr_release,
+};
+/**
+ * sdw_slave_verify - return parameter as sdw_slv, or NULL
+ * @dev: device, probably from some driver model iterator
+ *
+ * When traversing the driver model tree, perhaps using driver model
+ * iterators like @device_for_each_child(), you can't assume very much
+ * about the nodes you find.  Use this function to avoid oopses caused
+ * by wrongly treating some non-SDW device as an sdw_slv.
+ */
+struct sdw_slv *sdw_slave_verify(struct device *dev)
+{
+	return (dev->type == &sdw_slv_type)
+			? to_sdw_slave(dev)
+			: NULL;
+}
+
+/**
+ * sdw_mstr_verify - return parameter as sdw_master, or NULL
+ * @dev: device, probably from some driver model iterator
+ *
+ * When traversing the driver model tree, perhaps using driver model
+ * iterators like @device_for_each_child(), you can't assume very much
+ * about the nodes you find.  Use this function to avoid oopses caused
+ * by wrongly treating some non-SDW device as an sdw_slv.
+ */
+struct sdw_master *sdw_mstr_verify(struct device *dev)
+{
+	return (dev->type == &sdw_mstr_type)
+			? to_sdw_master(dev)
+			: NULL;
+}
+
+static const struct sdw_slv_id *sdw_match_slave(const struct sdw_slv_id *id,
+					const struct sdw_slv *sdw_slv)
+{
+	while (id->name[0]) {
+		if (strncmp(sdw_slv->name, id->name, SOUNDWIRE_NAME_SIZE) == 0)
+			return id;
+		id++;
+	}
+	return NULL;
+}
+
+static const struct sdw_master_id *sdw_match_master(
+			const struct sdw_master_id *id,
+			const struct sdw_master *sdw_mstr)
+{
+	if (!id)
+		return NULL;
+	while (id->name[0]) {
+		if (strncmp(sdw_mstr->name, id->name, SOUNDWIRE_NAME_SIZE) == 0)
+			return id;
+		id++;
+	}
+	return NULL;
+}
+
+static int sdw_slv_match(struct device *dev, struct device_driver *driver)
+{
+	struct sdw_slv *sdw_slv;
+	struct sdw_slave_driver *drv = to_sdw_slave_driver(driver);
+	int ret = 0;
+
+	/* Check if driver is slave type or not, both master and slave
+	 * driver has first field as driver_type, so if driver is not
+	 * of slave type return
+	 */
+	if (drv->driver_type !=  SDW_DRIVER_TYPE_SLAVE)
+		return ret;
+
+	sdw_slv = to_sdw_slave(dev);
+
+	if (drv->id_table)
+		ret = (sdw_match_slave(drv->id_table, sdw_slv) != NULL);
+
+	if (driver->name && !ret)
+		ret = (strncmp(sdw_slv->name, driver->name, SOUNDWIRE_NAME_SIZE)
+			== 0);
+	if (ret)
+		sdw_slv->driver = drv;
+	return ret;
+}
+static int sdw_mstr_match(struct device *dev, struct device_driver *driver)
+{
+	struct sdw_master *sdw_mstr;
+	struct sdw_mstr_driver *drv = to_sdw_mstr_driver(driver);
+	int ret = 0;
+
+	/* Check if driver is slave type or not, both master and slave
+	 * driver has first field as driver_type, so if driver is not
+	 * of slave type return
+	 */
+	if (drv->driver_type !=  SDW_DRIVER_TYPE_MASTER)
+		return ret;
+
+	sdw_mstr = to_sdw_master(dev);
+
+	if (drv->id_table)
+		ret =  (sdw_match_master(drv->id_table, sdw_mstr) != NULL);
+
+	if (driver->name)
+		ret = (strncmp(sdw_mstr->name, driver->name,
+			SOUNDWIRE_NAME_SIZE) == 0);
+	if (ret)
+		sdw_mstr->driver = drv;
+
+	return ret;
+}
+
+static int sdw_mstr_probe(struct device *dev)
+{
+	const struct sdw_mstr_driver *sdrv = to_sdw_mstr_driver(dev->driver);
+	struct sdw_master *mstr = to_sdw_master(dev);
+	int ret = 0;
+
+	if (!sdrv->probe)
+		return -ENODEV;
+	ret = dev_pm_domain_attach(dev, true);
+	if (ret != -EPROBE_DEFER) {
+		ret = sdrv->probe(mstr, sdw_match_master(sdrv->id_table, mstr));
+		if (ret)
+			dev_pm_domain_detach(dev, true);
+	}
+	return ret;
+}
+
+static int sdw_slv_probe(struct device *dev)
+{
+	const struct sdw_slave_driver *sdrv = to_sdw_slave_driver(dev->driver);
+	struct sdw_slv *sdwslv = to_sdw_slave(dev);
+	int ret = 0;
+
+	if (!sdrv->probe)
+		return -ENODEV;
+	ret = dev_pm_domain_attach(dev, true);
+	if (ret != -EPROBE_DEFER) {
+		ret = sdrv->probe(sdwslv, sdw_match_slave(sdrv->id_table,
+								sdwslv));
+		return 0;
+		if (ret)
+			dev_pm_domain_detach(dev, true);
+	}
+	return ret;
+}
+
+static int sdw_mstr_remove(struct device *dev)
+{
+	const struct sdw_mstr_driver *sdrv = to_sdw_mstr_driver(dev->driver);
+	int ret = 0;
+
+	if (sdrv->remove)
+		ret = sdrv->remove(to_sdw_master(dev));
+	else
+		return -ENODEV;
+
+	dev_pm_domain_detach(dev, true);
+	return ret;
+
+}
+
+static int sdw_slv_remove(struct device *dev)
+{
+	const struct sdw_slave_driver *sdrv = to_sdw_slave_driver(dev->driver);
+	int ret = 0;
+
+	if (sdrv->remove)
+		ret = sdrv->remove(to_sdw_slave(dev));
+	else
+		return -ENODEV;
+
+	dev_pm_domain_detach(dev, true);
+	return ret;
+}
+
+static void sdw_slv_shutdown(struct device *dev)
+{
+	const struct sdw_slave_driver *sdrv = to_sdw_slave_driver(dev->driver);
+
+	if (sdrv->shutdown)
+		sdrv->shutdown(to_sdw_slave(dev));
+}
+
+static void sdw_mstr_shutdown(struct device *dev)
+{
+	const struct sdw_mstr_driver *sdrv = to_sdw_mstr_driver(dev->driver);
+	struct sdw_master *mstr = to_sdw_master(dev);
+
+	if (sdrv->shutdown)
+		sdrv->shutdown(mstr);
+}
+
+static void sdw_shutdown(struct device *dev)
+{
+	struct sdw_slv *sdw_slv;
+	struct sdw_master *sdw_mstr;
+
+	sdw_slv = sdw_slave_verify(dev);
+	sdw_mstr = sdw_mstr_verify(dev);
+	if (sdw_slv)
+		sdw_slv_shutdown(dev);
+	else if (sdw_mstr)
+		sdw_mstr_shutdown(dev);
+}
+
+static int sdw_remove(struct device *dev)
+{
+	struct sdw_slv *sdw_slv;
+	struct sdw_master *sdw_mstr;
+
+	sdw_slv = sdw_slave_verify(dev);
+	sdw_mstr = sdw_mstr_verify(dev);
+	if (sdw_slv)
+		return sdw_slv_remove(dev);
+	else if (sdw_mstr)
+		return sdw_mstr_remove(dev);
+
+	return 0;
+}
+
+static int sdw_probe(struct device *dev)
+{
+
+	struct sdw_slv *sdw_slv;
+	struct sdw_master *sdw_mstr;
+
+	sdw_slv = sdw_slave_verify(dev);
+	sdw_mstr = sdw_mstr_verify(dev);
+	if (sdw_slv)
+		return sdw_slv_probe(dev);
+	else if (sdw_mstr)
+		return sdw_mstr_probe(dev);
+
+	return -ENODEV;
+
+}
+
+static int sdw_match(struct device *dev, struct device_driver *driver)
+{
+	struct sdw_slv *sdw_slv;
+	struct sdw_master *sdw_mstr;
+
+	sdw_slv = sdw_slave_verify(dev);
+	sdw_mstr = sdw_mstr_verify(dev);
+	if (sdw_slv)
+		return sdw_slv_match(dev, driver);
+	else if (sdw_mstr)
+		return sdw_mstr_match(dev, driver);
+	return 0;
+
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int sdw_legacy_suspend(struct device *dev, pm_message_t mesg)
+{
+	struct sdw_slv *sdw_slv = NULL;
+	struct sdw_slave_driver *driver;
+
+	if (dev->type == &sdw_slv_type)
+		sdw_slv = to_sdw_slave(dev);
+
+	if (!sdw_slv || !dev->driver)
+		return 0;
+
+	driver = to_sdw_slave_driver(dev->driver);
+	if (!driver->suspend)
+		return 0;
+
+	return driver->suspend(sdw_slv, mesg);
+}
+
+static int sdw_legacy_resume(struct device *dev)
+{
+	struct sdw_slv *sdw_slv = NULL;
+	struct sdw_slave_driver *driver;
+
+	if (dev->type == &sdw_slv_type)
+		sdw_slv = to_sdw_slave(dev);
+
+	if (!sdw_slv || !dev->driver)
+		return 0;
+
+	driver = to_sdw_slave_driver(dev->driver);
+	if (!driver->resume)
+		return 0;
+
+	return driver->resume(sdw_slv);
+}
+
+static int sdw_pm_suspend(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_suspend(dev);
+	else
+		return sdw_legacy_suspend(dev, PMSG_SUSPEND);
+}
+
+static int sdw_pm_resume(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_resume(dev);
+	else
+		return sdw_legacy_resume(dev);
+}
+
+static const struct dev_pm_ops soundwire_pm = {
+	.suspend = sdw_pm_suspend,
+	.resume = sdw_pm_resume,
+	.runtime_suspend = pm_generic_runtime_suspend,
+	.runtime_resume = pm_generic_runtime_resume,
+};
+
+#else
+#define sdw_pm_suspend		NULL
+#define sdw_pm_resume		NULL
+#endif
+
+struct bus_type sdwint_bus_type = {
+	.name		= "soundwire",
+	.match		= sdw_match,
+	.probe		= sdw_probe,
+	.remove		= sdw_remove,
+	.shutdown	= sdw_shutdown,
+	.pm		= &soundwire_pm,
+};
+EXPORT_SYMBOL_GPL(sdwint_bus_type);
+
+struct device sdw_slv = {
+	.init_name = "soundwire",
+};
+
+static struct static_key sdw_trace_msg = STATIC_KEY_INIT_FALSE;
+
+int sdw_transfer_trace_reg(void)
+{
+	static_key_slow_inc(&sdw_trace_msg);
+}
+
+void sdw_transfer_trace_unreg(void)
+{
+	static_key_slow_dec(&sdw_trace_msg);
+}
+
+/**
+ * sdw_lock_mstr - Get exclusive access to an SDW bus segment
+ * @mstr: Target SDW bus segment
+ */
+void sdw_lock_mstr(struct sdw_master *mstr)
+{
+	rt_mutex_lock(&mstr->bus_lock);
+}
+EXPORT_SYMBOL_GPL(sdw_lock_mstr);
+
+/**
+ * sdw_trylock_mstr - Try to get exclusive access to an SDW bus segment
+ * @mstr: Target SDW bus segment
+ */
+static int sdw_trylock_mstr(struct sdw_master *mstr)
+{
+	return rt_mutex_trylock(&mstr->bus_lock);
+}
+
+
+/**
+ * sdw_unlock_mstr - Release exclusive access to an SDW bus segment
+ * @mstr: Target SDW bus segment
+ */
+void sdw_unlock_mstr(struct sdw_master *mstr)
+{
+	rt_mutex_unlock(&mstr->bus_lock);
+}
+EXPORT_SYMBOL_GPL(sdw_unlock_mstr);
+
+
+static int sdw_assign_slv_number(struct sdw_master *mstr,
+				struct sdw_msg *msg)
+{
+	int i, j, ret = -1;
+
+	sdw_lock_mstr(mstr);
+	for (i = 1; i <= SOUNDWIRE_MAX_DEVICES; i++) {
+		if (mstr->sdw_addr[i].assigned == true)
+			continue;
+		mstr->sdw_addr[i].assigned = true;
+		for (j = 0; j < 6; j++)
+			mstr->sdw_addr[i].dev_id[j] = msg->buf[j];
+		ret = i;
+		break;
+	}
+	sdw_unlock_mstr(mstr);
+	return ret;
+}
+
+static int sdw_program_slv_address(struct sdw_master *mstr,
+				u8 slave_addr)
+{
+	struct sdw_msg msg;
+	u8 buf[1] = {0};
+	int ret;
+
+	buf[0] = slave_addr;
+	msg.ssp_tag = 0;
+	msg.flag = SDW_MSG_FLAG_WRITE;
+	msg.addr = SDW_SCP_DEVNUMBER;
+	msg.len = 1;
+	msg.buf = buf;
+	msg.slave_addr = 0x0;
+	msg.addr_page1 = 0x0;
+	msg.addr_page2 = 0x0;
+
+	ret = sdw_slave_transfer(mstr, &msg, 1);
+	if (ret != 1) {
+		dev_err(&mstr->dev, "Program Slave address change\n");
+		return ret;
+	}
+	return 0;
+}
+
+static int sdw_find_slave(struct sdw_master *mstr, struct sdw_msg
+						*msg, bool *found)
+{
+	struct sdw_slv_addr *sdw_addr;
+	int ret = 0, i, comparison;
+	*found = false;
+
+	sdw_lock_mstr(mstr);
+	sdw_addr = mstr->sdw_addr;
+	for (i = 1; i <= SOUNDWIRE_MAX_DEVICES; i++) {
+		comparison = memcmp(sdw_addr[i].dev_id, msg->buf,
+				SDW_NUM_DEV_ID_REGISTERS);
+		if ((!comparison) && (sdw_addr[i].assigned == true)) {
+				*found = true;
+				break;
+		}
+	}
+	sdw_unlock_mstr(mstr);
+	if (*found == true)
+		ret = sdw_program_slv_address(mstr, sdw_addr[i].slv_number);
+	return ret;
+}
+
+static void sdw_free_slv_number(struct sdw_master *mstr,
+		int slv_number)
+{
+	int i;
+
+	sdw_lock_mstr(mstr);
+	for (i = 0; i <= SOUNDWIRE_MAX_DEVICES; i++) {
+		if (slv_number == mstr->sdw_addr[i].slv_number) {
+			mstr->sdw_addr[slv_number].assigned = false;
+			memset(&mstr->sdw_addr[slv_number].dev_id[0], 0x0, 6);
+		}
+	}
+	sdw_unlock_mstr(mstr);
+}
+
+static int sdw_register_slave(struct sdw_master *mstr)
+{
+	int ret = 0, i, ports;
+	struct sdw_msg msg;
+	u8 buf[6] = {0};
+	struct sdw_slv *sdw_slv;
+	int slv_number = -1;
+	bool found = false;
+
+
+	msg.ssp_tag = 0;
+	msg.flag = SDW_MSG_FLAG_READ;
+	msg.addr = SDW_SCP_DEVID_0;
+	msg.len = 6;
+	msg.buf = buf;
+	msg.slave_addr = 0x0;
+	msg.addr_page1 = 0x0;
+	msg.addr_page2 = 0x0;
+
+	while ((ret = (sdw_slave_transfer(mstr, &msg, 1)) == 1)) {
+		ret = sdw_find_slave(mstr, &msg, &found);
+		if (found && !ret) {
+			dev_info(&mstr->dev, "Slave already registered\n");
+			continue;
+		/* Even if slave registering fails we continue for other
+		 * slave status, but we flag error
+		 */
+		} else if (ret) {
+			dev_err(&mstr->dev, "Re-registering slave failed");
+			continue;
+		}
+		slv_number = sdw_assign_slv_number(mstr, &msg);
+		if (slv_number <= 0) {
+			dev_err(&mstr->dev, "Failed to assign slv_number\n");
+			ret = -EINVAL;
+			goto slv_number_assign_fail;
+		}
+		sdw_slv = kzalloc(sizeof(struct sdw_slv), GFP_KERNEL);
+		if (!sdw_slv) {
+			ret = -ENOMEM;
+			goto mem_alloc_failed;
+		}
+		sdw_slv->mstr = mstr;
+		sdw_slv->dev.parent = &sdw_slv->mstr->dev;
+		sdw_slv->dev.bus = &sdwint_bus_type;
+		sdw_slv->dev.type = &sdw_slv_type;
+		sdw_slv->slv_addr = &mstr->sdw_addr[slv_number];
+		sdw_slv->slv_addr->slave = sdw_slv;
+		/* We have assigned new slave number, so its not present
+		 * till it again attaches to bus with this new
+		 * slave address
+		 */
+		sdw_slv->slv_addr->status = SDW_SLAVE_STAT_NOT_PRESENT;
+		for (i = 0; i < 6; i++)
+			sdw_slv->dev_id[i] = msg.buf[i];
+		dev_dbg(&mstr->dev, "SDW slave slave id found with values\n");
+		dev_dbg(&mstr->dev, "dev_id0 to dev_id5: %x:%x:%x:%x:%x:%x\n",
+			msg.buf[0], msg.buf[1], msg.buf[2],
+			msg.buf[3], msg.buf[4], msg.buf[5]);
+		dev_dbg(&mstr->dev, "Slave number assigned is %x\n", slv_number);
+		/* TODO: Fill the sdw_slv structre from ACPI */
+		ports = sdw_slv->sdw_slv_cap.num_of_sdw_ports;
+		/* Add 1 for port 0 for simplicity */
+		ports++;
+		sdw_slv->port_ready =
+			kzalloc((sizeof(struct completion) * ports),
+							GFP_KERNEL);
+		if (!sdw_slv->port_ready) {
+			ret = -ENOMEM;
+			goto port_alloc_mem_failed;
+		}
+		for (i = 0; i < ports; i++)
+			init_completion(&sdw_slv->port_ready[i]);
+
+		dev_set_name(&sdw_slv->dev, "sdw-slave%d-%02x:%02x:%02x:%02x:%02x:%02x",
+			sdw_master_id(mstr),
+			sdw_slv->dev_id[0],
+			sdw_slv->dev_id[1],
+			sdw_slv->dev_id[2],
+			sdw_slv->dev_id[3],
+			sdw_slv->dev_id[4],
+			sdw_slv->dev_id[5] + mstr->nr);
+		/* Set name based on dev_id. This will be
+		 * compared to load driver
+		 */
+		sprintf(sdw_slv->name, "%02x:%02x:%02x:%02x:%02x:%02x",
+				sdw_slv->dev_id[0],
+				sdw_slv->dev_id[1],
+				sdw_slv->dev_id[2],
+				sdw_slv->dev_id[3],
+				sdw_slv->dev_id[4],
+				sdw_slv->dev_id[5] + mstr->nr);
+		ret = device_register(&sdw_slv->dev);
+		if (ret) {
+			dev_err(&mstr->dev, "Register slave failed\n");
+			goto reg_slv_failed;
+		}
+		ret = sdw_program_slv_address(mstr, slv_number);
+		if (ret) {
+			dev_err(&mstr->dev, "Programming slave address failed\n");
+			goto program_slv_failed;
+		}
+		dev_dbg(&mstr->dev, "Slave registered with bus id %s\n",
+			dev_name(&sdw_slv->dev));
+		sdw_slv->slv_number = slv_number;
+		mstr->num_slv++;
+		sdw_lock_mstr(mstr);
+		list_add_tail(&sdw_slv->node, &mstr->slv_list);
+		sdw_unlock_mstr(mstr);
+
+	}
+	return 0;
+program_slv_failed:
+	device_unregister(&sdw_slv->dev);
+port_alloc_mem_failed:
+reg_slv_failed:
+	kfree(sdw_slv);
+mem_alloc_failed:
+	sdw_free_slv_number(mstr, slv_number);
+slv_number_assign_fail:
+	return ret;
+
+}
+
+/**
+ * __sdw_transfer - unlocked flavor of sdw_slave_transfer
+ * @mstr: Handle to SDW bus
+ * @msg: One or more messages to execute before STOP is issued to
+ *	terminate the operation; each message begins with a START.
+ * @num: Number of messages to be executed.
+ *
+ * Returns negative errno, else the number of messages executed.
+ *
+ * Adapter lock must be held when calling this function. No debug logging
+ * takes place. mstr->algo->master_xfer existence isn't checked.
+ */
+int __sdw_transfer(struct sdw_master *mstr, struct sdw_msg *msg, int num)
+{
+	unsigned long orig_jiffies;
+	int ret = 0, try, i;
+	struct sdw_slv_capabilities *slv_cap;
+	int program_scp_addr_page;
+	int addr = msg->slave_addr;
+
+	/* sdw_trace_msg gets enabled when tracepoint sdw_slave_transfer gets
+	 * enabled.  This is an efficient way of keeping the for-loop from
+	 * being executed when not needed.
+	 */
+	if (static_key_false(&sdw_trace_msg)) {
+		int i;
+
+		for (i = 0; i < num; i++)
+			if (msg[i].flag & SDW_MSG_FLAG_READ)
+				trace_sdw_read(mstr, &msg[i], i);
+			else
+				trace_sdw_write(mstr, &msg[i], i);
+	}
+	orig_jiffies = jiffies;
+	for (i = 0; i < num; i++) {
+		for (ret = 0, try = 0; try <= mstr->retries; try++) {
+			if (msg->slave_addr == 0)
+				/* If we are enumerating slave address 0,
+				 * we dont program scp, it should be set
+				 * default to 0
+				 */
+				program_scp_addr_page = 0;
+			else if (msg->slave_addr == 15)
+				/* If we are broadcasting, we need to program
+				 * the SCP address as some slaves will be
+				 * supporting it while some wont be.
+				 * So it should be programmed
+				 */
+				program_scp_addr_page = 1;
+
+			else {
+				slv_cap =
+					&mstr->sdw_addr[addr].slave->sdw_slv_cap;
+				program_scp_addr_page =
+					slv_cap->paging_supported;
+			}
+			ret = mstr->driver->mstr_ops->xfer_msg(mstr,
+						msg, program_scp_addr_page);
+			if (ret != -EAGAIN)
+				break;
+			if (time_after(jiffies,
+					orig_jiffies + mstr->timeout))
+				break;
+		}
+	}
+
+	if (static_key_false(&sdw_trace_msg)) {
+		int i;
+
+		for (i = 0; i < msg->len; i++)
+			if (msg[i].flag & SDW_MSG_FLAG_READ)
+				trace_sdw_reply(mstr, &msg[i], i);
+		trace_sdw_result(mstr, i, ret);
+	}
+	if (!ret)
+		return i;
+	return ret;
+}
+EXPORT_SYMBOL_GPL(__sdw_transfer);
+
+/* NO PM version of slave transfer. Called from power management APIs
+ * to avoid dead locks.
+ */
+static int sdw_slave_transfer_nopm(struct sdw_master *mstr, struct sdw_msg *msg,
+								int num)
+{
+	int ret;
+
+	if (mstr->driver->mstr_ops->xfer_msg) {
+		ret = __sdw_transfer(mstr, msg, num);
+		return ret;
+	}
+	dev_dbg(&mstr->dev, "SDW level transfers not supported\n");
+	return -EOPNOTSUPP;
+}
+
+/**
+ * sdw_slave_transfer:  Transfer message between slave and mstr on the bus.
+ * @mstr: mstr master which will transfer the message
+ * @msg: Array of messages to be transferred.
+ * @num: Number of messages to be transferred, messages include read and write
+ *		messages, but not the ping messages.
+ */
+int sdw_slave_transfer(struct sdw_master *mstr, struct sdw_msg *msg, int num)
+{
+	int ret;
+
+	/* REVISIT the fault reporting model here is weak:
+	 *
+	 *  - When we get an error after receiving N bytes from a slave,
+	 *    there is no way to report "N".
+	 *
+	 *  - When we get a NAK after transmitting N bytes to a slave,
+	 *    there is no way to report "N" ... or to let the mstr
+	 *    continue executing the rest of this combined message, if
+	 *    that's the appropriate response.
+	 *
+	 *  - When for example "num" is two and we successfully complete
+	 *    the first message but get an error part way through the
+	 *    second, it's unclear whether that should be reported as
+	 *    one (discarding status on the second message) or errno
+	 *    (discarding status on the first one).
+	 */
+	if (!(mstr->driver->mstr_ops->xfer_msg)) {
+		dev_dbg(&mstr->dev, "SDW level transfers not supported\n");
+		return -EOPNOTSUPP;
+	}
+	pm_runtime_get_sync(&mstr->dev);
+	if (in_atomic() || irqs_disabled()) {
+		ret = sdw_trylock_mstr(mstr);
+		if (!ret) {
+			/* SDW activity is ongoing. */
+			ret = -EAGAIN;
+			goto out;
+		}
+	} else {
+		sdw_lock_mstr(mstr);
+	}
+	ret = __sdw_transfer(mstr, msg, num);
+	sdw_unlock_mstr(mstr);
+out:
+	pm_runtime_mark_last_busy(&mstr->dev);
+	pm_runtime_put_sync_autosuspend(&mstr->dev);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sdw_slave_transfer);
+
+static int sdw_handle_dp0_interrupts(struct sdw_master *mstr,
+			struct sdw_slave *sdw_slv)
+{
+	int ret = 0;
+	struct sdw_msg rd_msg, wr_msg;
+	int impl_def_mask = 0;
+	u8 rbuf[1] = {0}, wbuf[1] = {0};
+
+	/* Create message for clearing the interrupts */
+	wr_msg.ssp_tag = 0;
+	wr_msg.flag = SDW_MSG_FLAG_WRITE;
+	wr_msg.addr = SDW_DP0_INTCLEAR;
+	wr_msg.len = 1;
+	wr_msg.buf = wbuf;
+	wr_msg.slave_addr = sdw_slv->slv_number;
+	wr_msg.addr_page1 = 0x0;
+	wr_msg.addr_page2 = 0x0;
+
+	/* Create message for reading the interrupts  for DP0 interrupts*/
+	rd_msg.ssp_tag = 0;
+	rd_msg.flag = SDW_MSG_FLAG_READ;
+	rd_msg.addr = SDW_DP0_INTSTAT;
+	rd_msg.len = 1;
+	rd_msg.buf = rbuf;
+	rd_msg.slave_addr = sdw_slv->slv_number;
+	rd_msg.addr_page1 = 0x0;
+	rd_msg.addr_page2 = 0x0;
+	ret = sdw_slave_transfer(mstr, &rd_msg, 1);
+	if (ret != 1) {
+		ret = -EINVAL;
+		dev_err(&mstr->dev, "Interrupt status read failed for slave %x\n", sdw_slv->slv_number);
+		goto out;
+	}
+	if (rd_msg.buf[0] & SDW_DP0_INTSTAT_TEST_FAIL_MASK) {
+		dev_err(&mstr->dev, "Test fail for slave %d port 0\n",
+				sdw_slv->slv_number);
+		wr_msg.buf[0] |= SDW_DP0_INTCLEAR_TEST_FAIL_MASK;
+	}
+	if (rd_msg.buf[0] & SDW_DP0_INTSTAT_PORT_READY_MASK) {
+		complete(&sdw_slv->port_ready[0]);
+		wr_msg.buf[0] |= SDW_DP0_INTCLEAR_PORT_READY_MASK;
+	}
+	if (rd_msg.buf[0] & SDW_DP0_INTMASK_BRA_FAILURE_MASK) {
+		/* TODO: Handle BRA failure */
+		dev_err(&mstr->dev, "BRA failed for slave %d\n",
+				sdw_slv->slv_number);
+		wr_msg.buf[0] |= SDW_DP0_INTCLEAR_BRA_FAILURE_MASK;
+	}
+	impl_def_mask = SDW_DP0_INTSTAT_IMPDEF1_MASK |
+			SDW_DP0_INTSTAT_IMPDEF2_MASK |
+			SDW_DP0_INTSTAT_IMPDEF3_MASK;
+	if (rd_msg.buf[0] & impl_def_mask) {
+		/* TODO: Handle implementation defined mask ready */
+		wr_msg.buf[0] |= impl_def_mask;
+	}
+	ret = sdw_slave_transfer(mstr, &wr_msg, 1);
+	if (ret != 1) {
+		ret = -EINVAL;
+		dev_err(&mstr->dev, "Register transfer failed\n");
+		goto out;
+	}
+out:
+	return ret;
+
+}
+
+static int sdw_handle_port_interrupt(struct sdw_master *mstr,
+		struct sdw_slave *sdw_slv, int port_num)
+{
+	int ret = 0;
+	struct sdw_msg rd_msg, wr_msg;
+	u8 rbuf[1], wbuf[1];
+	int impl_def_mask = 0;
+
+	if (port_num == 0)
+		ret = sdw_handle_dp0_interrupts(mstr, sdw_slv);
+
+	/* Create message for reading the port interrupts */
+	wr_msg.ssp_tag = 0;
+	wr_msg.flag = SDW_MSG_FLAG_WRITE;
+	wr_msg.addr = SDW_DPN_INTCLEAR +
+				(SDW_NUM_DATA_PORT_REGISTERS * port_num);
+	wr_msg.len = 1;
+	wr_msg.buf = wbuf;
+	wr_msg.slave_addr = sdw_slv->slv_number;
+	wr_msg.addr_page1 = 0x0;
+	wr_msg.addr_page2 = 0x0;
+
+	rd_msg.ssp_tag = 0;
+	rd_msg.flag = SDW_MSG_FLAG_READ;
+	rd_msg.addr = SDW_DPN_INTSTAT +
+				(SDW_NUM_DATA_PORT_REGISTERS * port_num);
+	rd_msg.len = 1;
+	rd_msg.buf = rbuf;
+	rd_msg.slave_addr = sdw_slv->slv_number;
+	rd_msg.addr_page1 = 0x0;
+	rd_msg.addr_page2 = 0x0;
+	ret = sdw_slave_transfer(mstr, &rd_msg, 1);
+	if (ret != 1) {
+		ret = -EINVAL;
+		dev_err(&mstr->dev, "Port Status read failed for slv %x port %x\n",
+			sdw_slv->slv_number, port_num);
+		goto out;
+	}
+	if (rd_msg.buf[0] & SDW_DPN_INTSTAT_TEST_FAIL_MASK) {
+		dev_err(&mstr->dev, "Test fail for slave %x port %x\n",
+				sdw_slv->slv_number, port_num);
+		wr_msg.buf[0] |= SDW_DPN_INTCLEAR_TEST_FAIL_MASK;
+	}
+	if (rd_msg.buf[0] & SDW_DPN_INTSTAT_PORT_READY_MASK) {
+		complete(&sdw_slv->port_ready[port_num]);
+		wr_msg.buf[0] |= SDW_DPN_INTCLEAR_PORT_READY_MASK;
+	}
+	impl_def_mask = SDW_DPN_INTSTAT_IMPDEF1_MASK |
+			SDW_DPN_INTSTAT_IMPDEF2_MASK |
+			SDW_DPN_INTSTAT_IMPDEF3_MASK;
+	if (rd_msg.buf[0] & impl_def_mask) {
+		/* TODO: Handle implementation defined mask ready */
+		wr_msg.buf[0] |= impl_def_mask;
+	}
+	/* Clear and Ack the interrupt */
+	ret = sdw_slave_transfer(mstr, &wr_msg, 1);
+	if (ret != 1) {
+		ret = -EINVAL;
+		dev_err(&mstr->dev, "Register transfer failed\n");
+		goto out;
+	}
+out:
+	return ret;
+
+}
+static int sdw_handle_slave_alerts(struct sdw_master *mstr,
+				struct sdw_slv *sdw_slv)
+{
+	struct sdw_msg rd_msg[3], wr_msg;
+	u8 rbuf[3], wbuf[1];
+	int i, ret = 0;
+	int cs_port_mask, cs_port_register, cs_port_start, cs_ports;
+
+
+	/* Read Instat 1, Instat 2 and Instat 3 registers */
+	rd_msg[0].ssp_tag = 0x0;
+	rd_msg[0].flag = SDW_MSG_FLAG_READ;
+	rd_msg[0].addr = SDW_SCP_INTSTAT_1;
+	rd_msg[0].len = 1;
+	rd_msg[0].buf = &rbuf[0];
+	rd_msg[0].slave_addr = sdw_slv->slv_number;
+	rd_msg[0].addr_page1 = 0x0;
+	rd_msg[0].addr_page2 = 0x0;
+
+	rd_msg[1].ssp_tag = 0x0;
+	rd_msg[1].flag = SDW_MSG_FLAG_READ;
+	rd_msg[1].addr = SDW_SCP_INTSTAT2;
+	rd_msg[1].len = 1;
+	rd_msg[1].buf = &rbuf[1];
+	rd_msg[1].slave_addr = sdw_slv->slv_number;
+	rd_msg[1].addr_page1 = 0x0;
+	rd_msg[1].addr_page2 = 0x0;
+
+	rd_msg[2].ssp_tag = 0x0;
+	rd_msg[2].flag = SDW_MSG_FLAG_READ;
+	rd_msg[2].addr = SDW_SCP_INTSTAT3;
+	rd_msg[2].len = 1;
+	rd_msg[2].buf = &rbuf[2];
+	rd_msg[2].slave_addr = sdw_slv->slv_number;
+	rd_msg[2].addr_page1 = 0x0;
+	rd_msg[2].addr_page2 = 0x0;
+
+	wr_msg.ssp_tag = 0x0;
+	wr_msg.flag = SDW_MSG_FLAG_WRITE;
+	wr_msg.addr = SDW_SCP_INTCLEAR1;
+	wr_msg.len = 1;
+	wr_msg.buf = &wbuf[0];
+	wr_msg.slave_addr = sdw_slv->slv_number;
+	wr_msg.addr_page1 = 0x0;
+	wr_msg.addr_page2 = 0x0;
+
+	ret = sdw_slave_transfer(mstr, rd_msg, 3);
+	if (ret != 3) {
+		ret = -EINVAL;
+		dev_err(&mstr->dev, "Reading of register failed\n");
+		goto out;
+	}
+	/* First handle parity and bus clash interrupts */
+	if (rd_msg[0].buf[0] & SDW_SCP_INTSTAT1_PARITY_MASK) {
+		dev_err(&mstr->dev, "Parity error detected\n");
+		wr_msg.buf[0] |= SDW_SCP_INTCLEAR1_PARITY_MASK;
+	}
+	/* Handle bus errors */
+	if (rd_msg[0].buf[0] & SDW_SCP_INTSTAT1_BUS_CLASH_MASK) {
+		dev_err(&mstr->dev, "Bus clash error detected\n");
+		wr_msg.buf[0] |= SDW_SCP_INTCLEAR1_BUS_CLASH_MASK;
+	}
+	/* Handle Port interrupts from Instat_1 registers */
+	cs_ports = 4;
+	cs_port_start = 0;
+	cs_port_mask = 0x08;
+	cs_port_register = 0;
+	for (i = cs_port_start; i < cs_port_start + cs_ports; i++) {
+		if (rd_msg[cs_port_register].buf[0] & cs_port_mask) {
+			ret += sdw_handle_port_interrupt(mstr,
+						sdw_slv, cs_port_start + i);
+		}
+		cs_port_mask = cs_port_mask << 1;
+	}
+	/* Handle interrupts from instat_2 register */
+	if (!(rd_msg[0].buf[0] & SDW_SCP_INTSTAT1_SCP2_CASCADE_MASK))
+		goto handle_instat_3_register;
+	cs_ports = 7;
+	cs_port_start = 4;
+	cs_port_mask = 0x1;
+	cs_port_register = 1;
+	for (i = cs_port_start; i < cs_port_start + cs_ports; i++) {
+		if (rd_msg[cs_port_register].buf[0] & cs_port_mask) {
+			ret += sdw_handle_port_interrupt(mstr,
+						sdw_slv, cs_port_start + i);
+		}
+		cs_port_mask = cs_port_mask << 1;
+	}
+handle_instat_3_register:
+
+	if (!(rd_msg[1].buf[0] & SDW_SCP_INTSTAT2_SCP3_CASCADE_MASK))
+		goto handle_instat_3_register;
+	cs_ports = 4;
+	cs_port_start = 11;
+	cs_port_mask = 0x1;
+	cs_port_register = 2;
+	for (i = cs_port_start; i < cs_port_start + cs_ports; i++) {
+		if (rd_msg[cs_port_register].buf[0] & cs_port_mask) {
+			ret += sdw_handle_port_interrupt(mstr,
+						sdw_slv, cs_port_start + i);
+		}
+		cs_port_mask = cs_port_mask << 1;
+	}
+	/* Ack the IntStat 1 interrupts */
+	ret = sdw_slave_transfer(mstr, &wr_msg, 1);
+	if (ret != 1) {
+		ret = -EINVAL;
+		dev_err(&mstr->dev, "Register transfer failed\n");
+		goto out;
+	}
+out:
+	return ret;
+}
+
+static void handle_slave_status(struct kthread_work *work)
+{
+	int i, ret = 0;
+	struct sdw_slv_status *status, *__status__;
+	struct sdw_bus *bus =
+		container_of(work, struct sdw_bus, kwork);
+	struct sdw_master *mstr = bus->mstr;
+	unsigned long flags;
+
+	/* Handle the new attached slaves to the bus. Register new slave
+	 * to the bus.
+	 */
+	list_for_each_entry_safe(status, __status__, &bus->status_list, node) {
+		if (status->status[0] == SDW_SLAVE_STAT_ATTACHED_OK) {
+			ret += sdw_register_slave(mstr);
+			if (ret)
+				/* Even if adding new slave fails, we will
+				 * continue.
+				 */
+				dev_err(&mstr->dev, "Registering new slave failed\n");
+		}
+		for (i = 1; i <= SOUNDWIRE_MAX_DEVICES; i++) {
+			if (status->status[i] == SDW_SLAVE_STAT_NOT_PRESENT &&
+				mstr->sdw_addr[i].assigned == true)
+				/* Logical address was assigned to slave, but
+				 * now its down, so mark it as not present
+				 */
+				mstr->sdw_addr[i].status =
+					SDW_SLAVE_STAT_NOT_PRESENT;
+
+			else if (status->status[i] == SDW_SLAVE_STAT_ALERT &&
+				mstr->sdw_addr[i].assigned == true) {
+				/* Handle slave alerts */
+				mstr->sdw_addr[i].status = SDW_SLAVE_STAT_ALERT;
+				ret = sdw_handle_slave_alerts(mstr,
+						mstr->sdw_addr[i].slave);
+				if (ret)
+					dev_err(&mstr->dev, "Handle slave alert failed for Slave %d\n", i);
+
+
+
+			} else if (status->status[i] ==
+					SDW_SLAVE_STAT_ATTACHED_OK &&
+				mstr->sdw_addr[i].assigned == true)
+					mstr->sdw_addr[i].status =
+						SDW_SLAVE_STAT_ATTACHED_OK;
+		}
+		spin_lock_irqsave(&bus->spinlock, flags);
+		list_del(&status->node);
+		spin_unlock_irqrestore(&bus->spinlock, flags);
+		kfree(status);
+	}
+}
+
+static int sdw_register_master(struct sdw_master *mstr)
+{
+	int ret = 0;
+	int i;
+	struct sdw_bus *sdw_bus;
+
+	/* Can't register until after driver model init */
+	if (unlikely(WARN_ON(!sdw_bus_type.p))) {
+		ret = -EAGAIN;
+		goto bus_init_not_done;
+	}
+	/* Sanity checks */
+	if (unlikely(mstr->name[0] == '\0')) {
+		pr_err("sdw-core: Attempt to register an master with no name!\n");
+		ret = -EINVAL;
+		goto mstr_no_name;
+	}
+	for (i = 0; i <= SOUNDWIRE_MAX_DEVICES; i++)
+		mstr->sdw_addr[i].slv_number = i;
+
+	rt_mutex_init(&mstr->bus_lock);
+	INIT_LIST_HEAD(&mstr->slv_list);
+	INIT_LIST_HEAD(&mstr->mstr_rt_list);
+
+	sdw_bus = kzalloc(sizeof(struct sdw_bus), GFP_KERNEL);
+	if (!sdw_bus)
+		goto bus_alloc_failed;
+	sdw_bus->mstr = mstr;
+
+	mutex_lock(&sdw_core.core_lock);
+	list_add_tail(&sdw_bus->bus_node, &sdw_core.bus_list);
+	mutex_unlock(&sdw_core.core_lock);
+
+	dev_set_name(&mstr->dev, "sdw-%d", mstr->nr);
+	mstr->dev.bus = &sdw_bus_type;
+	mstr->dev.type = &sdw_mstr_type;
+
+	ret = device_register(&mstr->dev);
+	if (ret)
+		goto out_list;
+	kthread_init_worker(&sdw_bus->kworker);
+	sdw_bus->status_thread = kthread_run(kthread_worker_fn,
+					&sdw_bus->kworker, "%s",
+					dev_name(&mstr->dev));
+	if (IS_ERR(sdw_bus->status_thread)) {
+		dev_err(&mstr->dev, "error: failed to create status message task\n");
+		ret = PTR_ERR(sdw_bus->status_thread);
+		goto task_failed;
+	}
+	kthread_init_work(&sdw_bus->kwork, handle_slave_status);
+	INIT_LIST_HEAD(&sdw_bus->status_list);
+	spin_lock_init(&sdw_bus->spinlock);
+	ret = sdw_mstr_bw_init(sdw_bus);
+	if (ret) {
+		dev_err(&mstr->dev, "error: Failed to init mstr bw\n");
+		goto mstr_bw_init_failed;
+	}
+	dev_dbg(&mstr->dev, "master [%s] registered\n", mstr->name);
+
+	return 0;
+
+mstr_bw_init_failed:
+task_failed:
+	device_unregister(&mstr->dev);
+out_list:
+	mutex_lock(&sdw_core.core_lock);
+	list_del(&sdw_bus->bus_node);
+	mutex_unlock(&sdw_core.core_lock);
+	kfree(sdw_bus);
+bus_alloc_failed:
+mstr_no_name:
+bus_init_not_done:
+	mutex_lock(&sdw_core.core_lock);
+	idr_remove(&sdw_core.idr, mstr->nr);
+	mutex_unlock(&sdw_core.core_lock);
+	return ret;
+}
+
+/**
+ * sdw_master_update_slv_status: Report the status of slave to the bus driver.
+ *			master calls this function based on the
+ *			interrupt it gets once the slave changes its
+ *			state.
+ * @mstr: Master handle for which status is reported.
+ * @status: Array of status of each slave.
+ */
+int sdw_master_update_slv_status(struct sdw_master *mstr,
+					struct sdw_status *status)
+{
+	struct sdw_bus *bus = NULL;
+	struct sdw_slv_status *slv_status;
+	unsigned long flags;
+
+	list_for_each_entry(bus, &sdw_core.bus_list, bus_node) {
+		if (bus->mstr == mstr)
+			break;
+	}
+	/* This is master is not registered with bus driver */
+	if (!bus) {
+		dev_info(&mstr->dev, "Master not registered with bus\n");
+		return 0;
+	}
+	slv_status = kzalloc(sizeof(struct sdw_slv_status), GFP_ATOMIC);
+	memcpy(slv_status->status, status, sizeof(struct sdw_status));
+
+	spin_lock_irqsave(&bus->spinlock, flags);
+	list_add_tail(&slv_status->node, &bus->status_list);
+	spin_unlock_irqrestore(&bus->spinlock, flags);
+
+	kthread_queue_work(&bus->kworker, &bus->kwork);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sdw_master_update_slv_status);
+
+/**
+ * sdw_add_master_controller - declare sdw master, use dynamic bus number
+ * @master: the master to add
+ * Context: can sleep
+ *
+ * This routine is used to declare an sdw master when its bus number
+ * doesn't matter or when its bus number is specified by an dt alias.
+ * Examples of bases when the bus number doesn't matter: sdw masters
+ * dynamically added by USB links or PCI plugin cards.
+ *
+ * When this returns zero, a new bus number was allocated and stored
+ * in mstr->nr, and the specified master became available for slaves.
+ * Otherwise, a negative errno value is returned.
+ */
+int sdw_add_master_controller(struct sdw_master *mstr)
+{
+	int id;
+
+	mutex_lock(&sdw_core.core_lock);
+
+	id = idr_alloc(&sdw_core.idr, mstr,
+		       sdw_core.first_dynamic_bus_num, 0, GFP_KERNEL);
+	mutex_unlock(&sdw_core.core_lock);
+	if (id < 0)
+		return id;
+
+	mstr->nr = id;
+
+	return sdw_register_master(mstr);
+}
+EXPORT_SYMBOL_GPL(sdw_add_master_controller);
+
+static void sdw_unregister_slave(struct sdw_slv *sdw_slv)
+{
+
+	struct sdw_master *mstr;
+
+	mstr = sdw_slv->mstr;
+	sdw_lock_mstr(mstr);
+	list_del(&sdw_slv->node);
+	sdw_unlock_mstr(mstr);
+	mstr->sdw_addr[sdw_slv->slv_number].assigned = false;
+	memset(mstr->sdw_addr[sdw_slv->slv_number].dev_id, 0x0, 6);
+	device_unregister(&sdw_slv->dev);
+	kfree(sdw_slv);
+}
+
+static int __unregister_slave(struct device *dev, void *dummy)
+{
+	struct sdw_slv *slave = sdw_slave_verify(dev);
+
+	if (slave && strcmp(slave->name, "dummy"))
+		sdw_unregister_slave(slave);
+	return 0;
+}
+
+/**
+ * sdw_del_master_controller - unregister SDW master
+ * @mstr: the master being unregistered
+ * Context: can sleep
+ *
+ * This unregisters an SDW master which was previously registered
+ * by @sdw_add_master_controller or @sdw_add_master_controller.
+ */
+void sdw_del_master_controller(struct sdw_master *mstr)
+{
+	struct sdw_master *found;
+
+	/* First make sure that this master was ever added */
+	mutex_lock(&sdw_core.core_lock);
+	found = idr_find(&sdw_core.idr, mstr->nr);
+	mutex_unlock(&sdw_core.core_lock);
+
+	if (found != mstr) {
+		pr_debug("sdw-core: attempting to delete unregistered master [%s]\n", mstr->name);
+		return;
+	}
+	/* Detach any active slaves. This can't fail, thus we do not
+	 * check the returned value.
+	 */
+	device_for_each_child(&mstr->dev, NULL, __unregister_slave);
+
+	/* device name is gone after device_unregister */
+	dev_dbg(&mstr->dev, "mstrter [%s] unregistered\n", mstr->name);
+
+	/* wait until all references to the device are gone
+	 *
+	 * FIXME: This is old code and should ideally be replaced by an
+	 * alternative which results in decoupling the lifetime of the struct
+	 * device from the sdw_master, like spi or netdev do. Any solution
+	 * should be thoroughly tested with DEBUG_KOBJECT_RELEASE enabled!
+	 */
+	init_completion(&mstr->slv_released);
+	device_unregister(&mstr->dev);
+	wait_for_completion(&mstr->slv_released);
+
+	/* free bus id */
+	mutex_lock(&sdw_core.core_lock);
+	idr_remove(&sdw_core.idr, mstr->nr);
+	mutex_unlock(&sdw_core.core_lock);
+
+	/* Clear the device structure in case this mstrter is ever going to be
+	   added again */
+	memset(&mstr->dev, 0, sizeof(mstr->dev));
+}
+EXPORT_SYMBOL_GPL(sdw_del_master_controller);
+
+/*
+ * An sdw_driver is used with one or more sdw_slv (slave) nodes to access
+ * sdw slave chips, on a bus instance associated with some sdw_master.
+ */
+int __sdw_mstr_driver_register(struct module *owner,
+					struct sdw_mstr_driver *driver)
+{
+	int res;
+
+	/* Can't register until after driver model init */
+	if (unlikely(WARN_ON(!sdwint_bus_type.p)))
+		return -EAGAIN;
+
+	/* add the driver to the list of sdw drivers in the driver core */
+	driver->driver.owner = owner;
+	driver->driver.bus = &sdwint_bus_type;
+
+	/* When registration returns, the driver core
+	 * will have called probe() for all matching-but-unbound slaves.
+	 */
+	res = driver_register(&driver->driver);
+	if (res)
+		return res;
+
+	pr_debug("sdw-core: driver [%s] registered\n", driver->driver.name);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(__sdw_mstr_driver_register);
+
+void sdw_mstr_driver_unregister(struct sdw_mstr_driver *driver)
+{
+	driver_unregister(&driver->driver);
+}
+EXPORT_SYMBOL_GPL(sdw_mstr_driver_unregister);
+
+void sdw_slave_driver_unregister(struct sdw_slave_driver *driver)
+{
+	driver_unregister(&driver->driver);
+}
+EXPORT_SYMBOL_GPL(sdw_slave_driver_unregister);
+
+/*
+ * An sdw_driver is used with one or more sdw_slv (slave) nodes to access
+ * sdw slave chips, on a bus instance associated with some sdw_master.
+ */
+int __sdw_slave_driver_register(struct module *owner,
+					struct sdw_slave_driver *driver)
+{
+	int res;
+	/* Can't register until after driver model init */
+	if (unlikely(WARN_ON(!sdwint_bus_type.p)))
+		return -EAGAIN;
+
+	/* add the driver to the list of sdw drivers in the driver core */
+	driver->driver.owner = owner;
+	driver->driver.bus = &sdwint_bus_type;
+
+	/* When registration returns, the driver core
+	 * will have called probe() for all matching-but-unbound slaves.
+	 */
+	res = driver_register(&driver->driver);
+	if (res)
+		return res;
+	pr_debug("sdw-core: driver [%s] registered\n", driver->driver.name);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(__sdw_slave_driver_register);
+
+int sdw_register_slave_capabilities(struct sdw_slv *sdw,
+					struct sdw_slv_capabilities *cap)
+{
+	struct sdw_slv_capabilities *slv_cap;
+	struct sdw_slv_dpn_capabilities *slv_dpn_cap, *dpn_cap;
+	struct port_audio_mode_properties *prop, *slv_prop;
+	int i, j;
+
+	slv_cap = &sdw->sdw_slv_cap;
+
+	slv_cap->wake_up_unavailable = cap->wake_up_unavailable;
+	slv_cap->wake_up_unavailable = cap->wake_up_unavailable;
+	slv_cap->test_mode_supported = cap->test_mode_supported;
+	slv_cap->clock_stop1_mode_supported = cap->clock_stop1_mode_supported;
+	slv_cap->simplified_clock_stop_prepare =
+				cap->simplified_clock_stop_prepare;
+	slv_cap->highphy_capable = cap->highphy_capable;
+	slv_cap->paging_supported  = cap->paging_supported;
+	slv_cap->bank_delay_support = cap->bank_delay_support;
+	slv_cap->port_15_read_behavior = cap->port_15_read_behavior;
+	slv_cap->sdw_dp0_supported  = cap->sdw_dp0_supported;
+	slv_cap->num_of_sdw_ports = cap->num_of_sdw_ports;
+	slv_cap->sdw_dpn_cap = devm_kzalloc(&sdw->dev,
+			((sizeof(struct sdw_slv_dpn_capabilities)) *
+			cap->num_of_sdw_ports), GFP_KERNEL);
+	if (!slv_cap->sdw_dpn_cap)
+		return -ENOMEM;
+
+	for (i = 0; i < cap->num_of_sdw_ports; i++) {
+		dpn_cap = &cap->sdw_dpn_cap[i];
+		slv_dpn_cap = &slv_cap->sdw_dpn_cap[i];
+		slv_dpn_cap->port_direction = dpn_cap->port_direction;
+		slv_dpn_cap->port_number = dpn_cap->port_number;
+		slv_dpn_cap->max_word_length = dpn_cap->max_word_length;
+		slv_dpn_cap->min_word_length = dpn_cap->min_word_length;
+		slv_dpn_cap->num_word_length = dpn_cap->num_word_length;
+		if (NULL == dpn_cap->word_length_buffer)
+			slv_dpn_cap->word_length_buffer =
+						dpn_cap->word_length_buffer;
+		else {
+			slv_dpn_cap->word_length_buffer =
+				devm_kzalloc(&sdw->dev,
+				dpn_cap->num_word_length *
+				(sizeof(unsigned  int)), GFP_KERNEL);
+			if (!slv_dpn_cap->word_length_buffer)
+				return -ENOMEM;
+			memcpy(slv_dpn_cap->word_length_buffer,
+				dpn_cap->word_length_buffer,
+				dpn_cap->num_word_length *
+				(sizeof(unsigned  int)));
+		}
+		slv_dpn_cap->dpn_type = dpn_cap->dpn_type;
+		slv_dpn_cap->dpn_grouping = dpn_cap->dpn_grouping;
+		slv_dpn_cap->prepare_ch = dpn_cap->prepare_ch;
+		slv_dpn_cap->imp_def_intr_mask = dpn_cap->imp_def_intr_mask;
+		slv_dpn_cap->min_ch_num = dpn_cap->min_ch_num;
+		slv_dpn_cap->max_ch_num = dpn_cap->max_ch_num;
+		slv_dpn_cap->num_ch_supported = dpn_cap->num_ch_supported;
+		if (NULL == slv_dpn_cap->ch_supported)
+			slv_dpn_cap->ch_supported  = dpn_cap->ch_supported;
+		else {
+			slv_dpn_cap->ch_supported =
+				devm_kzalloc(&sdw->dev,
+				dpn_cap->num_ch_supported *
+				(sizeof(unsigned  int)), GFP_KERNEL);
+			if (!slv_dpn_cap->ch_supported)
+				return -ENOMEM;
+			memcpy(slv_dpn_cap->ch_supported,
+				dpn_cap->ch_supported,
+				dpn_cap->num_ch_supported *
+				(sizeof(unsigned  int)));
+		}
+		slv_dpn_cap->port_flow_mode_mask  =
+					dpn_cap->port_flow_mode_mask;
+		slv_dpn_cap->block_packing_mode_mask =
+				dpn_cap->block_packing_mode_mask;
+		slv_dpn_cap->port_encoding_type_mask =
+				dpn_cap->port_encoding_type_mask;
+		slv_dpn_cap->num_audio_modes = dpn_cap->num_audio_modes;
+
+		slv_dpn_cap->mode_properties = devm_kzalloc(&sdw->dev,
+				((sizeof(struct port_audio_mode_properties)) *
+				dpn_cap->num_audio_modes), GFP_KERNEL);
+		if (!slv_dpn_cap->mode_properties)
+			return -ENOMEM;
+
+		for (j = 0; j < dpn_cap->num_audio_modes; j++) {
+			prop = &dpn_cap->mode_properties[j];
+			slv_prop = &slv_dpn_cap->mode_properties[j];
+			slv_prop->max_frequency = prop->max_frequency;
+			slv_prop->min_frequency = prop->min_frequency;
+			slv_prop->num_freq_configs = prop->num_freq_configs;
+			if (NULL == slv_prop->freq_supported)
+				slv_prop->freq_supported =
+						prop->freq_supported;
+			else {
+				slv_prop->freq_supported =
+					devm_kzalloc(&sdw->dev,
+					prop->num_freq_configs *
+					(sizeof(unsigned  int)), GFP_KERNEL);
+					if (!slv_prop->freq_supported)
+						return -ENOMEM;
+					memcpy(slv_prop->freq_supported,
+						prop->freq_supported,
+					prop->num_freq_configs *
+					(sizeof(unsigned  int)));
+			}
+			slv_prop->glitchless_transitions_mask
+					= prop->glitchless_transitions_mask;
+			slv_prop->max_sampling_frequency =
+						prop->max_sampling_frequency;
+			slv_prop->min_sampling_frequency  =
+						prop->min_sampling_frequency;
+			slv_prop->num_sampling_freq_configs =
+					prop->num_sampling_freq_configs;
+			if (NULL == prop->sampling_freq_config)
+				slv_prop->sampling_freq_config =
+						prop->sampling_freq_config;
+			else {
+				slv_prop->sampling_freq_config =
+					devm_kzalloc(&sdw->dev,
+					prop->num_sampling_freq_configs *
+					(sizeof(unsigned  int)), GFP_KERNEL);
+					if (!slv_prop->sampling_freq_config)
+						return -ENOMEM;
+					memcpy(slv_prop->sampling_freq_config,
+						prop->sampling_freq_config,
+					prop->num_sampling_freq_configs *
+					(sizeof(unsigned  int)));
+			}
+
+			slv_prop->ch_prepare_behavior =
+						prop->ch_prepare_behavior;
+		}
+	}
+	sdw->slave_cap_updated = true;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sdw_register_slave_capabilities);
+
+static int sdw_get_stream_tag(char *key, int *stream_tag)
+{
+	int i;
+	int ret = -EINVAL;
+	struct sdw_runtime *sdw_rt;
+	struct sdw_stream_tag *stream_tags = sdw_core.stream_tags;
+
+	/* If stream tag is already allocated return that after incrementing
+	 * reference count. This is only possible if key is provided.
+	 */
+	mutex_lock(&sdw_core.core_lock);
+	if (!key)
+		goto key_check_not_required;
+	for (i = 0; i < SDW_NUM_STREAM_TAGS; i++) {
+		if (!(strcmp(stream_tags[i].key, key))) {
+			stream_tags[i].ref_count++;
+			*stream_tag = stream_tags[i].stream_tag;
+			mutex_unlock(&sdw_core.core_lock);
+			return 0;
+		}
+	}
+key_check_not_required:
+	for (i = 0; i < SDW_NUM_STREAM_TAGS; i++) {
+		if (!stream_tags[i].ref_count) {
+			*stream_tag = stream_tags[i].stream_tag;
+			mutex_init(&stream_tags[i].stream_lock);
+			sdw_rt = kzalloc(sizeof(struct sdw_runtime),
+					GFP_KERNEL);
+			if (!sdw_rt) {
+				ret = -ENOMEM;
+				mutex_unlock(&sdw_core.core_lock);
+				goto out;
+			}
+			stream_tags[i].ref_count++;
+			INIT_LIST_HEAD(&sdw_rt->slv_rt_list);
+			INIT_LIST_HEAD(&sdw_rt->mstr_rt_list);
+			sdw_rt->stream_state = SDW_STATE_INIT_STREAM_TAG;
+			stream_tags[i].sdw_rt = sdw_rt;
+			if (key)
+				strlcpy(stream_tags[i].key, key,
+					SDW_MAX_STREAM_TAG_KEY_SIZE);
+			mutex_unlock(&sdw_core.core_lock);
+			return 0;
+		}
+	}
+	mutex_unlock(&sdw_core.core_lock);
+out:
+	return ret;
+}
+
+void sdw_release_stream_tag(int stream_tag)
+{
+	int i;
+	struct sdw_stream_tag *stream_tags = sdw_core.stream_tags;
+
+	mutex_lock(&sdw_core.core_lock);
+	for (i = 0; i < SDW_NUM_STREAM_TAGS; i++) {
+		if (stream_tag == stream_tags[i].stream_tag) {
+			stream_tags[i].ref_count--;
+			if (stream_tags[i].ref_count == 0) {
+				kfree(stream_tags[i].sdw_rt);
+				memset(stream_tags[i].key, 0x0,
+					SDW_MAX_STREAM_TAG_KEY_SIZE);
+			}
+		}
+	}
+	mutex_unlock(&sdw_core.core_lock);
+}
+EXPORT_SYMBOL_GPL(sdw_release_stream_tag);
+
+/**
+ * sdw_alloc_stream_tag: Assign the stream tag for the unique streams
+ *			between master and slave device.
+ *			Normally master master will request for the
+ *			stream tag for the stream between master
+ *			and slave device. It programs the same stream
+ *			tag to the slave device. Stream tag is unique
+ *			for all the streams between masters and slave
+ *			across SoCs.
+ * @guid: Group of the device port. All the ports of the device with
+ *			part of same stream will have same guid.
+ *
+ * @stream:tag: Stream tag returned by bus driver.
+ */
+int sdw_alloc_stream_tag(char *guid, int *stream_tag)
+{
+	int ret = 0;
+
+	ret = sdw_get_stream_tag(guid, stream_tag);
+	if (ret) {
+		pr_err("Stream tag assignment failed\n");
+		goto out;
+	}
+
+out:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sdw_alloc_stream_tag);
+
+static struct sdw_mstr_runtime *sdw_get_mstr_rt(struct sdw_runtime *sdw_rt,
+		struct sdw_master *mstr) {
+
+	struct sdw_mstr_runtime *mstr_rt;
+	int ret = 0;
+
+	list_for_each_entry(mstr_rt, &sdw_rt->mstr_rt_list, mstr_sdw_node) {
+		if (mstr_rt->mstr == mstr)
+			return mstr_rt;
+	}
+
+	/* Allocate sdw_mstr_runtime structure */
+	mstr_rt = kzalloc(sizeof(struct sdw_mstr_runtime), GFP_KERNEL);
+	if (!mstr_rt) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* Initialize sdw_mstr_runtime structure */
+	INIT_LIST_HEAD(&mstr_rt->port_rt_list);
+	INIT_LIST_HEAD(&mstr_rt->slv_rt_list);
+	list_add_tail(&mstr_rt->mstr_sdw_node, &sdw_rt->mstr_rt_list);
+	list_add_tail(&mstr_rt->mstr_node, &mstr->mstr_rt_list);
+	mstr_rt->rt_state = SDW_STATE_INIT_RT;
+	mstr_rt->mstr = mstr;
+out:
+	return mstr_rt;
+}
+
+static struct sdw_slave_runtime *sdw_config_slave_stream(
+				struct sdw_slv *slave,
+				struct sdw_stream_config *stream_config,
+				struct sdw_runtime *sdw_rt)
+{
+	struct sdw_slave_runtime *slv_rt;
+	int ret = 0;
+	struct sdw_stream_params *str_p;
+
+	slv_rt = kzalloc(sizeof(struct sdw_slave_runtime), GFP_KERNEL);
+	if (!slv_rt) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	slv_rt->slave = slave;
+	str_p = &slv_rt->stream_params;
+	slv_rt->direction = stream_config->direction;
+	slv_rt->rt_state = SDW_STATE_CONFIG_RT;
+	str_p->rate = stream_config->frame_rate;
+	str_p->channel_count = stream_config->channel_count;
+	str_p->bps = stream_config->bps;
+	INIT_LIST_HEAD(&slv_rt->port_rt_list);
+out:
+	return slv_rt;
+}
+
+static void sdw_release_mstr_stream(struct sdw_master *mstr,
+			struct sdw_runtime *sdw_rt)
+{
+	struct sdw_mstr_runtime *mstr_rt, *__mstr_rt;
+
+	list_for_each_entry_safe(mstr_rt, __mstr_rt, &sdw_rt->mstr_rt_list,
+			mstr_sdw_node) {
+		if (mstr_rt->mstr == mstr) {
+			list_del(&mstr_rt->mstr_sdw_node);
+			if (mstr_rt->direction == SDW_DATA_DIR_OUT)
+				sdw_rt->tx_ref_count--;
+			else
+				sdw_rt->rx_ref_count--;
+			list_del(&mstr_rt->mstr_node);
+			pm_runtime_mark_last_busy(&mstr->dev);
+			pm_runtime_put_sync_autosuspend(&mstr->dev);
+			kfree(mstr_rt);
+		}
+	}
+}
+
+static void sdw_release_slave_stream(struct sdw_slv *slave,
+			struct sdw_runtime *sdw_rt)
+{
+	struct sdw_slave_runtime *slv_rt, *__slv_rt;
+
+	list_for_each_entry_safe(slv_rt, __slv_rt, &sdw_rt->slv_rt_list,
+			slave_sdw_node) {
+		if (slv_rt->slave == slave) {
+			list_del(&slv_rt->slave_sdw_node);
+			if (slv_rt->direction == SDW_DATA_DIR_OUT)
+				sdw_rt->tx_ref_count--;
+			else
+				sdw_rt->rx_ref_count--;
+			pm_runtime_mark_last_busy(&slave->dev);
+			pm_runtime_put_sync_autosuspend(&slave->dev);
+			kfree(slv_rt);
+		}
+	}
+}
+
+/**
+ * sdw_release_stream: De-allocates the bandwidth allocated to the
+ *			the stream. This is reference counted,
+ *			so for the last stream count, BW will be de-allocated
+ *			for the stream. Normally this will be called
+ *			as part of hw_free.
+ *
+ * @mstr: Master handle
+ * @slave: SoundWire slave handle.
+ * @stream_config: Stream configuration for the soundwire audio stream.
+ * @stream_tag: Unique stream tag identifier across SoC for all soundwire
+ *		busses.
+ *		for each audio stream between slaves. This stream tag
+ *		will be allocated by master driver for every
+ *		stream getting open.
+ */
+int sdw_release_stream(struct sdw_master *mstr,
+		struct sdw_slv *slave,
+		unsigned int stream_tag)
+{
+	int i;
+	struct sdw_runtime *sdw_rt = NULL;
+	struct sdw_stream_tag *stream_tags = sdw_core.stream_tags;
+
+	for (i = 0; i < SDW_NUM_STREAM_TAGS; i++) {
+		if (stream_tags[i].stream_tag == stream_tag) {
+			sdw_rt = stream_tags[i].sdw_rt;
+			break;
+		}
+	}
+	if (!sdw_rt) {
+		dev_err(&mstr->dev, "Invalid stream tag\n");
+		return -EINVAL;
+	}
+	if (!slave)
+		sdw_release_mstr_stream(mstr, sdw_rt);
+	else
+		sdw_release_slave_stream(slave, sdw_rt);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sdw_release_stream);
+
+/**
+ * sdw_configure_stream: Allocates the B/W onto the soundwire bus
+ *			for transferring the data between slave and master.
+ *			This is configuring the single stream of data.
+ *			This will be called by slave, Slave stream
+ *			configuration should match the master stream
+ *			configuration. Normally slave would call this
+ *			as a part of hw_params.
+ *
+ * @mstr: Master handle
+ * @sdw_slv: SoundWire slave handle.
+ * @stream_config: Stream configuration for the soundwire audio stream.
+ * @stream_tag: Unique stream tag identifier across the soundwire bus
+ *		for each audio stream between slaves and master.
+ *		This is something like stream_tag in HDA protocol, but
+ *		here its virtual rather than being embedded into protocol.
+ *		Further same stream tag is valid across masters also
+ *		if some ports of the master is participating in
+ *		stream aggregation. This is input parameters to the
+ *		function.
+ */
+int sdw_config_stream(struct sdw_master *mstr,
+		struct sdw_slv *slave,
+		struct sdw_stream_config *stream_config,
+		unsigned int stream_tag)
+{
+	int i;
+	int ret = 0;
+	struct sdw_runtime *sdw_rt = NULL;
+	struct sdw_mstr_runtime *mstr_rt = NULL;
+	struct sdw_slave_runtime *slv_rt = NULL;
+	struct sdw_stream_tag *stream_tags = sdw_core.stream_tags;
+	struct sdw_stream_tag *stream = NULL;
+
+	for (i = 0; i < SDW_NUM_STREAM_TAGS; i++) {
+		if (stream_tags[i].stream_tag == stream_tag) {
+			sdw_rt = stream_tags[i].sdw_rt;
+			stream = &stream_tags[i];
+			break;
+		}
+	}
+	if (!sdw_rt) {
+		dev_dbg(&mstr->dev, "Valid stream tag not found\n");
+		ret = -EINVAL;
+		goto out;
+	}
+	if (static_key_false(&sdw_trace_msg))
+		trace_sdw_config_stream(mstr, slave, stream_config,
+							stream_tag);
+
+	mutex_lock(&stream->stream_lock);
+
+	mstr_rt = sdw_get_mstr_rt(sdw_rt, mstr);
+	if (!mstr_rt) {
+		dev_err(&mstr->dev, "master runtime configuration failed\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (!slave) {
+		mstr_rt->direction = stream_config->direction;
+		mstr_rt->rt_state = SDW_STATE_CONFIG_RT;
+		sdw_rt->xport_state = SDW_STATE_ONLY_XPORT_STREAM;
+
+		mstr_rt->stream_params.rate = stream_config->frame_rate;
+		mstr_rt->stream_params.channel_count =
+					stream_config->channel_count;
+		mstr_rt->stream_params.bps = stream_config->bps;
+
+	} else
+		slv_rt = sdw_config_slave_stream(slave,
+						stream_config, sdw_rt);
+	/* Stream params will be stored based on Tx only, since there can
+	 * be only one Tx and muliple Rx, There can be muliple Tx if
+	 * there is aggregation on Tx. That is handled by adding the channels
+	 * to stream_params for each aggregated Tx slaves
+	 */
+	if (!sdw_rt->tx_ref_count && stream_config->direction ==
+					SDW_DATA_DIR_OUT) {
+		sdw_rt->stream_params.rate = stream_config->frame_rate;
+		sdw_rt->stream_params.channel_count =
+						stream_config->channel_count;
+		sdw_rt->stream_params.bps = stream_config->bps;
+		sdw_rt->tx_ref_count++;
+	}
+
+
+	/* Normally there will be only one Tx in system, multiple Tx
+	 * can only  be there if we support aggregation. In that case
+	 * there may be multiple slave or masters handing different
+	 * channels of same Tx stream.
+	 */
+	else if (sdw_rt->tx_ref_count && stream_config->direction ==
+						SDW_DATA_DIR_OUT) {
+		if (sdw_rt->stream_params.rate !=
+			stream_config->frame_rate) {
+			dev_err(&mstr->dev, "Frame rate for aggregated devices not matching\n");
+			ret = -EINVAL;
+			goto free_mem;
+		}
+		if (sdw_rt->stream_params.bps != stream_config->bps) {
+			dev_err(&mstr->dev, "bps for aggregated devices not matching\n");
+			ret = -EINVAL;
+			goto free_mem;
+		}
+		/* Number of channels gets added, since both devices will
+		 * be supporting different channels. Like one Codec
+		 * supporting L and other supporting R channel.
+		 */
+		sdw_rt->stream_params.channel_count +=
+			stream_config->channel_count;
+		sdw_rt->tx_ref_count++;
+	} else
+		sdw_rt->rx_ref_count++;
+
+	/* SRK: check with hardik */
+	sdw_rt->type = stream_config->type;
+	sdw_rt->stream_state  = SDW_STATE_CONFIG_STREAM;
+
+	/* Slaves are added to two list, This is because BW is calculated
+	 * for two masters individually, while Ports are enabled of all
+	 * the aggregated masters and slaves part of the same  stream tag
+	 * simultaneously.
+	 */
+	if (slave) {
+		list_add_tail(&slv_rt->slave_sdw_node, &sdw_rt->slv_rt_list);
+		list_add_tail(&slv_rt->slave_node, &mstr_rt->slv_rt_list);
+	}
+	mutex_unlock(&stream->stream_lock);
+	if (slave)
+		pm_runtime_get_sync(&slave->dev);
+	else
+		pm_runtime_get_sync(&mstr->dev);
+	return ret;
+
+free_mem:
+	mutex_unlock(&stream->stream_lock);
+	kfree(mstr_rt);
+	kfree(slv_rt);
+out:
+	return ret;
+
+}
+EXPORT_SYMBOL_GPL(sdw_config_stream);
+
+static int sdw_mstr_port_configuration(struct sdw_master *mstr,
+			struct sdw_runtime *sdw_rt,
+			struct sdw_port_config *port_config)
+{
+	struct sdw_mstr_runtime *mstr_rt;
+	struct sdw_port_runtime *port_rt;
+	int found = 0;
+	int i;
+
+	list_for_each_entry(mstr_rt, &sdw_rt->mstr_rt_list, mstr_sdw_node) {
+		if (mstr_rt->mstr == mstr) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		dev_err(&mstr->dev, "Master not found for this port\n");
+		return -EINVAL;
+	}
+	port_rt = kzalloc((sizeof(struct sdw_port_runtime)) *
+			port_config->num_ports, GFP_KERNEL);
+	if (!port_rt)
+		return -EINVAL;
+	for (i = 0; i < port_config->num_ports; i++) {
+		port_rt[i].channel_mask = port_config->port_cfg[i].ch_mask;
+		port_rt[i].port_num = port_config->port_cfg[i].port_num;
+		list_add_tail(&port_rt[i].port_node, &mstr_rt->port_rt_list);
+	}
+	return 0;
+}
+
+static int sdw_slv_port_configuration(struct sdw_slv *slave,
+			struct sdw_runtime *sdw_rt,
+			struct sdw_port_config *port_config)
+{
+	struct sdw_slave_runtime *slv_rt;
+	struct sdw_port_runtime *port_rt;
+	int found = 0;
+	int i;
+
+	list_for_each_entry(slv_rt, &sdw_rt->slv_rt_list, slave_sdw_node) {
+		if (slv_rt->slave == slave) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		dev_err(&slave->mstr->dev, "Slave not found for this port\n");
+		return -EINVAL;
+	}
+	port_rt = kzalloc((sizeof(struct sdw_port_runtime)) *
+			port_config->num_ports, GFP_KERNEL);
+	if (!port_rt)
+		return -EINVAL;
+
+	for (i = 0; i < port_config->num_ports; i++) {
+		port_rt[i].channel_mask = port_config->port_cfg[i].ch_mask;
+		port_rt[i].port_num = port_config->port_cfg[i].port_num;
+		list_add_tail(&port_rt[i].port_node, &slv_rt->port_rt_list);
+	}
+	return 0;
+}
+
+/**
+ * sdw_config_port: Port configuration for the SoundWire. Multiple
+ *			soundWire ports may form single stream. Like two
+ *			ports each transferring/receiving mono channels
+ *			forms single stream with stereo channels.
+ *			There will be single ASoC DAI representing
+ *			the both ports. So stream configuration will be
+ *			stereo, but both of the ports will be configured
+ *			for mono channels, each with different channel
+ *			mask. This is used to program port w.r.t to stream.
+ *			params. So no need to de-configure, since these
+ *			are automatically destroyed once stream gets
+ *			destroyed.
+ * @mstr: Master handle where the slave is connected.
+ * @slave: Slave handle.
+ * @port_config: Port configuration for each port of soundwire slave.
+ * @stream_tag: Stream tag, where this port is connected.
+ *
+ */
+int sdw_config_port(struct sdw_master *mstr,
+			struct sdw_slv *slave,
+			struct sdw_port_config *port_config,
+			unsigned int stream_tag)
+{
+	int ret = 0;
+	int i;
+	struct sdw_stream_tag *stream_tags = sdw_core.stream_tags;
+	struct sdw_runtime *sdw_rt = NULL;
+	struct sdw_stream_tag *stream = NULL;
+
+
+	for (i = 0; i < SDW_NUM_STREAM_TAGS; i++) {
+		if (stream_tags[i].stream_tag == stream_tag) {
+			sdw_rt = stream_tags[i].sdw_rt;
+			stream = &stream_tags[i];
+			break;
+		}
+	}
+	if (!sdw_rt) {
+		dev_err(&mstr->dev, "Invalid stream tag\n");
+		return -EINVAL;
+	}
+	if (static_key_false(&sdw_trace_msg)) {
+		int i;
+
+		for (i = 0; i < port_config->num_ports; i++) {
+			trace_sdw_config_port(mstr, slave,
+				&port_config->port_cfg[i], stream_tag);
+		}
+	}
+	mutex_lock(&stream->stream_lock);
+	if (!slave)
+		ret = sdw_mstr_port_configuration(mstr, sdw_rt, port_config);
+	else
+		ret = sdw_slv_port_configuration(slave, sdw_rt, port_config);
+
+	mutex_unlock(&stream->stream_lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sdw_config_port);
+
+int sdw_prepare_and_enable(int stream_tag, bool enable)
+{
+
+	int i, ret = 0;
+	struct sdw_stream_tag *stream_tags = sdw_core.stream_tags;
+	struct sdw_stream_tag *stream = NULL;
+
+	/* TBD: SRK, Check with hardik whether both locks needed
+	 * stream and core??
+	 */
+	mutex_lock(&sdw_core.core_lock);
+
+	for (i = 0; i < SDW_NUM_STREAM_TAGS; i++) {
+		if (stream_tag == stream_tags[i].stream_tag) {
+			stream = &stream_tags[i];
+			break;
+		}
+	}
+	if (stream == NULL) {
+		mutex_unlock(&sdw_core.core_lock);
+		WARN_ON(1); /* Return from here after unlocking core*/
+		return -EINVAL;
+	}
+	mutex_lock(&stream->stream_lock);
+	ret = sdw_bus_calc_bw(&stream_tags[i], enable);
+	if (ret)
+		pr_err("Bandwidth allocation failed\n");
+
+	mutex_unlock(&stream->stream_lock);
+	mutex_unlock(&sdw_core.core_lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sdw_prepare_and_enable);
+
+int sdw_disable_and_unprepare(int stream_tag, bool unprepare)
+{
+	int i, ret = 0;
+	struct sdw_stream_tag *stream_tags = sdw_core.stream_tags;
+	struct sdw_stream_tag *stream = NULL;
+
+	mutex_lock(&sdw_core.core_lock);
+
+	for (i = 0; i < SDW_NUM_STREAM_TAGS; i++) {
+		if (stream_tag == stream_tags[i].stream_tag) {
+			stream = &stream_tags[i];
+			break;
+		}
+	}
+	if (stream == NULL) {
+		mutex_unlock(&sdw_core.core_lock);
+		WARN_ON(1); /* Return from here after unlocking core*/
+		return -EINVAL;
+	}
+	mutex_lock(&stream->stream_lock);
+	ret = sdw_bus_calc_bw_dis(&stream_tags[i], unprepare);
+	if (ret)
+		pr_err("Bandwidth de-allocation failed\n");
+
+	mutex_unlock(&stream->stream_lock);
+
+	mutex_unlock(&sdw_core.core_lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sdw_disable_and_unprepare);
+
+int sdw_stop_clock(struct sdw_master *mstr, enum sdw_clk_stop_mode mode)
+{
+	int ret = 0, i;
+	struct sdw_msg msg;
+	u8 buf[1] = {0};
+	int slave_present = 0;
+
+	for (i = 1; i <= SOUNDWIRE_MAX_DEVICES; i++) {
+		if (mstr->sdw_addr[i].assigned &&
+			mstr->sdw_addr[i].status !=
+					SDW_SLAVE_STAT_NOT_PRESENT)
+			slave_present = 1;
+	}
+
+	/* Send Broadcast message to the SCP_ctrl register with
+	 * clock stop now
+	 */
+	msg.ssp_tag = 1;
+	msg.flag = SDW_MSG_FLAG_WRITE;
+	msg.addr = SDW_SCP_CTRL;
+	msg.len = 1;
+	buf[0] |= 0x1 << SDW_SCP_CTRL_CLK_STP_NOW_SHIFT;
+	msg.buf = buf;
+	msg.slave_addr = 15;
+	msg.addr_page1 = 0x0;
+	msg.addr_page2 = 0x0;
+	ret = sdw_slave_transfer_nopm(mstr, &msg, 1);
+	if (ret != 1 && slave_present) {
+		dev_err(&mstr->dev, "Failed to stop clk\n");
+		return -EBUSY;
+	}
+	/* If we are entering clock stop mode1, mark all the slaves un-attached.
+	 */
+	if (mode == SDW_CLOCK_STOP_MODE_1) {
+		for (i = 1; i <= SOUNDWIRE_MAX_DEVICES; i++) {
+			if (mstr->sdw_addr[i].assigned)
+				mstr->sdw_addr[i].status =
+						SDW_SLAVE_STAT_NOT_PRESENT;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sdw_stop_clock);
+
+int sdw_wait_for_slave_enumeration(struct sdw_master *mstr,
+					struct sdw_slv *slave)
+{
+	int timeout = 0;
+
+	/* Wait till device gets enumerated. Wait for 2Secs before
+	 * giving up
+	 */
+	do {
+		msleep(100);
+		timeout++;
+	} while ((slave->slv_addr->status == SDW_SLAVE_STAT_NOT_PRESENT) &&
+		timeout < 20);
+
+	if (slave->slv_addr->status == SDW_SLAVE_STAT_NOT_PRESENT)
+		return -EBUSY;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sdw_wait_for_slave_enumeration);
+
+int sdw_prepare_for_clock_change(struct sdw_master *mstr, bool stop,
+			enum sdw_clk_stop_mode *clck_stop_mode)
+{
+	int i;
+	struct sdw_msg msg;
+	u8 buf[1] = {0};
+	struct sdw_slave *slave;
+	enum sdw_clk_stop_mode clock_stop_mode;
+	int timeout = 0;
+	int ret = 0;
+	int slave_dev_present = 0;
+
+	/*  Find if all slave support clock stop mode1 if all slaves support
+	 *  clock stop mode1 use mode1 else use mode0
+	 */
+	for (i = 1; i <= SOUNDWIRE_MAX_DEVICES; i++) {
+		if (mstr->sdw_addr[i].assigned &&
+		mstr->sdw_addr[i].status != SDW_SLAVE_STAT_NOT_PRESENT) {
+			slave_dev_present = 1;
+			slave = mstr->sdw_addr[i].slave;
+			clock_stop_mode &=
+				slave->sdw_slv_cap.clock_stop1_mode_supported;
+			if (!clock_stop_mode)
+				break;
+		}
+	}
+	if (stop) {
+		*clck_stop_mode = clock_stop_mode;
+		dev_info(&mstr->dev, "Entering Clock stop mode %x\n",
+						clock_stop_mode);
+	}
+	/* Slaves might have removed power during its suspend
+	 * in that case no need to do clock stop prepare
+	 * and return from here
+	 */
+	if (!slave_dev_present)
+		return 0;
+	/* Prepare for the clock stop mode. For simplified clock stop
+	 * prepare only mode is to be set, For others set the ClockStop
+	 * Prepare bit in SCP_SystemCtrl register. For all the other slaves
+	 * set the clock stop prepare bit. For all slave set the clock
+	 * stop mode based on what we got in earlier loop
+	 */
+	for (i = 1; i <= SOUNDWIRE_MAX_DEVICES; i++) {
+		if (mstr->sdw_addr[i].assigned != true)
+			continue;
+		if (mstr->sdw_addr[i].status == SDW_SLAVE_STAT_NOT_PRESENT)
+			continue;
+		slave = mstr->sdw_addr[i].slave;
+		msg.ssp_tag = 0;
+		slave = mstr->sdw_addr[i].slave;
+
+		if (stop) {
+			/* Even if its simplified clock stop prepare
+			 * setting prepare bit wont harm
+			 */
+			buf[0] |= (1 << SDW_SCP_SYSTEMCTRL_CLK_STP_PREP_SHIFT);
+			buf[0] |= clock_stop_mode <<
+				SDW_SCP_SYSTEMCTRL_CLK_STP_MODE_SHIFT;
+		}
+		msg.flag = SDW_MSG_FLAG_WRITE;
+		msg.addr = SDW_SCP_SYSTEMCTRL;
+		msg.len = 1;
+		msg.buf = buf;
+		msg.slave_addr = i;
+		msg.addr_page1 = 0x0;
+		msg.addr_page2 = 0x0;
+		ret = sdw_slave_transfer_nopm(mstr, &msg, 1);
+		if (ret != 1) {
+			dev_err(&mstr->dev, "Clock Stop prepare failed\n");
+			return -EBUSY;
+		}
+	}
+	/*
+	 * Once clock stop prepare bit is set, broadcast the message to read
+	 * ClockStop_NotFinished bit from SCP_Stat, till we read it as 11
+	 * we dont exit loop. We wait for definite time before retrying
+	 * if its simple clock stop it will be always 1, while for other
+	 * they will driver 0 on bus so we wont get 1. In total we are
+	 * waiting 1 sec before we timeout.
+	 */
+	do {
+		buf[0] = 0xFF;
+		msg.ssp_tag = 0;
+		msg.flag = SDW_MSG_FLAG_READ;
+		msg.addr = SDW_SCP_STAT;
+		msg.len = 1;
+		msg.buf = buf;
+		msg.slave_addr = 15;
+		msg.addr_page1 = 0x0;
+		msg.addr_page2 = 0x0;
+		ret = sdw_slave_transfer_nopm(mstr, &msg, 1);
+		if (ret != 1)
+			goto prepare_failed;
+
+		if (!(buf[0] & SDW_SCP_STAT_CLK_STP_NF_MASK))
+				break;
+		msleep(100);
+		timeout++;
+	} while (timeout != 11);
+	/* If we are trying to stop and prepare failed its not ok
+	 */
+	if (!(buf[0] & SDW_SCP_STAT_CLK_STP_NF_MASK)) {
+		dev_info(&mstr->dev, "Clock stop prepare done\n");
+		return 0;
+	/* If we are trying to resume and  un-prepare failes its ok
+	 * since codec might be down during suspned and will
+	 * start afresh after resuming
+	 */
+	} else if (!stop) {
+		dev_info(&mstr->dev, "Some Slaves un-prepare un-successful\n");
+		return 0;
+	}
+
+prepare_failed:
+	dev_err(&mstr->dev, "Clock Stop prepare failed\n");
+	return -EBUSY;
+
+}
+EXPORT_SYMBOL_GPL(sdw_prepare_for_clock_change);
+
+struct sdw_master *sdw_get_master(int nr)
+{
+	struct sdw_master *master;
+
+	mutex_lock(&sdw_core.core_lock);
+	master = idr_find(&sdw_core.idr, nr);
+	if (master && !try_module_get(master->owner))
+		master = NULL;
+	mutex_unlock(&sdw_core.core_lock);
+
+	return master;
+}
+EXPORT_SYMBOL_GPL(sdw_get_master);
+
+void sdw_put_master(struct sdw_master *mstr)
+{
+	if (mstr)
+		module_put(mstr->owner);
+}
+EXPORT_SYMBOL_GPL(sdw_put_master);
+
+static void sdw_exit(void)
+{
+	device_unregister(&sdw_slv);
+	bus_unregister(&sdwint_bus_type);
+}
+
+static int sdw_init(void)
+{
+	int retval;
+	int i;
+
+	for (i = 0; i < SDW_NUM_STREAM_TAGS; i++)
+		sdw_core.stream_tags[i].stream_tag = i;
+	mutex_init(&sdw_core.core_lock);
+	INIT_LIST_HEAD(&sdw_core.bus_list);
+	idr_init(&sdw_core.idr);
+	retval = bus_register(&sdwint_bus_type);
+
+	if (!retval)
+		retval = device_register(&sdw_slv);
+
+
+	if (retval)
+		bus_unregister(&sdwint_bus_type);
+
+	retval = sdw_bus_bw_init();
+	if (retval) {
+		device_unregister(&sdw_slv);
+		bus_unregister(&sdwint_bus_type);
+	}
+
+	return retval;
+}
+postcore_initcall(sdw_init);
+module_exit(sdw_exit);
+
+MODULE_AUTHOR("Hardik Shah <hardik.t.shah@intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("0.1");
+MODULE_DESCRIPTION("SoundWire bus driver");
+MODULE_ALIAS("platform:soundwire");
diff --git a/drivers/sdw/sdw_bwcalc.c b/drivers/sdw/sdw_bwcalc.c
new file mode 100644
index 000000000000..9c1ebc3297d2
--- /dev/null
+++ b/drivers/sdw/sdw_bwcalc.c
@@ -0,0 +1,2366 @@
+/*
+ *  sdw_bwcalc.c - SoundWire Bus BW calculation & CHN Enabling implementation
+ *
+ *  Copyright (C) 2015-2016 Intel Corp
+ *  Author:  Sanyog Kale <sanyog.r.kale@intel.com>
+ *
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/sdw_bus.h>
+#include "sdw_priv.h"
+#include <linux/delay.h>
+#include <linux/sdw/sdw_registers.h>
+
+
+#define MAXCLOCKFREQ		6
+
+#define MAXCLOCKFREQ           6
+
+/* TBD: Currently we are using 100x2 as frame shape. to be removed later */
+int rows[MAX_NUM_ROWS] = {100, 48, 50, 60, 64, 72, 75, 80, 90,
+		     96, 125, 144, 147, 120, 128, 150,
+		     160, 180, 192, 200, 240, 250, 256};
+
+int cols[MAX_NUM_COLS] = {2, 4, 6, 8, 10, 12, 14, 16};
+
+/*
+ * TBD: Get supported clock frequency from ACPI and store
+ * it in master data structure.
+ */
+/* Currently only 9.6MHz clock frequency used */
+int clock_freq[MAXCLOCKFREQ] = {9600000, 9600000,
+				9600000, 9600000,
+				9600000, 9600000};
+
+
+struct sdw_num_to_col sdw_num_col_mapping[MAX_NUM_COLS] = {
+	{0, 2}, {1, 4}, {2, 6}, {3, 8}, {4, 10}, {5, 12}, {6, 14}, {7, 16},
+};
+
+struct sdw_num_to_row sdw_num_row_mapping[MAX_NUM_ROWS] = {
+	{0, 48}, {1, 50}, {2, 60}, {3, 64}, {4, 75}, {5, 80}, {6, 125},
+	{7, 147}, {8, 96}, {9, 100}, {10, 120}, {11, 128}, {12, 150},
+	{13, 160}, {14, 250}, {16, 192}, {17, 200}, {18, 240}, {19, 256},
+	{20, 72}, {21, 144}, {22, 90}, {23, 180},
+};
+
+/**
+ * sdw_bus_bw_init - returns Success
+ *
+ *
+ * This function is called from sdw_init function when bus driver
+ * gets intitalized. This function performs all the generic
+ * intializations required for BW control.
+ */
+int sdw_bus_bw_init(void)
+{
+	int r, c, rowcolcount = 0;
+	int control_bits = 48;
+
+	for (c = 0; c < MAX_NUM_COLS; c++) {
+
+		for (r = 0; r < MAX_NUM_ROWS; r++) {
+			sdw_core.rowcolcomb[rowcolcount].col = cols[c];
+			sdw_core.rowcolcomb[rowcolcount].row = rows[r];
+			sdw_core.rowcolcomb[rowcolcount].control_bits =
+				control_bits;
+			sdw_core.rowcolcomb[rowcolcount].data_bits =
+				(cols[c] * rows[r]) - control_bits;
+			rowcolcount++;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sdw_bus_bw_init);
+
+
+/**
+ * sdw_mstr_bw_init - returns Success
+ *
+ *
+ * This function is called from sdw_register_master function
+ * for each master controller gets register. This function performs
+ * all the intializations per master controller required for BW control.
+ */
+int sdw_mstr_bw_init(struct sdw_bus *sdw_bs)
+{
+	struct sdw_master_capabilities *sdw_mstr_cap = NULL;
+
+	/* Initialize required parameters in bus structure */
+	sdw_bs->bandwidth = 0;
+	sdw_bs->system_interval = 0;
+	sdw_bs->frame_freq = 0;
+	/* TBD: Base Clock frequency should be read from
+	 * master capabilities
+	 * Currenly hardcoding to 9.6MHz
+	 */
+	sdw_bs->clk_freq = 9.6*1000*1000;
+	sdw_bs->clk_state = SDW_CLK_STATE_ON;
+
+	/* TBD: to be removed later */
+	/* Assumption is these should be already filled */
+	sdw_mstr_cap = &sdw_bs->mstr->mstr_capabilities;
+	sdw_mstr_cap->base_clk_freq = 9.6 * 1000 * 1000;
+	sdw_mstr_cap->monitor_handover_supported = false;
+	sdw_mstr_cap->highphy_capable = false;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sdw_mstr_bw_init);
+
+
+/**
+ * sdw_get_col_to_num
+ *
+ * Returns column number from the mapping.
+ */
+int sdw_get_col_to_num(int col)
+{
+	int i;
+
+	for (i = 0; i < MAX_NUM_COLS; i++) {
+		if (sdw_num_col_mapping[i].col == col)
+			return sdw_num_col_mapping[i].num;
+	}
+
+	return 0; /* Lowest Column number = 2 */
+}
+
+
+/**
+ * sdw_get_row_to_num
+ *
+ * Returns row number from the mapping.
+ */
+int sdw_get_row_to_num(int row)
+{
+	int i;
+
+	for (i = 0; i < MAX_NUM_ROWS; i++) {
+		if (sdw_num_row_mapping[i].row == row)
+			return sdw_num_row_mapping[i].num;
+	}
+
+	return 0; /* Lowest Row number = 48 */
+}
+
+/*
+ * sdw_lcm - returns LCM of two numbers
+ *
+ *
+ * This function is called BW calculation function to find LCM
+ * of two numbers.
+ */
+int sdw_lcm(int num1, int num2)
+{
+	int max;
+
+	/* maximum value is stored in variable max */
+	max = (num1 > num2) ? num1 : num2;
+
+	while (1) {
+		if (max%num1 == 0 && max%num2 == 0)
+			break;
+		++max;
+	}
+
+	return max;
+}
+
+
+/*
+ * sdw_cfg_slv_params - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function configures slave registers for
+ * transport and port parameters.
+ */
+int sdw_cfg_slv_params(struct sdw_bus *mstr_bs,
+		struct sdw_slave_runtime *slv_rt,
+		struct sdw_transport_params *t_slv_params,
+		struct sdw_port_params *p_slv_params)
+{
+	struct sdw_msg wr_msg, wr_msg1, rd_msg;
+	int ret = 0;
+	int banktouse;
+	u8 wbuf[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	u8 wbuf1[2] = {0, 0};
+	u8 rbuf[1] = {0};
+	u8 rbuf1[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	u8 rbuf2[2] = {0, 0};
+
+	/* Program slave alternate bank with all transport parameters */
+	/* DPN_BlockCtrl2 */
+	wbuf[0] = t_slv_params->blockgroupcontrol;
+	/* DPN_SampleCtrl1 */
+	wbuf[1] = (t_slv_params->sample_interval - 1) &
+			SDW_DPN_SAMPLECTRL1_LOW_MASK;
+	wbuf[2] = ((t_slv_params->sample_interval - 1) >> 8) &
+			SDW_DPN_SAMPLECTRL1_LOW_MASK; /* DPN_SampleCtrl2 */
+	wbuf[3] = t_slv_params->offset1; /* DPN_OffsetCtrl1 */
+	wbuf[4] = t_slv_params->offset2; /* DPN_OffsetCtrl1 */
+	/*  DPN_HCtrl  */
+	wbuf[5] = (t_slv_params->hstop | (t_slv_params->hstart << 4));
+	wbuf[6] = t_slv_params->blockpackingmode; /* DPN_BlockCtrl3 */
+	wbuf[7] = t_slv_params->lanecontrol; /* DPN_LaneCtrl */
+
+	/* Get current bank in use from bus structure*/
+	banktouse = mstr_bs->active_bank;
+	banktouse = !banktouse;
+	/* Program slave alternate bank with all port parameters */
+	rd_msg.addr = SDW_DPN_PORTCTRL +
+		(SDW_NUM_DATA_PORT_REGISTERS * t_slv_params->num);
+	rd_msg.ssp_tag = 0x0;
+	rd_msg.flag = SDW_MSG_FLAG_READ;
+	rd_msg.len = 1;
+	rd_msg.slave_addr =  slv_rt->slave->slv_number;
+	rd_msg.buf = rbuf;
+	rd_msg.addr_page1 = 0x0;
+	rd_msg.addr_page2 = 0x0;
+
+	ret = sdw_slave_transfer(mstr_bs->mstr, &rd_msg, 1);
+	if (ret != 1) {
+		ret = -EINVAL;
+		dev_err(&mstr_bs->mstr->dev, "Register transfer failed\n");
+		goto out;
+	}
+
+
+	wbuf1[0] = (p_slv_params->port_flow_mode |
+			(p_slv_params->port_data_mode <<
+			SDW_DPN_PORTCTRL_PORTDATAMODE_SHIFT) |
+			(rbuf[0]));
+
+	wbuf1[1] = (p_slv_params->word_length - 1);
+
+	/* Check whether address computed is correct for both cases */
+	wr_msg.addr = ((SDW_DPN_BLOCKCTRL2 +
+				(1 * (!t_slv_params->blockgroupcontrol_valid))
+				+ (SDW_BANK1_REGISTER_OFFSET * banktouse)) +
+			(SDW_NUM_DATA_PORT_REGISTERS * t_slv_params->num));
+
+	wr_msg1.addr =  SDW_DPN_PORTCTRL +
+		(SDW_NUM_DATA_PORT_REGISTERS * t_slv_params->num);
+
+	wr_msg.ssp_tag = 0x0;
+	wr_msg.flag = SDW_MSG_FLAG_WRITE;
+	wr_msg.len = (7 + (1 * (t_slv_params->blockgroupcontrol_valid)));
+	wr_msg.slave_addr = slv_rt->slave->slv_number;
+	wr_msg.buf = &wbuf[0 + (1 * (!t_slv_params->blockgroupcontrol_valid))];
+	wr_msg.addr_page1 = 0x0;
+	wr_msg.addr_page2 = 0x0;
+
+	wr_msg1.ssp_tag = 0x0;
+	wr_msg1.flag = SDW_MSG_FLAG_WRITE;
+	wr_msg1.len = 2;
+	wr_msg1.slave_addr = slv_rt->slave->slv_number;
+	wr_msg1.buf = &wbuf1[0];
+	wr_msg1.addr_page1 = 0x0;
+	wr_msg1.addr_page2 = 0x0;
+
+	ret = sdw_slave_transfer(mstr_bs->mstr, &wr_msg, 1);
+	if (ret != 1) {
+		ret = -EINVAL;
+		dev_err(&mstr_bs->mstr->dev, "Register transfer failed\n");
+		goto out;
+	}
+
+
+	ret = sdw_slave_transfer(mstr_bs->mstr, &wr_msg1, 1);
+	if (ret != 1) {
+		ret = -EINVAL;
+		dev_err(&mstr_bs->mstr->dev, "Register transfer failed\n");
+		goto out;
+	}
+
+out:
+	return ret;
+}
+
+
+/*
+ * sdw_cfg_mstr_params - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function configures master registers for
+ * transport and port parameters.
+ */
+int sdw_cfg_mstr_params(struct sdw_bus *mstr_bs,
+		struct sdw_transport_params *t_mstr_params,
+		struct sdw_port_params *p_mstr_params)
+{
+	struct sdw_mstr_driver *ops = mstr_bs->mstr->driver;
+	int banktouse, ret = 0;
+
+	/* 1. Get current bank in use from bus structure*/
+	banktouse = mstr_bs->active_bank;
+	banktouse = !banktouse;
+
+	/* 2. Set Master Xport Params */
+	if (ops->mstr_port_ops->dpn_set_port_transport_params) {
+		ret = ops->mstr_port_ops->dpn_set_port_transport_params
+				(mstr_bs->mstr, t_mstr_params, banktouse);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* 3. Set Master Port Params */
+	if (ops->mstr_port_ops->dpn_set_port_params) {
+		ret = ops->mstr_port_ops->dpn_set_port_params
+				(mstr_bs->mstr, p_mstr_params, banktouse);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+
+/*
+ * sdw_cfg_mstr_slv - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function call master/slave transport/port
+ * params configuration API's, called from sdw_bus_calc_bw
+ * & sdw_bus_calc_bw_dis API's.
+ */
+int sdw_cfg_mstr_slv(struct sdw_bus *sdw_mstr_bs,
+		struct sdw_mstr_runtime *sdw_mstr_bs_rt,
+		bool is_master)
+{
+	struct sdw_transport_params *t_params, *t_slv_params;
+	struct sdw_port_params *p_params, *p_slv_params;
+	struct sdw_slave_runtime *slv_rt = NULL;
+	struct sdw_port_runtime *port_rt, *port_slv_rt;
+	int ret = 0;
+
+	if (is_master) {
+		/* should not compute any transport params */
+		if (sdw_mstr_bs_rt->rt_state == SDW_STATE_UNPREPARE_RT)
+			return 0;
+
+		list_for_each_entry(port_rt,
+			&sdw_mstr_bs_rt->port_rt_list, port_node) {
+
+			/* Transport and port parameters */
+			t_params = &port_rt->transport_params;
+			p_params = &port_rt->port_params;
+
+			p_params->num = port_rt->port_num;
+			p_params->word_length =
+				sdw_mstr_bs_rt->stream_params.bps;
+			p_params->port_flow_mode = 0x0; /* Isochronous Mode */
+			p_params->port_data_mode = 0x0; /* Normal Mode */
+
+			/* Configure xport params and port params for master */
+			ret = sdw_cfg_mstr_params(sdw_mstr_bs,
+					t_params, p_params);
+			if (ret < 0)
+				return ret;
+
+			/* Since one port per master runtime,
+			 * breaking port_list loop
+			 * TBD: to be extended for multiple port support
+			 */
+
+			break;
+		}
+
+	} else {
+
+
+		list_for_each_entry(slv_rt,
+			&sdw_mstr_bs_rt->slv_rt_list, slave_node) {
+
+			if (slv_rt->slave == NULL)
+				break;
+
+			/* should not compute any transport params */
+			if (slv_rt->rt_state == SDW_STATE_UNPREPARE_RT)
+				continue;
+
+			list_for_each_entry(port_slv_rt,
+				&slv_rt->port_rt_list, port_node) {
+
+				/* Fill in port params here */
+				port_slv_rt->port_params.num =
+					port_slv_rt->port_num;
+				port_slv_rt->port_params.word_length =
+					slv_rt->stream_params.bps;
+				/* Isochronous Mode */
+				port_slv_rt->port_params.port_flow_mode = 0x0;
+				/* Normal Mode */
+				port_slv_rt->port_params.port_data_mode = 0x0;
+				t_slv_params = &port_slv_rt->transport_params;
+				p_slv_params = &port_slv_rt->port_params;
+
+				/* Configure xport  & port params for slave */
+				ret = sdw_cfg_slv_params(sdw_mstr_bs,
+					slv_rt, t_slv_params, p_slv_params);
+				if (ret < 0)
+					return ret;
+
+				/* Since one port per slave runtime,
+				 * breaking port_list loop
+				 * TBD: to be extended for multiple
+				 * port support
+				 */
+
+				break;
+			}
+		}
+
+	}
+
+	return 0;
+}
+
+
+/*
+ * sdw_cpy_params_mstr_slv - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function copies/configure master/slave transport &
+ * port params to alternate bank.
+ *
+ */
+int sdw_cpy_params_mstr_slv(struct sdw_bus *sdw_mstr_bs,
+		struct sdw_mstr_runtime *sdw_mstr_bs_rt)
+{
+	struct sdw_slave_runtime *slv_rt = NULL;
+	struct sdw_port_runtime *port_rt, *port_slv_rt;
+	struct sdw_transport_params *t_params, *t_slv_params;
+	struct sdw_port_params *p_params, *p_slv_params;
+	int ret = 0;
+
+	list_for_each_entry(slv_rt,
+			&sdw_mstr_bs_rt->slv_rt_list, slave_node) {
+
+		if (slv_rt->slave == NULL)
+			break;
+
+		list_for_each_entry(port_slv_rt,
+				&slv_rt->port_rt_list, port_node) {
+
+			/* Fill in port params here */
+			port_slv_rt->port_params.num = port_slv_rt->port_num;
+			port_slv_rt->port_params.word_length =
+				slv_rt->stream_params.bps;
+			/* Normal/Isochronous Mode */
+			port_slv_rt->port_params.port_flow_mode = 0x0;
+			/* Normal Mode */
+			port_slv_rt->port_params.port_data_mode = 0x0;
+			t_slv_params = &port_slv_rt->transport_params;
+			p_slv_params = &port_slv_rt->port_params;
+
+			/* Configure xport & port params for slave */
+			ret = sdw_cfg_slv_params(sdw_mstr_bs,
+					slv_rt, t_slv_params, p_slv_params);
+			if (ret < 0)
+				return ret;
+
+			/*
+			 * Since one port per slave runtime,
+			 * breaking port_list loop
+			 * TBD: to be extended for multiple port support
+			 */
+			break;
+		}
+	}
+
+
+	list_for_each_entry(port_rt,
+			&sdw_mstr_bs_rt->port_rt_list, port_node) {
+
+		/* Transport and port parameters */
+		t_params = &port_rt->transport_params;
+		p_params = &port_rt->port_params;
+
+
+		p_params->num = port_rt->port_num;
+		p_params->word_length = sdw_mstr_bs_rt->stream_params.bps;
+		p_params->port_flow_mode = 0x0; /* Normal/Isochronous Mode */
+		p_params->port_data_mode = 0x0; /* Normal Mode */
+
+		/* Configure xport params and port params for master */
+		ret = sdw_cfg_mstr_params(sdw_mstr_bs, t_params, p_params);
+		if (ret < 0)
+			return ret;
+
+		/* Since one port per slave runtime, breaking port_list loop
+		 * TBD: to be extended for multiple port support
+		 */
+		break;
+	}
+
+	return 0;
+}
+
+
+/*
+ * sdw_cfg_slv_enable_disable - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function enable/disable slave port channels.
+ */
+int sdw_cfg_slv_enable_disable(struct sdw_bus *mstr_bs,
+	struct sdw_slave_runtime *slv_rt_strm,
+	struct sdw_port_runtime *port_slv_strm,
+	struct port_chn_en_state *chn_en)
+{
+	struct sdw_msg wr_msg, rd_msg;
+	int ret = 0;
+	int banktouse;
+	u8 wbuf[1] = {0};
+	u8 rbuf[1] = {0};
+
+	/* Get current bank in use from bus structure*/
+	banktouse = mstr_bs->active_bank;
+	if ((chn_en->is_activate) || (chn_en->is_bank_sw))
+		banktouse = !banktouse;
+
+	rd_msg.addr = wr_msg.addr = ((SDW_DPN_CHANNELEN +
+				(SDW_BANK1_REGISTER_OFFSET * banktouse)) +
+			(SDW_NUM_DATA_PORT_REGISTERS *
+			 port_slv_strm->port_num));
+
+	rd_msg.ssp_tag = 0x0;
+	rd_msg.flag = SDW_MSG_FLAG_READ;
+	rd_msg.len = 1;
+	rd_msg.slave_addr = slv_rt_strm->slave->slv_number;
+	rd_msg.buf = rbuf;
+	rd_msg.addr_page1 = 0x0;
+	rd_msg.addr_page2 = 0x0;
+
+	wr_msg.ssp_tag = 0x0;
+	wr_msg.flag = SDW_MSG_FLAG_WRITE;
+	wr_msg.len = 1;
+	wr_msg.slave_addr = slv_rt_strm->slave->slv_number;
+	wr_msg.buf = wbuf;
+	wr_msg.addr_page1 = 0x0;
+	wr_msg.addr_page2 = 0x0;
+
+
+	if (chn_en->is_activate) {
+
+		/*
+		 * 1. slave port enable_ch_pre
+		 * --> callback
+		 * --> no callback available
+		 */
+
+		/* 2. slave port enable */
+		ret = sdw_slave_transfer(mstr_bs->mstr, &rd_msg, 1);
+		if (ret != 1) {
+			ret = -EINVAL;
+			dev_err(&mstr_bs->mstr->dev,
+					"Register transfer failed\n");
+			goto out;
+		}
+
+		wbuf[0] = (rbuf[0] | port_slv_strm->channel_mask);
+
+		ret = sdw_slave_transfer(mstr_bs->mstr, &wr_msg, 1);
+		if (ret != 1) {
+			ret = -EINVAL;
+			dev_err(&mstr_bs->mstr->dev,
+					"Register transfer failed\n");
+			goto out;
+		}
+
+		rbuf[0] = 0;
+		ret = sdw_slave_transfer(mstr_bs->mstr, &rd_msg, 1);
+		if (ret != 1) {
+			ret = -EINVAL;
+			dev_err(&mstr_bs->mstr->dev,
+					"Register transfer failed\n");
+			goto out;
+		}
+
+		/*
+		 * 3. slave port enable post pre
+		 * --> callback
+		 * --> no callback available
+		 */
+		slv_rt_strm->rt_state = SDW_STATE_ENABLE_RT;
+
+	} else {
+
+		/*
+		 * 1. slave port enable_ch_unpre
+		 * --> callback
+		 * --> no callback available
+		 */
+
+		/* 2. slave port disable */
+		ret = sdw_slave_transfer(mstr_bs->mstr, &rd_msg, 1);
+		if (ret != 1) {
+			ret = -EINVAL;
+			dev_err(&mstr_bs->mstr->dev,
+					"Register transfer failed\n");
+			goto out;
+		}
+
+		wbuf[0] = (rbuf[0] & ~(port_slv_strm->channel_mask));
+
+		ret = sdw_slave_transfer(mstr_bs->mstr, &wr_msg, 1);
+		if (ret != 1) {
+			ret = -EINVAL;
+			dev_err(&mstr_bs->mstr->dev,
+					"Register transfer failed\n");
+			goto out;
+		}
+
+		rbuf[0] = 0;
+		ret = sdw_slave_transfer(mstr_bs->mstr, &rd_msg, 1);
+		if (ret != 1) {
+			ret = -EINVAL;
+			dev_err(&mstr_bs->mstr->dev,
+					"Register transfer failed\n");
+			goto out;
+		}
+
+		/*
+		 * 3. slave port enable post unpre
+		 * --> callback
+		 * --> no callback available
+		 */
+		if (!chn_en->is_bank_sw)
+			slv_rt_strm->rt_state = SDW_STATE_DISABLE_RT;
+
+	}
+
+out:
+	return ret;
+
+}
+
+
+/*
+ * sdw_cfg_mstr_activate_disable - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function enable/disable master port channels.
+ */
+int sdw_cfg_mstr_activate_disable(struct sdw_bus *mstr_bs,
+		struct sdw_mstr_runtime *mstr_rt_strm,
+		struct sdw_port_runtime *port_mstr_strm,
+		struct port_chn_en_state *chn_en)
+{
+	struct sdw_mstr_driver *ops = mstr_bs->mstr->driver;
+	struct sdw_activate_ch activate_ch;
+	int banktouse, ret = 0;
+
+	activate_ch.num = port_mstr_strm->port_num;
+	activate_ch.ch_mask = port_mstr_strm->channel_mask;
+	activate_ch.activate = chn_en->is_activate; /* Enable/Disable */
+
+	/* Get current bank in use from bus structure*/
+	banktouse = mstr_bs->active_bank;
+	if ((chn_en->is_activate) || (chn_en->is_bank_sw))
+		banktouse = !banktouse;
+
+
+	/* 1. Master port enable_ch_pre */
+	if (ops->mstr_port_ops->dpn_port_activate_ch_pre) {
+		ret = ops->mstr_port_ops->dpn_port_activate_ch_pre
+			(mstr_bs->mstr, &activate_ch, banktouse);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* 2. Master port enable */
+	if (ops->mstr_port_ops->dpn_port_activate_ch) {
+		ret = ops->mstr_port_ops->dpn_port_activate_ch(mstr_bs->mstr,
+				&activate_ch, banktouse);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* 3. Master port enable_ch_post */
+	if (ops->mstr_port_ops->dpn_port_activate_ch_post) {
+		ret = ops->mstr_port_ops->dpn_port_activate_ch_post
+			(mstr_bs->mstr, &activate_ch, banktouse);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (chn_en->is_activate)
+		mstr_rt_strm->rt_state = SDW_STATE_ENABLE_RT;
+	else if (!chn_en->is_bank_sw)
+		mstr_rt_strm->rt_state = SDW_STATE_DISABLE_RT;
+
+	return 0;
+}
+
+
+/*
+ * sdw_en_dis_mstr_slv - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function call master/slave enable/disable
+ * channel API's.
+ */
+int sdw_en_dis_mstr_slv(struct sdw_bus *sdw_mstr_bs,
+		struct sdw_runtime *sdw_rt, bool is_act)
+{
+	struct sdw_slave_runtime *slv_rt_strm = NULL;
+	struct sdw_port_runtime *port_slv_strm, *port_mstr_strm;
+	struct sdw_mstr_runtime *mstr_rt_strm = NULL;
+	struct port_chn_en_state chn_en;
+	int ret = 0;
+
+	if (is_act)
+		chn_en.is_bank_sw = true;
+	else
+		chn_en.is_bank_sw = false;
+
+	chn_en.is_activate = is_act;
+
+	list_for_each_entry(slv_rt_strm, &sdw_rt->slv_rt_list, slave_sdw_node) {
+
+		if (slv_rt_strm->slave == NULL)
+			break;
+
+		list_for_each_entry(port_slv_strm,
+				&slv_rt_strm->port_rt_list, port_node) {
+
+			ret = sdw_cfg_slv_enable_disable
+				(sdw_mstr_bs, slv_rt_strm,
+					port_slv_strm, &chn_en);
+			if (ret < 0)
+				return ret;
+
+			/*
+			 * Since one port per slave runtime,
+			 * breaking port_list loop
+			 * TBD: to be extended for multiple port support
+			 */
+			break;
+
+		}
+
+		break;
+
+	}
+
+	list_for_each_entry(mstr_rt_strm,
+			&sdw_rt->mstr_rt_list, mstr_sdw_node) {
+
+		if (mstr_rt_strm->mstr == NULL)
+			break;
+
+		list_for_each_entry(port_mstr_strm,
+			&mstr_rt_strm->port_rt_list, port_node) {
+
+			ret = sdw_cfg_mstr_activate_disable
+				(sdw_mstr_bs, mstr_rt_strm,
+				port_mstr_strm, &chn_en);
+			if (ret < 0)
+				return ret;
+
+			/*
+			 * Since one port per master runtime,
+			 * breaking port_list loop
+			 * TBD: to be extended for multiple port support
+			 */
+			break;
+
+		}
+
+	}
+
+	return 0;
+}
+
+
+/*
+ * sdw_en_dis_mstr_slv_state - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function call master/slave enable/disable
+ * channel API's based on runtime state.
+ */
+int sdw_en_dis_mstr_slv_state(struct sdw_bus *sdw_mstr_bs,
+	struct sdw_mstr_runtime *sdw_mstr_bs_rt,
+	struct port_chn_en_state *chn_en)
+{
+	struct sdw_slave_runtime *slv_rt = NULL;
+	struct sdw_port_runtime *port_slv_rt, *port_rt;
+	int ret = 0;
+
+	list_for_each_entry(slv_rt, &sdw_mstr_bs_rt->slv_rt_list, slave_node)  {
+
+		if (slv_rt->slave == NULL)
+			break;
+
+		if (slv_rt->rt_state == SDW_STATE_ENABLE_RT) {
+
+			list_for_each_entry(port_slv_rt,
+				&slv_rt->port_rt_list, port_node) {
+
+				ret = sdw_cfg_slv_enable_disable
+					(sdw_mstr_bs, slv_rt,
+					port_slv_rt, chn_en);
+				if (ret < 0)
+					return ret;
+
+				/*
+				 * Since one port per slave runtime,
+				 * breaking port_list loop
+				 * TBD: to be extended for multiple
+				 * port support
+				 */
+				break;
+			}
+		}
+	}
+
+	if (sdw_mstr_bs_rt->rt_state == SDW_STATE_ENABLE_RT) {
+
+		list_for_each_entry(port_rt,
+			&sdw_mstr_bs_rt->port_rt_list, port_node) {
+
+			ret = sdw_cfg_mstr_activate_disable
+				(sdw_mstr_bs, sdw_mstr_bs_rt, port_rt, chn_en);
+			if (ret < 0)
+				return ret;
+
+			/*
+			 * Since one port per master runtime,
+			 * breaking port_list loop
+			 * TBD: to be extended for multiple port support
+			 */
+
+			break;
+		}
+	}
+
+	return 0;
+}
+
+
+/*
+ * sdw_get_clock_frmshp - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function computes clock and frame shape based on
+ * clock frequency.
+ */
+int sdw_get_clock_frmshp(struct sdw_bus *sdw_mstr_bs, int *frame_int,
+		int *col, int *row)
+{
+	int i, rc, clock_reqd = 0, frame_interval = 0, frame_frequency = 0;
+	int sel_row = 0, sel_col = 0;
+	bool clock_ok = false;
+
+	/*
+	 * Find nearest clock frequency needed by master for
+	 * given bandwidth
+	 */
+
+	/*
+	 * TBD: Need to run efficient algorithm to make sure we have
+	 * only 1 to 10 percent of control bandwidth usage
+	 */
+	for (i = 0; i < MAXCLOCKFREQ; i++) {
+
+		/* TBD: Check why 3000 */
+		if ((clock_freq[i] <= sdw_mstr_bs->bandwidth) ||
+				((clock_freq[i] % 3000) != 0))
+			continue;
+		clock_reqd = clock_freq[i];
+
+		/*
+		 * TBD: Check all the slave device capabilities
+		 * here and find whether given frequency is
+		 * supported by all slaves
+		 */
+
+		/* Find frame shape based on bandwidth per controller */
+		/*
+		 * TBD: Need to run efficient algorithm to make sure we have
+		 * only 1 to 10 percent of control bandwidth usage
+		 */
+		for (rc = 0; rc <= MAX_NUM_ROW_COLS; rc++) {
+			frame_interval =
+				sdw_core.rowcolcomb[rc].row *
+				sdw_core.rowcolcomb[rc].col;
+			frame_frequency = clock_reqd/frame_interval;
+
+			if ((clock_reqd -
+						(frame_frequency *
+						 sdw_core.rowcolcomb[rc].
+						 control_bits)) <
+					sdw_mstr_bs->bandwidth)
+				continue;
+
+			break;
+		}
+
+		sel_row = sdw_core.rowcolcomb[rc].row;
+		sel_col = sdw_core.rowcolcomb[rc].col;
+		sdw_mstr_bs->frame_freq = frame_frequency;
+		sdw_mstr_bs->clk_freq = clock_reqd;
+		clock_ok = false;
+		*frame_int = frame_interval;
+		*col = sel_col;
+		*row = sel_row;
+		sdw_mstr_bs->col = sel_col;
+		sdw_mstr_bs->row = sel_row;
+
+		break;
+
+	}
+
+	return 0;
+}
+
+/*
+ * sdw_compute_sys_interval - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function computes system interval.
+ */
+int sdw_compute_sys_interval(struct sdw_bus *sdw_mstr_bs,
+		struct sdw_master_capabilities *sdw_mstr_cap,
+		int frame_interval)
+{
+	struct sdw_master *sdw_mstr = sdw_mstr_bs->mstr;
+	struct sdw_mstr_runtime *sdw_mstr_bs_rt;
+	struct sdw_transport_params *t_params;
+	struct sdw_port_runtime *port_rt;
+	int lcmnum1 = 0, lcmnum2 = 0, div = 0, lcm = 0;
+
+	/*
+	 * once you got bandwidth frame shape for bus,
+	 * run a loop for all the active streams running
+	 * on bus and compute sample_interval & other transport parameters.
+	 */
+	list_for_each_entry(sdw_mstr_bs_rt,
+			&sdw_mstr->mstr_rt_list, mstr_node) {
+
+		if (sdw_mstr_bs_rt->mstr == NULL)
+			break;
+
+		/* should not compute any transport params */
+		if (sdw_mstr_bs_rt->rt_state == SDW_STATE_UNPREPARE_RT)
+			continue;
+
+		list_for_each_entry(port_rt,
+				&sdw_mstr_bs_rt->port_rt_list, port_node) {
+
+			t_params = &port_rt->transport_params;
+
+			/*
+			 * Current Assumption:
+			 * One port per bus runtime structure
+			 */
+			/* Calculate sample interval */
+			t_params->sample_interval =
+				((sdw_mstr_bs->clk_freq/
+				  sdw_mstr_bs_rt->stream_params.rate) * 2);
+
+			/* Only BlockPerPort supported */
+			t_params->blockpackingmode = 0;
+			t_params->lanecontrol = 0;
+
+			/* Calculate LCM */
+			lcmnum2 = t_params->sample_interval;
+			if (!lcmnum1)
+				lcmnum1 = sdw_lcm(lcmnum2, lcmnum2);
+			else
+				lcmnum1 = sdw_lcm(lcmnum1, lcmnum2);
+
+			/*
+			 * Since one port per bus runtime, breaking
+			 *  port_list loop
+			 * TBD: to be extended for multiple port support
+			 */
+			break;
+
+		}
+	}
+
+
+	/* 6. compute system_interval */
+	if ((sdw_mstr_cap) && (sdw_mstr_bs->clk_freq)) {
+
+		div = ((sdw_mstr_cap->base_clk_freq * 2) /
+					sdw_mstr_bs->clk_freq);
+		lcm = sdw_lcm(lcmnum1, frame_interval);
+		sdw_mstr_bs->system_interval = (div  * lcm);
+
+	}
+
+	/*
+	 * Something went wrong, may be sdw_lcm value may be 0,
+	 * return error accordingly
+	 */
+	if (!sdw_mstr_bs->system_interval)
+		return -EINVAL;
+
+
+	return 0;
+}
+
+
+/*
+ * sdw_compute_hstart_hstop - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function computes hstart and hstop for running
+ * streams per master & slaves.
+ */
+int sdw_compute_hstart_hstop(struct sdw_bus *sdw_mstr_bs, int sel_col)
+{
+	struct sdw_master *sdw_mstr = sdw_mstr_bs->mstr;
+	struct sdw_mstr_runtime *sdw_mstr_bs_rt;
+	struct sdw_transport_params *t_params = NULL, *t_slv_params = NULL;
+	struct sdw_slave_runtime *slv_rt = NULL;
+	struct sdw_port_runtime *port_rt, *port_slv_rt;
+	int hstop = 0, hwidth = 0;
+	int payload_bw = 0, full_bw = 0, column_needed = 0;
+	bool hstop_flag = false;
+
+	/* Calculate hwidth, hstart and hstop */
+	list_for_each_entry(sdw_mstr_bs_rt,
+			&sdw_mstr->mstr_rt_list, mstr_node) {
+
+		if (sdw_mstr_bs_rt->mstr == NULL)
+			break;
+
+		/* should not compute any transport params */
+		if (sdw_mstr_bs_rt->rt_state == SDW_STATE_UNPREPARE_RT)
+			continue;
+
+		list_for_each_entry(port_rt,
+				&sdw_mstr_bs_rt->port_rt_list, port_node) {
+
+			t_params = &port_rt->transport_params;
+			t_params->num = port_rt->port_num;
+
+			/*
+			 * 1. find full_bw and payload_bw per stream
+			 * 2. find h_width per stream
+			 * 3. find hstart, hstop, block_offset,sub_block_offset
+			 * Note: full_bw is nothing but sampling interval
+			 * of stream.
+			 * payload_bw is serving size no.
+			 * of channels * bps per stream
+			 */
+			full_bw = sdw_mstr_bs->clk_freq/
+				sdw_mstr_bs_rt->stream_params.rate;
+			payload_bw =
+				sdw_mstr_bs_rt->stream_params.bps *
+				sdw_mstr_bs_rt->stream_params.channel_count;
+
+			hwidth = (sel_col * payload_bw + full_bw - 1)/full_bw;
+			column_needed += hwidth;
+
+			/*
+			 * These needs to be done only for
+			 * 1st entry in link list
+			 */
+			if (!hstop_flag) {
+				hstop = sel_col - 1;
+				hstop_flag = true;
+			}
+
+			/* Assumption: Only block per port is supported
+			 * For blockperport:
+			 * offset1 value = LSB 8 bits of block_offset value
+			 * offset2 value = MSB 8 bits of block_offset value
+			 * For blockperchannel:
+			 * offset1 = LSB 8 bit of block_offset value
+			 * offset2 = MSB 8 bit of sub_block_offload value
+			 * if hstart and hstop of different streams in
+			 * master are different, then block_offset is zero.
+			 * if not then block_offset value for 2nd stream
+			 * is block_offset += payload_bw
+			 */
+
+			t_params->hstop = hstop;
+			t_params->hstart = hstop - hwidth + 1;
+
+
+			/*
+			 * TBD: perform this when you have 2 ports
+			 * and accordingly configure hstart hstop for slave
+			 * removing for now
+			 */
+#if 0
+			hstop = hstop - hwidth;
+#endif
+			/* Since one port per bus runtime,
+			 * breaking port_list loop
+			 * TBD: to be extended for multiple port support
+			 */
+			break;
+		}
+
+		/*
+		 * Run loop for slave_rt_list for given master_list
+		 * to compute hstart hstop for slave
+		 */
+		list_for_each_entry(slv_rt,
+				&sdw_mstr_bs_rt->slv_rt_list, slave_node)  {
+
+			if (slv_rt->slave == NULL)
+				break;
+
+			if (slv_rt->rt_state == SDW_STATE_UNPREPARE_RT)
+				continue;
+
+			list_for_each_entry(port_slv_rt,
+					&slv_rt->port_rt_list, port_node) {
+
+				t_slv_params = &port_slv_rt->transport_params;
+				t_slv_params->num = port_slv_rt->port_num;
+
+				/*
+				 * TBD: Needs to be verifid for
+				 * multiple combination
+				 * 1. 1 master port, 1 slave rt,
+				 * 1 port per slave rt -->
+				 * In this case, use hstart hstop same as master
+				 * for 1 slave rt
+				 * 2. 1 master port, 2 slave rt,
+				 * 1 port per slave rt -->
+				 * In this case, use hstart hstop same as master
+				 * for 2 slave rt
+				 * only offset will change for 2nd slave rt
+				 * Current assumption is one port per rt,
+				 * hence no multiple port combination
+				 * considered.
+				 */
+				t_slv_params->hstop = hstop;
+				t_slv_params->hstart = hstop - hwidth + 1;
+
+				/* Only BlockPerPort supported */
+				t_slv_params->blockpackingmode = 0;
+				t_slv_params->lanecontrol = 0;
+
+				/*
+				 * below copy needs to be changed when
+				 * more than one port is supported
+				 */
+				if (t_params)
+					t_slv_params->sample_interval =
+						t_params->sample_interval;
+
+				/* Since one port per slave runtime,
+				 * breaking port_list loop
+				 * TBD: to be extended for multiple
+				 * port support
+				 */
+				break;
+			}
+
+		}
+	}
+
+#if 0
+	/* TBD: To be verified */
+	if  (column_needed > sel_col - 1)
+		return -EINVAL; /* Error case, check what has gone wrong */
+#endif
+
+	return 0;
+}
+
+
+/*
+ * sdw_compute_blk_subblk_offset - returns Success
+ *
+ *
+ * This function computes block offset and sub block
+ * offset for running streams per master & slaves.
+ */
+int sdw_compute_blk_subblk_offset(struct sdw_bus *sdw_mstr_bs)
+{
+	struct sdw_master *sdw_mstr = sdw_mstr_bs->mstr;
+	struct sdw_mstr_runtime *sdw_mstr_bs_rt;
+	struct sdw_transport_params *t_params, *t_slv_params;
+	struct sdw_slave_runtime *slv_rt = NULL;
+	struct sdw_port_runtime *port_rt, *port_slv_rt;
+	int hstart1 = 0, hstop1 = 0, hstart2 = 0, hstop2 = 0;
+	int block_offset = 1;
+
+
+	/* Calculate block_offset and subblock_offset */
+	list_for_each_entry(sdw_mstr_bs_rt,
+			&sdw_mstr->mstr_rt_list, mstr_node) {
+
+		if (sdw_mstr_bs_rt->mstr == NULL)
+			break;
+
+		/* should not compute any transport params */
+		if (sdw_mstr_bs_rt->rt_state == SDW_STATE_UNPREPARE_RT)
+			continue;
+
+		list_for_each_entry(port_rt,
+				&sdw_mstr_bs_rt->port_rt_list, port_node) {
+
+			t_params = &port_rt->transport_params;
+
+
+			if ((!hstart2) && (!hstop2)) {
+				hstart1 = hstart2 = t_params->hstart;
+				hstop1  = hstop2 = t_params->hstop;
+				/* TBD: Verify this condition */
+				block_offset = 0;
+			} else {
+
+				hstart1 = t_params->hstart;
+				hstop1 = t_params->hstop;
+
+				/* hstart/stop not same */
+				if ((hstart1 != hstart2) &&
+					(hstop1 != hstop2)) {
+					/* TBD: Harcoding to 0, to be removed*/
+					block_offset = 0;
+				} else {
+					/* TBD: Harcoding to 0, to be removed*/
+					block_offset = 0;
+				}
+
+#if 0
+				if ((hstart1 != hstart2) &&
+					(hstop1 != hstop2)) {
+					block_offset = 1;
+				} else {
+					block_offset +=
+						(sdw_mstr_bs_rt->stream_params.
+						bps
+						*
+						sdw_mstr_bs_rt->stream_params.
+						channel_count);
+				}
+#endif
+
+			}
+
+
+			/*
+			 * TBD: Hardcding block control group as true,
+			 * to be changed later
+			 */
+			t_params->blockgroupcontrol_valid = true;
+			t_params->blockgroupcontrol = 0x0; /* Hardcoding to 0 */
+
+			/*
+			 * Since one port per bus runtime,
+			 * breaking port_list loop
+			 * TBD: to be extended for multiple port support
+			 */
+			break;
+		}
+
+		/*
+		 * Run loop for slave_rt_list for given master_list
+		 * to compute block and sub block offset for slave
+		 */
+		list_for_each_entry(slv_rt,
+				&sdw_mstr_bs_rt->slv_rt_list, slave_node)  {
+
+			if (slv_rt->slave == NULL)
+				break;
+
+			if (slv_rt->rt_state == SDW_STATE_UNPREPARE_RT)
+				continue;
+
+			list_for_each_entry(port_slv_rt,
+					&slv_rt->port_rt_list, port_node) {
+
+				t_slv_params = &port_slv_rt->transport_params;
+
+				/*
+				 * TBD: Needs to be verifid for
+				 * multiple combination
+				 * 1. 1 master port, 1 slave rt,
+				 * 1 port per slave rt -->
+				 * In this case, use block_offset same as
+				 * master for 1 slave rt
+				 * 2. 1 master port, 2 slave rt,
+				 * 1 port per slave rt -->
+				 * In this case, use block_offset same as
+				 * master for 1st slave rt and compute for 2nd.
+				 */
+
+				/*
+				 * Current assumption is one port per rt,
+				 * hence no multiple port combination.
+				 * TBD: block offset to be computed for
+				 * more than 1 slave_rt list.
+				 */
+				t_slv_params->offset1 = block_offset;
+				t_slv_params->offset2 = block_offset >> 8;
+
+
+				/*
+				 * TBD: Hardcding block control group as true,
+				 * to be changed later
+				 */
+				t_slv_params->blockgroupcontrol_valid = true;
+				/* Hardcoding to 0 */
+				t_slv_params->blockgroupcontrol = 0x0;
+				/* Since one port per slave runtime,
+				 * breaking port_list loop
+				 * TBD:to be extended for multiple port support
+				 */
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+/*
+ * sdw_configure_frmshp_bnkswtch - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function broadcast frameshape on framectrl
+ * register and performs bank switch.
+ */
+int sdw_configure_frmshp_bnkswtch(struct sdw_bus *mstr_bs, int col, int row)
+{
+	struct sdw_msg wr_msg;
+	int ret = 0;
+	int banktouse, numcol, numrow;
+	u8 wbuf[1] = {0};
+
+	numcol = sdw_get_col_to_num(col);
+	numrow = sdw_get_row_to_num(row);
+
+	wbuf[0] = numcol | (numrow << 3);
+	/* Get current bank in use from bus structure*/
+	banktouse = mstr_bs->active_bank;
+	banktouse = !banktouse;
+
+	if (banktouse) {
+		wr_msg.addr = (SDW_SCP_FRAMECTRL + SDW_BANK1_REGISTER_OFFSET) +
+			(SDW_NUM_DATA_PORT_REGISTERS * 0); /* Data port 0 */
+	} else {
+
+		wr_msg.addr = SDW_SCP_FRAMECTRL +
+			(SDW_NUM_DATA_PORT_REGISTERS * 0); /* Data port 0 */
+	}
+
+	wr_msg.ssp_tag = 0x1;
+	wr_msg.flag = SDW_MSG_FLAG_WRITE;
+	wr_msg.len = 1;
+	wr_msg.slave_addr = 0xF; /* Broadcast address*/
+	wr_msg.buf = wbuf;
+	wr_msg.addr_page1 = 0x0;
+	wr_msg.addr_page2 = 0x0;
+
+
+	ret = sdw_slave_transfer(mstr_bs->mstr, &wr_msg, 1);
+	if (ret != 1) {
+		ret = -EINVAL;
+		dev_err(&mstr_bs->mstr->dev, "Register transfer failed\n");
+		goto out;
+	}
+
+	msleep(100); /* TBD: Remove this */
+
+	/*
+	 * TBD: check whether we need to poll on
+	 * mcp active bank bit to switch bank
+	 */
+	mstr_bs->active_bank = banktouse;
+
+out:
+
+	return ret;
+}
+
+
+/*
+ * sdw_cfg_bs_params - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function performs master/slave transport
+ * params config, set SSP interval, set Clock
+ * frequency, enable channel. This API is called
+ * from sdw_bus_calc_bw & sdw_bus_calc_bw_dis API.
+ *
+ */
+int sdw_cfg_bs_params(struct sdw_bus *sdw_mstr_bs,
+		struct sdw_mstr_runtime *sdw_mstr_bs_rt,
+		bool is_strm_cpy)
+{
+	struct port_chn_en_state chn_en;
+	struct sdw_master *sdw_mstr = sdw_mstr_bs->mstr;
+	struct sdw_mstr_driver *ops;
+	int banktouse, ret = 0;
+
+	list_for_each_entry(sdw_mstr_bs_rt,
+		&sdw_mstr->mstr_rt_list, mstr_node) {
+
+		if (sdw_mstr_bs_rt->mstr == NULL)
+			continue;
+
+		if (is_strm_cpy) {
+			/*
+			 * Configure and enable all slave
+			 * transport params first
+			 */
+			ret = sdw_cfg_mstr_slv(sdw_mstr_bs,
+				sdw_mstr_bs_rt, false);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+					"slave config params failed\n");
+				return ret;
+			}
+
+			/* Configure and enable all master params */
+			ret = sdw_cfg_mstr_slv(sdw_mstr_bs,
+				sdw_mstr_bs_rt, true);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+					"master config params failed\n");
+				return ret;
+			}
+
+		} else {
+
+			/*
+			 * 7.1 Copy all slave transport and port params
+			 * to alternate bank
+			 * 7.2 copy all master transport and port params
+			 * to alternate bank
+			 */
+			ret = sdw_cpy_params_mstr_slv(sdw_mstr_bs,
+				sdw_mstr_bs_rt);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+					"slave/master copy params failed\n");
+				return ret;
+			}
+		}
+
+		/* Get master driver ops */
+		ops = sdw_mstr_bs->mstr->driver;
+
+		/* Configure SSP */
+		banktouse = sdw_mstr_bs->active_bank;
+		banktouse = !banktouse;
+
+		/*
+		 * TBD: Currently harcoded SSP interval to 24,
+		 * computed value to be taken from system_interval in
+		 * bus data structure.
+		 * Add error check.
+		 */
+		if (ops->mstr_ops->set_ssp_interval)
+			ops->mstr_ops->set_ssp_interval(sdw_mstr_bs->mstr,
+					24, banktouse); /* hardcoding to 24 */
+		/*
+		 * Configure Clock
+		 * TBD: Add error check
+		 */
+		if (ops->mstr_ops->set_clock_freq)
+			ops->mstr_ops->set_clock_freq(sdw_mstr_bs->mstr,
+					sdw_mstr_bs->clk_freq, banktouse);
+
+		/* Enable channel on alternate bank for running streams */
+		chn_en.is_activate = true;
+		chn_en.is_bank_sw = true;
+		ret = sdw_en_dis_mstr_slv_state
+				(sdw_mstr_bs, sdw_mstr_bs_rt, &chn_en);
+		if (ret < 0) {
+			/* TBD: Undo all the computation */
+			dev_err(&sdw_mstr_bs->mstr->dev,
+					"Channel enable failed\n");
+			return ret;
+		}
+
+	}
+
+	return 0;
+}
+
+/*
+ * sdw_dis_chan - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function disables channel on alternate
+ * bank. This API is called from sdw_bus_calc_bw
+ * & sdw_bus_calc_bw_dis when channel on current
+ * bank is enabled.
+ *
+ */
+int sdw_dis_chan(struct sdw_bus *sdw_mstr_bs,
+	struct sdw_mstr_runtime *sdw_mstr_bs_rt)
+{
+	struct sdw_master *sdw_mstr = sdw_mstr_bs->mstr;
+	struct port_chn_en_state chn_en;
+	int ret = 0;
+
+	list_for_each_entry(sdw_mstr_bs_rt,
+			&sdw_mstr->mstr_rt_list, mstr_node) {
+
+		if (sdw_mstr_bs_rt->mstr == NULL)
+			continue;
+
+		chn_en.is_activate = false;
+		chn_en.is_bank_sw = true;
+		ret = sdw_en_dis_mstr_slv_state(sdw_mstr_bs,
+				sdw_mstr_bs_rt, &chn_en);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+
+/*
+ * sdw_cfg_slv_prep_unprep - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function prepare/unprepare slave ports.
+ */
+int sdw_cfg_slv_prep_unprep(struct sdw_bus *mstr_bs,
+	struct sdw_slave_runtime *slv_rt_strm,
+	struct sdw_port_runtime *port_slv_strm,
+	bool prep)
+{
+	struct sdw_slave_driver	*slv_ops = slv_rt_strm->slave->driver;
+	struct sdw_slv_capabilities *slv_cap =
+			&slv_rt_strm->slave->sdw_slv_cap;
+	struct sdw_slv_dpn_capabilities *sdw_slv_dpn_cap =
+			slv_cap->sdw_dpn_cap;
+
+	struct sdw_msg wr_msg, rd_msg, rd_msg1;
+	int ret = 0;
+	int banktouse;
+	u8 wbuf[1] = {0};
+	u8 rbuf[1] = {0};
+	u8 rbuf1[1] = {0};
+
+	/* Get current bank in use from bus structure*/
+	banktouse = mstr_bs->active_bank;
+	banktouse = !banktouse;
+
+	/* Read SDW_DPN_PREPARECTRL register */
+	rd_msg.addr = wr_msg.addr = SDW_DPN_PREPARECTRL +
+		(SDW_NUM_DATA_PORT_REGISTERS * port_slv_strm->port_num);
+
+	rd_msg.ssp_tag = 0x0;
+	rd_msg.flag = SDW_MSG_FLAG_READ;
+	rd_msg.len = 1;
+	rd_msg.slave_addr = slv_rt_strm->slave->slv_number;
+	rd_msg.buf = rbuf;
+	rd_msg.addr_page1 = 0x0;
+	rd_msg.addr_page2 = 0x0;
+
+	rd_msg1.ssp_tag = 0x0;
+	rd_msg1.flag = SDW_MSG_FLAG_READ;
+	rd_msg1.len = 1;
+	rd_msg1.slave_addr = slv_rt_strm->slave->slv_number;
+	rd_msg1.buf = rbuf1;
+	rd_msg1.addr_page1 = 0x0;
+	rd_msg1.addr_page2 = 0x0;
+
+
+	rd_msg1.addr = SDW_DPN_PREPARESTATUS +
+		(SDW_NUM_DATA_PORT_REGISTERS * port_slv_strm->port_num);
+
+	wr_msg.ssp_tag = 0x0;
+	wr_msg.flag = SDW_MSG_FLAG_WRITE;
+	wr_msg.len = 1;
+	wr_msg.slave_addr = slv_rt_strm->slave->slv_number;
+	wr_msg.buf = wbuf;
+	wr_msg.addr_page1 = 0x0;
+	wr_msg.addr_page2 = 0x0;
+
+
+	if (prep) { /* PREPARE */
+
+		/*
+		 * 1. slave port prepare_ch_pre
+		 * --> callback
+		 * --> handle_pre_port_prepare
+		 */
+		if (slv_ops->handle_pre_port_prepare) {
+			slv_ops->handle_pre_port_prepare(slv_rt_strm->slave,
+					port_slv_strm->port_num,
+					port_slv_strm->channel_mask,
+					banktouse);
+		}
+
+		/* 2. slave port prepare --> to write */
+		if (sdw_slv_dpn_cap->prepare_ch) {
+
+			/* NON SIMPLIFIED CM, prepare required */
+			ret = sdw_slave_transfer(mstr_bs->mstr, &rd_msg, 1);
+			if (ret != 1) {
+				ret = -EINVAL;
+				dev_err(&mstr_bs->mstr->dev,
+					"Register transfer failed\n");
+				goto out;
+			}
+
+			ret = sdw_slave_transfer(mstr_bs->mstr, &rd_msg1, 1);
+			if (ret != 1) {
+				ret = -EINVAL;
+				dev_err(&mstr_bs->mstr->dev,
+						"Register transfer failed\n");
+				goto out;
+			}
+
+			wbuf[0] = (rbuf[0] | port_slv_strm->channel_mask);
+
+			/*
+			 * TBD: poll for prepare interrupt bit
+			 * before calling post_prepare
+			 * 2. check capabilities if simplified
+			 * CM no need to prepare
+			 */
+			ret = sdw_slave_transfer(mstr_bs->mstr, &wr_msg, 1);
+			if (ret != 1) {
+				ret = -EINVAL;
+				dev_err(&mstr_bs->mstr->dev,
+					"Register transfer failed\n");
+				goto out;
+			}
+
+			/*
+			 * TBD: check on port ready,
+			 * ideally we should check on prepare
+			 * status for port_ready
+			 */
+
+			/* wait for completion on port ready*/
+			msleep(100); /* TBD: Remove this */
+
+			ret = sdw_slave_transfer(mstr_bs->mstr, &rd_msg1, 1);
+			if (ret != 1) {
+				ret = -EINVAL;
+				dev_err(&mstr_bs->mstr->dev,
+					"Register transfer failed\n");
+				goto out;
+			}
+		}
+
+		/*
+		 * 3. slave port post pre
+		 * --> callback
+		 * --> handle_post_port_prepare
+		 */
+		if (slv_ops->handle_post_port_prepare) {
+			slv_ops->handle_post_port_prepare
+				(slv_rt_strm->slave,
+				port_slv_strm->port_num,
+				port_slv_strm->channel_mask, banktouse);
+		}
+
+		slv_rt_strm->rt_state = SDW_STATE_PREPARE_RT;
+
+	} else {
+		/* UNPREPARE */
+		/*
+		 * 1. slave port unprepare_ch_pre
+		 * --> callback
+		 * --> handle_pre_port_prepare
+		 */
+		if (slv_ops->handle_pre_port_unprepare) {
+			slv_ops->handle_pre_port_unprepare(slv_rt_strm->slave,
+						port_slv_strm->port_num,
+						port_slv_strm->channel_mask,
+						banktouse);
+		}
+
+		/* 2. slave port unprepare --> to write */
+		if (sdw_slv_dpn_cap->prepare_ch) {
+
+			/* NON SIMPLIFIED CM, unprepare required */
+
+			/* Read SDW_DPN_PREPARECTRL register */
+			ret = sdw_slave_transfer(mstr_bs->mstr, &rd_msg, 1);
+			if (ret != 1) {
+				ret = -EINVAL;
+				dev_err(&mstr_bs->mstr->dev,
+					"Register transfer failed\n");
+				goto out;
+			}
+
+			wbuf[0] = (rbuf[0] & ~(port_slv_strm->channel_mask));
+
+			/*
+			 * TBD: poll for prepare interrupt bit before
+			 * calling post_prepare
+			 * Does it apply for unprepare aswell?
+			 * 2. check capabilities if simplified CM
+			 * no need to unprepare
+			 */
+			ret = sdw_slave_transfer(mstr_bs->mstr, &wr_msg, 1);
+			if (ret != 1) {
+				ret = -EINVAL;
+				dev_err(&mstr_bs->mstr->dev,
+					"Register transfer failed\n");
+				goto out;
+			}
+		}
+
+		/*
+		 * 3. slave port post unpre
+		 * --> callback
+		 * --> handle_post_port_unprepare
+		 */
+		if (slv_ops->handle_post_port_unprepare) {
+			slv_ops->handle_post_port_unprepare(slv_rt_strm->slave,
+					port_slv_strm->port_num,
+					port_slv_strm->channel_mask,
+					banktouse);
+		}
+
+		slv_rt_strm->rt_state = SDW_STATE_UNPREPARE_RT;
+	}
+out:
+	return ret;
+
+}
+
+
+/*
+ * sdw_cfg_mstr_prep_unprep - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function prepare/unprepare master ports.
+ */
+int sdw_cfg_mstr_prep_unprep(struct sdw_bus *mstr_bs,
+	struct sdw_mstr_runtime *mstr_rt_strm,
+	struct sdw_port_runtime *port_mstr_strm,
+	bool prep)
+{
+	struct sdw_mstr_driver *ops = mstr_bs->mstr->driver;
+	struct sdw_prepare_ch prep_ch;
+	int ret = 0;
+
+	prep_ch.num = port_mstr_strm->port_num;
+	prep_ch.ch_mask = port_mstr_strm->channel_mask;
+	prep_ch.prepare = prep; /* Prepare/Unprepare */
+
+	/* TBD: Bank configuration */
+
+	/* 1. Master port prepare_ch_pre */
+	if (ops->mstr_port_ops->dpn_port_prepare_ch_pre) {
+		ret = ops->mstr_port_ops->dpn_port_prepare_ch_pre
+				(mstr_bs->mstr, &prep_ch);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* 2. Master port prepare */
+	if (ops->mstr_port_ops->dpn_port_prepare_ch) {
+		ret = ops->mstr_port_ops->dpn_port_prepare_ch
+				(mstr_bs->mstr, &prep_ch);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* 3. Master port prepare_ch_post */
+	if (ops->mstr_port_ops->dpn_port_prepare_ch_post) {
+		ret = ops->mstr_port_ops->dpn_port_prepare_ch_post
+				(mstr_bs->mstr, &prep_ch);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (prep)
+		mstr_rt_strm->rt_state = SDW_STATE_PREPARE_RT;
+	else
+		mstr_rt_strm->rt_state = SDW_STATE_UNPREPARE_RT;
+
+	return 0;
+}
+
+
+/*
+ * sdw_prep_unprep_mstr_slv - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function call master/slave prepare/unprepare
+ * port configuration API's, called from sdw_bus_calc_bw
+ * & sdw_bus_calc_bw_dis API's.
+ */
+int sdw_prep_unprep_mstr_slv(struct sdw_bus *sdw_mstr_bs,
+		struct sdw_runtime *sdw_rt, bool is_prep)
+{
+	struct sdw_slave_runtime *slv_rt_strm = NULL;
+	struct sdw_port_runtime *port_slv_strm, *port_mstr_strm;
+	struct sdw_mstr_runtime *mstr_rt_strm = NULL;
+	int ret = 0;
+
+	list_for_each_entry(slv_rt_strm,
+			&sdw_rt->slv_rt_list, slave_sdw_node) {
+
+		if (slv_rt_strm->slave == NULL)
+			break;
+
+		list_for_each_entry(port_slv_strm,
+				&slv_rt_strm->port_rt_list, port_node) {
+
+			ret = sdw_cfg_slv_prep_unprep(sdw_mstr_bs,
+					slv_rt_strm, port_slv_strm, is_prep);
+			if (ret < 0)
+				return ret;
+
+			/* Since one port per slave runtime,
+			 * breaking port_list loop
+			 * TBD: to be extended for multiple port support
+			 */
+			break;
+		}
+
+		break;
+	}
+
+	list_for_each_entry(mstr_rt_strm,
+			&sdw_rt->mstr_rt_list, mstr_sdw_node) {
+
+		if (mstr_rt_strm->mstr == NULL)
+			break;
+
+		list_for_each_entry(port_mstr_strm,
+			&mstr_rt_strm->port_rt_list, port_node) {
+
+			ret = sdw_cfg_mstr_prep_unprep(sdw_mstr_bs,
+				mstr_rt_strm, port_mstr_strm, is_prep);
+			if (ret < 0)
+				return ret;
+
+			/* Since one port per master runtime,
+			 * breaking port_list loop
+			 * TBD: to be extended for multiple port support
+			 */
+			break;
+		}
+	}
+
+	return 0;
+}
+
+
+/**
+ * sdw_bus_calc_bw - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function is called from sdw_prepare_and_enable
+ * whenever new stream is processed. The function based
+ * on the stream associated with controller calculates
+ * required bandwidth, clock, frameshape, computes
+ * all transport params for a given port, enable channel
+ * & perform bankswitch.
+ */
+int sdw_bus_calc_bw(struct sdw_stream_tag *stream_tag, bool enable)
+{
+
+	struct sdw_runtime *sdw_rt = stream_tag->sdw_rt;
+	struct sdw_stream_params *stream_params = &sdw_rt->stream_params;
+	struct sdw_mstr_runtime *sdw_mstr_rt = NULL, *sdw_mstr_bs_rt = NULL;
+	struct sdw_bus *sdw_mstr_bs = NULL;
+	struct sdw_master *sdw_mstr = NULL;
+	struct sdw_master_capabilities *sdw_mstr_cap = NULL;
+	struct sdw_stream_params *mstr_params;
+	int stream_frame_size;
+	int frame_interval = 0, sel_row = 0, sel_col = 0;
+	int ret = 0;
+
+	/* TBD: Add PCM/PDM flag in sdw_config_stream */
+
+	/*
+	 * TBD: check for mstr_rt is in configured state or not
+	 * If yes, then configure masters as well
+	 * If no, then do not configure/enable master related parameters
+	 */
+
+	/* BW calulation for active master controller for given stream tag */
+	list_for_each_entry(sdw_mstr_rt, &sdw_rt->mstr_rt_list, mstr_sdw_node) {
+
+		if (sdw_mstr_rt->mstr == NULL)
+			break;
+
+		/* Get bus structure for master */
+		list_for_each_entry(sdw_mstr_bs, &sdw_core.bus_list, bus_node) {
+
+			/* Match master structure pointer */
+			if (sdw_mstr_bs->mstr != sdw_mstr_rt->mstr)
+				continue;
+
+
+			sdw_mstr = sdw_mstr_bs->mstr;
+			break;
+		}
+
+		/*
+		 * All data structures required available,
+		 * lets calculate BW for master controller
+		 */
+
+		/* Check for isochronous mode plus other checks if required */
+		sdw_mstr_cap = &sdw_mstr_bs->mstr->mstr_capabilities;
+		mstr_params = &sdw_mstr_rt->stream_params;
+
+		if ((sdw_rt->stream_state == SDW_STATE_CONFIG_STREAM) ||
+				(sdw_rt->stream_state ==
+					SDW_STATE_UNPREPARE_STREAM)) {
+
+			/* we do not support asynchronous mode Return Error */
+			if ((sdw_mstr_cap->base_clk_freq % mstr_params->rate)
+					!= 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"Asynchronous mode not supported\n");
+				return -EINVAL;
+			}
+
+			/* Check for sampling frequency */
+			if (stream_params->rate != mstr_params->rate) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"Sampling frequency mismatch\n");
+				return -EINVAL;
+			}
+
+			/*
+			 * Calculate stream bandwidth, frame size and
+			 * total BW required for master controller
+			 */
+			sdw_mstr_rt->stream_bw = mstr_params->rate *
+				mstr_params->channel_count * mstr_params->bps;
+			stream_frame_size = mstr_params->channel_count *
+				mstr_params->bps;
+
+			sdw_mstr_bs->bandwidth += sdw_mstr_rt->stream_bw;
+
+			ret = sdw_get_clock_frmshp(sdw_mstr_bs,
+					&frame_interval, &sel_col, &sel_row);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev, "clock/frameshape config failed\n");
+				return ret;
+			}
+
+
+			/*
+			 * TBD: find right place to run sorting on
+			 * master rt_list. Below sorting is done based on
+			 * bps from low to high, that means PDM streams
+			 * will be placed before PCM.
+			 */
+
+			/*
+			 * TBD Should we also perform sorting based on rate
+			 * for PCM stream check. if yes then how??
+			 * creating two different list.
+			 */
+
+			/* Compute system interval */
+			ret = sdw_compute_sys_interval(sdw_mstr_bs,
+					sdw_mstr_cap, frame_interval);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev, "compute system interval failed\n");
+				return ret;
+			}
+
+			/* Compute hstart/hstop */
+			ret = sdw_compute_hstart_hstop(sdw_mstr_bs, sel_col);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"compute hstart/hstop failed\n");
+				return ret;
+			}
+
+			/* Compute block offset */
+			ret = sdw_compute_blk_subblk_offset(sdw_mstr_bs);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(
+						&sdw_mstr_bs->mstr->dev,
+						"compute block offset failed\n");
+				return ret;
+			}
+
+			/* Change Stream State */
+			sdw_rt->stream_state = SDW_STATE_COMPUTE_STREAM;
+
+			/* Configure bus parameters */
+			ret = sdw_cfg_bs_params(sdw_mstr_bs,
+					sdw_mstr_bs_rt, true);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"xport params config failed\n");
+				return ret;
+			}
+
+			sel_col = sdw_mstr_bs->col;
+			sel_row = sdw_mstr_bs->row;
+
+			/* Configure Frame Shape/Switch Bank */
+			ret = sdw_configure_frmshp_bnkswtch(sdw_mstr_bs,
+					sel_col, sel_row);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"bank switch failed\n");
+				return ret;
+			}
+
+			/* Disable all channels enabled on previous bank */
+			ret = sdw_dis_chan(sdw_mstr_bs, sdw_mstr_bs_rt);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"Channel disabled failed\n");
+				return ret;
+			}
+
+			/* Prepare new port for master and slave */
+			ret = sdw_prep_unprep_mstr_slv(sdw_mstr_bs,
+					sdw_rt, true);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"Channel prepare failed\n");
+				return ret;
+			}
+
+			/* change stream state to prepare */
+			sdw_rt->stream_state = SDW_STATE_PREPARE_STREAM;
+		}
+
+		if ((enable) && (SDW_STATE_PREPARE_STREAM
+					== sdw_rt->stream_state)) {
+
+			ret = sdw_cfg_bs_params(sdw_mstr_bs,
+					sdw_mstr_bs_rt, false);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"xport params config failed\n");
+				return ret;
+			}
+
+			/* Enable new port for master and slave */
+			ret = sdw_en_dis_mstr_slv(sdw_mstr_bs, sdw_rt, true);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"Channel enable failed\n");
+				return ret;
+			}
+
+			/* change stream state to enable */
+			sdw_rt->stream_state = SDW_STATE_ENABLE_STREAM;
+
+			sel_col = sdw_mstr_bs->col;
+			sel_row = sdw_mstr_bs->row;
+
+			/* Configure Frame Shape/Switch Bank */
+			ret = sdw_configure_frmshp_bnkswtch(sdw_mstr_bs,
+					sel_col, sel_row);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"bank switch failed\n");
+				return ret;
+			}
+
+			/* Disable all channels enabled on previous bank */
+			ret = sdw_dis_chan(sdw_mstr_bs, sdw_mstr_bs_rt);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"Channel disabled faile\n");
+				return ret;
+			}
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sdw_bus_calc_bw);
+
+
+/**
+ * sdw_bus_calc_bw_dis - returns Success
+ * -EINVAL - In case of error.
+ *
+ *
+ * This function is called from sdw_disable_and_unprepare
+ * whenever stream is ended. The function based disables/
+ * unprepare port/channel of associated stream and computes
+ * required bandwidth, clock, frameshape, computes
+ * all transport params for a given port, enable channel
+ * & perform bankswitch for remaining streams on given
+ * controller.
+ */
+int sdw_bus_calc_bw_dis(struct sdw_stream_tag *stream_tag, bool unprepare)
+{
+	struct sdw_runtime *sdw_rt = stream_tag->sdw_rt;
+	struct sdw_mstr_runtime *sdw_mstr_rt = NULL, *sdw_mstr_bs_rt = NULL;
+	struct sdw_bus *sdw_mstr_bs = NULL;
+	struct sdw_master *sdw_mstr = NULL;
+	struct sdw_master_capabilities *sdw_mstr_cap = NULL;
+	struct sdw_stream_params *mstr_params;
+	int stream_frame_size;
+	int frame_interval = 0, sel_row = 0, sel_col = 0;
+	int ret = 0;
+
+
+	/* BW calulation for active master controller for given stream tag */
+	list_for_each_entry(sdw_mstr_rt, &sdw_rt->mstr_rt_list, mstr_sdw_node) {
+
+		if (sdw_mstr_rt->mstr == NULL)
+			break;
+
+		/* Get bus structure for master */
+		list_for_each_entry(sdw_mstr_bs, &sdw_core.bus_list, bus_node) {
+
+			/* Match master structure pointer */
+			if (sdw_mstr_bs->mstr != sdw_mstr_rt->mstr)
+				continue;
+
+
+			sdw_mstr = sdw_mstr_bs->mstr;
+			break;
+		}
+
+
+		sdw_mstr_cap = &sdw_mstr_bs->mstr->mstr_capabilities;
+		mstr_params = &sdw_mstr_rt->stream_params;
+
+		if (sdw_rt->stream_state == SDW_STATE_ENABLE_STREAM) {
+
+			/* Lets do disabling of port for stream to be freed */
+			list_for_each_entry(sdw_mstr_bs_rt,
+					&sdw_mstr->mstr_rt_list, mstr_node) {
+
+				if (sdw_mstr_bs_rt->mstr == NULL)
+					continue;
+
+				/*
+				 * Disable channel for slave and
+				 * master on current bank
+				 */
+				ret = sdw_en_dis_mstr_slv(sdw_mstr_bs,
+						sdw_rt, false);
+				if (ret < 0) {
+					/* TBD: Undo all the computation */
+					dev_err(&sdw_mstr_bs->mstr->dev,
+							"Channel dis failed\n");
+					return ret;
+				}
+
+				/* Change stream state to disable */
+				sdw_rt->stream_state = SDW_STATE_DISABLE_STREAM;
+			}
+
+			ret = sdw_cfg_bs_params(sdw_mstr_bs,
+					sdw_mstr_bs_rt, false);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"xport params config failed\n");
+				return ret;
+			}
+
+			sel_col = sdw_mstr_bs->col;
+			sel_row = sdw_mstr_bs->row;
+
+			/* Configure frame shape/Switch Bank  */
+			ret = sdw_configure_frmshp_bnkswtch(sdw_mstr_bs,
+					sel_col, sel_row);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"bank switch failed\n");
+				return ret;
+			}
+
+			/* Disable all channels enabled on previous bank */
+			ret = sdw_dis_chan(sdw_mstr_bs, sdw_mstr_bs_rt);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"Channel disabled failed\n");
+				return ret;
+			}
+		}
+
+		if ((unprepare) &&
+				(SDW_STATE_DISABLE_STREAM ==
+				 sdw_rt->stream_state)) {
+
+			/* 1. Un-prepare master and slave port */
+			list_for_each_entry(sdw_mstr_bs_rt,
+					&sdw_mstr->mstr_rt_list, mstr_node) {
+
+				if (sdw_mstr_bs_rt->mstr == NULL)
+					continue;
+
+				ret = sdw_prep_unprep_mstr_slv(sdw_mstr_bs,
+						sdw_rt, false);
+				if (ret < 0) {
+					/* TBD: Undo all the computation */
+					dev_err(&sdw_mstr_bs->mstr->dev,
+							"Chan unprep failed\n");
+					return ret;
+				}
+
+				/* change stream state to unprepare */
+				sdw_rt->stream_state =
+					SDW_STATE_UNPREPARE_STREAM;
+			}
+
+			/*
+			 * Calculate new bandwidth, frame size
+			 * and total BW required for master controller
+			 */
+			sdw_mstr_rt->stream_bw = mstr_params->rate *
+				mstr_params->channel_count * mstr_params->bps;
+			stream_frame_size = mstr_params->channel_count *
+				mstr_params->bps;
+
+			sdw_mstr_bs->bandwidth -= sdw_mstr_rt->stream_bw;
+
+			/* Something went wrong in bandwidth calulation */
+			if (sdw_mstr_bs->bandwidth < 0) {
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"BW calculation failed\n");
+				return -EINVAL;
+			}
+
+			if (!sdw_mstr_bs->bandwidth) {
+				/*
+				 * Last stream on master should
+				 * return successfully
+				 */
+				sdw_rt->stream_state =
+					SDW_STATE_UNCOMPUTE_STREAM;
+				return 0;
+			}
+
+			ret = sdw_get_clock_frmshp(sdw_mstr_bs,
+					&frame_interval, &sel_col, &sel_row);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"clock/frameshape failed\n");
+				return ret;
+			}
+
+			/* Compute new transport params for running streams */
+			/* No sorting required here */
+
+			/* Compute system interval */
+			ret = sdw_compute_sys_interval(sdw_mstr_bs,
+					sdw_mstr_cap, frame_interval);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"compute SI failed\n");
+				return ret;
+			}
+
+			/* Compute hstart/hstop */
+			ret = sdw_compute_hstart_hstop(sdw_mstr_bs, sel_col);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"compute hstart/hstop fail\n");
+				return ret;
+			}
+
+			/* Compute block offset */
+			ret = sdw_compute_blk_subblk_offset(sdw_mstr_bs);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"compute block offset failed\n");
+				return ret;
+			}
+
+			/* Configure bus params */
+			ret = sdw_cfg_bs_params(sdw_mstr_bs,
+					sdw_mstr_bs_rt, true);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"xport params config failed\n");
+				return ret;
+			}
+
+			/* Configure Frame Shape/Switch Bank */
+			ret = sdw_configure_frmshp_bnkswtch(sdw_mstr_bs,
+					sel_col, sel_row);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"bank switch failed\n");
+				return ret;
+			}
+
+			/* Change stream state to uncompute */
+			sdw_rt->stream_state = SDW_STATE_UNCOMPUTE_STREAM;
+
+			/* Disable all channels enabled on previous bank */
+			ret = sdw_dis_chan(sdw_mstr_bs, sdw_mstr_bs_rt);
+			if (ret < 0) {
+				/* TBD: Undo all the computation */
+				dev_err(&sdw_mstr_bs->mstr->dev,
+						"Channel disabled failed\n");
+				return ret;
+			}
+		}
+
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sdw_bus_calc_bw_dis);
diff --git a/drivers/sdw/sdw_cnl.c b/drivers/sdw/sdw_cnl.c
new file mode 100644
index 000000000000..3f3317a6707a
--- /dev/null
+++ b/drivers/sdw/sdw_cnl.c
@@ -0,0 +1,1583 @@
+/*
+ *  sdw_cnl.c - Intel SoundWire master controller driver implementation.
+ *
+ *  Copyright (C) 2015-2016 Intel Corp
+ *  Author:  Hardik T Shah <hardik.t.shah@intel.com>
+ *
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/ctype.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/completion.h>
+#include <linux/idr.h>
+#include <linux/rtmutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/pm.h>
+#include <linux/mod_devicetable.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#include <linux/debugfs.h>
+#include <linux/sdw_bus.h>
+#include <linux/sdw/sdw_registers.h>
+#include <linux/sdw/sdw_cnl.h>
+#include "sdw_cnl_priv.h"
+
+static inline int cnl_sdw_reg_readl(void __iomem *base, int offset)
+{
+	int value;
+
+	value = readl(base + offset);
+	return value;
+}
+
+static inline void cnl_sdw_reg_writel(void __iomem *base, int offset, int value)
+{
+	writel(value, base + offset);
+}
+
+static inline u16 cnl_sdw_reg_readw(void __iomem *base, int offset)
+{
+	int value;
+
+	value = readw(base + offset);
+	return value;
+}
+
+static inline void cnl_sdw_reg_writew(void __iomem *base, int offset, u16 value)
+{
+	writew(value, base + offset);
+}
+
+static inline int cnl_sdw_port_reg_readl(void __iomem *base, int offset,
+						int port_num)
+{
+	return cnl_sdw_reg_readl(base, offset + port_num * 128);
+}
+
+static inline void cnl_sdw_port_reg_writel(u32 __iomem *base, int offset,
+						int port_num, int value)
+{
+	return cnl_sdw_reg_writel(base, offset + port_num * 128, value);
+}
+
+struct cnl_sdw {
+	struct cnl_sdw_data data;
+	struct sdw_master *mstr;
+	irqreturn_t (*thread)(int irq, void *context);
+	void *thread_context;
+	struct completion tx_complete;
+	struct cnl_sdw_port port[CNL_SDW_MAX_PORTS];
+	int num_pcm_streams;
+	struct cnl_sdw_pdi_stream *pcm_streams;
+	int num_in_pcm_streams;
+	struct cnl_sdw_pdi_stream *in_pcm_streams;
+	int num_out_pcm_streams;
+	struct cnl_sdw_pdi_stream *out_pcm_streams;
+	int num_pdm_streams;
+	struct cnl_sdw_pdi_stream *pdm_streams;
+	int num_in_pdm_streams;
+	struct cnl_sdw_pdi_stream *in_pdm_streams;
+	int num_out_pdm_streams;
+	struct cnl_sdw_pdi_stream *out_pdm_streams;
+	struct mutex	stream_lock;
+	spinlock_t ctrl_lock;
+	u32 response_buf[0x80];
+	bool sdw_link_status;
+
+};
+
+static int sdw_power_up_link(struct cnl_sdw *sdw)
+{
+	volatile int link_control;
+	struct sdw_master *mstr = sdw->mstr;
+	struct cnl_sdw_data *data = &sdw->data;
+	/* Try 10 times before timing out */
+	int timeout = 10;
+	int spa_mask, cpa_mask;
+
+	link_control = cnl_sdw_reg_readl(data->sdw_shim, SDW_CNL_LCTL);
+	spa_mask = (CNL_LCTL_SPA_MASK << (data->inst_id + CNL_LCTL_SPA_SHIFT));
+	cpa_mask = (CNL_LCTL_CPA_MASK << (data->inst_id + CNL_LCTL_CPA_SHIFT));
+	link_control |=  spa_mask;
+	cnl_sdw_reg_writel(data->sdw_shim, SDW_CNL_LCTL, link_control);
+	do {
+		link_control = cnl_sdw_reg_readl(data->sdw_shim, SDW_CNL_LCTL);
+		if (link_control & cpa_mask)
+			break;
+		timeout--;
+		/* Wait 20ms before each time */
+		msleep(20);
+	} while (timeout != 0);
+	/* Read once again to confirm */
+	link_control = cnl_sdw_reg_readl(data->sdw_shim, SDW_CNL_LCTL);
+	if (link_control & cpa_mask) {
+		dev_info(&mstr->dev, "SoundWire ctrl %d Powered Up\n",
+						data->inst_id);
+		sdw->sdw_link_status = 1;
+		return 0;
+	}
+	dev_err(&mstr->dev, "Failed to Power Up the SDW ctrl %d\n",
+								data->inst_id);
+	return -EIO;
+}
+
+static void sdw_power_down_link(struct cnl_sdw *sdw)
+{
+	volatile int link_control;
+	struct sdw_master *mstr = sdw->mstr;
+	struct cnl_sdw_data *data = &sdw->data;
+	/* Retry 10 times before giving up */
+	int timeout = 10;
+	int spa_mask, cpa_mask;
+
+	link_control = cnl_sdw_reg_readl(data->sdw_shim, SDW_CNL_LCTL);
+	spa_mask = ~(CNL_LCTL_SPA_MASK << (data->inst_id + CNL_LCTL_SPA_SHIFT));
+	cpa_mask = (CNL_LCTL_CPA_MASK << (data->inst_id + CNL_LCTL_CPA_SHIFT));
+	link_control &=  spa_mask;
+	cnl_sdw_reg_writel(data->sdw_shim, SDW_CNL_LCTL, link_control);
+	do {
+		link_control = cnl_sdw_reg_readl(data->sdw_shim, SDW_CNL_LCTL);
+		if (!(link_control & cpa_mask))
+			break;
+		timeout--;
+		/* Wait for 20ms before each retry */
+		msleep(20);
+	} while (timeout != 0);
+	/* Read once again to confirm */
+	link_control = cnl_sdw_reg_readl(data->sdw_shim, SDW_CNL_LCTL);
+	if (!(link_control & cpa_mask)) {
+		dev_info(&mstr->dev, "SoundWire ctrl %d Powered Down\n",
+						data->inst_id);
+		sdw->sdw_link_status = 0;
+		return;
+	}
+	dev_err(&mstr->dev, "Failed to Power Down the SDW ctrl %d\n",
+								data->inst_id);
+}
+
+static void sdw_init_phyctrl(struct cnl_sdw *sdw)
+{
+	/* TODO: Initialize based on hardware requirement */
+
+}
+
+static void sdw_switch_to_mip(struct cnl_sdw *sdw)
+{
+	u16 ioctl;
+	u16 act = 0;
+	struct cnl_sdw_data *data = &sdw->data;
+	int ioctl_offset = SDW_CNL_IOCTL + (data->inst_id *
+					SDW_CNL_IOCTL_REG_OFFSET);
+	int act_offset = SDW_CNL_CTMCTL + (data->inst_id *
+					SDW_CNL_CTMCTL_REG_OFFSET);
+
+	ioctl = cnl_sdw_reg_readw(data->sdw_shim,  ioctl_offset);
+
+	ioctl &= ~(CNL_IOCTL_DOE_MASK << CNL_IOCTL_DOE_SHIFT);
+	cnl_sdw_reg_writew(data->sdw_shim,  ioctl_offset, ioctl);
+
+	ioctl &= ~(CNL_IOCTL_DO_MASK << CNL_IOCTL_DO_SHIFT);
+	cnl_sdw_reg_writew(data->sdw_shim,  ioctl_offset, ioctl);
+
+	ioctl |= CNL_IOCTL_MIF_MASK << CNL_IOCTL_MIF_SHIFT;
+	cnl_sdw_reg_writew(data->sdw_shim,  ioctl_offset, ioctl);
+
+	ioctl &= ~(CNL_IOCTL_BKE_MASK << CNL_IOCTL_BKE_SHIFT);
+	ioctl &= ~(CNL_IOCTL_COE_MASK << CNL_IOCTL_COE_SHIFT);
+
+	cnl_sdw_reg_writew(data->sdw_shim,  ioctl_offset, ioctl);
+
+	act |= 0x1 << CNL_CTMCTL_DOAIS_SHIFT;
+	act |= CNL_CTMCTL_DACTQE_MASK << CNL_CTMCTL_DACTQE_SHIFT;
+	act |= CNL_CTMCTL_DODS_MASK << CNL_CTMCTL_DODS_SHIFT;
+	cnl_sdw_reg_writew(data->sdw_shim,  act_offset, act);
+}
+
+static void sdw_switch_to_glue(struct cnl_sdw *sdw)
+{
+	u16 ioctl;
+	struct cnl_sdw_data *data = &sdw->data;
+	int ioctl_offset = SDW_CNL_IOCTL + (data->inst_id *
+					SDW_CNL_IOCTL_REG_OFFSET);
+
+	ioctl = cnl_sdw_reg_readw(data->sdw_shim,  ioctl_offset);
+	ioctl |= CNL_IOCTL_BKE_MASK << CNL_IOCTL_BKE_SHIFT;
+	ioctl |= CNL_IOCTL_COE_MASK << CNL_IOCTL_COE_SHIFT;
+	cnl_sdw_reg_writew(data->sdw_shim,  ioctl_offset, ioctl);
+
+	ioctl &= ~(CNL_IOCTL_MIF_MASK << CNL_IOCTL_MIF_SHIFT);
+	cnl_sdw_reg_writew(data->sdw_shim,  ioctl_offset, ioctl);
+}
+
+static void sdw_init_shim(struct cnl_sdw *sdw)
+{
+	u16 ioctl = 0;
+	struct cnl_sdw_data *data = &sdw->data;
+	int ioctl_offset = SDW_CNL_IOCTL + (data->inst_id *
+					SDW_CNL_IOCTL_REG_OFFSET);
+
+
+	ioctl |= CNL_IOCTL_BKE_MASK << CNL_IOCTL_BKE_SHIFT;
+	cnl_sdw_reg_writew(data->sdw_shim,  ioctl_offset, ioctl);
+
+	ioctl |= CNL_IOCTL_WPDD_MASK << CNL_IOCTL_WPDD_SHIFT;
+	cnl_sdw_reg_writew(data->sdw_shim,  ioctl_offset, ioctl);
+
+	ioctl |= CNL_IOCTL_DO_MASK << CNL_IOCTL_DO_SHIFT;
+	cnl_sdw_reg_writew(data->sdw_shim,  ioctl_offset, ioctl);
+
+	ioctl |= CNL_IOCTL_DOE_MASK << CNL_IOCTL_DOE_SHIFT;
+	cnl_sdw_reg_writew(data->sdw_shim,  ioctl_offset, ioctl);
+}
+
+static int sdw_config_update(struct cnl_sdw *sdw)
+{
+	struct cnl_sdw_data *data = &sdw->data;
+	struct sdw_master *mstr = sdw->mstr;
+
+	volatile int config_update = 0;
+	/* Try 10 times before giving up on configuration update */
+	int timeout = 10;
+	int config_updated = 0;
+
+	config_update |= MCP_CONFIGUPDATE_CONFIGUPDATE_MASK <<
+				MCP_CONFIGUPDATE_CONFIGUPDATE_SHIFT;
+	/* Bit is self-cleared when configuration gets updated. */
+	cnl_sdw_reg_writel(data->sdw_regs,  SDW_CNL_MCP_CONFIGUPDATE,
+			config_update);
+	do {
+		config_update = cnl_sdw_reg_readl(data->sdw_regs,
+				SDW_CNL_MCP_CONFIGUPDATE);
+		if ((config_update &
+				MCP_CONFIGUPDATE_CONFIGUPDATE_MASK) == 0) {
+			config_updated = 1;
+			break;
+		}
+		timeout--;
+		/* Wait for 20ms between each try */
+		msleep(20);
+
+	} while (timeout != 0);
+	if (!config_updated) {
+		dev_err(&mstr->dev, "SoundWire update failed\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static void sdw_enable_interrupt(struct cnl_sdw *sdw)
+{
+	struct cnl_sdw_data *data = &sdw->data;
+	int int_mask = 0;
+
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_SLAVEINTMASK0,
+						MCP_SLAVEINTMASK0_MASK);
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_SLAVEINTMASK1,
+						MCP_SLAVEINTMASK1_MASK);
+	/* Enable slave interrupt mask */
+	int_mask |= MCP_INTMASK_SLAVERESERVED_MASK <<
+				MCP_INTMASK_SLAVERESERVED_SHIFT;
+	int_mask |= MCP_INTMASK_SLAVEALERT_MASK <<
+				MCP_INTMASK_SLAVEALERT_SHIFT;
+	int_mask |= MCP_INTMASK_SLAVEATTACHED_MASK <<
+				MCP_INTMASK_SLAVEATTACHED_SHIFT;
+	int_mask |= MCP_INTMASK_SLAVENOTATTACHED_MASK <<
+				MCP_INTMASK_SLAVENOTATTACHED_SHIFT;
+	int_mask |= MCP_INTMASK_CONTROLBUSCLASH_MASK <<
+				MCP_INTMASK_CONTROLBUSCLASH_SHIFT;
+	int_mask |= MCP_INTMASK_DATABUSCLASH_MASK <<
+				MCP_INTMASK_DATABUSCLASH_SHIFT;
+	int_mask |= MCP_INTMASK_RXWL_MASK <<
+				MCP_INTMASK_RXWL_SHIFT;
+	int_mask |= MCP_INTMASK_IRQEN_MASK <<
+				MCP_INTMASK_IRQEN_SHIFT;
+	int_mask |= MCP_INTMASK_DPPDIINT_MASK <<
+				MCP_INTMASK_DPPDIINT_SHIFT;
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_INTMASK, int_mask);
+}
+
+static int sdw_pcm_pdi_init(struct cnl_sdw *sdw)
+{
+	struct sdw_master *mstr = sdw->mstr;
+	struct cnl_sdw_data *data = &sdw->data;
+	int pcm_cap;
+	int pcm_cap_offset = SDW_CNL_PCMSCAP + (data->inst_id *
+					SDW_CNL_PCMSCAP_REG_OFFSET);
+	int ch_cnt_offset;
+	int i;
+
+	pcm_cap = cnl_sdw_reg_readw(data->sdw_shim, pcm_cap_offset);
+	sdw->num_pcm_streams = (pcm_cap >> CNL_PCMSCAP_BSS_SHIFT) &
+			CNL_PCMSCAP_BSS_MASK;
+	dev_info(&mstr->dev, "Number of Bidirectional PCM stream = %d\n",
+			sdw->num_pcm_streams);
+	sdw->pcm_streams = devm_kzalloc(&mstr->dev,
+		sdw->num_pcm_streams * sizeof(struct cnl_sdw_pdi_stream),
+		GFP_KERNEL);
+	if (!sdw->pcm_streams)
+		return -ENOMEM;
+	/* Two of the PCM streams are reserved for bulk transfers */
+	sdw->pcm_streams -= SDW_CNL_PCM_PDI_NUM_OFFSET;
+	for (i = SDW_CNL_PCM_PDI_NUM_OFFSET; i < sdw->num_pcm_streams; i++) {
+		ch_cnt_offset = SDW_CNL_PCMSCHC +
+			(data->inst_id * SDW_CNL_PCMSCHC_REG_OFFSET) +
+			((i + SDW_CNL_PCM_PDI_NUM_OFFSET) * 0x2);
+
+		sdw->pcm_streams[i].ch_cnt = cnl_sdw_reg_readw(data->sdw_shim,
+						ch_cnt_offset);
+		/* Zero based value in register */
+		sdw->pcm_streams[i].ch_cnt++;
+		sdw->pcm_streams[i].pdi_num = i;
+		sdw->pcm_streams[i].allocated = false;
+		dev_info(&mstr->dev, "CH Count for stream %d is %d\n",
+			i, sdw->pcm_streams[i].ch_cnt);
+	}
+	return 0;
+}
+
+static int sdw_pdm_pdi_init(struct cnl_sdw *sdw)
+{
+	int i;
+	struct sdw_master *mstr = sdw->mstr;
+	struct cnl_sdw_data *data = &sdw->data;
+	int pdm_cap, pdm_ch_count, total_pdm_streams;
+	int pdm_cap_offset = SDW_CNL_PDMSCAP +
+			(data->inst_id * SDW_CNL_PDMSCAP_REG_OFFSET);
+
+	pdm_cap = cnl_sdw_reg_readw(data->sdw_regs, pdm_cap_offset);
+	sdw->num_pdm_streams = (pdm_cap >> CNL_PDMSCAP_BSS_SHIFT) &
+			CNL_PDMSCAP_BSS_MASK;
+	/* Zero based value in register */
+	sdw->num_pdm_streams++;
+	sdw->pdm_streams = devm_kzalloc(&mstr->dev,
+		sdw->num_pdm_streams * sizeof(struct cnl_sdw_pdi_stream),
+		GFP_KERNEL);
+	if (!sdw->pdm_streams)
+		return -ENOMEM;
+
+	sdw->num_in_pdm_streams = (pdm_cap >> CNL_PDMSCAP_ISS_SHIFT) &
+			CNL_PDMSCAP_ISS_MASK;
+	/* Zero based value in register */
+	sdw->num_in_pdm_streams++;
+	sdw->in_pdm_streams = devm_kzalloc(&mstr->dev,
+		sdw->num_in_pdm_streams * sizeof(struct cnl_sdw_pdi_stream),
+		GFP_KERNEL);
+
+	if (!sdw->in_pdm_streams)
+		return -ENOMEM;
+
+	sdw->num_out_pdm_streams = (pdm_cap >> CNL_PDMSCAP_OSS_SHIFT) &
+			CNL_PDMSCAP_OSS_MASK;
+	/* Zero based value in register */
+	sdw->num_out_pdm_streams++;
+	sdw->out_pdm_streams = devm_kzalloc(&mstr->dev,
+		sdw->num_out_pdm_streams * sizeof(struct cnl_sdw_pdi_stream),
+		GFP_KERNEL);
+	if (!sdw->out_pdm_streams)
+		return -ENOMEM;
+
+	total_pdm_streams = sdw->num_pdm_streams +
+			sdw->num_in_pdm_streams +
+			sdw->num_out_pdm_streams;
+
+	pdm_ch_count = (pdm_cap >> CNL_PDMSCAP_CPSS_SHIFT) &
+				CNL_PDMSCAP_CPSS_MASK;
+	for (i = 0; i < sdw->num_pdm_streams; i++) {
+		sdw->pdm_streams[i].ch_cnt = pdm_ch_count;
+		sdw->pdm_streams[i].pdi_num = i + SDW_CNL_PDM_PDI_NUM_OFFSET;
+		sdw->pdm_streams[i].allocated = false;
+	}
+	for (i = 0; i < sdw->num_in_pdm_streams; i++) {
+		sdw->in_pdm_streams[i].ch_cnt = pdm_ch_count;
+		sdw->in_pdm_streams[i].pdi_num = i + SDW_CNL_PDM_PDI_NUM_OFFSET;
+		sdw->in_pdm_streams[i].allocated = false;
+	}
+	for (i = 0; i < sdw->num_out_pdm_streams; i++) {
+		sdw->out_pdm_streams[i].ch_cnt = pdm_ch_count;
+		sdw->out_pdm_streams[i].pdi_num =
+					i + SDW_CNL_PDM_PDI_NUM_OFFSET;
+		sdw->out_pdm_streams[i].allocated = false;
+	}
+	return 0;
+}
+
+static int sdw_port_pdi_init(struct cnl_sdw *sdw)
+{
+	int i, ret = 0;
+
+	for (i = 0; i < CNL_SDW_MAX_PORTS; i++) {
+		sdw->port[i].port_num = i;
+		sdw->port[i].allocated = false;
+	}
+	ret = sdw_pcm_pdi_init(sdw);
+	if (ret)
+		return ret;
+	ret = sdw_pdm_pdi_init(sdw);
+
+	return ret;
+}
+
+static int sdw_init(struct cnl_sdw *sdw)
+{
+	struct sdw_master *mstr = sdw->mstr;
+	struct cnl_sdw_data *data = &sdw->data;
+	int mcp_config, mcp_control;
+	int ret = 0;
+
+	/* Power up the link controller */
+	ret = sdw_power_up_link(sdw);
+	if (ret)
+		return ret;
+
+	/* Initialize the IO control registers */
+	sdw_init_shim(sdw);
+
+	/* Switch the ownership to Master IP from glue logic */
+	sdw_switch_to_mip(sdw);
+
+	/* Set command acceptance mode. This is required because when
+	 * Master broadcasts the clock_stop command to slaves, slaves
+	 * might be already suspended, so this return NO ACK, in that
+	 * case also master should go to clock stop mode.
+	 */
+	mcp_control = cnl_sdw_reg_readl(data->sdw_regs,
+					SDW_CNL_MCP_CONTROL);
+	mcp_control |= (MCP_CONTROL_CMDACCEPTMODE_MASK <<
+			MCP_CONTROL_CMDACCEPTMODE_SHIFT);
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_CONTROL, mcp_control);
+
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_FRAMESHAPEINIT, 0x48);
+
+	mcp_config = cnl_sdw_reg_readl(data->sdw_regs, SDW_CNL_MCP_CONFIG);
+	/* Set Max cmd retry to 15 times */
+	mcp_config |= (CNL_SDW_MAX_CMD_RETRIES <<
+				MCP_CONFIG_MAXCMDRETRY_SHIFT);
+
+	/* Set Ping request to ping delay to 15 frames.
+	 * Spec supports 32 max frames
+	 */
+	mcp_config |= (CNL_SDW_MAX_PREQ_DELAY <<
+					MCP_CONFIG_MAXPREQDELAY_SHIFT);
+
+	/* If master is synchronized to some other master set Multimode */
+	if (mstr->link_sync_mask) {
+		mcp_config |= (MCP_CONFIG_MMMODEEN_MASK <<
+						MCP_CONFIG_MMMODEEN_SHIFT);
+		mcp_config |= (MCP_CONFIG_SSPMODE_MASK <<
+						MCP_CONFIG_SSPMODE_SHIFT);
+	} else {
+		mcp_config &= ~(MCP_CONFIG_MMMODEEN_MASK <<
+						MCP_CONFIG_MMMODEEN_SHIFT);
+		mcp_config &= ~(MCP_CONFIG_SSPMODE_MASK <<
+						MCP_CONFIG_SSPMODE_SHIFT);
+	}
+
+	/* Disable automatic bus release */
+	mcp_config &= ~(MCP_CONFIG_BRELENABLE_MASK <<
+				MCP_CONFIG_BRELENABLE_SHIFT);
+
+	/* Disable sniffer mode now */
+	mcp_config &= ~(MCP_CONFIG_SNIFFEREN_MASK <<
+				MCP_CONFIG_SNIFFEREN_SHIFT);
+
+	/* Set the command mode for Tx and Rx command */
+	mcp_config &= ~(MCP_CONFIG_CMDMODE_MASK <<
+				MCP_CONFIG_CMDMODE_SHIFT);
+
+	/* Set operation mode to normal */
+	mcp_config &= ~(MCP_CONFIG_OPERATIONMODE_MASK <<
+				MCP_CONFIG_OPERATIONMODE_SHIFT);
+	mcp_config |= ((MCP_CONFIG_OPERATIONMODE_NORMAL &
+			MCP_CONFIG_OPERATIONMODE_MASK) <<
+			MCP_CONFIG_OPERATIONMODE_SHIFT);
+
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_CONFIG, mcp_config);
+	/* Set the SSP interval to 32 for both banks */
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_SSPCTRL0,
+					SDW_CNL_DEFAULT_SSP_INTERVAL);
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_SSPCTRL1,
+					SDW_CNL_DEFAULT_SSP_INTERVAL);
+
+	/* Initialize the phy control registers. */
+	sdw_init_phyctrl(sdw);
+
+	/* Initlaize the ports */
+	ret = sdw_port_pdi_init(sdw);
+	if (ret) {
+		dev_err(&mstr->dev, "SoundWire controller init failed %d\n",
+				data->inst_id);
+		sdw_power_down_link(sdw);
+		return ret;
+	}
+
+	/* Lastly enable interrupts */
+	sdw_enable_interrupt(sdw);
+
+	/* Update soundwire configuration */
+	return sdw_config_update(sdw);
+}
+
+static int sdw_alloc_pcm_stream(struct cnl_sdw *sdw,
+			struct cnl_sdw_port *port, int ch_cnt,
+			enum sdw_data_direction direction)
+{
+	int num_pcm_streams, pdi_ch_map = 0, stream_id;
+	struct cnl_sdw_pdi_stream *stream, *pdi_stream;
+	unsigned int i;
+	unsigned int ch_map_offset, port_ctrl_offset, pdi_config_offset;
+	struct sdw_master *mstr = sdw->mstr;
+	unsigned int port_ctrl = 0, pdi_config = 0, channel_mask;
+	unsigned int stream_config;
+
+	/* Currently PCM supports only bi-directional streams only */
+	num_pcm_streams = sdw->num_pcm_streams;
+	stream = sdw->pcm_streams;
+
+	mutex_lock(&sdw->stream_lock);
+	for (i = SDW_CNL_PCM_PDI_NUM_OFFSET; i < num_pcm_streams; i++) {
+		if (stream[i].allocated == false) {
+			stream[i].allocated = true;
+			stream[i].port_num = port->port_num;
+			port->pdi_stream = &stream[i];
+			break;
+		}
+	}
+	mutex_unlock(&sdw->stream_lock);
+	if (!port->pdi_stream) {
+		dev_err(&mstr->dev, "Unable to allocate stream for PCM\n");
+		return -EINVAL;
+	}
+	pdi_stream = port->pdi_stream;
+	/* We didnt get enough PDI streams, so free the allocated
+	 * PDI streams. Free the port as well and return with error
+	 */
+	pdi_stream->l_ch_num = 0;
+	pdi_stream->h_ch_num = ch_cnt - 1;
+	ch_map_offset = SDW_CNL_PCMSCHM +
+			(SDW_CNL_PCMSCHM_REG_OFFSET * mstr->nr) +
+			(0x2 * pdi_stream->pdi_num);
+	if (port->direction == SDW_DATA_DIR_IN)
+		pdi_ch_map |= (CNL_PCMSYCM_DIR_MASK << CNL_PCMSYCM_DIR_SHIFT);
+	else
+		pdi_ch_map &= ~(CNL_PCMSYCM_DIR_MASK << CNL_PCMSYCM_DIR_SHIFT);
+	/* TODO: Remove this hardcoding */
+	stream_id = mstr->nr * 16 + pdi_stream->pdi_num + 5;
+	pdi_stream->sdw_pdi_num = stream_id;
+	pdi_ch_map |= (stream_id & CNL_PCMSYCM_STREAM_MASK) <<
+					CNL_PCMSYCM_STREAM_SHIFT;
+	pdi_ch_map |= (pdi_stream->l_ch_num &
+			CNL_PCMSYCM_LCHAN_MASK) <<
+					CNL_PCMSYCM_LCHAN_SHIFT;
+	pdi_ch_map |= (0xF & CNL_PCMSYCM_HCHAN_MASK) <<
+					CNL_PCMSYCM_HCHAN_SHIFT;
+	cnl_sdw_reg_writew(sdw->data.sdw_shim, ch_map_offset,
+				pdi_ch_map);
+	/* If direction is input, port is sink port*/
+	if (direction ==  SDW_DATA_DIR_IN)
+		port_ctrl |= (PORTCTRL_PORT_DIRECTION_MASK <<
+				PORTCTRL_PORT_DIRECTION_SHIFT);
+	else
+		port_ctrl &= ~(PORTCTRL_PORT_DIRECTION_MASK <<
+				PORTCTRL_PORT_DIRECTION_SHIFT);
+
+	port_ctrl_offset =  SDW_CNL_PORTCTRL + (port->port_num *
+				SDW_CNL_PORT_REG_OFFSET);
+	cnl_sdw_reg_writel(sdw->data.sdw_regs, port_ctrl_offset, port_ctrl);
+
+	pdi_config |= ((port->port_num & PDINCONFIG_PORT_NUMBER_MASK) <<
+			PDINCONFIG_PORT_NUMBER_SHIFT);
+
+	channel_mask = (1 << ch_cnt) - 1;
+	pdi_config |= (channel_mask << PDINCONFIG_CHANNEL_MASK_SHIFT);
+	/* TODO: Remove below hardcodings */
+	pdi_config_offset =  (SDW_CNL_PDINCONFIG0 +
+				(pdi_stream->pdi_num * 16));
+	cnl_sdw_reg_writel(sdw->data.sdw_regs, pdi_config_offset, pdi_config);
+
+	stream_config = cnl_sdw_reg_readl(sdw->data.alh_base,
+			(pdi_stream->sdw_pdi_num * ALH_CNL_STRMZCFG_OFFSET));
+	stream_config |= (CNL_STRMZCFG_DMAT_VAL & CNL_STRMZCFG_DMAT_MASK) <<
+				CNL_STRMZCFG_DMAT_SHIFT;
+	stream_config |=  ((ch_cnt - 1) & CNL_STRMZCFG_CHAN_MASK) <<
+			CNL_STRMZCFG_CHAN_SHIFT;
+	cnl_sdw_reg_writel(sdw->data.alh_base,
+			 (pdi_stream->sdw_pdi_num * ALH_CNL_STRMZCFG_OFFSET),
+			stream_config);
+	return 0;
+}
+
+static int sdw_alloc_pdm_stream(struct cnl_sdw *sdw,
+			struct cnl_sdw_port *port, int ch_cnt, int direction)
+{
+	int num_pdm_streams;
+	struct cnl_sdw_pdi_stream *stream;
+	int i;
+	unsigned int port_ctrl_offset, pdi_config_offset;
+	unsigned int port_ctrl = 0, pdi_config = 0, channel_mask;
+
+	/* Currently PDM supports either Input or Output Streams */
+	if (direction == SDW_DATA_DIR_IN) {
+		num_pdm_streams = sdw->num_in_pdm_streams;
+		stream = sdw->in_pdm_streams;
+	} else {
+		num_pdm_streams = sdw->num_out_pdm_streams;
+		stream = sdw->out_pdm_streams;
+	}
+	mutex_lock(&sdw->stream_lock);
+	for (i = 0; i < num_pdm_streams; i++) {
+		if (stream[i].allocated == false) {
+			stream[i].allocated = true;
+			stream[i].port_num = port->port_num;
+			port->pdi_stream = &stream[i];
+			break;
+		}
+	}
+	mutex_unlock(&sdw->stream_lock);
+	if (!port->pdi_stream)
+		return -EINVAL;
+	/* If direction is input, port is sink port*/
+	if (direction ==  SDW_DATA_DIR_IN)
+		port_ctrl |= (PORTCTRL_PORT_DIRECTION_MASK <<
+				PORTCTRL_PORT_DIRECTION_SHIFT);
+	else
+		port_ctrl &= ~(PORTCTRL_PORT_DIRECTION_MASK <<
+				PORTCTRL_PORT_DIRECTION_SHIFT);
+
+	port_ctrl_offset =  SDW_CNL_PORTCTRL + (port->port_num *
+				SDW_CNL_PORT_REG_OFFSET);
+	cnl_sdw_reg_writel(sdw->data.sdw_regs, port_ctrl_offset, port_ctrl);
+
+	pdi_config |= ((port->port_num & PDINCONFIG_PORT_NUMBER_MASK) <<
+			PDINCONFIG_PORT_NUMBER_SHIFT);
+
+	channel_mask = (1 << ch_cnt) - 1;
+	pdi_config |= (channel_mask << PDINCONFIG_CHANNEL_MASK_SHIFT);
+	/* TODO: Remove below hardcodings */
+	pdi_config_offset =  (SDW_CNL_PDINCONFIG0 + (stream[i].pdi_num * 16));
+	cnl_sdw_reg_writel(sdw->data.sdw_regs, pdi_config_offset, pdi_config);
+
+	return 0;
+}
+
+struct cnl_sdw_port *cnl_sdw_alloc_port(struct sdw_master *mstr, int ch_count,
+				enum sdw_data_direction direction,
+				enum cnl_sdw_pdi_stream_type stream_type)
+{
+	struct cnl_sdw *sdw;
+	struct cnl_sdw_port *port = NULL;
+	int i, ret = 0;
+	struct num_pdi_streams;
+
+	sdw = sdw_master_get_drvdata(mstr);
+
+	mutex_lock(&sdw->stream_lock);
+	for (i = 1; i < CNL_SDW_MAX_PORTS; i++) {
+		if (sdw->port[i].allocated == false) {
+			port = &sdw->port[i];
+			port->allocated = true;
+			port->direction = direction;
+			port->ch_cnt = ch_count;
+			break;
+		}
+	}
+	mutex_unlock(&sdw->stream_lock);
+	if (!port) {
+		dev_err(&mstr->dev, "Unable to allocate port\n");
+		return NULL;
+	}
+	port->pdi_stream = NULL;
+	if (stream_type == CNL_SDW_PDI_TYPE_PDM)
+		ret = sdw_alloc_pdm_stream(sdw, port, ch_count, direction);
+	else
+		ret = sdw_alloc_pcm_stream(sdw, port, ch_count, direction);
+	if (!ret)
+		return port;
+
+	dev_err(&mstr->dev, "Unable to allocate stream\n");
+	mutex_lock(&sdw->stream_lock);
+	port->allocated = false;
+	mutex_unlock(&sdw->stream_lock);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(cnl_sdw_alloc_port);
+
+void cnl_sdw_free_port(struct sdw_master *mstr, int port_num)
+{
+	int i;
+	struct cnl_sdw *sdw;
+	struct cnl_sdw_port *port = NULL;
+
+	sdw = sdw_master_get_drvdata(mstr);
+	for (i = 1; i < CNL_SDW_MAX_PORTS; i++) {
+		if (sdw->port[i].port_num == port_num) {
+			port = &sdw->port[i];
+			break;
+		}
+	}
+	if (!port)
+		return;
+	mutex_lock(&sdw->stream_lock);
+	port->pdi_stream->allocated = false;
+	port->pdi_stream = NULL;
+	port->allocated = false;
+	mutex_unlock(&sdw->stream_lock);
+}
+EXPORT_SYMBOL_GPL(cnl_sdw_free_port);
+
+static int cnl_sdw_update_slave_status(struct cnl_sdw *sdw, int slave_intstat0,
+			int slave_intstat1)
+{
+	int i;
+	struct sdw_status slave_status;
+	u64 slaves_stat, slave_stat;
+	int ret = 0;
+
+	memset(&slave_status, 0x0, sizeof(slave_status));
+	slaves_stat = (u64) slave_intstat1 <<
+			SDW_CNL_SLAVES_STAT_UPPER_DWORD_SHIFT;
+	slaves_stat |= slave_intstat0;
+	for (i = 0; i <= SOUNDWIRE_MAX_DEVICES; i++) {
+		slave_stat = slaves_stat >> (i * SDW_CNL_SLAVE_STATUS_BITS);
+		if (slave_stat &  MCP_SLAVEINTSTAT_NOT_PRESENT_MASK)
+			slave_status.status[i] = SDW_SLAVE_STAT_NOT_PRESENT;
+		else if (slave_stat &  MCP_SLAVEINTSTAT_ATTACHED_MASK)
+			slave_status.status[i] = SDW_SLAVE_STAT_ATTACHED_OK;
+		else if (slave_stat &  MCP_SLAVEINTSTAT_ALERT_MASK)
+			slave_status.status[i] = SDW_SLAVE_STAT_ALERT;
+		else if (slave_stat &  MCP_SLAVEINTSTAT_RESERVED_MASK)
+			slave_status.status[i] = SDW_SLAVE_STAT_RESERVED;
+	}
+	ret = sdw_master_update_slv_status(sdw->mstr, &slave_status);
+	return ret;
+}
+
+static void cnl_sdw_read_response(struct cnl_sdw *sdw)
+{
+	struct cnl_sdw_data *data = &sdw->data;
+	int num_res = 0, i;
+	u32 cmd_base = SDW_CNL_MCP_COMMAND_BASE;
+
+	num_res = cnl_sdw_reg_readl(data->sdw_regs, SDW_CNL_MCP_FIFOSTAT);
+	num_res &= MCP_RX_FIFO_AVAIL_MASK;
+	for (i = 0; i < num_res; i++) {
+		sdw->response_buf[i] = cnl_sdw_reg_readl(data->sdw_regs,
+				cmd_base);
+		cmd_base += SDW_CNL_CMD_WORD_LEN;
+	}
+}
+
+irqreturn_t cnl_sdw_irq_handler(int irq, void *context)
+{
+	struct cnl_sdw *sdw = context;
+	volatile int int_status, status, wake_sts;
+
+	struct cnl_sdw_data *data = &sdw->data;
+	volatile int slave_intstat0 = 0, slave_intstat1 = 0;
+	struct sdw_master *mstr = sdw->mstr;
+
+	/*
+	 * Return if IP is in power down state. Interrupt can still come
+	 * since  its shared irq.
+	 */
+	if (!sdw->sdw_link_status)
+		return IRQ_NONE;
+
+	int_status = cnl_sdw_reg_readl(data->sdw_regs, SDW_CNL_MCP_INTSTAT);
+	status = cnl_sdw_reg_readl(data->sdw_regs, SDW_CNL_MCP_STAT);
+	slave_intstat0 = cnl_sdw_reg_readl(data->sdw_regs,
+					SDW_CNL_MCP_SLAVEINTSTAT0);
+	slave_intstat1 = cnl_sdw_reg_readl(data->sdw_regs,
+					SDW_CNL_MCP_SLAVEINTSTAT1);
+	wake_sts = cnl_sdw_reg_readw(data->sdw_shim,
+				SDW_CNL_SNDWWAKESTS_REG_OFFSET);
+	cnl_sdw_reg_writew(data->sdw_shim, SDW_CNL_SNDWWAKESTS_REG_OFFSET,
+				wake_sts);
+
+	if (!(int_status & (MCP_INTSTAT_IRQ_MASK << MCP_INTSTAT_IRQ_SHIFT)))
+		return IRQ_NONE;
+
+	if (int_status & (MCP_INTSTAT_RXWL_MASK << MCP_INTSTAT_RXWL_SHIFT)) {
+		cnl_sdw_read_response(sdw);
+		complete(&sdw->tx_complete);
+	}
+	if (int_status & (MCP_INTSTAT_CONTROLBUSCLASH_MASK <<
+				MCP_INTSTAT_CONTROLBUSCLASH_SHIFT)) {
+		/* Some slave is behaving badly, where its driving
+		 * data line during control word bits.
+		 */
+		dev_err_ratelimited(&mstr->dev, "Bus clash detected for control word\n");
+		WARN_ONCE(1, "Bus clash detected for control word\n");
+	}
+	if (int_status & (MCP_INTSTAT_DATABUSCLASH_MASK <<
+				MCP_INTSTAT_DATABUSCLASH_SHIFT)) {
+		/* More than 1 slave is trying to drive bus. There is
+		 * some problem with ownership of bus data bits,
+		 * or either of the
+		 * slave is behaving badly.
+		 */
+		dev_err_ratelimited(&mstr->dev, "Bus clash detected for control word\n");
+		WARN_ONCE(1, "Bus clash detected for data word\n");
+	}
+
+	if (int_status & (MCP_INTSTAT_SLAVE_STATUS_CHANGED_MASK <<
+		MCP_INTSTAT_SLAVE_STATUS_CHANGED_SHIFT)) {
+		dev_info(&mstr->dev, "Slave status change\n");
+		cnl_sdw_update_slave_status(sdw, slave_intstat0,
+							slave_intstat1);
+	}
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_SLAVEINTSTAT0,
+								slave_intstat0);
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_SLAVEINTSTAT1,
+								slave_intstat1);
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_INTSTAT, int_status);
+	return IRQ_HANDLED;
+}
+
+static enum sdw_command_response cnl_program_scp_addr(struct sdw_master *mstr,
+					struct sdw_msg *msg)
+{
+	struct cnl_sdw *sdw = sdw_master_get_drvdata(mstr);
+	struct cnl_sdw_data *data = &sdw->data;
+	u32 cmd_base = SDW_CNL_MCP_COMMAND_BASE;
+	u32 cmd_data[2] = {0, 0};
+	unsigned long time_left;
+	int no_ack = 0, nack = 0;
+	int i;
+
+	/* Since we are programming 2 commands, program the
+	 * RX watermark level at 2
+	 */
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_FIFOLEVEL, 2);
+	/* Program device address */
+	cmd_data[0] |= (msg->slave_addr & MCP_COMMAND_DEV_ADDR_MASK) <<
+				MCP_COMMAND_DEV_ADDR_SHIFT;
+	/* Write command to program the scp_addr1 register */
+	cmd_data[0] |= (0x3 << MCP_COMMAND_COMMAND_SHIFT);
+	cmd_data[1] = cmd_data[0];
+	/* scp_addr1 register address */
+	cmd_data[0] |= (SDW_SCP_ADDRPAGE1 << MCP_COMMAND_REG_ADDR_L_SHIFT);
+	cmd_data[1] |= (SDW_SCP_ADDRPAGE2 << MCP_COMMAND_REG_ADDR_L_SHIFT);
+	cmd_data[0] |= msg->addr_page1;
+	cmd_data[1] |= msg->addr_page2;
+
+	cnl_sdw_reg_writel(data->sdw_regs, cmd_base, cmd_data[0]);
+	cmd_base += SDW_CNL_CMD_WORD_LEN;
+	cnl_sdw_reg_writel(data->sdw_regs, cmd_base, cmd_data[1]);
+
+	time_left = wait_for_completion_timeout(&sdw->tx_complete,
+						3000);
+	if (!time_left) {
+		dev_err(&mstr->dev, "Controller Timed out\n");
+		msg->len = 0;
+		return -ETIMEDOUT;
+	}
+
+	for (i = 0; i < CNL_SDW_SCP_ADDR_REGS; i++) {
+		if (!(MCP_RESPONSE_ACK_MASK & sdw->response_buf[i])) {
+			no_ack = 1;
+				dev_err(&mstr->dev, "Ack not recevied\n");
+			if ((MCP_RESPONSE_NACK_MASK & sdw->response_buf[i])) {
+				nack = 1;
+				dev_err(&mstr->dev, "NACK recevied\n");
+			}
+		}
+	}
+	/* We dont return error if NACK or No ACK detected for broadcast addr
+	 * because some slave might support SCP addr, while some slaves may not
+	 * support it. This is not correct, since we wont be able to find out
+	 * if NACK is detected because of slave not supporting SCP_addrpage or
+	 * its a genuine NACK because of bus errors. We are not sure what slaves
+	 * will report, NACK or No ACK for the scp_addrpage programming if they
+	 * dont support it. Spec is not clear about this.
+	 * This needs to be thought through
+	 */
+	if (nack & (msg->slave_addr != 15)) {
+		dev_err(&mstr->dev, "SCP_addrpage write NACKed for slave %d\n", msg->slave_addr);
+		return -EREMOTEIO;
+	} else if (no_ack && (msg->slave_addr != 15)) {
+		dev_err(&mstr->dev, "SCP_addrpage write ignored for slave %d\n", msg->slave_addr);
+		return -EREMOTEIO;
+	} else
+		return 0;
+
+}
+
+static enum sdw_command_response sdw_xfer_msg(struct sdw_master *mstr,
+		struct sdw_msg *msg, int cmd, int offset, int count)
+{
+	struct cnl_sdw *sdw = sdw_master_get_drvdata(mstr);
+	struct cnl_sdw_data *data = &sdw->data;
+	int i, j;
+	u32 cmd_base =  SDW_CNL_MCP_COMMAND_BASE;
+	u32 response_base = SDW_CNL_MCP_RESPONSE_BASE;
+	u32 cmd_data = 0, response_data;
+	unsigned long time_left;
+	int no_ack = 0, nack = 0;
+	u16 addr = msg->addr;
+
+	/* Program the watermark level upto number of count */
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_FIFOLEVEL, count);
+
+	cmd_base = SDW_CNL_MCP_COMMAND_BASE;
+	for (j = 0; j < count; j++) {
+		/* Program device address */
+		cmd_data = 0;
+		cmd_data |= (msg->slave_addr &
+			MCP_COMMAND_DEV_ADDR_MASK) <<
+			MCP_COMMAND_DEV_ADDR_SHIFT;
+		/* Program read/write command */
+		cmd_data |= (cmd << MCP_COMMAND_COMMAND_SHIFT);
+		/* program incrementing address register */
+		cmd_data |= (addr++ << MCP_COMMAND_REG_ADDR_L_SHIFT);
+		/* Program the data if write command */
+		if (msg->flag == SDW_MSG_FLAG_WRITE)
+			cmd_data |=
+				msg->buf[j + offset];
+
+		cmd_data |= ((msg->ssp_tag &
+				MCP_COMMAND_SSP_TAG_MASK) <<
+				MCP_COMMAND_SSP_TAG_SHIFT);
+		cnl_sdw_reg_writel(data->sdw_regs,
+					cmd_base, cmd_data);
+		cmd_base += SDW_CNL_CMD_WORD_LEN;
+	}
+	/* Wait for 3 second for timeout */
+	time_left = wait_for_completion_timeout(&sdw->tx_complete, 3 * HZ);
+	if (!time_left) {
+		dev_err(&mstr->dev, "Controller timedout\n");
+		msg->len = 0;
+		return -ETIMEDOUT;
+	}
+	for (i = 0; i < count; i++) {
+		if (!(MCP_RESPONSE_ACK_MASK & sdw->response_buf[i])) {
+			no_ack = 1;
+			dev_err(&mstr->dev, "Ack not recevied\n");
+			if ((MCP_RESPONSE_NACK_MASK &
+					sdw->response_buf[i])) {
+				nack = 1;
+				dev_err(&mstr->dev, "NACK recevied\n");
+			}
+		}
+		break;
+	}
+	if (nack) {
+		dev_err(&mstr->dev, "Nack detected for slave %d\n", msg->slave_addr);
+		msg->len = 0;
+		return -EREMOTEIO;
+	} else if (no_ack) {
+		dev_err(&mstr->dev, "Command ignored for slave %d\n", msg->slave_addr);
+		msg->len = 0;
+		return -EREMOTEIO;
+	}
+	if (msg->flag == SDW_MSG_FLAG_WRITE)
+		return 0;
+	/* Response and Command has same base address */
+	response_base = SDW_CNL_MCP_COMMAND_BASE;
+	for (j = 0; j < count; j++) {
+			response_data = cnl_sdw_reg_readl(data->sdw_regs,
+								cmd_base);
+			msg->buf[j + offset] =
+			(sdw->response_buf[j]  >> MCP_RESPONSE_RDATA_SHIFT);
+			cmd_base += 4;
+	}
+	return 0;
+}
+
+static enum sdw_command_response cnl_sdw_xfer_msg(struct sdw_master *mstr,
+		struct sdw_msg *msg, bool program_scp_addr_page)
+{
+	int i, ret = 0, cmd;
+
+	if (program_scp_addr_page)
+		ret = cnl_program_scp_addr(mstr, msg);
+
+	if (ret) {
+		msg->len = 0;
+		return ret;
+	}
+
+	switch (msg->flag) {
+	case SDW_MSG_FLAG_READ:
+		cmd = 0x2;
+		break;
+	case SDW_MSG_FLAG_WRITE:
+		cmd = 0x3;
+		break;
+	default:
+		dev_err(&mstr->dev, "Command not supported\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < msg->len / SDW_CNL_MCP_COMMAND_LENGTH; i++) {
+		ret = sdw_xfer_msg(mstr, msg,
+				cmd, i * SDW_CNL_MCP_COMMAND_LENGTH,
+				SDW_CNL_MCP_COMMAND_LENGTH);
+		if (ret < 0)
+			break;
+	}
+	if (!(msg->len % SDW_CNL_MCP_COMMAND_LENGTH))
+		return ret;
+	ret = sdw_xfer_msg(mstr, msg, cmd, i * SDW_CNL_MCP_COMMAND_LENGTH,
+			msg->len % SDW_CNL_MCP_COMMAND_LENGTH);
+	if (ret < 0)
+		return -EINVAL;
+	return ret;
+}
+
+static int cnl_sdw_xfer_bulk(struct sdw_master *mstr,
+	struct sdw_bra_block *block)
+{
+	return 0;
+}
+
+static int cnl_sdw_mon_handover(struct sdw_master *mstr,
+			bool enable)
+{
+	int mcp_config;
+	struct cnl_sdw *sdw = sdw_master_get_drvdata(mstr);
+	struct cnl_sdw_data *data = &sdw->data;
+
+	mcp_config = cnl_sdw_reg_readl(data->sdw_regs, SDW_CNL_MCP_CONFIG);
+	if (enable)
+		mcp_config |= MCP_CONFIG_BRELENABLE_MASK <<
+				MCP_CONFIG_BRELENABLE_SHIFT;
+	else
+		mcp_config &= ~(MCP_CONFIG_BRELENABLE_MASK <<
+				MCP_CONFIG_BRELENABLE_SHIFT);
+
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_CONFIG, mcp_config);
+	return 0;
+}
+
+static int cnl_sdw_set_ssp_interval(struct sdw_master *mstr,
+			int ssp_interval, int bank)
+{
+	struct cnl_sdw *sdw = sdw_master_get_drvdata(mstr);
+	struct cnl_sdw_data *data = &sdw->data;
+	int sspctrl_offset, check;
+
+	if (bank)
+		sspctrl_offset = SDW_CNL_MCP_SSPCTRL1;
+	else
+		sspctrl_offset = SDW_CNL_MCP_SSPCTRL0;
+
+	cnl_sdw_reg_writel(data->sdw_regs, sspctrl_offset, ssp_interval);
+
+	check = cnl_sdw_reg_readl(data->sdw_regs, sspctrl_offset);
+
+	return 0;
+}
+
+static int cnl_sdw_set_clock_freq(struct sdw_master *mstr,
+			int cur_clk_freq, int bank)
+{
+	struct cnl_sdw *sdw = sdw_master_get_drvdata(mstr);
+	struct cnl_sdw_data *data = &sdw->data;
+	int mcp_clockctrl_offset, mcp_clockctrl;
+
+
+	/* TODO: Retrieve divider value or get value directly from calling
+	 * function
+	 */
+	int divider = ((9600000/cur_clk_freq) - 1);
+
+	if (bank) {
+		mcp_clockctrl_offset = SDW_CNL_MCP_CLOCKCTRL1;
+		mcp_clockctrl = cnl_sdw_reg_readl(data->sdw_regs,
+				SDW_CNL_MCP_CLOCKCTRL1);
+
+	} else {
+		mcp_clockctrl_offset = SDW_CNL_MCP_CLOCKCTRL0;
+		mcp_clockctrl = cnl_sdw_reg_readl(data->sdw_regs,
+				SDW_CNL_MCP_CLOCKCTRL0);
+	}
+
+	mcp_clockctrl |= divider;
+
+	/* Write value here */
+	cnl_sdw_reg_writel(data->sdw_regs, mcp_clockctrl_offset,
+				mcp_clockctrl);
+
+	mcp_clockctrl = cnl_sdw_reg_readl(data->sdw_regs,
+				mcp_clockctrl_offset);
+	return 0;
+}
+
+static int cnl_sdw_set_port_params(struct sdw_master *mstr,
+			struct sdw_port_params *params, int bank)
+{
+	struct cnl_sdw *sdw = sdw_master_get_drvdata(mstr);
+	struct cnl_sdw_data *data = &sdw->data;
+	int dpn_config = 0, dpn_config_offset;
+
+	if (bank)
+		dpn_config_offset = SDW_CNL_DPN_CONFIG1;
+	else
+		dpn_config_offset = SDW_CNL_DPN_CONFIG0;
+
+	dpn_config = cnl_sdw_port_reg_readl(data->sdw_regs,
+				dpn_config_offset, params->num);
+
+	dpn_config |= (((params->word_length - 1) & DPN_CONFIG_WL_MASK) <<
+				DPN_CONFIG_WL_SHIFT);
+	dpn_config |= ((params->port_flow_mode & DPN_CONFIG_PF_MODE_MASK) <<
+				DPN_CONFIG_PF_MODE_SHIFT);
+	dpn_config |= ((params->port_data_mode & DPN_CONFIG_PD_MODE_MASK) <<
+				DPN_CONFIG_PD_MODE_SHIFT);
+	cnl_sdw_port_reg_writel(data->sdw_regs,
+				dpn_config_offset, params->num, dpn_config);
+
+	cnl_sdw_port_reg_readl(data->sdw_regs,
+				dpn_config_offset, params->num);
+	return 0;
+}
+
+static int cnl_sdw_set_port_transport_params(struct sdw_master *mstr,
+			struct sdw_transport_params *params, int bank)
+{
+struct cnl_sdw *sdw = sdw_master_get_drvdata(mstr);
+	struct cnl_sdw_data *data = &sdw->data;
+
+	int dpn_config = 0, dpn_config_offset;
+	int dpn_samplectrl_offset;
+	int dpn_offsetctrl = 0, dpn_offsetctrl_offset;
+	int dpn_hctrl = 0, dpn_hctrl_offset;
+
+	if (bank) {
+		dpn_config_offset = SDW_CNL_DPN_CONFIG1;
+		dpn_samplectrl_offset = SDW_CNL_DPN_SAMPLECTRL1;
+		dpn_hctrl_offset = SDW_CNL_DPN_HCTRL1;
+		dpn_offsetctrl_offset = SDW_CNL_DPN_OFFSETCTRL1;
+	} else {
+		dpn_config_offset = SDW_CNL_DPN_CONFIG0;
+		dpn_samplectrl_offset = SDW_CNL_DPN_SAMPLECTRL0;
+		dpn_hctrl_offset = SDW_CNL_DPN_HCTRL0;
+		dpn_offsetctrl_offset = SDW_CNL_DPN_OFFSETCTRL0;
+	}
+	dpn_config = cnl_sdw_port_reg_readl(data->sdw_regs,
+		dpn_config_offset,  params->num);
+	dpn_config |= ((params->blockgroupcontrol & DPN_CONFIG_BGC_MASK) <<
+					DPN_CONFIG_BGC_SHIFT);
+	dpn_config |= ((params->blockpackingmode & DPN_CONFIG_BPM_MASK) <<
+					DPN_CONFIG_BPM_SHIFT);
+
+	cnl_sdw_port_reg_writel(data->sdw_regs,
+		dpn_config_offset, params->num, dpn_config);
+
+	cnl_sdw_port_reg_readl(data->sdw_regs,
+		dpn_config_offset,  params->num);
+
+	dpn_offsetctrl |= ((params->offset1 & DPN_OFFSETCTRL0_OF1_MASK) <<
+			DPN_OFFSETCTRL0_OF1_SHIFT);
+
+	dpn_offsetctrl |= ((params->offset2 & DPN_OFFSETCTRL0_OF2_MASK) <<
+			DPN_OFFSETCTRL0_OF2_SHIFT);
+
+	cnl_sdw_port_reg_writel(data->sdw_regs,
+		dpn_offsetctrl_offset, params->num, dpn_offsetctrl);
+
+
+	dpn_hctrl |= ((params->hstart & DPN_HCTRL_HSTART_MASK) <<
+				DPN_HCTRL_HSTART_SHIFT);
+	dpn_hctrl |= ((params->hstop & DPN_HCTRL_HSTOP_MASK) <<
+				DPN_HCTRL_HSTOP_SHIFT);
+	dpn_hctrl |= ((params->lanecontrol & DPN_HCTRL_LCONTROL_MASK) <<
+				DPN_HCTRL_LCONTROL_SHIFT);
+
+	cnl_sdw_port_reg_writel(data->sdw_regs,
+			dpn_hctrl_offset, params->num, dpn_hctrl);
+
+	cnl_sdw_port_reg_writel(data->sdw_regs,
+			dpn_samplectrl_offset, params->num,
+			(params->sample_interval - 1));
+
+	cnl_sdw_port_reg_readl(data->sdw_regs,
+		dpn_hctrl_offset,  params->num);
+
+	cnl_sdw_port_reg_readl(data->sdw_regs,
+		dpn_samplectrl_offset,  params->num);
+
+	return 0;
+}
+
+static int cnl_sdw_port_activate_ch(struct sdw_master *mstr,
+			struct sdw_activate_ch *activate_ch, int bank)
+{
+	struct cnl_sdw *sdw = sdw_master_get_drvdata(mstr);
+	struct cnl_sdw_data *data = &sdw->data;
+	int dpn_channelen_offset;
+	int ch_mask;
+
+	if (bank)
+		dpn_channelen_offset = SDW_CNL_DPN_CHANNELEN1;
+	else
+		dpn_channelen_offset = SDW_CNL_DPN_CHANNELEN0;
+
+	if (activate_ch->activate)
+		ch_mask = activate_ch->ch_mask;
+	else
+		ch_mask = 0;
+
+	cnl_sdw_port_reg_writel(data->sdw_regs,
+			dpn_channelen_offset, activate_ch->num,
+			ch_mask);
+
+	return 0;
+}
+
+static int cnl_sdw_port_activate_ch_pre(struct sdw_master *mstr,
+			struct sdw_activate_ch *activate_ch, int bank)
+{
+	int sync_reg;
+	struct cnl_sdw *sdw = sdw_master_get_drvdata(mstr);
+	struct cnl_sdw_data *data = &sdw->data;
+
+	if (mstr->link_sync_mask) {
+		/* Check if this link is synchronized with some other link */
+		sync_reg = cnl_sdw_reg_readl(data->sdw_shim,  SDW_CNL_SYNC);
+		/* If link is synchronized with other link than
+		 * Need to make sure that command doesnt go till
+		 * ssync is applied
+		 */
+		sync_reg |= (1 << (data->inst_id + CNL_SYNC_CMDSYNC_SHIFT));
+		cnl_sdw_reg_writel(data->sdw_shim, SDW_CNL_SYNC, sync_reg);
+	}
+
+	return 0;
+}
+static int cnl_sdw_port_activate_ch_post(struct sdw_master *mstr,
+			struct sdw_activate_ch *activate_ch, int bank)
+{
+	int sync_reg;
+	struct cnl_sdw *sdw = sdw_master_get_drvdata(mstr);
+	struct cnl_sdw_data *data = &sdw->data;
+
+	sync_reg = cnl_sdw_reg_readl(data->sdw_shim,  SDW_CNL_SYNC);
+	sync_reg |= CNL_SYNC_SYNCGO_MASK << CNL_SYNC_SYNCGO_SHIFT;
+	cnl_sdw_reg_writel(data->sdw_shim, SDW_CNL_SYNC, sync_reg);
+
+	return 0;
+}
+
+static int cnl_sdw_probe(struct sdw_master *mstr,
+				const struct sdw_master_id *sdw_id)
+{
+	struct cnl_sdw *sdw;
+	int ret = 0;
+	struct cnl_sdw_data *data = mstr->dev.platform_data;
+
+	sdw = devm_kzalloc(&mstr->dev, sizeof(*sdw), GFP_KERNEL);
+	if (!sdw) {
+		ret = -ENOMEM;
+		return ret;
+	}
+	dev_info(&mstr->dev,
+		"Controller Resources ctrl_base = %p shim=%p irq=%d inst_id=%d\n",
+		data->sdw_regs, data->sdw_shim, data->irq, data->inst_id);
+	sdw->data.sdw_regs = data->sdw_regs;
+	sdw->data.sdw_shim = data->sdw_shim;
+	sdw->data.irq = data->irq;
+	sdw->data.inst_id = data->inst_id;
+	sdw->data.alh_base = data->alh_base;
+	sdw->mstr = mstr;
+	spin_lock_init(&sdw->ctrl_lock);
+	sdw_master_set_drvdata(mstr, sdw);
+	init_completion(&sdw->tx_complete);
+	mutex_init(&sdw->stream_lock);
+	ret = sdw_init(sdw);
+	if (ret) {
+		dev_err(&mstr->dev, "SoundWire controller init failed %d\n",
+				data->inst_id);
+		return ret;
+	}
+	ret = devm_request_irq(&mstr->dev,
+		sdw->data.irq, cnl_sdw_irq_handler, IRQF_SHARED, "SDW", sdw);
+	if (ret) {
+		dev_err(&mstr->dev, "unable to grab IRQ %d, disabling device\n",
+			       sdw->data.irq);
+		sdw_power_down_link(sdw);
+		return ret;
+	}
+	pm_runtime_set_autosuspend_delay(&mstr->dev, 3000);
+	pm_runtime_use_autosuspend(&mstr->dev);
+	pm_runtime_enable(&mstr->dev);
+	pm_runtime_get_sync(&mstr->dev);
+	/* Resuming the device, since its already ON, function will simply
+	 * return doing nothing
+	 */
+	pm_runtime_mark_last_busy(&mstr->dev);
+	/* Suspending the device after 3 secs, by the time
+	 * all the slave would have enumerated. Initial
+	 * clock freq is 9.6MHz and frame shape is 48X2, so
+	 * there are 200000 frames in second, total there are
+	 * minimum 600000 frames before device suspends. Soundwire
+	 * spec says slave should get attached to bus in 4096
+	 * error free frames after reset. So this should be
+	 * enough to make sure device gets attached to bus.
+	 */
+	pm_runtime_put_sync_autosuspend(&mstr->dev);
+	return ret;
+}
+
+static int cnl_sdw_remove(struct sdw_master *mstr)
+{
+	struct cnl_sdw *sdw = sdw_master_get_drvdata(mstr);
+
+	sdw_power_down_link(sdw);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int cnl_sdw_runtime_suspend(struct device *dev)
+{
+	enum  sdw_clk_stop_mode clock_stop_mode;
+
+	int volatile mcp_stat;
+	int mcp_control;
+	int timeout = 0;
+	int ret = 0;
+
+	struct cnl_sdw *sdw = dev_get_drvdata(dev);
+	struct cnl_sdw_data *data = &sdw->data;
+
+	/* If its suspended return */
+	mcp_stat = cnl_sdw_reg_readl(data->sdw_regs,
+					SDW_CNL_MCP_STAT);
+	if (mcp_stat & (MCP_STAT_CLOCKSTOPPED_MASK <<
+				MCP_STAT_CLOCKSTOPPED_SHIFT)) {
+		dev_info(dev, "Clock is already stopped\n");
+		return 0;
+	}
+
+	/* Write the MCP Control register to prevent block wakeup */
+	mcp_control = cnl_sdw_reg_readl(data->sdw_regs,
+					SDW_CNL_MCP_CONTROL);
+	mcp_control |= (MCP_CONTROL_BLOCKWAKEUP_MASK <<
+				MCP_CONTROL_BLOCKWAKEUP_SHIFT);
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_CONTROL, mcp_control);
+
+	/* Prepare all the slaves for clock stop */
+	ret = sdw_prepare_for_clock_change(sdw->mstr, 1, &clock_stop_mode);
+	if (ret)
+		return ret;
+
+	/* Call bus function to broadcast the clock stop now */
+	ret = sdw_stop_clock(sdw->mstr, clock_stop_mode);
+	if (ret)
+		return ret;
+	/* Wait for clock to be stopped, we are waiting at max 1sec now */
+	while (timeout != 10) {
+		mcp_stat = cnl_sdw_reg_readl(data->sdw_regs,
+					SDW_CNL_MCP_STAT);
+		if (mcp_stat & (MCP_STAT_CLOCKSTOPPED_MASK <<
+			MCP_STAT_CLOCKSTOPPED_SHIFT))
+			break;
+		msleep(100);
+		timeout++;
+	}
+	mcp_stat = cnl_sdw_reg_readl(data->sdw_regs,
+					SDW_CNL_MCP_STAT);
+	if (!(mcp_stat & (MCP_STAT_CLOCKSTOPPED_MASK <<
+				MCP_STAT_CLOCKSTOPPED_SHIFT))) {
+		dev_err(dev, "Clock Stop failed\n");
+		ret = -EBUSY;
+		goto out;
+	}
+	/* Switch control from master IP to glue */
+	sdw_switch_to_glue(sdw);
+
+	sdw_power_down_link(sdw);
+
+	/* Enable the wakeup */
+	cnl_sdw_reg_writew(data->sdw_shim,
+			SDW_CNL_SNDWWAKEEN_REG_OFFSET,
+			(0x1 << data->inst_id));
+out:
+	return ret;
+}
+
+static int cnl_sdw_clock_stop_exit(struct cnl_sdw *sdw)
+{
+	u16 wake_en, wake_sts, ioctl;
+	int volatile mcp_control;
+	int timeout = 0;
+	struct cnl_sdw_data *data = &sdw->data;
+	int ioctl_offset = SDW_CNL_IOCTL + (data->inst_id *
+					SDW_CNL_IOCTL_REG_OFFSET);
+
+	/* Disable the wake up interrupt */
+	wake_en = cnl_sdw_reg_readw(data->sdw_shim,
+				SDW_CNL_SNDWWAKEEN_REG_OFFSET);
+	wake_en &= ~(0x1 << data->inst_id);
+	cnl_sdw_reg_writew(data->sdw_shim, SDW_CNL_SNDWWAKEEN_REG_OFFSET,
+				wake_en);
+
+	/* Clear wake status. This may be set if Slave requested wakeup has
+	 * happened, or may not be if it master requested. But in any case
+	 * this wont make any harm
+	 */
+	wake_sts = cnl_sdw_reg_readw(data->sdw_shim,
+				SDW_CNL_SNDWWAKESTS_REG_OFFSET);
+	wake_sts |= (0x1 << data->inst_id);
+	cnl_sdw_reg_writew(data->sdw_shim, SDW_CNL_SNDWWAKESTS_REG_OFFSET,
+				wake_sts);
+
+	ioctl = cnl_sdw_reg_readw(data->sdw_shim, ioctl_offset);
+	ioctl |= CNL_IOCTL_DO_MASK << CNL_IOCTL_DO_SHIFT;
+	cnl_sdw_reg_writew(data->sdw_shim,  ioctl_offset, ioctl);
+	ioctl |= CNL_IOCTL_DOE_MASK << CNL_IOCTL_DOE_SHIFT;
+	cnl_sdw_reg_writew(data->sdw_shim,  ioctl_offset, ioctl);
+	/* Switch control back to master */
+	sdw_switch_to_mip(sdw);
+
+	mcp_control = cnl_sdw_reg_readl(data->sdw_regs,
+					SDW_CNL_MCP_CONTROL);
+	mcp_control &= ~(MCP_CONTROL_BLOCKWAKEUP_MASK <<
+				MCP_CONTROL_BLOCKWAKEUP_SHIFT);
+	mcp_control |= (MCP_CONTROL_CLOCKSTOPCLEAR_MASK <<
+				MCP_CONTROL_CLOCKSTOPCLEAR_SHIFT);
+	cnl_sdw_reg_writel(data->sdw_regs, SDW_CNL_MCP_CONTROL, mcp_control);
+	/*
+	 * Wait for timeout to be clear to successful enabling of the clock
+	 * We will wait for 1sec before giving up
+	 */
+	while (timeout != 10) {
+		mcp_control = cnl_sdw_reg_readl(data->sdw_regs,
+					SDW_CNL_MCP_CONTROL);
+		if ((mcp_control & (MCP_CONTROL_CLOCKSTOPCLEAR_MASK <<
+				MCP_CONTROL_CLOCKSTOPCLEAR_SHIFT)) == 0)
+			break;
+		msleep(1000);
+		timeout++;
+	}
+	mcp_control = cnl_sdw_reg_readl(data->sdw_regs,
+					SDW_CNL_MCP_CONTROL);
+	if ((mcp_control & (MCP_CONTROL_CLOCKSTOPCLEAR_MASK <<
+			MCP_CONTROL_CLOCKSTOPCLEAR_SHIFT)) != 0) {
+		dev_err(&sdw->mstr->dev, "Clop Stop Exit failed\n");
+		return -EBUSY;
+	}
+
+	dev_info(&sdw->mstr->dev, "Exit from clock stop successful\n");
+	return 0;
+
+}
+
+static int cnl_sdw_runtime_resume(struct device *dev)
+{
+	struct cnl_sdw *sdw = dev_get_drvdata(dev);
+	struct cnl_sdw_data *data = &sdw->data;
+	int volatile mcp_stat;
+	struct sdw_master *mstr;
+	int ret = 0;
+
+	mstr = sdw->mstr;
+	/*
+	 * If already resumed, do nothing. This can happen because of
+	 * wakeup enable.
+	 */
+	mcp_stat = cnl_sdw_reg_readl(data->sdw_regs,
+					SDW_CNL_MCP_STAT);
+	if (!(mcp_stat & (MCP_STAT_CLOCKSTOPPED_MASK <<
+				MCP_STAT_CLOCKSTOPPED_SHIFT))) {
+		dev_info(dev, "Clock is already running\n");
+		return 0;
+	}
+	dev_info(dev, "%s %d Clock is stopped\n", __func__, __LINE__);
+
+	ret = cnl_sdw_clock_stop_exit(sdw);
+	if (ret)
+		return ret;
+	dev_info(&mstr->dev, "Exit from clock stop successful\n");
+
+	/* Prepare all the slaves to comeout of clock stop */
+	ret = sdw_prepare_for_clock_change(sdw->mstr, 0, NULL);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int cnl_sdw_sleep_resume(struct device *dev)
+{
+	return cnl_sdw_runtime_resume(dev);
+}
+static int cnl_sdw_sleep_suspend(struct device *dev)
+{
+	return cnl_sdw_runtime_suspend(dev);
+}
+#endif
+
+static const struct dev_pm_ops cnl_sdw_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(cnl_sdw_sleep_suspend, cnl_sdw_sleep_resume)
+	SET_RUNTIME_PM_OPS(cnl_sdw_runtime_suspend,
+				cnl_sdw_runtime_resume, NULL)
+};
+
+static struct sdw_master_ops cnl_sdw_master_ops  = {
+	.xfer_msg = cnl_sdw_xfer_msg,
+	.xfer_bulk = cnl_sdw_xfer_bulk,
+	.monitor_handover = cnl_sdw_mon_handover,
+	.set_ssp_interval = cnl_sdw_set_ssp_interval,
+	.set_clock_freq = cnl_sdw_set_clock_freq,
+	.set_frame_shape = NULL,
+};
+
+static struct sdw_master_port_ops cnl_sdw_master_port_ops = {
+	.dpn_set_port_params = cnl_sdw_set_port_params,
+	.dpn_set_port_transport_params = cnl_sdw_set_port_transport_params,
+	.dpn_port_activate_ch = cnl_sdw_port_activate_ch,
+	.dpn_port_activate_ch_pre = cnl_sdw_port_activate_ch_pre,
+	.dpn_port_activate_ch_post = cnl_sdw_port_activate_ch_post,
+	.dpn_port_prepare_ch = NULL,
+	.dpn_port_prepare_ch_pre = NULL,
+	.dpn_port_prepare_ch_post = NULL,
+
+};
+
+static struct sdw_mstr_driver cnl_sdw_mstr_driver = {
+	.driver_type = SDW_DRIVER_TYPE_MASTER,
+	.driver = {
+		.name   = "cnl_sdw_mstr",
+		.pm	= &cnl_sdw_pm_ops,
+	},
+	.probe          = cnl_sdw_probe,
+	.remove         = cnl_sdw_remove,
+	.mstr_ops	= &cnl_sdw_master_ops,
+	.mstr_port_ops = &cnl_sdw_master_port_ops,
+};
+
+static int __init cnl_sdw_init(void)
+{
+	return sdw_mstr_driver_register(&cnl_sdw_mstr_driver);
+}
+module_init(cnl_sdw_init);
+
+static void cnl_sdw_exit(void)
+{
+	sdw_mstr_driver_unregister(&cnl_sdw_mstr_driver);
+}
+module_exit(cnl_sdw_exit);
+
+MODULE_DESCRIPTION("Intel SoundWire Master Controller Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Hardik Shah <hardik.t.shah@intel.com>");
diff --git a/drivers/sdw/sdw_cnl_priv.h b/drivers/sdw/sdw_cnl_priv.h
new file mode 100644
index 000000000000..914f7cae2b01
--- /dev/null
+++ b/drivers/sdw/sdw_cnl_priv.h
@@ -0,0 +1,337 @@
+/*
+ *  sdw_cnl_priv.h - Private definition for intel master controller driver.
+ *
+ *  Copyright (C) 2014-2015 Intel Corp
+ *  Author:  Hardik Shah  <hardik.t.shah@intel.com>
+ *
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+#ifndef _LINUX_SDW_CNL_PRIV_H
+#define _LINUX_SDW_CNL_PRIV_H
+
+#define SDW_CNL_PM_TIMEOUT	3000 /* ms */
+#define SDW_CNL_SLAVES_STAT_UPPER_DWORD_SHIFT 32
+#define SDW_CNL_SLAVE_STATUS_BITS	4
+#define SDW_CNL_CMD_WORD_LEN	4
+#define SDW_CNL_DEFAULT_SSP_INTERVAL	0x32
+#define SDW_CNL_PORT_REG_OFFSET		0x80
+#define CNL_SDW_SCP_ADDR_REGS		0x2
+#define SDW_CNL_PCM_PDI_NUM_OFFSET	0x2
+#define SDW_CNL_PDM_PDI_NUM_OFFSET	0x6
+
+#define SDW_CNL_CTMCTL_REG_OFFSET	0x60
+#define SDW_CNL_IOCTL_REG_OFFSET	0x60
+#define SDW_CNL_PCMSCAP_REG_OFFSET	0x60
+#define SDW_CNL_PCMSCHC_REG_OFFSET	0x60
+#define SDW_CNL_PDMSCAP_REG_OFFSET	0x60
+#define SDW_CNL_PCMSCHM_REG_OFFSET	0x60
+#define SDW_CNL_SNDWWAKEEN_REG_OFFSET   0x190
+#define SDW_CNL_SNDWWAKESTS_REG_OFFSET   0x192
+
+
+#define SDW_CNL_MCP_CONFIG			0x0
+#define MCP_CONFIG_BRELENABLE_MASK		0x1
+#define MCP_CONFIG_BRELENABLE_SHIFT		0x6
+#define MCP_CONFIG_MAXCMDRETRY_SHIFT		24
+#define MCP_CONFIG_MAXCMDRETRY_MASK		0xF
+#define MCP_CONFIG_MAXPREQDELAY_SHIFT		16
+#define MCP_CONFIG_MAXPREQDELAY_MASK		0x1F
+#define MCP_CONFIG_MMMODEEN_SHIFT		0x7
+#define MCP_CONFIG_MMMODEEN_MASK		0x1
+#define MCP_CONFIG_SNIFFEREN_SHIFT		0x5
+#define MCP_CONFIG_SNIFFEREN_MASK		0x1
+#define MCP_CONFIG_SSPMODE_SHIFT		0x4
+#define MCP_CONFIG_SSPMODE_MASK			0x1
+#define MCP_CONFIG_CMDMODE_SHIFT		0x3
+#define MCP_CONFIG_CMDMODE_MASK			0x1
+
+#define MCP_CONFIG_OPERATIONMODE_MASK		0x7
+#define MCP_CONFIG_OPERATIONMODE_SHIFT		0x0
+#define MCP_CONFIG_OPERATIONMODE_NORMAL		0x0
+
+#define SDW_CNL_MCP_CONTROL			0x4
+#define MCP_CONTROL_RESETDELAY_SHIFT		0x8
+#define MCP_CONTROL_CMDRST_SHIFT		0x7
+#define MCP_CONTROL_CMDRST_MASK			0x1
+#define MCP_CONTROL_SOFTRST_SHIFT		0x6
+#define MCP_CONTROL_SOFTCTRLBUSRST_SHIFT	0x5
+#define MCP_CONTROL_HARDCTRLBUSRST_SHIFT	0x4
+#define MCP_CONTROL_CLOCKPAUSEREQ_SHIFT		0x3
+#define MCP_CONTROL_CLOCKSTOPCLEAR_SHIFT	0x2
+#define MCP_CONTROL_CLOCKSTOPCLEAR_MASK		0x1
+#define MCP_CONTROL_CMDACCEPTMODE_MASK		0x1
+#define MCP_CONTROL_CMDACCEPTMODE_SHIFT		0x1
+#define MCP_CONTROL_BLOCKWAKEUP_SHIFT		0x0
+#define MCP_CONTROL_BLOCKWAKEUP_MASK		0x1
+
+
+#define MCP_SLAVEINTMASK0_MASK			0xFFFFFFFF
+#define MCP_SLAVEINTMASK1_MASK			0x0000FFFF
+
+#define SDW_CNL_MCP_CMDCTRL			0x8
+#define SDW_CNL_MCP_SSPSTAT			0xC
+#define SDW_CNL_MCP_FRAMESHAPE			0x10
+#define SDW_CNL_MCP_FRAMESHAPEINIT		0x14
+#define SDW_CNL_MCP_CONFIGUPDATE		0x18
+#define MCP_CONFIGUPDATE_CONFIGUPDATE_SHIFT	0x0
+#define MCP_CONFIGUPDATE_CONFIGUPDATE_MASK	0x1
+
+#define SDW_CNL_MCP_PHYCTRL			0x1C
+#define SDW_CNL_MCP_SSPCTRL0			0x20
+#define SDW_CNL_MCP_SSPCTRL1			0x28
+#define SDW_CNL_MCP_CLOCKCTRL0			0x30
+#define SDW_CNL_MCP_CLOCKCTRL1			0x38
+#define SDW_CNL_MCP_STAT			0x40
+#define SDW_CNL_MCP_INTSTAT			0x44
+#define MCP_INTSTAT_IRQ_SHIFT			31
+#define MCP_INTSTAT_IRQ_MASK			1
+#define MCP_INTSTAT_WAKEUP_SHIFT		16
+#define MCP_INTSTAT_SLAVE_STATUS_CHANGED_SHIFT	12
+#define MCP_INTSTAT_SLAVE_STATUS_CHANGED_MASK	0xF
+#define MCP_INTSTAT_SLAVENOTATTACHED_SHIFT	12
+#define MCP_INTSTAT_SLAVEATTACHED_SHIFT		13
+#define MCP_INTSTAT_SLAVEALERT_SHIFT		14
+#define MCP_INTSTAT_SLAVERESERVED_SHIFT		15
+
+#define MCP_INTSTAT_DPPDIINT_SHIFT		11
+#define MCP_INTSTAT_DPPDIINTMASK		0x1
+#define MCP_INTSTAT_CONTROLBUSCLASH_SHIFT	10
+#define MCP_INTSTAT_CONTROLBUSCLASH_MASK	0x1
+#define MCP_INTSTAT_DATABUSCLASH_SHIFT		9
+#define MCP_INTSTAT_DATABUSCLASH_MASK		0x1
+#define MCP_INTSTAT_CMDERR_SHIFT		7
+#define MCP_INTSTAT_CMDERR_MASK			0x1
+#define MCP_INTSTAT_TXE_SHIFT			1
+#define MCP_INTSTAT_TXE_MASK			0x1
+#define MCP_INTSTAT_RXWL_SHIFT			2
+#define MCP_INTSTAT_RXWL_MASK			1
+
+#define SDW_CNL_MCP_INTMASK			0x48
+#define MCP_INTMASK_IRQEN_SHIFT			31
+#define MCP_INTMASK_IRQEN_MASK			0x1
+#define MCP_INTMASK_WAKEUP_SHIFT		16
+#define MCP_INTMASK_WAKEUP_MASK			0x1
+#define MCP_INTMASK_SLAVERESERVED_SHIFT		15
+#define MCP_INTMASK_SLAVERESERVED_MASK		0x1
+#define MCP_INTMASK_SLAVEALERT_SHIFT		14
+#define MCP_INTMASK_SLAVEALERT_MASK		0x1
+#define MCP_INTMASK_SLAVEATTACHED_SHIFT		13
+#define MCP_INTMASK_SLAVEATTACHED_MASK		0x1
+#define MCP_INTMASK_SLAVENOTATTACHED_SHIFT	12
+#define MCP_INTMASK_SLAVENOTATTACHED_MASK	0x1
+#define MCP_INTMASK_DPPDIINT_SHIFT		11
+#define MCP_INTMASK_DPPDIINT_MASK		0x1
+#define MCP_INTMASK_CONTROLBUSCLASH_SHIFT	10
+#define MCP_INTMASK_CONTROLBUSCLASH_MASK	1
+#define MCP_INTMASK_DATABUSCLASH_SHIFT		9
+#define MCP_INTMASK_DATABUSCLASH_MASK		1
+#define MCP_INTMASK_CMDERR_SHIFT		7
+#define MCP_INTMASK_CMDERR_MASK			0x1
+#define MCP_INTMASK_TXE_SHIFT			1
+#define MCP_INTMASK_TXE_MASK			0x1
+#define MCP_INTMASK_RXWL_SHIFT			2
+#define MCP_INTMASK_RXWL_MASK			0x1
+
+#define SDW_CNL_MCP_INTSET			0x4C
+#define SDW_CNL_MCP_STAT			0x40
+#define MCP_STAT_ACTIVE_BANK_MASK		0x1
+#define MCP_STAT_ACTIVE_BANK_SHIT		20
+#define MCP_STAT_CLOCKSTOPPED_MASK		0x1
+#define MCP_STAT_CLOCKSTOPPED_SHIFT		16
+
+#define SDW_CNL_MCP_SLAVESTAT			0x50
+#define MCP_SLAVESTAT_MASK			0x3
+
+#define SDW_CNL_MCP_SLAVEINTSTAT0		0x54
+#define MCP_SLAVEINTSTAT_NOT_PRESENT_MASK	0x1
+#define MCP_SLAVEINTSTAT_ATTACHED_MASK		0x2
+#define MCP_SLAVEINTSTAT_ALERT_MASK		0x4
+#define MCP_SLAVEINTSTAT_RESERVED_MASK		0x8
+
+#define SDW_CNL_MCP_SLAVEINTSTAT1		0x58
+#define SDW_CNL_MCP_SLAVEINTMASK0		0x5C
+#define SDW_CNL_MCP_SLAVEINTMASK1		0x60
+#define SDW_CNL_MCP_PORTINTSTAT			0x64
+#define SDW_CNL_MCP_PDISTAT			0x6C
+
+#define SDW_CNL_MCP_FIFOLEVEL			0x78
+#define SDW_CNL_MCP_FIFOSTAT			0x7C
+#define MCP_RX_FIFO_AVAIL_MASK			0x3F
+#define SDW_CNL_MCP_COMMAND_BASE		0x80
+#define SDW_CNL_MCP_RESPONSE_BASE		0x80
+#define SDW_CNL_MCP_COMMAND_LENGTH		0x20
+
+#define MCP_COMMAND_SSP_TAG_MASK		0x1
+#define MCP_COMMAND_SSP_TAG_SHIFT		31
+#define MCP_COMMAND_COMMAND_MASK		0x7
+#define MCP_COMMAND_COMMAND_SHIFT		28
+#define MCP_COMMAND_DEV_ADDR_MASK		0xF
+#define MCP_COMMAND_DEV_ADDR_SHIFT		24
+#define MCP_COMMAND_REG_ADDR_H_MASK		0x7
+#define MCP_COMMAND_REG_ADDR_H_SHIFT		16
+#define MCP_COMMAND_REG_ADDR_L_MASK		0xFF
+#define MCP_COMMAND_REG_ADDR_L_SHIFT		8
+#define MCP_COMMAND_REG_DATA_MASK		0xFF
+#define MCP_COMMAND_REG_DATA_SHIFT		0x0
+
+#define MCP_RESPONSE_RDATA_MASK			0xFF
+#define MCP_RESPONSE_RDATA_SHIFT		8
+#define MCP_RESPONSE_ACK_MASK			0x1
+#define MCP_RESPONSE_ACK_SHIFT			0
+#define MCP_RESPONSE_NACK_MASK			0x2
+
+#define SDW_CNL_DPN_CONFIG0			0x100
+#define SDW_CNL_DPN_CHANNELEN0		0x104
+#define SDW_CNL_DPN_SAMPLECTRL0		0x108
+#define SDW_CNL_DPN_OFFSETCTRL0		0x10C
+#define SDW_CNL_DPN_HCTRL0			0x110
+#define SDW_CNL_DPN_ASYNCCTRL0		0x114
+
+#define SDW_CNL_DPN_CONFIG1			0x118
+#define SDW_CNL_DPN_CHANNELEN1		0x11C
+#define SDW_CNL_DPN_SAMPLECTRL1		0x120
+#define SDW_CNL_DPN_OFFSETCTRL1		0x124
+#define SDW_CNL_DPN_HCTRL1			0x128
+
+#define SDW_CNL_PORTCTRL			0x130
+#define PORTCTRL_PORT_DIRECTION_SHIFT		0x7
+#define PORTCTRL_PORT_DIRECTION_MASK		0x1
+#define PORTCTRL_BANK_INVERT_SHIFT		0x8
+#define PORTCTRL_BANK_INVERT_MASK		0x1
+
+#define SDW_CNL_PDINCONFIG0			0x1100
+#define SDW_CNL_PDINCONFIG1			0x1108
+#define PDINCONFIG_CHANNEL_MASK_SHIFT		0x8
+#define PDINCONFIG_CHANNEL_MASK_MASK		0xFF
+#define PDINCONFIG_PORT_NUMBER_SHIFT		0x0
+#define PDINCONFIG_PORT_NUMBER_MASK		0x1F
+
+#define DPN_CONFIG_WL_SHIFT			0x8
+#define DPN_CONFIG_WL_MASK			0x1F
+#define DPN_CONFIG_PF_MODE_SHIFT		0x0
+#define DPN_CONFIG_PF_MODE_MASK			0x3
+#define DPN_CONFIG_PD_MODE_SHIFT		0x2
+#define DPN_CONFIG_PD_MODE_MASK			0x3
+#define DPN_CONFIG_BPM_MASK			0x1
+#define DPN_CONFIG_BPM_SHIFT			0x12
+#define DPN_CONFIG_BGC_MASK			0x3
+#define DPN_CONFIG_BGC_SHIFT			0x10
+
+#define DPN_SAMPLECTRL_SI_MASK			0xFFFF
+#define DPN_SAMPLECTRL_SI_SHIFT			0x0
+
+#define DPN_OFFSETCTRL0_OF1_MASK		0xFF
+#define DPN_OFFSETCTRL0_OF1_SHIFT		0x0
+#define DPN_OFFSETCTRL0_OF2_MASK		0xFF
+#define DPN_OFFSETCTRL0_OF2_SHIFT		0x8
+
+#define DPN_HCTRL_HSTOP_MASK			0xF
+#define DPN_HCTRL_HSTOP_SHIFT			0x0
+#define DPN_HCTRL_HSTART_MASK			0xF
+#define DPN_HCTRL_HSTART_SHIFT			0x4
+#define DPN_HCTRL_LCONTROL_MASK			0x7
+#define DPN_HCTRL_LCONTROL_SHIFT		0x8
+
+/* SoundWire Shim registers */
+#define SDW_CNL_LCAP				0x0
+#define SDW_CNL_LCTL				0x4
+#define CNL_LCTL_CPA_SHIFT			8
+#define CNL_LCTL_SPA_SHIFT			0
+#define CNL_LCTL_CPA_MASK			0x1
+#define CNL_LCTL_SPA_MASK			0x1
+
+#define SDW_CNL_IPPTR				0x8
+#define SDW_CNL_SYNC				0xC
+#define CNL_SYNC_CMDSYNC_MASK			0x1
+#define CNL_SYNC_CMDSYNC_SHIFT			16
+#define CNL_SYNC_SYNCGO_MASK			0x1
+#define CNL_SYNC_SYNCGO_SHIFT			0x18
+
+#define SDW_CNL_CTLSCAP				0x10
+#define SDW_CNL_CTLS0CM				0x12
+#define SDW_CNL_CTLS1CM				0x14
+#define SDW_CNL_CTLS2CM				0x16
+#define SDW_CNL_CTLS3CM				0x18
+
+#define SDW_CNL_PCMSCAP				0x20
+#define CNL_PCMSCAP_BSS_SHIFT			8
+#define CNL_PCMSCAP_BSS_MASK			0x1F
+#define CNL_PCMSCAP_OSS_SHIFT			4
+#define CNL_PCMSCAP_OSS_MASK			0xF
+#define CNL_PCMSCAP_ISS_SHIFT			0
+#define CNL_PCMSCAP_ISS_MASK			0xF
+
+#define SDW_CNL_PCMSCHM				0x22
+#define CNL_PCMSYCM_DIR_SHIFT			15
+#define CNL_PCMSYCM_DIR_MASK			0x1
+#define CNL_PCMSYCM_STREAM_SHIFT		8
+#define CNL_PCMSYCM_STREAM_MASK			0x3F
+#define CNL_PCMSYCM_HCHAN_SHIFT			4
+#define CNL_PCMSYCM_HCHAN_MASK			0xF
+#define CNL_PCMSYCM_LCHAN_SHIFT			0
+#define CNL_PCMSYCM_LCHAN_MASK			0xF
+
+#define SDW_CNL_PCMSCHC				0x42
+
+#define SDW_CNL_PDMSCAP				0x62
+#define CNL_PDMSCAP_BSS_SHIFT			8
+#define CNL_PDMSCAP_BSS_MASK			0x1F
+#define CNL_PDMSCAP_OSS_SHIFT			4
+#define CNL_PDMSCAP_OSS_MASK			0xF
+#define CNL_PDMSCAP_ISS_SHIFT			0
+#define CNL_PDMSCAP_ISS_MASK			0xF
+#define CNL_PDMSCAP_CPSS_SHIFT			13
+#define CNL_PDMSCAP_CPSS_MASK			0x7
+#define SDW_CNL_PDMSCM
+
+#define SDW_CNL_IOCTL				0x6C
+#define CNL_IOCTL_MIF_SHIFT			0x0
+#define CNL_IOCTL_MIF_MASK			0x1
+#define CNL_IOCTL_CO_SHIFT			0x1
+#define CNL_IOCTL_CO_MASK			0x1
+#define CNL_IOCTL_COE_SHIFT			0x2
+#define CNL_IOCTL_COE_MASK			0x1
+#define CNL_IOCTL_DO_SHIFT			0x3
+#define CNL_IOCTL_DO_MASK			0x1
+#define CNL_IOCTL_DOE_SHIFT			0x4
+#define CNL_IOCTL_DOE_MASK			0x1
+#define CNL_IOCTL_BKE_SHIFT			0x5
+#define CNL_IOCTL_BKE_MASK			0x1
+#define CNL_IOCTL_WPDD_SHIFT			0x6
+#define CNL_IOCTL_WPDD_MASK			0x1
+#define CNL_IOCTL_CIBD_SHIFT			0x8
+#define CNL_IOCTL_CIBD_MASK			0x1
+#define CNL_IOCTL_DIBD_SHIFT			0x9
+#define CNL_IOCTL_DIBD_MASK			0x1
+
+#define SDW_CNL_CTMCTL_OFFSET			0x60
+#define SDW_CNL_CTMCTL				0x6E
+#define CNL_CTMCTL_DACTQE_SHIFT			0x0
+#define CNL_CTMCTL_DACTQE_MASK			0x1
+#define CNL_CTMCTL_DODS_SHIFT			0x1
+#define CNL_CTMCTL_DODS_MASK			0x1
+#define CNL_CTMCTL_DOAIS_SHIFT			0x3
+#define CNL_CTMCTL_DOAIS_MASK			0x3
+
+#define ALH_CNL_STRMZCFG_BASE			0x4
+#define ALH_CNL_STRMZCFG_OFFSET			0x4
+#define CNL_STRMZCFG_DMAT_SHIFT			0x0
+#define CNL_STRMZCFG_DMAT_MASK			0xFF
+#define CNL_STRMZCFG_DMAT_VAL			0x3
+#define CNL_STRMZCFG_CHAN_SHIFT			16
+#define CNL_STRMZCFG_CHAN_MASK			0xF
+
+#endif /* _LINUX_SDW_CNL_H */
diff --git a/drivers/sdw/sdw_maxim.c b/drivers/sdw/sdw_maxim.c
new file mode 100644
index 000000000000..0081c5c00497
--- /dev/null
+++ b/drivers/sdw/sdw_maxim.c
@@ -0,0 +1,146 @@
+/*
+ * sdw_maxim.c -- Maxim SoundWire slave device driver. Dummy driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/sdw_bus.h>
+#include <linux/module.h>
+
+
+static int maxim_register_sdw_capabilties(struct sdw_slv *sdw,
+				 const struct sdw_slv_id *sdw_id)
+{
+	struct sdw_slv_capabilities cap;
+	struct sdw_slv_dpn_capabilities *dpn_cap = NULL;
+	struct port_audio_mode_properties *prop = NULL;
+	int i, j;
+
+	cap.wake_up_unavailable = true;
+	cap.test_mode_supported = false;
+	cap.clock_stop1_mode_supported = false;
+	cap.simplified_clock_stop_prepare = false;
+	cap.highphy_capable = true;
+	cap.paging_supported = false;
+	cap.bank_delay_support = false;
+	cap.port_15_read_behavior = 0;
+	cap.sdw_dp0_supported = false;
+	cap.num_of_sdw_ports = 3;
+	cap.sdw_dpn_cap = devm_kzalloc(&sdw->dev,
+			((sizeof(struct sdw_slv_dpn_capabilities)) *
+			cap.num_of_sdw_ports), GFP_KERNEL);
+	for (i = 0; i < cap.num_of_sdw_ports; i++) {
+		dpn_cap = &cap.sdw_dpn_cap[i];
+		if (i == 0 || i == 2)
+			dpn_cap->port_direction = SDW_PORT_SOURCE;
+		else
+			dpn_cap->port_direction = SDW_PORT_SINK;
+
+		dpn_cap->port_number = i+1;
+		dpn_cap->max_word_length =  24;
+		dpn_cap->min_word_length = 16;
+		dpn_cap->num_word_length = 0;
+		dpn_cap->word_length_buffer = NULL;
+		dpn_cap->dpn_type = SDW_FULL_DP;
+		dpn_cap->dpn_grouping = SDW_BLOCKGROUPCOUNT_1;
+		dpn_cap->prepare_ch = SDW_CP_SM;
+		dpn_cap->imp_def_intr_mask = 0x0;
+		dpn_cap->min_ch_num = 1;
+		dpn_cap->max_ch_num = 2;
+		dpn_cap->num_ch_supported = 0;
+		dpn_cap->ch_supported = NULL;
+		dpn_cap->port_flow_mode_mask = SDW_PORT_FLOW_MODE_ISOCHRONOUS;
+		dpn_cap->block_packing_mode_mask =
+				SDW_PORT_BLK_PKG_MODE_BLK_PER_PORT_MASK |
+				SDW_PORT_BLK_PKG_MODE_BLK_PER_CH_MASK;
+		dpn_cap->port_encoding_type_mask =
+				SDW_PORT_ENCODING_TYPE_TWOS_CMPLMNT |
+				SDW_PORT_ENCODING_TYPE_SIGN_MAGNITUDE |
+				SDW_PORT_ENCODING_TYPE_IEEE_32_FLOAT;
+		dpn_cap->num_audio_modes = 1;
+
+		dpn_cap->mode_properties = devm_kzalloc(&sdw->dev,
+				((sizeof(struct port_audio_mode_properties)) *
+				dpn_cap->num_audio_modes), GFP_KERNEL);
+		for (j = 0; j < dpn_cap->num_audio_modes; j++) {
+			prop = &dpn_cap->mode_properties[j];
+			prop->max_frequency = 16000000;
+			prop->min_frequency = 1000000;
+			prop->num_freq_configs = 0;
+			prop->freq_supported = NULL;
+			prop->glitchless_transitions_mask = 0x1;
+			prop->max_sampling_frequency = 192000;
+			prop->min_sampling_frequency = 8000;
+			prop->num_sampling_freq_configs = 0;
+			prop->sampling_freq_config = NULL;
+			prop->ch_prepare_behavior = SDW_CH_PREP_ANY_TIME;
+		}
+	}
+	return sdw_register_slave_capabilities(sdw, &cap);
+
+}
+static int maxim_sdw_probe(struct sdw_slv *sdw,
+				 const struct sdw_slv_id *sdw_id)
+{
+	dev_info(&sdw->dev, "Maxim SoundWire Slave Registered %lx\n", sdw_id->driver_data);
+	return maxim_register_sdw_capabilties(sdw, sdw_id);
+}
+
+static int maxim_sdw_remove(struct sdw_slv *sdw)
+{
+	dev_info(&sdw->dev, "Maxim SoundWire Slave un-Registered\n");
+	return 0;
+}
+
+static const struct sdw_slv_id maxim_id[] = {
+	{"03:01:9f:79:00:00", 0},
+	{"09:01:9f:79:00:00", 1},
+	{"04:01:9f:79:00:00", 2},
+	{"0a:01:9f:79:00:00", 3},
+	{"04:01:9f:79:00:00", 4},
+	{"0a:01:9f:79:00:00", 5},
+	{"05:01:9f:79:00:00", 6},
+	{"06:01:9f:79:00:00", 7},
+	{"05:01:9f:79:00:00", 8},
+	{"00:01:9f:79:00:00", 9},
+	{"06:01:9f:79:00:00", 10},
+	{"07:01:9f:79:00:00", 11},
+	{"00:01:9f:79:00:00", 12},
+	{"06:01:9f:79:00:00", 13},
+	{"01:01:9f:79:00:00", 14},
+	{"07:01:9f:79:00:00", 15},
+	{"08:01:9f:79:00:00", 16},
+	{"01:01:9f:79:00:00", 17},
+	{"07:01:9f:79:00:00", 18},
+	{"02:01:9f:79:00:00", 19},
+	{"08:01:9f:79:00:00", 20},
+	{"09:01:9f:79:00:00", 21},
+	{"02:01:9f:79:00:00", 22},
+	{"08:01:9f:79:00:00", 23},
+	{"03:01:9f:79:00:00", 24},
+	{"09:01:9f:79:00:00", 25},
+	{"0a:01:9f:79:00:00", 26},
+	{},
+};
+
+MODULE_DEVICE_TABLE(sdwint, maxim_id);
+
+static struct sdw_slave_driver maxim_sdw_driver = {
+	.driver_type = SDW_DRIVER_TYPE_SLAVE,
+	.driver = {
+		   .name = "maxim",
+		   },
+	.probe = maxim_sdw_probe,
+	.remove = maxim_sdw_remove,
+	.id_table = maxim_id,
+};
+
+module_sdw_slave_driver(maxim_sdw_driver);
+
+MODULE_DESCRIPTION("SoundWire Maxim Slave Driver");
+MODULE_AUTHOR("Hardik Shah, <hardik.t.shah@intel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/sdw/sdw_priv.h b/drivers/sdw/sdw_priv.h
new file mode 100644
index 000000000000..5ec3edc30d27
--- /dev/null
+++ b/drivers/sdw/sdw_priv.h
@@ -0,0 +1,243 @@
+/*
+ *  sdw_priv.h - Private definition for sdw bus interface.
+ *
+ *  Copyright (C) 2014-2015 Intel Corp
+ *  Author:  Hardik Shah  <hardik.t.shah@intel.com>
+ *
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+#ifndef _LINUX_SDW_PRIV_H
+#define _LINUX_SDW_PRIV_H
+
+#include <linux/kthread.h>	/* For kthread */
+#include <linux/spinlock.h>
+
+#define SDW_MAX_STREAM_TAG_KEY_SIZE	80
+#define SDW_NUM_STREAM_TAGS		100
+#define MAX_NUM_ROWS			23 /* As per SDW Spec */
+#define MAX_NUM_COLS			8/* As per SDW Spec */
+#define MAX_NUM_ROW_COLS		(MAX_NUM_ROWS * MAX_NUM_COLS)
+
+#define SDW_STATE_INIT_STREAM_TAG	    0x1
+#define SDW_STATE_ALLOC_STREAM              0x2
+#define SDW_STATE_CONFIG_STREAM             0x3
+#define SDW_STATE_COMPUTE_STREAM	    0x4
+#define SDW_STATE_PREPARE_STREAM            0x5
+#define SDW_STATE_ENABLE_STREAM             0x6
+#define SDW_STATE_DISABLE_STREAM            0x7
+#define SDW_STATE_UNPREPARE_STREAM          0x8
+#define SDW_STATE_UNCOMPUTE_STREAM	    0x9
+#define SDW_STATE_RELEASE_STREAM            0xa
+#define SDW_STATE_FREE_STREAM               0xb
+#define SDW_STATE_FREE_STREAM_TAG           0xc
+#define SDW_STATE_ONLY_XPORT_STREAM	    0xd
+
+#define SDW_STATE_INIT_RT		0x1
+#define SDW_STATE_CONFIG_RT		0x2
+#define SDW_STATE_PREPARE_RT		0x3
+#define SDW_STATE_ENABLE_RT		0x4
+#define SDW_STATE_DISABLE_RT		0x5
+#define SDW_STATE_UNPREPARE_RT		0x6
+#define SDW_STATE_RELEASE_RT		0x7
+
+struct sdw_runtime;
+/* Defined in sdw.c, used by multiple files of module */
+extern struct sdw_core sdw_core;
+
+enum sdw_port_state {
+	SDW_PORT_STATE_CH_READY,
+	SDW_PORT_STATE_CH_STOPPED,
+	SDW_PORT_STATE_CH_PREPARING,
+	SDW_PORT_STATE_CH_DEPREPARING,
+};
+
+enum sdw_stream_state {
+	SDW_STREAM_ALLOCATED,
+	SDW_STREAM_FREE,
+	SDW_STREAM_ACTIVE,
+	SDW_STREAM_INACTIVE,
+};
+
+enum sdw_clk_state {
+	SDW_CLK_STATE_OFF = 0,
+	SDW_CLK_STATE_ON = 1,
+};
+
+struct port_chn_en_state {
+	bool is_activate;
+	bool is_bank_sw;
+};
+
+struct sdw_stream_tag {
+	int stream_tag;
+	struct mutex stream_lock;
+	int ref_count;
+	enum sdw_stream_state stream_state;
+	char key[SDW_MAX_STREAM_TAG_KEY_SIZE];
+	struct sdw_runtime *sdw_rt;
+};
+
+struct sdw_stream_params {
+	unsigned int rate;
+	unsigned int channel_count;
+	unsigned int bps;
+};
+
+struct sdw_port_runtime {
+	int port_num;
+	enum sdw_port_state port_state;
+	int channel_mask;
+	/* Frame params and stream params are per port based
+	 * Single stream of audio may be split
+	 * into mutliple port each handling
+	 * subset of channels, channels should
+	 * be contiguous in subset
+	 */
+	struct sdw_transport_params transport_params;
+	struct sdw_port_params port_params;
+	struct list_head port_node;
+};
+
+struct sdw_slave_runtime {
+	/* Simplified port or full port, there cannot be both types of
+	 * data port for single stream, so data structure is kept per
+	 * slave runtime, not per port
+	 */
+	enum sdw_dpn_type type;
+	struct sdw_slv *slave;
+	int direction;
+	/* Stream may be split into multiple slaves, so this is for
+	 * this particular slave
+	 */
+	struct sdw_stream_params stream_params;
+	struct list_head port_rt_list;
+	struct list_head slave_sdw_node;
+	struct list_head slave_node;
+	int rt_state; /* State of runtime structure */
+
+};
+
+
+struct sdw_mstr_runtime {
+	struct sdw_master *mstr;
+	int direction;
+	/* Stream may be split between  multiple masters so this
+	 * is for invidual master, if stream is split into multiple
+	 * streams. For calculating the bandwidth on the particular bus
+	 * stream params of master is taken into account.
+	 */
+	struct sdw_stream_params stream_params;
+	struct list_head port_rt_list;
+	/* Two nodes are required because BW calculation is based on master
+	 * while stream enabling is based on stream_tag, where multiple
+	 * masters may be involved
+	 */
+	struct list_head mstr_sdw_node; /* This is to add mstr_rt in sdw_rt */
+	struct list_head mstr_node; /* This is to add mstr_rt in mstr */
+
+	struct list_head slv_rt_list;
+	 /* Individual stream bandwidth on given master */
+	unsigned int	stream_bw;
+	 /* State of runtime structure */
+	int rt_state;
+};
+
+struct sdw_runtime {
+	int tx_ref_count;
+	int rx_ref_count;
+	/* This is stream params for whole stream
+	 * but stream may be split between two
+	 * masters, or two slaves.
+	 */
+	struct sdw_stream_params stream_params;
+	struct list_head slv_rt_list;
+	struct list_head mstr_rt_list;
+	enum sdw_stream_type	type;
+	int stream_state;
+	int xport_state;
+
+};
+
+struct sdw_slv_status {
+	struct list_head node;
+	enum sdw_slave_status status[SOUNDWIRE_MAX_DEVICES+1];
+};
+
+/** Bus structure which handles bus related information */
+struct sdw_bus {
+	struct list_head bus_node;
+	struct sdw_master *mstr;
+	unsigned int	port_grp_mask[2];
+	unsigned int	slave_grp_mask[2];
+	unsigned int	clk_state;
+	unsigned int	active_bank;
+	unsigned int	clk_freq;
+	/* Bus total Bandwidth. Initialize and reset to zero */
+	unsigned int	bandwidth;
+	unsigned int	system_interval; /* Bus System Interval */
+	unsigned int	frame_freq;
+	unsigned int	col;
+	unsigned int	row;
+	struct task_struct *status_thread;
+	struct kthread_worker kworker;
+	struct kthread_work kwork;
+	struct list_head status_list;
+	spinlock_t spinlock;
+};
+
+/** Holds supported Row-Column combination related information */
+struct sdw_rowcol {
+	int     row;
+	int     col;
+	int     control_bits;
+	int data_bits;
+};
+
+/**
+ * Global soundwire structure. It handles all the streams spawned
+ * across masters and has list of bus structure per every master
+ * registered
+ */
+struct sdw_core {
+	struct sdw_stream_tag stream_tags[SDW_NUM_STREAM_TAGS];
+	struct sdw_rowcol     rowcolcomb[MAX_NUM_ROW_COLS];
+	struct list_head bus_list;
+	struct mutex core_lock;
+	struct idr idr;
+	int first_dynamic_bus_num;
+};
+
+/* Structure holding mapping of numbers to cols */
+struct sdw_num_to_col {
+	int num;
+	int col;
+};
+
+/* Structure holding mapping of numbers to rows */
+struct sdw_num_to_row {
+	int num;
+	int row;
+};
+
+int sdw_slave_port_config_port_params(struct sdw_slave_runtime *slv_rt);
+int sdw_slave_port_prepare(struct sdw_slave_runtime, bool prepare);
+int sdw_bus_bw_init(void);
+int sdw_mstr_bw_init(struct sdw_bus *sdw_bs);
+int sdw_bus_calc_bw(struct sdw_stream_tag *stream_tag, bool enable);
+int sdw_bus_calc_bw_dis(struct sdw_stream_tag *stream_tag, bool unprepare);
+int sdw_chn_enable(void);
+
+#endif /* _LINUX_SDW_PRIV_H */
diff --git a/drivers/soundwire/Kconfig b/drivers/soundwire/Kconfig
index 19c8efb9a5ee..a4b03e8cd694 100644
--- a/drivers/soundwire/Kconfig
+++ b/drivers/soundwire/Kconfig
@@ -4,6 +4,7 @@
 
 menuconfig SOUNDWIRE
 	bool "SoundWire support"
+	depends on !SDW
 	---help---
 	  SoundWire is a 2-Pin interface with data and clock line ratified
 	  by the MIPI Alliance. SoundWire is used for transporting data
diff --git a/include/linux/mod_devicetable.h b/include/linux/mod_devicetable.h
index 01797cb4587e..13619e910d6f 100644
--- a/include/linux/mod_devicetable.h
+++ b/include/linux/mod_devicetable.h
@@ -762,4 +762,17 @@ struct typec_device_id {
 	kernel_ulong_t driver_data;
 };
 
+#define SOUNDWIRE_NAME_SIZE       64
+#define SOUNDWIRE_MODULE_PREFIX "sdw:"
+
+struct sdw_slv_id {
+	char name[SOUNDWIRE_NAME_SIZE];
+	kernel_ulong_t driver_data;      /* Data private to the driver */
+};
+
+struct sdw_master_id {
+	char name[SOUNDWIRE_NAME_SIZE];
+	kernel_ulong_t driver_data;     /* Data private to the driver */
+};
+
 #endif /* LINUX_MOD_DEVICETABLE_H */
diff --git a/include/linux/regmap.h b/include/linux/regmap.h
index 379505a53722..035129bf1ac5 100644
--- a/include/linux/regmap.h
+++ b/include/linux/regmap.h
@@ -34,6 +34,7 @@ struct regmap_range_cfg;
 struct regmap_field;
 struct snd_ac97;
 struct sdw_slave;
+struct sdw_slv;
 
 /* An enum of all the supported cache types */
 enum regcache_type {
@@ -561,6 +562,9 @@ struct regmap *__regmap_init_sdw(struct sdw_slave *sdw,
 				 const struct regmap_config *config,
 				 struct lock_class_key *lock_key,
 				 const char *lock_name);
+struct regmap *regmap_init_slave(struct sdw_slv *sdw,
+			       const struct regmap_config *config);
+
 
 struct regmap *__devm_regmap_init(struct device *dev,
 				  const struct regmap_bus *bus,
@@ -610,6 +614,9 @@ struct regmap *__devm_regmap_init_slimbus(struct slim_device *slimbus,
 				 const struct regmap_config *config,
 				 struct lock_class_key *lock_key,
 				 const char *lock_name);
+struct regmap *devm_regmap_init_sdwint(struct sdw_slv *sdw,
+				    const struct regmap_config *config);
+
 /*
  * Wrapper for regmap_init macros to include a unique lockdep key and name
  * for each call. No-op if CONFIG_LOCKDEP is not set.
diff --git a/include/linux/sdw/sdw_cnl.h b/include/linux/sdw/sdw_cnl.h
new file mode 100644
index 000000000000..acf223cba595
--- /dev/null
+++ b/include/linux/sdw/sdw_cnl.h
@@ -0,0 +1,96 @@
+/*
+ *  sdw_cnl.h - Shared header file for intel soundwire controller driver.
+ *
+ *  Copyright (C) 2014-2015 Intel Corp
+ *  Author:  Hardik Shah  <hardik.t.shah@intel.com>
+ *
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+#ifndef _LINUX_SDW_CNL_H
+#define _LINUX_SDW_CNL_H
+
+#include <linux/sdw_bus.h>
+
+
+#define SDW_CNL_PM_TIMEOUT	3000 /* ms */
+
+#define CNL_SDW_MAX_PORTS				15
+
+/* Maximum number hardware tries to send command if the command failed */
+#define CNL_SDW_MAX_CMD_RETRIES			15
+/* Standard allows 32 frames delay max between PREQ and Ping command
+ * We kept midway in hardware
+ */
+#define CNL_SDW_MAX_PREQ_DELAY			15
+
+/* Reset Delay for hw controlled reset
+ * Reset length = 4096+(ResetDelay*256) clock cycles
+ */
+#define CNL_SDW_RESET_DELAY				15
+
+#define CNL_SDW_SHIM_OFFSET		0x2C000
+#define CNL_SDW_LINK_0_OFFSET		0x30000
+#define CNL_SDW_LINK_1_OFFSET		0x40000
+#define CNL_SDW_LINK_2_OFFSET		0x50000
+#define CNL_SDW_LINK_3_OFFSET		0x60000
+
+enum cnl_sdw_pdi_stream_type {
+	CNL_SDW_PDI_TYPE_PCM = 0,
+	CNL_SDW_PDI_TYPE_PDM = 1,
+};
+
+struct cnl_sdw_pdi_stream {
+	int pdi_num;
+	int sdw_pdi_num;
+	int ch_cnt;
+	bool allocated;
+	int port_num;
+	enum sdw_data_direction direction;
+	int h_ch_num, l_ch_num;
+	struct list_head node;
+
+};
+
+struct cnl_sdw_port {
+	int port_num;
+	int allocated;
+	bool port_type;
+	int ch_cnt;
+	enum sdw_data_direction direction;
+	struct cnl_sdw_pdi_stream *pdi_stream;
+};
+
+struct cnl_sdw_data {
+	/* SoundWire IP registers per instance */
+	void __iomem *sdw_regs;
+	/* SoundWire shim registers */
+	void __iomem *sdw_shim;
+	/* This is just for enaling SoundWire interrupts */
+	void __iomem *alh_base;
+	/* HDA interrupt */
+	int irq;
+	/* Instance id */
+	int inst_id;
+};
+
+struct cnl_sdw_port *cnl_sdw_alloc_port(struct sdw_master *mstr, int ch_count,
+				enum sdw_data_direction direction,
+				enum cnl_sdw_pdi_stream_type stream_type);
+void cnl_sdw_free_port(struct sdw_master *mstr, int port_num);
+
+
+#endif
+
diff --git a/include/linux/sdw/sdw_registers.h b/include/linux/sdw/sdw_registers.h
new file mode 100644
index 000000000000..1abdf4bf863a
--- /dev/null
+++ b/include/linux/sdw/sdw_registers.h
@@ -0,0 +1,157 @@
+/*  sdw_registers.h - SoundWire MIPI spec 1.0 defined SoundWire slave
+ *			register definition file. This defines the register
+ *			offsets, bit masks and shifts in accordance with
+ *			mipi spec 1.0
+ *  Copyright (C) 2015-2016 Intel Corp
+ *  Author:  Hardik T Shah <hardik.t.shah@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _LINUX_SDW_REG_H
+#define _LINUX_SDW_REG_H
+
+#define SDW_NUM_DATA_PORT_REGISTERS			0x100
+#define SDW_BANK1_REGISTER_OFFSET			0x10
+
+#define SDW_DP0_INTSTAT					0x0
+#define SDW_DP0_INTSTAT_TEST_FAIL_MASK			0x1
+#define SDW_DP0_INTSTAT_TEST_FAIL_SHIFT			0x2
+#define SDW_DP0_INTSTAT_PORT_READY_MASK			0x4
+#define SDW_DP0_INTSTAT_PORT_READY_SHIFT		0x20
+#define SDW_DP0_INTSTAT_BRA_FAILURE_MASK		0x40
+#define SDW_DP0_INTSTAT_BRA_FAILURE_SHIFT		0x80
+
+#define SDW_DP0_INTCLEAR				0x0
+#define SDW_DP0_INTCLEAR_TEST_FAIL_MASK			0x1
+#define SDW_DP0_INTCLEAR_PORT_READY_MASK		0x2
+#define SDW_DP0_INTCLEAR_BRA_FAILURE_MASK		0x4
+#define SDW_DP0_INTSTAT_IMPDEF1_MASK			0x20
+#define SDW_DP0_INTSTAT_IMPDEF2_MASK			0x40
+#define SDW_DP0_INTSTAT_IMPDEF3_MASK			0x80
+
+#define SDW_DP0_INTMASK					0x1
+#define SDW_DP0_INTMASK_TEST_FAIL_MASK			0x1
+#define SDW_DP0_INTMASK_PORT_READY_MASK			0x2
+#define SDW_DP0_INTMASK_BRA_FAILURE_MASK		0x4
+#define SDW_DP0_INTMASK_IMPDEF1_MASK			0x20
+#define SDW_DP0_INTMASK_IMPDEF2_MASK			0x40
+#define SDW_DP0_INTMASK_IMPDEF3_MASK			0x80
+
+#define SDW_DP0_PORTCTRL				0x2
+#define SDW_DP0_PORTCTRL_PORTDATAMODE_MASK		0x3
+#define SDW_DP0_PORTCTRL_PORTDATAMODE_SHIFT		2
+#define SDW_DP0_PORTCTRL_NEXTINVERTBANK_MASK		0x1
+#define SDW_DP0_PORTCTRL_NEXTINVERTBANK_SHIFT		4
+
+#define SDW_DP0_BLOCKCTRL1				0x3
+
+#define SDW_DP0_PREPARESTATUS				0x4
+
+#define SDW_DP0_PREPARECTRL				0x5
+
+#define SDW_DP0_CHANNELEN				0x20
+#define SDW_DP0_SAMPLECTRL1				0x22
+#define SDW_DP0_SAMPLECTRL2				0x23
+#define SDW_DP0_OFFSETCTRL1				0x24
+#define SDW_DP0_OFFSETCTRL2				0x25
+#define SDW_DP0_HCTRL					0x26
+#define SDW_DP0_LANECTRL				0x28
+
+#define SDW_SCP_INTSTAT_1				0x40
+#define SDW_SCP_INTSTAT1_PARITY_MASK			0x1
+#define SDW_SCP_INTSTAT1_BUS_CLASH_MASK			0x2
+#define SDW_SCP_INTSTAT1_SCP2_CASCADE_MASK		0x80
+
+#define SDW_SCP_INTCLEAR1				0x40
+#define SDW_SCP_INTCLEAR1_PARITY_MASK			0x1
+#define SDW_SCP_INTCLEAR1_BUS_CLASH_MASK		0x2
+#define SDW_SCP_INTCLEAR1_SCP2_CASCADE_MASK		0x80
+#define SDW_SCP_INTMASK1
+#define SDW_SCP_INTSTAT2				0x42
+#define SDW_SCP_INTSTAT2_SCP3_CASCADE_MASK		0x80
+#define SDW_SCP_INTSTAT3				0x43
+#define SDW_SCP_CTRL					0x44
+#define SDW_SCP_CTRL_CLK_STP_NOW_MASK			0x1
+#define SDW_SCP_CTRL_CLK_STP_NOW_SHIFT			0x1
+#define SDW_SCP_STAT					0x44
+#define SDW_SCP_STAT_CLK_STP_NF_MASK			0x1
+#define SDW_SCP_SYSTEMCTRL				0x45
+#define SDW_SCP_SYSTEMCTRL_CLK_STP_PREP_SHIFT		0x0
+#define SDW_SCP_SYSTEMCTRL_CLK_STP_MODE_SHIFT		0x1
+#define SDW_SCP_SYSTEMCTRL_WAKE_UP_EN_SHIFT		0x2
+#define SDW_SCP_SYSTEMCTRL_HIGH_PHY_SHIFT		0x3
+
+#define SDW_SCP_DEVNUMBER				0x46
+#define SDW_SCP_HIGH_PHY_CHECK				0x47
+#define SDW_SCP_ADDRPAGE1				0x48
+#define SDW_SCP_ADDRPAGE2				0x49
+#define SDW_SCP_KEEPEREN				0x4A
+#define SDW_SCP_BANKDELAY				0x4B
+#define SDW_SCP_TESTMODE				0x4F
+#define SDW_SCP_DEVID_0					0x50
+#define SDW_SCP_DEVID_1					0x51
+#define SDW_SCP_DEVID_2					0x52
+#define SDW_SCP_DEVID_3					0x53
+#define SDW_SCP_DEVID_4					0x54
+#define SDW_SCP_DEVID_5					0x55
+
+/* Banked Registers */
+#define SDW_SCP_FRAMECTRL				0x60
+#define SDW_SCP_NEXTFRAME				0x61
+
+#define SDW_DPN_INTSTAT					0x0
+#define SDW_DPN_INTSTAT_TEST_FAIL_MASK			0x1
+#define SDW_DPN_INTSTAT_PORT_READY_MASK			0x2
+#define SDW_DPN_INTSTAT_IMPDEF1_MASK			0x20
+#define SDW_DPN_INTSTAT_IMPDEF2_MASK			0x40
+#define SDW_DPN_INTSTAT_IMPDEF3_MASK			0x80
+
+#define SDW_DPN_INTCLEAR				0x0
+#define SDW_DPN_INTCLEAR_TEST_FAIL_MASK			0x1
+#define SDW_DPN_INTCLEAR_PORT_READY_MASK		0x2
+#define SDW_DPN_INTCLEAR_IMPDEF1_MASK			0x20
+#define SDW_DPN_INTCLEAR_IMPDEF2_MASK			0x40
+#define SDW_DPN_INTCLEAR_IMPDEF3_MASK			0x80
+
+#define SDW_DPN_INTMASK					0x1
+#define SDW_DPN_PORTCTRL				0x2
+#define SDW_DPN_PORTCTRL_PORTFLOWMODE_MASK		0x3
+#define SDW_DPN_PORTCTRL_PORTFLOWMODE_SHIFT		0
+#define SDW_DPN_PORTCTRL_PORTDATAMODE_MASK		0x3
+#define SDW_DPN_PORTCTRL_PORTDATAMODE_SHIFT		2
+#define SDW_DPN_PORTCTRL_NEXTINVERTBANK_MASK		0x1
+#define SDW_DPN_PORTCTRL_NEXTINVERTBANK_SHIFT		4
+
+#define SDW_DPN_BLOCKCTRL1				0x3
+#define SDW_DPN_BLOCKCTRL1_WORDLENGTH_MASK		0x3F
+#define SDW_DPN_BLOCKCTRL1_WORDLENGTH_SHIFT		0
+
+#define SDW_DPN_PREPARESTATUS				0x4
+#define SDW_DPN_PREPARECTRL				0x5
+#define SDW_DPN_PREPARECTRL_CH_PREPARE_MASK		0xFF
+
+#define SDW_DPN_CHANNELEN				0x20
+#define SDW_DPN_BLOCKCTRL2				0x21
+#define SDW_DPN_SAMPLECTRL1				0x22
+#define SDW_DPN_SAMPLECTRL1_LOW_MASK			0xFF
+#define SDW_DPN_SAMPLECTRL2				0x23
+#define SDW_DPN_SAMPLECTRL2_LOW_MASK			0xFF00
+#define SDW_DPN_OFFSETCTRL1				0x24
+#define SDW_DPN_OFFSETCTRL2				0x25
+#define SDW_DPN_HCTRL					0x26
+#define SDW_DPN_HCTRL_HSTART_MASK			0xF
+#define SDW_DPN_HCTRL_HSTOP_MASK			0xF
+#define SDW_DPN_HCTRL_HSTART_SHIFT			4
+#define SDW_DPN_HCTRL_HSTOP_SHIFT			0
+#define SDW_DPN_BLOCKCTRL3				0x27
+#define SDW_DPN_LANECTRL				0x28
+
+#endif
diff --git a/include/linux/sdw_bus.h b/include/linux/sdw_bus.h
new file mode 100644
index 000000000000..01c846b0c695
--- /dev/null
+++ b/include/linux/sdw_bus.h
@@ -0,0 +1,1354 @@
+/*
+ *  sdw_bus.h - Definition for SoundWire bus interface.
+ *
+ * This header file refers to the MIPI SoundWire 1.0. The comments try to
+ * follow the same conventions with a capital letter for all standard
+ * definitions such as Master, Slave, Data Port, etc. When possible, the
+ * constant numeric values are kept the same as in the MIPI specifications
+ *
+ *  Copyright (C) 2016 Intel Corp
+ *  Author:  Hardik Shah  <hardik.t.shah@intel.com>
+ *
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+#ifndef _LINUX_SDW_BUS_H
+#define _LINUX_SDW_BUS_H
+
+#include <linux/device.h>	/* for struct device */
+#include <linux/mod_devicetable.h> /* For Name size */
+#include <linux/rtmutex.h> /* For rt mutex */
+
+
+#define SOUNDWIRE_MAX_DEVICES 11
+
+#define SDW_NUM_DEV_ID_REGISTERS 6
+
+/* Port flow mode, used to indicate what port flow mode
+ * slave supports
+ */
+#define SDW_PORT_FLOW_MODE_ISOCHRONOUS		0x1
+#define SDW_PORT_FLOW_MODE_TX_CONTROLLED	0x2
+#define SDW_PORT_FLOW_MODE_RX_CONTROLLED	0x4
+#define SDW_PORT_FLOW_MODE_ASYNCHRONOUS		0x8
+
+/* Bit-mask used to indicate Port capability, OR both bits if
+ * Port is bidirectional capable
+ */
+#define SDW_PORT_SOURCE				0x1
+#define SDW_PORT_SINK				0x2
+
+/* Mask to specify what type of sample packaging mode
+ * is supported by port
+ */
+#define	SDW_PORT_BLK_PKG_MODE_BLK_PER_PORT_MASK	0x1
+#define	SDW_PORT_BLK_PKG_MODE_BLK_PER_CH_MASK 0x2
+
+/* Mask to specify data encoding supported by port */
+#define SDW_PORT_ENCODING_TYPE_TWOS_CMPLMNT	0x1
+#define SDW_PORT_ENCODING_TYPE_SIGN_MAGNITUDE	0x2
+#define SDW_PORT_ENCODING_TYPE_IEEE_32_FLOAT	0x4
+
+/* enum sdw_driver_type: There are different driver callbacks for slave and
+ *			master. This is to differentiate between slave driver
+ *			and master driver. Bus driver binds master driver to
+ *			master device and slave driver to slave device using
+ *			this field. Driver populates this field based on whether
+ *			its handling slave or master device.
+ */
+enum sdw_driver_type {
+	SDW_DRIVER_TYPE_MASTER = 0,
+	SDW_DRIVER_TYPE_SLAVE = 1,
+};
+
+/**
+ * enum sdw_block_pkg_mode: Block packing mode for the port.
+ * @SDW_PORT_BLK_PKG_MODE_BLK_PER_PORT: Block packing per port
+ * @SDW_PORT_BLK_PKG_MODE_BLK_PER_CH: Block packing per channel.
+ */
+enum sdw_block_pkg_mode {
+	SDW_PORT_BLK_PKG_MODE_BLK_PER_PORT = 0,
+	SDW_PORT_BLK_PKG_MODE_BLK_PER_CH = 1,
+};
+
+
+/**
+ * enum sdw_command_response: Data Port type
+ * @SDW_COMMAND_OK: Command is Ok.
+ * @SDW_COMMAND_IGNORED: Command is ignored.
+ * @SDW_COMMAND_FAILED: Command failed.
+ */
+enum sdw_command_response {
+	SDW_COMMAND_OK = 0,
+	SDW_COMMAND_IGNORED = 1,
+	SDW_COMMAND_FAILED = 2,
+};
+/**
+ * enum sdw_dpn_type: Data Port type
+ * @SDW_FULL_DP: Full Data Port supported.
+ * @SDW_SIMPLIFIED_DP: Simplified Data Port. Following registers are not
+ *			implemented by simplified data port
+ *			DPN_SampleCtrl2, DPN_OffsetCtrl2, DPN_HCtrl and
+ *			DPN_BlockCtrl3
+ */
+enum sdw_dpn_type {
+	SDW_FULL_DP = 0,
+	SDW_SIMPLIFIED_DP = 1,
+};
+
+/**
+ * enum sdw_dpn_grouping: Maximum block group count supported.
+ * @SDW_BLOCKGROUPCOUNT_1: Maximum Group count 1 supported.
+ * @SDW_BLOCKGROUPCOUNT_2: Maximum Group count 2 supported.
+ * @SDW_BLOCKGROUPCOUNT_3: Maximum Group count 3 supported.
+ * @SDW_BLOCKGROUPCOUNT_4: Maximum Group count 4 supported.
+ */
+enum sdw_dpn_grouping {
+	SDW_BLOCKGROUPCOUNT_1 = 0,
+	SDW_BLOCKGROUPCOUNT_2 = 1,
+	SDW_BLOCKGROUPCOUNT_3 = 2,
+	SDW_BLOCKGROUPCOUNT_4 = 3,
+};
+
+/**
+ * enum sdw_prep_ch_behavior: Specifies the dependencies between
+ *				Channel Prepare sequence and bus
+ *				clock configuration.This property is not
+ *				required for ports implementing a
+ *				Simplified ChannelPrepare State Machine (SCPSM)
+ * @SDW_CH_PREP_ANY_TIME: Channel Prepare can happen at any bus clock rate
+ * @SDW_CH_PREP_AFTER_BUS_CLK_CHANGE: : Channel Prepare sequence needs to
+ *				happen after bus clock is changed to a
+ *				frequency supported by this mode or
+ *				compatible modes described by the next field.
+ *				This may be required, e.g. when the Slave
+ *				internal audio clocks are derived from the
+ *				bus clock.
+ */
+enum sdw_prep_ch_behavior {
+	SDW_CH_PREP_ANY_TIME = 0,
+	SDW_CH_PREP_AFTER_BUS_CLK_CHANGE = 1,
+};
+
+/**
+ * enum sdw_slave_status: Slave status reported in PING frames
+ * @SDW_SLAVE_STAT_NOT_PRESENT: Slave is not present.
+ * @SDW_SLAVE_STAT_ATTACHED_OK: Slave is Attached to the bus.
+ * @SDW_SLAVE_STAT_ALERT: Some alert condition on the Slave.
+ * @SDW_SLAVE_STAT_RESERVED: Reserved.
+ */
+enum sdw_slave_status {
+	SDW_SLAVE_STAT_NOT_PRESENT = 0,
+	SDW_SLAVE_STAT_ATTACHED_OK = 1,
+	SDW_SLAVE_STAT_ALERT = 2,
+	SDW_SLAVE_STAT_RESERVED = 3,
+};
+
+enum sdw_stream_type {
+	SDW_STREAM_PCM = 0,
+	SDW_STREAM_PDM = 1,
+};
+
+
+enum sdw_rt_state {
+	SDW_RT_INITIALIZED = 0,
+	SDW_RT_CONFIGURED = 1,
+};
+
+/**
+ * enum sdw_ch_prepare_mode: Channel prepare mode.
+ * @SDW_SIMPLIFIED_CP_SM: Simplified channel prepare.
+ * @SDW_CP_SM: Normal channel prepare.
+ */
+enum sdw_ch_prepare_mode {
+	SDW_SIMPLIFIED_CP_SM = 0,
+	SDW_CP_SM = 1,
+};
+
+/**
+ * enums dfw_clk_stop_prepare: Clock Stop prepare mode.
+ * @SDW_CLOCK_STOP_MODE_0: Clock Stop mode 0
+ * @SDW_CLOCK_STOP_MODE_1: Clock Stop mode 1
+ */
+enum sdw_clk_stop_mode {
+	SDW_CLOCK_STOP_MODE_0 = 0,
+	SDW_CLOCK_STOP_MODE_1 = 1,
+};
+
+/**
+ *  enum sdw_data_direction: Data direction w.r.t Port. For e.g for playback
+ *				between the Master and Slave, where Slave
+ *				is codec, data direction for the Master
+ *				port will be OUT, since its transmitting
+ *				the data, while for the Slave (codec) it
+ *				will be IN, since its receiving the data.
+ *  @SDW_DATA_DIR_IN: Data is input to Port.
+ *  @SDW_DATA_DIR_OUT: Data is output from Port.
+ */
+enum sdw_data_direction {
+	SDW_DATA_DIR_IN = 0,
+	SDW_DATA_DIR_OUT = 1,
+};
+
+/* Forward declaration of the data structures */
+struct sdw_master;
+struct sdw_slv;
+struct sdw_msg;
+struct sdw_bra_block;
+struct sdw_mstr_driver;
+
+/**
+ * struct port_audio_mode_properties: Audio properties for the Port
+ *
+ * @max_frequency: Maximum frequency Port can support for the clock.
+ *		The use of max_ and min_ frequency requires num_freq_config
+ *		to be zero
+ * @min_frequency: Minimum frequency Port can support for the clock.
+ * @num_freq_configs: Array size for the frequencies supported by Port.
+ * @freq_supported: Array of frequencies supported by the Port.
+ * @glitchless_transitions_mask: Glitch transition mask from one mode to
+ *				other mode. Each bit refers to a mode
+ *				number.
+ */
+
+struct port_audio_mode_properties {
+	unsigned int max_frequency;
+	unsigned int min_frequency;
+	unsigned int num_freq_configs;
+	unsigned int *freq_supported;
+	unsigned int max_sampling_frequency;
+	unsigned int min_sampling_frequency;
+	unsigned int num_sampling_freq_configs;
+	unsigned int *sampling_freq_config;
+	enum sdw_prep_ch_behavior ch_prepare_behavior;
+	unsigned int glitchless_transitions_mask;
+};
+
+/**
+ * struct sdw_slv_addr: Structure representing the device_id and
+ *			and SoundWire logical Slave address.
+ * @dev_id: 6-byte device id of the Slave
+ * @slv_number: Logical SoundWire Slave number, in the range [1..11]
+ * @assigned: Logical address is assigned to some Slave or not
+ * @status: What is the current state of the slave.
+ *
+ */
+struct sdw_slv_addr {
+	struct sdw_slv *slave;
+	u8 dev_id[SDW_NUM_DEV_ID_REGISTERS];
+	u8 slv_number;
+	bool assigned;
+	enum sdw_slave_status status;
+};
+
+/**
+ * struct sdw_slv_dpn_capabilities: Capabilities of the Data Port, other than
+ *				Data Port 0 for SoundWire Slave
+ * @port_direction: Direction of the Port. Sink or Source or bidirectional.
+ *			Set appropriate bit mak based on port capabilities.
+ * @port_number: Port number.
+ * @max_word_length: Maximum length of the sample word.
+ * @min_word_length: Minimum length of sample word.
+ * @num_word_length: Length of supported word length buffer.
+ *		The use of max_ and min_ word length requires
+ *		num_word_length to be zero
+ * @word_length_buffer: Array of the supported word length.
+ * @dpn_type: Type of Data Port. Simplified or Normal data port.
+ * @dpn_grouping: Max Block group count supported for this Port.
+ * @prepare_ch: Channel prepare scheme. Simplified channel prepare or Normal
+ *		channel prepare.
+ * @imp_def_intr_mask: Implementation defined interrupt mask.
+ * @min_ch_num: Minimum number of channels supported.
+ * @max_ch_num: Maximum number of channels supported.
+ * @num_ch_supported: Buffer length for the channels supported.
+ *			The use of max_ and min_ ch_num requires
+ *			num_ch_supported to be zero
+ * @ch_supported: Array of the channel supported.
+ * @port_flow_mode_mask: Transport flow modes supported by Port.
+ * @block_packing_mode_mask: Block packing mode mask.
+ * @port_encoding_type_mask: Port Data encoding type mask.
+ * @num_audio_modes: Number of audio modes supported by device.
+ * @mode_properties: Port audio mode properties buffer of size num_audio_modes
+ */
+
+struct sdw_slv_dpn_capabilities {
+	unsigned int port_direction;
+	unsigned int port_number;
+	unsigned int max_word_length;
+	unsigned int min_word_length;
+	unsigned int num_word_length;
+	unsigned int *word_length_buffer;
+	enum sdw_dpn_type dpn_type;
+	enum sdw_dpn_grouping dpn_grouping;
+	enum sdw_ch_prepare_mode prepare_ch;
+	unsigned int imp_def_intr_mask;
+	unsigned int min_ch_num;
+	unsigned int max_ch_num;
+	unsigned int num_ch_supported;
+	unsigned int *ch_supported;
+	unsigned int port_flow_mode_mask;
+	unsigned int block_packing_mode_mask;
+	unsigned int port_encoding_type_mask;
+	unsigned int num_audio_modes;
+	struct port_audio_mode_properties *mode_properties;
+};
+
+/**
+ *  struct sdw_slv_bra_capabilities: BRA Capabilities of the Slave.
+ *  @max_bus_frequency: Maximum bus frequency of this mode, in Hz
+ *  @min_bus_frequency: Minimum bus frequency of this mode, in Hz
+ *		When using min-max properties, all values in the defined
+ *		range are allowed. Use the config list in the next field
+ *		if only discrete values are supported.
+ *  @num_bus_config_frequency:  Number of discrete bus frequency configurations
+ *  @bus_config_frequencies: Array of bus frequency configs.
+ *  @max_data_per_frame: Maximum Data payload, in bytes per frame.
+ *		Excludes header, CRC, footer. Maximum value is 470
+ *  @min_us_between_transactions: Amount of delay, in microseconds,
+ *		required to be inserted between BRA transactions.
+ *		Use if Slave needs idle time between BRA transactions.
+ *  @max_bandwidth: Maximum bandwidth (in bytes/s) that can be written/read
+ *		(header, CRCs, footer excluded)
+ *  @mode_block_alignment: Size of basic block in bytes. The Data payload
+ *		size needs to be a multiple of this basic block and
+ *		padding/repeating of the same value is required for
+ *		transactions smaller than this basic block.
+ */
+
+struct sdw_slv_bra_capabilities {
+	unsigned int max_bus_frequency;
+	unsigned int min_bus_frequency;
+	unsigned int num_bus_config_frequency;
+	unsigned int *bus_config_frequencies;
+	unsigned int max_data_per_frame;
+	unsigned int min_us_between_transactions;
+	unsigned int max_bandwidth;
+	unsigned int mode_block_alignment;
+};
+
+/**
+ * struct sdw_slv_dp0_capabilities: Capabilities of the Data Port 0 of Slave.
+ *
+ * @max_word_length: Maximum word length supported by the Data Port.
+ * @min_word_length: Minimum word length supported by the Data Port.
+ * @num_word_length: Array size of the buffer containing the supported
+ *			word lengths.
+ *			The use of max_ and min_ word length requires
+ *			num_word_length to be zero
+ * @word_length_buffer: Array containing supported word length.
+ * @bra_use_flow_control: Flow control is required or not for bra block
+ *			transfer.
+ * @bra_initiator_supported: Can Slave be BRA initiator.
+ * @ch_prepare_mode: Type of channel prepare scheme. Simplified or Normal
+ *			channel prepare.
+ * @impl_def_response_supported;: If True (nonzero), implementation-defined
+ *			response is supported. This information may be used
+ *			by a device driver to request that a generic bus
+ *			driver forwards the response to the client device
+ *			driver.
+ * @imp_def_intr_mask: Implementation defined interrupt mask for DP0 Port.
+ * @impl_def_bpt_supported: If True (nonzero), implementation-defined
+ *			Payload Type is supported. This information is used
+ *			to bypass the BRA protocol and may only be of
+ *			interest when a device driver is aware of the
+ *			Capabilities of the Master controller and Slave
+ *			devices.
+ * @slave_bra_cap: BRA capabilities of the Slave.
+ */
+
+struct sdw_slv_dp0_capabilities {
+	unsigned int max_word_length;
+	unsigned int min_word_length;
+	unsigned int num_word_length;
+	unsigned int *word_length_buffer;
+	unsigned int bra_use_flow_control;
+	bool bra_initiator_supported;
+	enum sdw_ch_prepare_mode ch_prepare_mode;
+	bool impl_def_response_supported;
+	unsigned int imp_def_intr_mask;
+	bool impl_def_bpt_supported;
+	struct sdw_slv_bra_capabilities slave_bra_cap;
+};
+
+/** struct sdw_slv_capabilities: Capabilities of the SoundWire Slave. This
+ *				is public structure for slave drivers to
+ *				updated its capability to bus driver.
+ *
+ * @wake_up_unavailable: Slave is capable of waking up the Master.
+ * @test_mode_supported: Slave supports test modes.
+ * @clock_stop1_mode_supported: Clock stop 1 mode supported by this Slave.
+ * @simplified_clock_stop_prepare: Simplified clock stop prepare
+ *				supported.
+ * @highphy_capable: Slave is highphy_capable or not?
+ * @paging_supported: Paging registers supported for Slave?
+ * @bank_delay_support: Bank switching delay for Slave
+ * @port_15_read_behavior: Slave behavior when the Master attempts a Read to
+ *			the Port15 alias
+ *			0: Command_Ignored
+ *			1: Command_OK, Data is OR of all registers
+ * @sdw_dp0_supported: DP0 is supported by Slave.
+ * @sdw_dp0_cap: Data Port 0 Capabilities of the Slave.
+ * @num_of_sdw_ports: Number of SoundWire Data ports present. The representation
+ *			assumes contiguous Port numbers starting at 1.
+ * @sdw_dpn_cap: Capabilities of the SoundWire Slave ports.
+ */
+
+struct sdw_slv_capabilities {
+	bool wake_up_unavailable;
+	bool test_mode_supported;
+	bool clock_stop1_mode_supported;
+	bool simplified_clock_stop_prepare;
+	bool highphy_capable;
+	bool paging_supported;
+	bool bank_delay_support;
+	unsigned int port_15_read_behavior;
+	bool sdw_dp0_supported;
+	struct sdw_slv_dp0_capabilities *sdw_dp0_cap;
+	int num_of_sdw_ports;
+	struct sdw_slv_dpn_capabilities *sdw_dpn_cap;
+};
+
+
+/**
+ * struct sdw_slv: Represents SoundWire Slave device
+ *				(similar to 'i2c_client' on I2C)
+ *		This is not public structure. Maintained by
+ *		bus driver internally.
+ * @dev: Driver model representation of the device
+ * @slave_cap_updated: Did slave device driver updated slave capabilties
+ *			to bus.
+ * @name: Name of the driver to use with the device.
+ * @dev_id: 6-byte unique device identification.
+ * @driver: Slave's driver, pointer to access routine.
+ * @mstr: SoundWire Master, managing the bus on which this Slave is
+ * @slv_number: Logical address of the Slave, assigned by bus driver
+ * @node: Node to add the Slave to the list of Slave devices managed
+ *		by same Master.
+ * @port_ready: Port ready completion flag for each Port of the Slave;
+ * @sdw_slv_cap: Slave Capabilities.
+ */
+struct sdw_slv {
+	struct device		dev;
+	bool			slave_cap_updated;
+	char			name[SOUNDWIRE_NAME_SIZE];
+	u8			dev_id[6];
+	struct sdw_slv_addr	*slv_addr;
+	struct sdw_slave_driver	*driver;
+	struct sdw_master	*mstr;
+	u8			slv_number;
+	struct list_head	node;
+	struct completion	*port_ready;
+	struct sdw_slv_capabilities sdw_slv_cap;
+};
+#define to_sdw_slave(d) container_of(d, struct sdw_slv, dev)
+
+/**
+ *  struct sdw_bus_params: Bus params for the Slave to be ready for next
+ *  bus changes.
+ *  @num_rows: Number of rows in new frame to be effective.
+ *  @num_cols: Number of columns in new frame to be effective.
+ *  @bus_clk_freq: Clock frequency for the bus.
+ *  @bank: Register bank, which Slave driver should program for
+ *			implementation define Slave registers. This is the
+ *			inverted value of the current bank.
+ */
+
+struct sdw_bus_params {
+	int num_rows;
+	int num_cols;
+	int bus_clk_freq;
+	int bank;
+};
+
+/**
+ * struct sdw_slave_driver: Manage SoundWire generic/Slave device driver
+ * @driver_type: To distinguish between master and slave driver. Set and
+ *		used by bus driver.
+ * @probe: Binds this driver to a SoundWire Slave.
+ * @remove: Unbinds this driver from the SoundWire Slave.
+ * @shutdown: Standard shutdown callback used during powerdown/halt.
+ * @suspend: Standard suspend callback used during system suspend
+ * @resume: Standard resume callback used during system resume
+ * @driver: Generic driver structure, according to driver model.
+ * @handle_impl_def_interrupts: Slave driver callback, for status of the
+ *			Slave other than "REPORT_PRESENT". There may be
+ *			jack detect, pll locked kind of status update
+ *			interrupt required by Slave, which Slave need to
+ *			handle in impl_defined way, using implementation
+ *			defined interrupts. This is callback function to
+ *			Slave to handle implementation defined interrupts.
+ * @handle_bus_changes: Slave callback function to let Slave configure
+ *			implementation defined registers prior to any bus
+ *			configuration changes. Bus configuration changes
+ *			will be signaled by a bank switch initiated by the bus
+ *			driver once all Slaves drivers have performed their
+ *			imp-def configuration sequence (if any).
+ *			If this callback is not implemented the bus driver
+ *			will assume the Slave can tolerate bus configurations
+ *			changes at any time.
+ *
+ * @handle_pre_port_prepare: Slave driver callback to allow Slave Port to be
+ *				prepared by configuring impl defined register
+ *				as part of Port prepare state machine.
+ *				This fn is called before DPn_Prepare ctrl is
+ *				written. Before this function is
+ *				called Port state is un-prepared (CP_Stopped).
+ *				This is optional based on any impl
+ *				defined register needs to be set by Slave
+ *				driver before Port is prepared.
+ * @handle_post_port_prepare: Slave driver callback to allow Slave Port to be
+ *				prepared by configuring impl defined register
+ *				as part of Port prepare state machine.
+ *				This is called after DPn_Prepare
+ *				ctrl is written, and DPn_status reports as
+ *				Port prepared(CP_Ready). This is optional
+ *				based on any impl defined register needs to
+ *				be set by Slave driver once Port is ready.
+ * @handle_pre_port_unprepare: Slave driver callback to allow Slave Port to be
+ *				un-prepared by configuring impl defined register
+ *				as part of Port un-prepare state machine.
+ *				This is called before DPn_Prepare ctrl is
+ *				written. Before this function is called
+ *				Port state is ready (CP_Ready).
+ *				This is optional based on any impl
+ *				defined register needs to be set by Slave
+ *				driver before Port is un-prepared.
+ * @handle_post_port_unprepare: Slave driver callback to allow Slave Port to be
+ *				un-prepared by configuring impl defined register
+ *				as part of Port prepare state machine.
+ *				This is called after DPn_Prepare
+ *				ctrl is written, and DPn_status reports as
+ *				Port un-prepared (CP_Stopped).
+ *				This is optional based on any impl defined
+ *				register needs to be set by Slave driver once
+ *				Port is un-prepared.
+ *
+ * @id_table: List of SoundWire Slaves supported by this driver
+ */
+struct sdw_slave_driver {
+	enum sdw_driver_type driver_type;
+	int (*probe)(struct sdw_slv *swdev, const struct sdw_slv_id *);
+	int (*remove)(struct sdw_slv *swdev);
+	void (*shutdown)(struct sdw_slv *swdev);
+	int (*suspend)(struct sdw_slv *swdev,
+		pm_message_t pmesg);
+	int (*resume)(struct sdw_slv *swdev);
+	struct device_driver driver;
+	int (*handle_impl_def_interrupts)(struct sdw_slv *swdev,
+		struct sdw_impl_def_intr_stat *intr_status);
+	int (*handle_bus_changes)(struct sdw_slv *swdev,
+			struct sdw_bus_params *params);
+	int (*handle_pre_port_prepare)(struct sdw_slv *swdev,
+			int port, int ch_mask, int bank);
+	int (*handle_post_port_prepare)(struct sdw_slv *swdev,
+			int port, int ch_mask, int bank);
+	int (*handle_pre_port_unprepare)(struct sdw_slv *swdev,
+			int port, int ch_mask, int bank);
+	int (*handle_post_port_unprepare)(struct sdw_slv *swdev,
+			int port, int ch_mask, int bank);
+	const struct sdw_slv_id *id_table;
+};
+#define to_sdw_slave_driver(d) container_of(d, struct sdw_slave_driver, driver)
+
+/**
+ * struct sdw_mstr_dpn_capabilities: Capabilities of the Data Port, other than
+ *				Data Port 0 for SoundWire Master
+ * @port_direction: Direction of the Port.
+ * @port_number: Port number.
+ * @max_word_length: Maximum length of the sample word.
+ * @min_word_length: Minimum length of sample word.
+ * @num_word_length: Length of supported word length buffer. This should be
+ *			0 in order to use min and max.
+ * @word_length_buffer: Array of the supported word length.
+ * @dpn_type: Type of Data Port.
+ * @dpn_grouping: Max Block count grouping supported for this Port. if
+ *		slave supports only 1 block group count, than DPN_BlockCtrl2
+ *		wont be programmed.
+ * @min_ch_num: Minimum number of channels supported.
+ * @max_ch_num: Maximum number of channels supported.
+ * @num_ch_supported: Buffer length for the channels supported.This should be
+ *			0 in order to use min and max.
+ * @ch_supported: Array of the channel supported.
+ * @port_mode_mask: Transport modes supported by Port.
+ * @block_packing_mode_mask: Block packing mode mask.
+ */
+
+struct sdw_mstr_dpn_capabilities {
+	unsigned int port_direction;
+	unsigned int port_number;
+	unsigned int max_word_length;
+	unsigned int min_word_length;
+	unsigned int num_word_length;
+	unsigned int *word_length_buffer;
+	enum sdw_dpn_type dpn_type;
+	enum sdw_dpn_grouping dpn_grouping;
+	unsigned int min_ch_num;
+	unsigned int max_ch_num;
+	unsigned int num_ch_supported;
+	unsigned int *ch_supported;
+	unsigned int port_mode_mask;
+	unsigned int block_packing_mode_mask;
+};
+
+/**
+ * struct sdw_mstr_dp0_capabilities: Capabilities of the Data Port 0 of Slave.
+ *
+ * @max_word_length: Maximum word length supported by the Data Port.
+ * @min_word_length: Minimum word length supported by the Data Port.
+ * @num_word_length: Array size of the buffer containing the supported
+ *			word lengths.
+ * @word_length_buffer: Array containing supported word length.
+ * @bra_max_data_per_frame: Maximum Data size per BRA.
+ */
+struct sdw_mstr_dp0_capabilities {
+	unsigned int max_word_length;
+	unsigned int min_word_length;
+	unsigned int num_word_length;
+	unsigned int *word_length_buffer;
+	unsigned int bra_max_data_per_frame;
+};
+
+/**
+ * struct sdw_master_capabilities: Capabilities of the Master.
+ *	This is filled by the software registering Master.
+ * @base_clk_freq: Highest base frequency at which Master can be driven
+ *	This is in Hz.
+ * @monitor_handover_supported: Does Master support monitor handover.
+ * @highphy_capable: Is Master Highphy capable?
+ * @sdw_dp0_supported: Data port0 supported?
+ * @sdw_dp0_cap: Capabilities of the dataport 0 of the Master.
+ * @num_data_ports: Array size for the number of Data ports present in
+ *			Master.
+ * @sdw_dpn_cap: Array containing information about SoundWire Master
+ *		Data Port Capabilities
+ *
+ */
+struct sdw_master_capabilities {
+	unsigned int			base_clk_freq;
+	bool				monitor_handover_supported;
+	bool				highphy_capable;
+	bool				sdw_dp0_supported;
+	struct sdw_mstr_dp0_capabilities sdw_dp0_cap;
+	unsigned int			num_data_ports;
+	struct sdw_mstr_dpn_capabilities *sdw_dpn_cap;
+
+};
+
+/**
+ * struct sdw_master: Master device controller on SoundWire bus.
+ *				(similar to 'Master' on I2C)
+ * @owner: Owner of this module. Generally THIS module.
+ * @dev: Slave interface for this driver;
+ * @nr: Bus number of SoundWire Master bus. Also referred to as link number.
+ * @slv_list: List of SoundWire Slaves registered to the bus.
+ * @name: Name of the Master driver.
+ * @sdw_addr: Array containing Slave SoundWire bus Slave address information.
+ * @bus_lock: Global lock for bus functions.
+ * @num_slv: Number of SoundWire Slaves assigned logical address.
+ * @wq: Workqueue instance for Slave detection.
+ * @mstr_capabilities: Capabilities of the SoundWire Master controller.
+ * @driver: Driver handling the Master.
+ * @slv_released: Flag to indicate Slave release completion. Internally used
+ *		by bus driver.
+ * @timeout: Timeout before getting response from Slave.
+ * @retries: How many times to retry before giving up on Slave response.
+ * @ssp_tag_synchronized: Do bus driver needs to set SSP tag based on
+ *			sample interval of of all streams.
+ * @link_sync_mask: Bit mask representing all the other controller links
+ *		with which this link is synchronized.
+ *
+ */
+struct sdw_master {
+	struct module		*owner;
+	struct device		dev;
+	unsigned int		nr;
+	struct list_head	slv_list;
+	char			name[SOUNDWIRE_NAME_SIZE];
+	struct sdw_slv_addr	sdw_addr[SOUNDWIRE_MAX_DEVICES + 1];
+	struct rt_mutex		bus_lock;
+	u8			num_slv;
+	struct workqueue_struct *wq;
+	struct sdw_master_capabilities mstr_capabilities;
+	struct sdw_mstr_driver	*driver;
+	struct completion slv_released;
+	struct list_head	mstr_rt_list;
+	int timeout;
+	int retries;
+	bool ssp_tag_synchronized;
+	int link_sync_mask;
+};
+#define to_sdw_master(d) container_of(d, struct sdw_master, dev)
+
+
+/** struct sdw_port_params: This is used to program the
+ *			Data Port based on Data Port
+ *			stream params. These parameters cannot be changed
+ *			dynamically
+ *
+ * @num : Port number for which params are there.
+ * @word_length: Word length of the Port
+ * @port_flow_mode: Port Data flow mode.
+ * @port_data_mode: Test mode or normal mode.
+ */
+struct sdw_port_params {
+	int num;
+	int word_length;
+	int port_flow_mode;
+	int port_data_mode;
+};
+
+/** struct sdw_transport_params: This is used to program the
+ *			Data Port based on Data Port
+ *			transport params. These parameters may be changed
+ *			dynamically based on Frame Shape changes and bandwidth
+ *			allocation
+ *
+ * @num : Port number for which params are there.
+ * @blockgroupcontrol_valid: Does Port implement block group control?
+ * @blockgroupcontrol: Block group control value.
+ * @sample_interval: Sample interval.
+ * @offset1: Blockoffset of the payload Data.
+ * @offset2: Blockoffset of the payload Data.
+ * @hstart: Horizontal start of the payload Data.
+ * @hstop: Horizontal stop of the payload Data.
+ * @blockpackingmode: Block per channel or block per Port.
+ * @lanecontrol: Data lane Port uses for Data transfer.
+ */
+struct sdw_transport_params {
+	int num;
+	bool blockgroupcontrol_valid;
+	int blockgroupcontrol; /* DPN_BlockCtrl2 */
+	int sample_interval;   /* DPN_SampleCtrl1 and DPN_SampleCtrl2 */
+	int offset1;		/* DPN_OffsetCtrl1 */
+	int offset2;		/* DPN_OffsetCtrl2 */
+	int hstart;		/*  DPN_HCtrl  */
+	int hstop;		/*  DPN_HCtrl  */
+	int blockpackingmode;	/* DPN_BlockCtrl3 */
+	int lanecontrol;	/* DPN_LaneCtrl */
+};
+
+/** struct sdw_prepare_ch: Prepare/Un-prepare the Data Port channel.
+ *
+ * @num : Port number for which params are there.
+ * @ch_mask: prepare/un-prepare channels specified by ch_mask
+ * @prepare: Prepare/Un-prepare channel
+ */
+struct sdw_prepare_ch {
+	int num;
+	int ch_mask;
+	bool prepare;
+};
+
+/** struct sdw_activate_ch: Activate/Deactivate Data Port channel.
+ *
+ * @num : Port number for which params are there.
+ * @ch_mask: Active channel mask for this port.
+ * @activate: Activate/Deactivate channel
+ */
+struct sdw_activate_ch {
+	int num;
+	int ch_mask;
+	bool activate;
+};
+
+/**
+ * struct sdw_master_port_ops: Callback functions from bus driver
+ *				to Master driver to set Master
+ *				Data ports. Since Master registers
+ *				are not standard, commands are passed
+ *				to Master from bus and Master
+ *				converts commands to register settings
+ *				based on Master register map.
+ * @dpn_set_port_params: Set the Port parameters for the Master Port.
+ * @dpn_set_port_transport_params: Set transport parameters for the
+ *				Master Port.
+ * @dpn_port_prepare_ch: Prepare/Un-prepare the Master channels of the Port
+ * @dpn_port_prepare_ch_pre: Called before calling dpn_port_prepare_ch, if
+ *				Master driver needs to do update
+ *				register settings before ch_prepare
+ * @dpn_port_prepare_ch_post: Called after calling dpn_port_prepare_ch, if
+ *				Master driver needs to do some
+ *				register settings after ch_prepare
+ * @dpn_port_activate_ch: Activate the channels of particular Master Port
+ * @dpn_port_activate_ch_pre: Called before calling dpn_port_activate_ch, if
+ *				Master driver needs to some register
+ *				setting before activating channel.
+ * @dpn_port_activate_ch_post : Called after calling dpn_port_activate_ch, if
+ *				Master driver needs to some register
+ *				setting after activating channel.
+ */
+struct sdw_master_port_ops {
+	int (*dpn_set_port_params)(struct sdw_master *mstr,
+			struct sdw_port_params *port_params, int bank);
+	int (*dpn_set_port_transport_params)(struct sdw_master *mstr,
+			struct sdw_transport_params *transport_params,
+								int bank);
+	int (*dpn_port_prepare_ch)(struct sdw_master *mstr,
+			struct sdw_prepare_ch *prepare_ch);
+	int (*dpn_port_prepare_ch_pre)(struct sdw_master *mstr,
+			struct sdw_prepare_ch *prepare_ch);
+	int (*dpn_port_prepare_ch_post)(struct sdw_master *mstr,
+			struct sdw_prepare_ch *prepare_ch);
+	int (*dpn_port_activate_ch)(struct sdw_master *mstr,
+			struct sdw_activate_ch *activate_ch, int bank);
+	int (*dpn_port_activate_ch_pre)(struct sdw_master *mstr,
+			struct sdw_activate_ch *activate_ch, int bank);
+	int (*dpn_port_activate_ch_post)(struct sdw_master *mstr,
+			struct sdw_activate_ch *activate_ch, int bank);
+};
+
+/**
+ * struct sdw_master_ops: Callback operations from bus driver to Master
+ *				Master driver.Bus driver calls these
+ *				functions to control the bus parameters
+ *				in Master hardware specific way. Its
+ *				like i2c_algorithm to access the bus
+ *				in Master specific way.
+ *
+ *				Slave registers are standard.
+ * @xfer_msg: Callback function to Master driver to read/write
+ *		Slave registers.
+ * @xfer_bulk: Callback function to Master driver for bulk transfer.
+ * @monitor_handover: Allow monitor to be owner of command, if requested.
+ * @set_ssp_interval: Set SSP interval.
+ * @set_clock_freq: Set the clock frequency based on bandwidth requirement.
+ *			Controller driver sets the frequency in hardware
+ *			specific way.
+ *
+ */
+
+struct sdw_master_ops {
+	enum sdw_command_response (*xfer_msg)(struct sdw_master *mstr,
+		struct sdw_msg *msg, bool program_scp_addr_page);
+	int (*xfer_bulk)(struct sdw_master *mstr,
+		struct sdw_bra_block *block);
+	int (*monitor_handover)(struct sdw_master *mstr,
+		bool handover);
+	int (*set_ssp_interval)(struct sdw_master *mstr,
+			int ssp_interval, int bank);
+	int (*set_clock_freq)(struct sdw_master *mstr,
+			int cur_clk_freq, int bank);
+	int (*set_frame_shape)(struct sdw_master *mstr,
+			int col, int row, int bank);
+};
+
+/**
+ * struct sdw_mstr_driver: Manage SoundWire Master/Master device driver
+ * @driver_type: To distinguish between master and slave driver. Set and
+ *		used by bus driver.
+ * @probe: Binds this driver to a SoundWire Master.
+ * @remove: Unbinds this driver from the SoundWire Master.
+ * @shutdown: Standard shutdown callback used during powerdown/halt.
+ * @suspend: Standard suspend callback used during system suspend
+ * @resume: Standard resume callback used during system resume
+ * @driver: SoundWire device drivers should initialize name and owner field of
+ *      this structure.
+ * @mstr_ops: Callback operations from bus driver to Master driver for
+ *		programming and controlling bus parameters and to program
+ *		Slave  registers.
+ * @mstr_port_ops: Commands to setup the Master ports. Master register
+ *		map is not defined by standard. So these ops represents the
+ *		commands to setup Master ports.
+ * @id_table: List of SoundWire devices supported by this driver.
+ */
+struct sdw_mstr_driver {
+	enum sdw_driver_type driver_type;
+	int (*probe)(struct sdw_master *sdwmstr, const struct sdw_master_id *);
+	int (*remove)(struct sdw_master *sdwmstr);
+	void (*shutdown)(struct sdw_master *sdwmstr);
+	int (*suspend)(struct sdw_master *sdwmstr,
+		pm_message_t pmesg);
+	int (*resume)(struct sdw_master *sdwmstr);
+	struct device_driver driver;
+	struct sdw_master_ops *mstr_ops;
+	struct sdw_master_port_ops *mstr_port_ops;
+	const struct sdw_master_id *id_table;
+};
+#define to_sdw_mstr_driver(d) container_of(d, struct sdw_mstr_driver, driver)
+
+/**
+ * struct sdw_msg : Message to be sent on bus. This is similar to i2c_msg
+ *			on I2C bus.
+ *			Actually controller sends the message on bus
+ *			in hardware specific way. This interface is from
+ *			bus driver to Slaves.
+ * @slave_addr: Slave address
+ * @ssp_tag: send message at ssp_tag. It should be used when a command needs
+ *		to be issued during the next SSP. For all normal reads/writes
+ *		this should be zero. This will be used for broadcast write
+ *		to SCP_FrameCtrl register by bus driver only. Normally
+ *		slave driver should always set ssp_tag  to 0.
+ * @addr_page1: SCP address page 1
+ * @addr_page2: SCP address page 2
+ * @flag: Message to be read or write.
+ * @addr: Address of the register to be read;
+ * @len: Length of the message to be read. Successive increment in the
+ *	register address for every message.
+ * @buf: Buf to be written or read from the register.
+ */
+struct sdw_msg {
+	u8 slave_addr;
+	bool ssp_tag;
+	u8 addr_page1;
+	u8 addr_page2;
+#define SDW_MSG_FLAG_READ	0x0
+#define SDW_MSG_FLAG_WRITE	0x1
+	u8 flag;
+	u16 addr;
+	u16 len;
+	u8 *buf;
+};
+
+/**
+ * sdw_stream_config: Stream configuration of the device. This includes
+ *			Master and Slave.
+ * @frame_rate: Audio frame rate of the stream.
+ * @channel_count: Channel count of the stream.
+ * @bps: Number of bits per audio sample.
+ * @direction: Direction of the Data. What is the data direction for the
+ *		device calling stream_config. This is w.r.t device.
+ * @type: Stream type PCM or PDM
+ *
+ */
+struct sdw_stream_config {
+	unsigned int frame_rate;
+	unsigned int channel_count;
+	unsigned int bps;
+	enum sdw_data_direction direction;
+	enum sdw_stream_type	type;
+};
+
+/**
+ * sdw_port_cfg: SoundWire Port configuration, Configuration is done
+ *		for all port of all the devices which are part of stream.
+ *		All the ports of stream handles same pcm parameters accept
+ *		channels. e.g Master may handle stereo channels using single
+ *		port, but slave may handle Left and Right channel on one
+ *		port each.
+ * @port_num:	Port number to be configured
+ * @ch_mask: Which channels needs to be activated for this Port.
+ */
+struct sdw_port_cfg {
+	int port_num;
+	unsigned int ch_mask;
+};
+
+/**
+ * sdw_port_config: List of the ports handled by slave or master
+ *			for particular stream. Both slave and master calls
+ *			this with ports they trasmit/recevie onfor particular
+ *			stream.
+ * @num_ports: Number of ports to be configured.
+ * @port_cfg : Port configuration for each Port.
+ */
+struct sdw_port_config {
+	unsigned int num_ports;
+	struct sdw_port_cfg *port_cfg;
+};
+
+/**
+ * struct sdw_bra_block: Data block to be sent/received using SoundWire
+ *			bulk transfer protocol
+ * @slave_addr: Slave logical address from/to which transfer
+ *			needs to take place.
+ * @operation: Read operation or write operation.
+ * @num_bytes: Number of Data bytes to be transferred.
+ * @reg_offset: Register offset from where the first byte to read/write.
+ * @values: Array containing value for write operation and to be filled
+ *		for read operation.
+ */
+struct  sdw_bra_block {
+	int slave_addr;
+	int cmd;
+	int num_bytes;
+	int reg_offset;
+	u8 *values;
+};
+
+/**
+ *  Struct sdw_slave_status: Status of all the SoundWire Slave devices.
+ *  @status: Array of status of SoundWire Slave devices. 0 is also
+ *		a soundwire device during enumeration, so adding +1 for
+ *		that. Actual number fo devices that can be supported are
+ *		11 as defined by SOUNDWIRE_MAX_DEVICES
+ */
+struct sdw_status {
+	enum sdw_slave_status status[SOUNDWIRE_MAX_DEVICES + 1];
+};
+
+/**
+ * sdw_add_master_controller: Add SoundWire Master controller interface
+ * @mstr: Controller to be registered as SoundWire Master interface.
+ *	This is to be called for each Master interface.
+ *	This is same as I2C, where each adapter register specifies one
+ *	pair of clock and Data lines (link).
+ */
+int sdw_add_master_controller(struct sdw_master *mstr);
+
+/**
+ * sdw_del_master_controller: Master tear-down.
+ * Master added with the "sdw_add_master_controller" API is teared down
+ * using this API.
+ * @mstr: Master to be teared down
+ */
+void sdw_del_master_controller(struct sdw_master *mstr);
+
+/**
+ * sdw_mstr_driver_register: SoundWire Master driver registration with SDW bus.
+ *			This API will register the Master driver with the
+ *			SoundWire bus. It is typically called from the
+ *			driver's module-init function.
+ * @drv: Master Driver to be associated with device.
+ *
+ */
+int __sdw_mstr_driver_register(struct module *owner,
+					struct sdw_mstr_driver *driver);
+#define sdw_mstr_driver_register(drv) \
+			__sdw_mstr_driver_register(THIS_MODULE, drv)
+
+/**
+ * sdw_mstr_driver_unregister: Undo effects of sdw_mstr_driver_register
+ * @drv: SDW Master driver to be unregistered
+ */
+void sdw_mstr_driver_unregister(struct sdw_mstr_driver *drv);
+
+/**
+ * __sdw_slave_driver_register: SoundWire Slave driver registration with
+ *				SDW bus. This API will register the Slave
+ *				driver with the SoundWire bus. It is typically
+ *				called from the driver's module-init function.
+ * @drv: Driver to be associated with Slave.
+ */
+int __sdw_slave_driver_register(struct module *owner,
+					struct sdw_slave_driver *drv);
+#define sdw_slave_driver_register(drv) \
+			__sdw_slave_driver_register(THIS_MODULE, drv)
+
+/**
+ * sdw_register_slave_capabilities: Register slave device capabilties to the
+ *				bus driver. Since bus driver handles bunch
+ *				of slave register programming it should
+ *				be aware of slave device capabilties.
+ *				Slave device is attached to bus based on
+ *				enumeration. Once slave driver is attached
+ *				to device and probe of slave driver is called
+ *				on device and driver binding, slave driver
+ *				should call this function to register its
+ *				capabilties to bus. This should be the very
+ *				first function to bus driver from slave driver
+ *				once slave driver is registered and probed.
+ * @slave: SoundWire Slave handle
+ * @cap: Slave capabilities to be updated to bus driver.
+ */
+int sdw_register_slave_capabilities(struct sdw_slv *slave,
+					struct sdw_slv_capabilities *cap);
+
+/**
+ * sdw_slave_driver_unregister: Undo effects of sdw_slave_driver_register
+ * @drv: SDW Slave driver to be unregistered
+ */
+void sdw_slave_driver_unregister(struct sdw_slave_driver *drv);
+
+/**
+ * sdw_slave_transfer: Transfer SDW message on bus.
+ * @mstr: Master which will transfer the message.
+ * @msg: Array of messages to be transferred.
+ * @num: Number of messages to be transferred, messages include read and write
+ *		messages, but not the ping messages.
+ */
+int sdw_slave_transfer(struct sdw_master *mstr, struct sdw_msg *msg, int num);
+
+/**
+ * sdw_alloc_stream_tag: Allocate stream_tag for each audio stream
+ *			between SoundWire Masters and Slaves.
+ *			(Multiple Masters and Slave in case of
+ *			aggregation) stream_tag is
+ *			unique across system.  Stream tag represents the
+ *			independent audio stream which can be controlled
+ *			configure individually. Stream can be split between
+ *			multiple Masters and Slaves. It can also be
+ *			split between multiple ports of the Master and Slave.
+ *			All the stream configuration for Masters and Slaves
+ *			and ports of the Master and Slave for particular
+ *			stream is done on stream_tag as handle. Normally
+ *			stream is between CPU and Codec. CPU dai ops
+ *			allocate the stream tag and programs same to the
+ *			codec dai. If there are multiple codecs attached
+ *			to each CPU DAI, like L and R digital speaker, both
+ *			codecs should be programmed with same stream tag.
+ *
+ *
+ * @uuid:		uuid  is used to make sure same stream tag gets
+ *			allocated for same uuid. If stream tag is not
+ *			allocated for uuid, it will get allocated and
+ *			uuid-stream tag pair will be saved, for next
+ *			allocation based on uuid. If this is NULL,
+ *			new stream tag will be allocated each time this
+ *			function is called.
+ *
+ *
+ * @stream_tag: Stream tag returned by bus driver.
+ */
+int sdw_alloc_stream_tag(char *uuid, int *stream_tag);
+
+/**
+ * sdw_release_stream_tag: Free the already assigned stream tag.
+ *
+ * @stream_tag: Stream tag to be freed.
+ */
+void sdw_release_stream_tag(int stream_tag);
+
+/**
+ * sdw_config_stream: Configure the audio stream. Each stream between
+ *			master and slave, or between slaves has unique
+ *			stream tag.
+ *			Master and Slave attaches to
+ *			the stream using the unique stream_tag for each
+ *			stream between Master(s) and Slave(s). Both
+ *			Master and Slave driver call this function to
+ *			attach to stream and let bus driver know the
+ *			stream params. Master and Slave calls this function
+ *			typically as part of hw_params ops of their respective
+ *			DAIs to let bus driver know about stream parameters.
+ *			Stream parameters between Tx and Rx direction
+ *			should match. Function is reference counted so
+ *			multiple Master and Slaves attached to particular
+ *			stream can call to setup stream config.
+ *			Master calls this function with Slave handle as
+ *			NULL.
+ * @mstr: Master handle,
+ * @slave: SoundWire Slave handle, Null if stream configuration is called
+ *             by Master driver.
+ * @stream_config: Stream configuration for the SoundWire audio stream.
+ * @stream_tag: Stream_tag representing the audio stream. All Masters and Slaves
+ *             part of the same stream will have same stream tag. So bus drivers
+ *             know  which all Masters and Slaves are part of stream.
+ *
+ */
+int sdw_config_stream(struct sdw_master *mstr,
+		struct sdw_slv *slave,
+		struct sdw_stream_config *stream_config,
+		unsigned int stream_tag);
+
+/**
+ * sdw_release_stream: De-associates Master(s) and Slave(s) from stream. Reverse
+ *		effect of the sdw_config_stream
+ *
+ * @mstr: Master handle,
+ * @slave: SoundWire Slave handle, Null if stream configuration is called
+ *		by Master driver.
+ * @stream_tag: Stream_tag representing the audio stream. All Masters and Slaves
+ *		part of the same stream has same stream tag. So bus drivers
+ *		know  which all Masters and Slaves are part of stream.
+ *
+ */
+int sdw_release_stream(struct sdw_master *mstr,
+		struct sdw_slv *slave,
+		unsigned int stream_tag);
+
+/**
+ * sdw_config_port: Master(s) and Slave(s) are associated to stream.
+ *			Each Master and Slave can handle stream using
+ *			different SoundWire Port number(s).
+ *			e.g Master may handle stereo stream using single
+ *			Data Port, while Slave may handle each channel
+ *			of Data stream using one Port each. Bus driver
+ *			needs to know the stream to Port association
+ *			for each Master(s) and Slave(s) assocated with the
+ *			stream for configuring Master and Slave ports
+ *			based on transport params calculate by bus for a
+ *			stream. Both Master and Slave call this function to let
+ *			bus driver know about stream to Port mapping.
+ *			Master driver calls this with Slave handle
+ *			as NULL.
+ * @mstr: Master handle where the Slave is connected.
+ * @slave: Slave handle.
+ * @port_config: Port configuration for each Port of SoundWire Slave.
+ * @stream_tag: Stream tag, where this Port is connected.
+ *
+ */
+int sdw_config_port(struct sdw_master *mstr,
+			struct sdw_slv *slave,
+			struct sdw_port_config *port_config,
+			unsigned int stream_tag);
+
+/**
+ * sdw_prepare_and_enable: Prepare and enable all the ports of all the Master(s)
+ *			and Slave(s) associated with this stream tag.
+ *			Following will be done as part of prepare and
+ *			enable by bus driver.
+ *			1. Calculate new bandwidth required on bus
+ *				because of addition be this new stream.
+ *			2. Calculate new frameshape based on bandwidth
+ *			3. Calculate the new clock frequency on which
+ *				bus will be transistioned based on new
+ *				bandwidth and frameshape.
+ *			4. Calculate new transport params for the already
+ *				active on the bus based on clock frequency,
+ *				frameshape and bandwidth changes.
+ *			5. Calculate transport params for this stream
+ *			6. Program already active ports with new transport
+ *				params and frame shape,
+ *				change clock frequency of master.
+ *			7. Prepare ports for this stream.
+ *			8. Enable ports for this stream.
+ * @stream_tag: Audio stream to be activated. Each stream has unique
+ *		stream_tag. All the channels of all the ports of Slave(s)
+ *		and Master(s) attached to this stream will be activated
+ *		deactivated simultaneously at proper SSP or gsync.
+ * @enable: Enable the ports as part of current call or not. If its
+ *		false only till steps 1 to 7 will be executed as part of this
+ *		function call. if its true, than steps 1 to 7 will be executed
+ *		if not already done, else only step 8 will be executed.
+ *
+ */
+int sdw_prepare_and_enable(int stream_tag, bool enable);
+
+/**
+ * sdw_disable_and_unprepare: Un-Prepare and disable all the ports of all the
+ *			 Master(s) and Slave(s) associated with stream tag.
+ *			Following will be done as part of Un-prepare and
+ *			disable by bus driver.
+ *			1. Disable all the ports for this stream.
+ *			2. Un-Prepare ports for this stream.
+ *			3. Calculate new bandwidth required on bus
+ *				because of removal of this new stream.
+ *			4. Calculate new frameshape based on bandwidth
+ *			5. Calculate the new clock frequency on which
+ *				bus will be transistioned based on new
+ *				bandwidth and frameshape.
+ *			6. Calculate new transport params for the already
+ *				active on the bus based on clock frequency,
+ *				frameshape and bandwidth changes.
+ *			7.Program already active ports with new transport
+ *				params and frame shape,
+ *				change clock frequency of master.
+ * @stream_tag: Audio stream to be disabled. Each stream has unique
+ *		stream_tag. All the channels of all the ports of Slave(s)
+ *		and Master(s) attached to this stream will be activated
+ *		deactivated simultaneously at proper SSP or gsync.
+ * @un_prepare: Un-prepare the ports as part of current call or not. If its
+ *		false only step 1 will be executed as part of this
+ *		function call. if its true, than step 1 will be executed
+ *		if not already done, else only 2 to 7 will be executed.
+ */
+int sdw_disable_and_unprepare(int stream_tag, bool un_prepare);
+
+/**
+ * sdw_master_update_slv_status: Update the status of the Slave to the bus
+ *			driver. Master calls this function based on the
+ *			interrupt it gets once the Slave changes its
+ *			state or from interrupts for the Master hardware
+ *			that caches status information reported in PING frames
+ * @mstr: Master handle for which status is reported.
+ * @status: Array of status of each Slave.
+ */
+int sdw_master_update_slv_status(struct sdw_master *mstr,
+					struct sdw_status *status);
+
+/**
+ * sdw_get_master: Return the Master handle from Master number.
+ *			Increments the reference count of the module.
+ *			Similar to i2c_get_adapter.
+ *  nr: Master controller number.
+ *  returns Master handle on success, else NULL
+ */
+struct sdw_master *sdw_get_master(int nr);
+
+/**
+ *  sdw_put_master: Reverses the effect of sdw_get_master
+ *  mstr: Master controller handle.
+ */
+void sdw_put_master(struct sdw_master *mstr);
+
+
+/**
+ * module_sdw_slave_driver() - Helper macro for registering a sdw Slave driver
+ * @__sdw_slave_driver: sdw_slave_driver struct
+ *
+ * Helper macro for sdw drivers which do not do anything special in module
+ * init/exit. This eliminates a lot of boilerplate. Each module may only
+ * use this macro once, and calling it replaces module_init() and module_exit()
+ */
+#define module_sdw_slave_driver(__sdw_slave_driver) \
+	module_driver(__sdw_slave_driver, sdw_slave_driver_register, \
+			sdw_slave_driver_unregister)
+/**
+ * sdw_prepare_for_clock_change: Prepare all the Slaves for clock stop or
+ *		clock start. Prepares Slaves based on what they support
+ *		simplified clock stop or normal clock stop based on
+ *		their capabilities registered to slave driver.
+ * @mstr: Master handle for which clock state has to be changed.
+ * @start: Prepare for starting or stopping the clock
+ * @clk_stop_mode: Bus used which clock mode, if bus finds all the Slaves
+ *		on the bus to be supported clock stop mode1 it prepares
+ *		all the Slaves for mode1 else it will prepare all the
+ *		Slaves for mode0.
+ */
+int sdw_prepare_for_clock_change(struct sdw_master *mstr, bool start,
+			enum sdw_clk_stop_mode *clck_stop_mode);
+
+/**
+ * sdw_wait_for_slave_enumeration: Wait till all the slaves are enumerated.
+ *			Typicall this function is called by master once
+ *			it resumes its clock. This function waits in
+ *			loop for about 2Secs before all slaves gets enumerated
+ *			This function returns immediately if the clock
+ *			stop mode0 was entered earlier, where slave need
+ *			not re-enumerated.
+ *
+ * @mstr: Master handle
+ * @slave: Slave handle
+ */
+int sdw_wait_for_slave_enumeration(struct sdw_master *mstr,
+			struct sdw_slv *slave);
+
+/**
+ * sdw_stop_clock: Stop the clock. This function broadcasts the SCP_CTRL
+ *			register with clock_stop_now bit set.
+ * @mstr: Master handle for which clock has to be stopped.
+ * @clk_stop_mode: Bus used which clock mode.
+ */
+
+int sdw_stop_clock(struct sdw_master *mstr, enum sdw_clk_stop_mode mode);
+
+/* Return the adapter number for a specific adapter */
+static inline int sdw_master_id(struct sdw_master *mstr)
+{
+	return mstr->nr;
+}
+
+static inline void *sdw_master_get_drvdata(const struct sdw_master *mstr)
+{
+	return dev_get_drvdata(&mstr->dev);
+}
+
+static inline void sdw_master_set_drvdata(struct sdw_master *mstr,
+					void *data)
+{
+	dev_set_drvdata(&mstr->dev, data);
+}
+
+static inline void *sdw_slave_get_drvdata(const struct sdw_slv *slv)
+{
+	return dev_get_drvdata(&slv->dev);
+}
+
+static inline void sdw_slave_set_drvdata(struct sdw_slv *slv,
+					void *data)
+{
+	dev_set_drvdata(&slv->dev, data);
+}
+
+#endif /*  _LINUX_SDW_BUS_H */
diff --git a/include/trace/events/sdw.h b/include/trace/events/sdw.h
new file mode 100644
index 000000000000..0c08e58a18bf
--- /dev/null
+++ b/include/trace/events/sdw.h
@@ -0,0 +1,232 @@
+/* SDW message transfer tracepoints
+ *
+ *  Copyright (C) 2014-2015 Intel Corp
+ *  Author:  Hardik Shah  <hardik.t.shah@intel.com>
+ *
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM sdw
+
+#if !defined(_TRACE_SDW_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_SDW_H
+
+#include <linux/mod_devicetable.h>
+#include <linux/sdw_bus.h>
+#include <linux/tracepoint.h>
+
+/*
+ * drivers/sdw/sdw.c
+ */
+extern int sdw_transfer_trace_reg(void);
+extern void sdw_transfer_trace_unreg(void);
+/*
+ * __sdw_transfer() write request
+ */
+TRACE_EVENT_FN(sdw_write,
+	       TP_PROTO(const struct sdw_master *mstr, const struct sdw_msg *msg,
+			int num),
+	       TP_ARGS(mstr, msg, num),
+	       TP_STRUCT__entry(
+		       __field(int,	master_nr)
+		       __field(__u16,	msg_nr)
+		       __field(__u8,	addr_page1)
+		       __field(__u8,	addr_page2)
+		       __field(__u16,	addr)
+		       __field(__u16,	flag)
+		       __field(__u16,	len)
+		       __dynamic_array(__u8, buf, msg->len)),
+	       TP_fast_assign(
+		       __entry->master_nr = mstr->nr;
+		       __entry->msg_nr = num;
+		       __entry->addr = msg->addr;
+		       __entry->flag = msg->flag;
+		       __entry->len = msg->len;
+		       __entry->addr_page1 = msg->addr_page1;
+		       __entry->addr_page2 = msg->addr_page2;
+		       memcpy(__get_dynamic_array(buf), msg->buf, msg->len);
+			      ),
+	       TP_printk("sdw-%d #%u a=%03x addr_page1=%04x addr_page2=%04x f=%04x l=%u [%*phD]",
+			 __entry->master_nr,
+			 __entry->msg_nr,
+			 __entry->addr,
+			 __entry->addr_page1,
+			 __entry->addr_page2,
+			 __entry->flag,
+			 __entry->len,
+			 __entry->len, __get_dynamic_array(buf)
+			 ),
+	       sdw_transfer_trace_reg,
+	       sdw_transfer_trace_unreg);
+
+/*
+ * __sdw_transfer() read request
+ */
+TRACE_EVENT_FN(sdw_read,
+	       TP_PROTO(const struct sdw_master *mstr, const struct sdw_msg *msg,
+			int num),
+	       TP_ARGS(mstr, msg, num),
+	       TP_STRUCT__entry(
+		       __field(int,	master_nr)
+		       __field(__u16,	msg_nr)
+		       __field(__u8,	addr_page1)
+		       __field(__u8,	addr_page2)
+		       __field(__u16,	addr)
+		       __field(__u16,	flag)
+		       __field(__u16,	len)
+		       __dynamic_array(__u8, buf, msg->len)),
+	       TP_fast_assign(
+		       __entry->master_nr = mstr->nr;
+		       __entry->msg_nr = num;
+		       __entry->addr = msg->addr;
+		       __entry->flag = msg->flag;
+		       __entry->len = msg->len;
+		       __entry->addr_page1 = msg->addr_page1;
+		       __entry->addr_page2 = msg->addr_page2;
+		       memcpy(__get_dynamic_array(buf), msg->buf, msg->len);
+			      ),
+	       TP_printk("sdw-%d #%u a=%03x addr_page1=%04x addr_page2=%04x f=%04x l=%u [%*phD]",
+			 __entry->master_nr,
+			 __entry->msg_nr,
+			 __entry->addr,
+			 __entry->addr_page1,
+			 __entry->addr_page2,
+			 __entry->flag,
+			 __entry->len,
+			 __entry->len, __get_dynamic_array(buf)
+			 ),
+	       sdw_transfer_trace_reg,
+	sdw_transfer_trace_unreg);
+
+/*
+ * __sdw_transfer() read reply
+ */
+TRACE_EVENT_FN(sdw_reply,
+	       TP_PROTO(const struct sdw_master *mstr, const struct sdw_msg *msg,
+			int num),
+	       TP_ARGS(mstr, msg, num),
+	       TP_STRUCT__entry(
+		       __field(int,	master_nr)
+		       __field(__u16,	msg_nr)
+		       __field(__u16,	addr)
+		       __field(__u16,	flag)
+		       __field(__u16,	len)
+		       __dynamic_array(__u8, buf, msg->len)),
+	       TP_fast_assign(
+		       __entry->master_nr = mstr->nr;
+		       __entry->msg_nr = num;
+		       __entry->addr = msg->addr;
+		       __entry->flag = msg->flag;
+		       __entry->len = msg->len;
+		       memcpy(__get_dynamic_array(buf), msg->buf, msg->len);
+			      ),
+	       TP_printk("sdw-%d #%u a=%03x f=%04x l=%u [%*phD]",
+			 __entry->master_nr,
+			 __entry->msg_nr,
+			 __entry->addr,
+			 __entry->flag,
+			 __entry->len,
+			 __entry->len, __get_dynamic_array(buf)
+			 ),
+	       sdw_transfer_trace_reg,
+	       sdw_transfer_trace_unreg);
+
+/*
+ * __sdw_transfer() result
+ */
+TRACE_EVENT_FN(sdw_result,
+	       TP_PROTO(const struct sdw_master *mstr, int num, int ret),
+	       TP_ARGS(mstr, num, ret),
+	       TP_STRUCT__entry(
+		       __field(int,	master_nr)
+		       __field(__u16,	nr_msgs)
+		       __field(__s16,	ret)
+				),
+	       TP_fast_assign(
+		       __entry->master_nr = mstr->nr;
+		       __entry->nr_msgs = num;
+		       __entry->ret = ret;
+			      ),
+	       TP_printk("sdw-%d n=%u ret=%d",
+			 __entry->master_nr,
+			 __entry->nr_msgs,
+			 __entry->ret
+			 ),
+	       sdw_transfer_trace_reg,
+	       sdw_transfer_trace_unreg);
+
+/*
+ * sdw_stream_config() configuration
+ */
+TRACE_EVENT_FN(sdw_config_stream,
+	       TP_PROTO(const struct sdw_master *mstr, const struct sdw_slv *slv, const struct sdw_stream_config *str_cfg, int stream_tag),
+	       TP_ARGS(mstr, slv, str_cfg, stream_tag),
+	       TP_STRUCT__entry(
+		       __field(unsigned int,	frame_rate)
+		       __field(unsigned int,	ch_cnt)
+		       __field(unsigned int,	bps)
+		       __field(unsigned int,	direction)
+		       __field(unsigned int,	stream_tag)
+		       __array(char,		name,	SOUNDWIRE_NAME_SIZE)
+				),
+	       TP_fast_assign(
+		       __entry->frame_rate = str_cfg->frame_rate;
+		       __entry->ch_cnt = str_cfg->channel_count;
+		       __entry->bps = str_cfg->bps;
+		       __entry->direction = str_cfg->direction;
+		       __entry->stream_tag = stream_tag;
+		       slv ? strncpy(entry->name, dev_name(&slv->dev), SOUNDWIRE_NAME_SIZE) : strncpy(entry->name, dev_name(&mstr->dev), SOUNDWIRE_NAME_SIZE);
+			      ),
+	       TP_printk("Stream_config dev = %s stream_tag = %d, frame_rate = %d, ch_count = %d bps = %d dir = %d",
+			__entry->name,
+			__entry->stream_tag,
+			 __entry->frame_rate,
+			 __entry->ch_cnt,
+			 __entry->bps,
+			 __entry->direction
+			 ),
+	       sdw_transfer_trace_reg,
+	       sdw_transfer_trace_unreg);
+
+/*
+ * sdw_port_config() configuration
+ */
+TRACE_EVENT_FN(sdw_config_port,
+	       TP_PROTO(const struct sdw_master *mstr, const struct sdw_slv *slv, const struct sdw_port_cfg *port_cfg, int stream_tag),
+	       TP_ARGS(mstr, slv, port_cfg, stream_tag),
+	       TP_STRUCT__entry(
+		       __field(unsigned int,	port_num)
+		       __field(unsigned int,	ch_mask)
+		       __field(unsigned int,	stream_tag)
+		       __array(char,		name,	SOUNDWIRE_NAME_SIZE)
+				),
+	       TP_fast_assign(
+		       __entry->port_num = port_cfg->port_num;
+		       __entry->ch_mask = port_cfg->ch_mask;
+		       __entry->stream_tag = stream_tag;
+		       slv ? strncpy(entry->name, dev_name(&slv->dev), SOUNDWIRE_NAME_SIZE) : strncpy(entry->name, dev_name(&mstr->dev), SOUNDWIRE_NAME_SIZE);
+			      ),
+	       TP_printk("Port_config dev = %s stream_tag = %d, port = %d, ch_mask = %d",
+			__entry->name,
+			__entry->stream_tag,
+			 __entry->port_num,
+			 __entry->ch_mask
+			 ),
+	       sdw_transfer_trace_reg,
+	       sdw_transfer_trace_unreg);
+
+#endif /* _TRACE_SDW_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
-- 
2.19.1

