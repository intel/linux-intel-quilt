From ab3a334557b7dc4690e185bb3b855a08b492a8aa Mon Sep 17 00:00:00 2001
From: "Wong, Vee Khee" <vee.khee.wong@intel.com>
Date: Mon, 16 Mar 2020 13:34:38 +0800
Subject: [PATCH 6/9] net: stmmac: Fix incorrect handling of TX/RX interrupts

In the case of multi-MSI interrupt enabled, TX/RX interrupts should be
handled separately by the sbd_perch_[tx|rx]_intr_o (Transmit/Receive
Per Channel) interrupt service routines.

Current implementation has TX/RX handling in the sbd_intr_o (Common)
interrupt service routine, which will cause unexpected behavior when
there are sbd_perch_[tx|rx]intr_o and sbd_intr_o interrupts asserted at
the same time. Moving the TX/RX related codes to the correct ISR, and
also setting the Interrupt Mode to 1 in the DMA_Bus_Mode register, so
that TX/RX packet transfer will not cause the sbd_intr_o interrupt to
assert.

Signed-off-by: Wong, Vee Khee <vee.khee.wong@intel.com>
---
 .../net/ethernet/stmicro/stmmac/dwmac4_dma.c  |  8 ++++++
 .../net/ethernet/stmicro/stmmac/dwmac4_dma.h  |  5 ++++
 .../net/ethernet/stmicro/stmmac/stmmac_main.c | 28 ++++++++-----------
 include/linux/stmmac.h                        |  1 +
 4 files changed, 26 insertions(+), 16 deletions(-)

Index: kernel-lts-staging/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
===================================================================
--- kernel-lts-staging.orig/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
+++ kernel-lts-staging/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
@@ -163,6 +163,14 @@ static void dwmac4_dma_init(void __iomem
 #endif
 
 	writel(value, ioaddr + DMA_SYS_BUS_MODE);
+
+	value = readl(ioaddr + DMA_BUS_MODE);
+
+	if (dma_cfg->multi_msi_en) {
+		value &= ~DMA_BUS_MODE_INTM_MASK;
+		value |= (DMA_BUS_MODE_INTM_MODE1 << DMA_BUS_MODE_INTM_SHIFT);
+	}
+	writel(value, ioaddr + DMA_BUS_MODE);
 }
 
 static void _dwmac4_dump_dma_regs(void __iomem *ioaddr, u32 channel,
Index: kernel-lts-staging/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.h
===================================================================
--- kernel-lts-staging.orig/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.h
+++ kernel-lts-staging/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.h
@@ -24,6 +24,11 @@
 #define DMA_AXI_BUS_MODE		0x00001028
 
 /* DMA Bus Mode bitmap */
+#define DMA_BUS_MODE_INTM_MASK		GENMASK(17, 16)
+#define DMA_BUS_MODE_INTM_SHIFT		16
+#define DMA_BUS_MODE_INTM_MODE0		0x0
+#define DMA_BUS_MODE_INTM_MODE1		0x1
+#define DMA_BUS_MODE_INTM_MODE2		0x2
 #define DMA_BUS_MODE_SFT_RESET		BIT(0)
 
 /* DMA SYS Bus Mode bitmap */
Index: kernel-lts-staging/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
===================================================================
--- kernel-lts-staging.orig/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ kernel-lts-staging/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -5023,7 +5023,6 @@ static void stmmac_common_interrupt(stru
 	u32 rx_cnt = priv->plat->rx_queues_to_use;
 	u32 tx_cnt = priv->plat->tx_queues_to_use;
 	u32 queues_count;
-	u32 queue;
 	bool xmac;
 
 	xmac = priv->plat->has_gmac4 || priv->plat->has_xgmac;
@@ -5050,10 +5049,6 @@ static void stmmac_common_interrupt(stru
 				priv->tx_path_in_lpi_mode = false;
 		}
 
-		for (queue = 0; queue < queues_count; queue++) {
-			status = stmmac_host_mtl_irq_status(priv, priv->hw,
-							    queue);
-		}
 
 		/* PCS link status */
 		if (priv->hw->pcs) {
@@ -5189,6 +5184,7 @@ static irqreturn_t stmmac_msi_intr_rx(in
 	struct stmmac_rx_queue *rx_q = (struct stmmac_rx_queue *)data;
 	int chan = rx_q->queue_index;
 	struct stmmac_priv *priv;
+	int mtl_status;
 
 	priv = container_of(rx_q, struct stmmac_priv, rx_queue[chan]);
 
@@ -5201,6 +5197,16 @@ static irqreturn_t stmmac_msi_intr_rx(in
 	if (test_bit(STMMAC_DOWN, &priv->state))
 		return IRQ_HANDLED;
 
+	mtl_status = stmmac_host_mtl_irq_status(priv, priv->hw,
+						chan);
+
+	if (mtl_status & CORE_IRQ_MTL_RX_OVERFLOW) {
+		stmmac_set_rx_tail_ptr(priv, priv->ioaddr,
+				       rx_q->rx_tail_addr,
+				       chan);
+		return IRQ_HANDLED;
+	}
+
 	/* Skip napi for XDP ZC queues to reduce latency.
 	 * Penalties of not using NAPI should be minimal for XDP's case.
 	 * Otherwise, users can increase the Rx interrupt coalesce.
@@ -6314,6 +6320,7 @@ int stmmac_dvr_probe(struct device *devi
 	priv->plat = plat_dat;
 	priv->ioaddr = res->addr;
 	priv->dev->base_addr = (unsigned long)res->addr;
+	priv->plat->dma_cfg->multi_msi_en = priv->plat->multi_msi_en;
 
 	priv->dev->irq = res->irq;
 	priv->wol_irq = res->wol_irq;
Index: kernel-lts-staging/include/linux/stmmac.h
===================================================================
--- kernel-lts-staging.orig/include/linux/stmmac.h
+++ kernel-lts-staging/include/linux/stmmac.h
@@ -93,6 +93,7 @@ struct stmmac_dma_cfg {
 	int fixed_burst;
 	int mixed_burst;
 	bool aal;
+	bool multi_msi_en;
 };
 
 #define AXI_BLEN	7
