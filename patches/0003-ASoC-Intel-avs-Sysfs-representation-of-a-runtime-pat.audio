From aafe3b60a42cb33322298e432d958a6479dea2b8 Mon Sep 17 00:00:00 2001
From: Cezary Rojewski <cezary.rojewski@intel.com>
Date: Sun, 5 Dec 2021 16:24:50 +0100
Subject: [PATCH 3/4] ASoC: Intel: avs: Sysfs representation of a runtime path

Signed-off-by: Cezary Rojewski <cezary.rojewski@intel.com>
---
 .../ABI/testing/sysfs-bus-pci-devices-avs     |  33 +++
 sound/soc/intel/avs/avs.h                     |   1 +
 sound/soc/intel/avs/messages.h                |   4 +
 sound/soc/intel/avs/path.c                    | 208 +++++++++++++++++-
 sound/soc/intel/avs/path.h                    |   3 +
 sound/soc/intel/avs/pcm.c                     |  10 +
 6 files changed, 250 insertions(+), 9 deletions(-)

diff --git a/Documentation/ABI/testing/sysfs-bus-pci-devices-avs b/Documentation/ABI/testing/sysfs-bus-pci-devices-avs
index ebff3fa12055d..04f6eefb5d370 100644
--- a/Documentation/ABI/testing/sysfs-bus-pci-devices-avs
+++ b/Documentation/ABI/testing/sysfs-bus-pci-devices-avs
@@ -6,3 +6,36 @@ Description:
 		with.
 
 		Format: %d.%d.%d.%d, type:major:minor:build.
+
+What:		/sys/devices/pci0000:00/<dev>/keyphrase_notify
+Date:		December 2021
+Contact:	Cezary Rojewski <cezary.rojewski@intel.com>
+Description:
+		File which should be used by user space application making use
+		of speech recognition features of avs driver. On notification
+		contains 6 dwords, representing contents of FW notification.
+
+What:		/sys/devices/pci0000:00/<dev>/<tplg_name>/<path_template>:<path>/<pipeline>/state
+Date:		December 2021
+Contact:	Cezary Rojewski <cezary.rojewski@intel.com>
+Description:
+		File is only present when specific pipeline is instantiated in
+		driver. It is used to check or change pipeline state. Possible
+		read values: invalid, uninitialized, reset, paused, running,
+		eos, error_stop, saved, restored.
+		Allows only to set state to: reset, paused, running.
+
+What:		/sys/devices/pci0000:00/<dev>/<tplg_name>/<path_template>:<path>/<pipeline>/<module>/fw_id
+Date:		December 2021
+Contact:	Cezary Rojewski <cezary.rojewski@intel.com>
+Description:
+		File is only present when specific module is instantiated in
+		driver. Used to get module id used by FW for module in question.
+
+What:		/sys/devices/pci0000:00/<dev>/<tplg_name>/<path_template>:<path>/<pipeline>/<module>/fw_instance
+Date:		December 2021
+Contact:	Cezary Rojewski <cezary.rojewski@intel.com>
+Description:
+		File is only present when specific module is instantiated in
+		driver. Used to get instance id assigned from pool of ids
+		for module in question.
diff --git a/sound/soc/intel/avs/avs.h b/sound/soc/intel/avs/avs.h
index f80f79415344a..e1a3cb868b085 100644
--- a/sound/soc/intel/avs/avs.h
+++ b/sound/soc/intel/avs/avs.h
@@ -332,6 +332,7 @@ int avs_icl_load_basefw(struct avs_dev *adev, struct firmware *fw);
 struct avs_soc_component {
 	struct snd_soc_component base;
 	struct avs_tplg *tplg;
+	struct kobject *kobj;
 
 	struct list_head node;
 };
diff --git a/sound/soc/intel/avs/messages.h b/sound/soc/intel/avs/messages.h
index a0907c15ae9f7..a0217eac91227 100644
--- a/sound/soc/intel/avs/messages.h
+++ b/sound/soc/intel/avs/messages.h
@@ -299,6 +299,10 @@ enum avs_pipeline_state {
 	AVS_PPL_STATE_RESET,
 	AVS_PPL_STATE_PAUSED,
 	AVS_PPL_STATE_RUNNING,
+	AVS_PPL_STATE_EOS,
+	AVS_PPL_STATE_ERROR_STOP,
+	AVS_PPL_STATE_SAVED,
+	AVS_PPL_STATE_RESTORED,
 };
 
 int avs_ipc_create_pipeline(struct avs_dev *adev, u16 req_size, u8 priority,
diff --git a/sound/soc/intel/avs/path.c b/sound/soc/intel/avs/path.c
index 75c4303788cb8..f465f9219e5e3 100644
--- a/sound/soc/intel/avs/path.c
+++ b/sound/soc/intel/avs/path.c
@@ -621,11 +621,80 @@ static int avs_path_module_type_create(struct avs_dev *adev, struct avs_path_mod
 	return avs_modext_create(adev, mod);
 }
 
-static void avs_path_module_free(struct avs_dev *adev, struct avs_path_module *mod)
+static int avs_path_module_send_init_configs(struct avs_dev *adev, struct avs_path_module *mod)
+{
+	struct avs_soc_component *acomp;
+
+	acomp = to_avs_soc_component(mod->template->owner->owner->owner->owner->comp);
+
+	u32 num_ids = mod->template->num_config_ids;
+	u32 *ids = mod->template->config_ids;
+
+	for (int i = 0; i < num_ids; i++) {
+		struct avs_tplg_init_config *config = &acomp->tplg->init_configs[ids[i]];
+		size_t len = config->length;
+		void *data = config->data;
+		u32 param = config->param;
+		int ret;
+
+		ret = avs_ipc_set_large_config(adev, mod->module_id, mod->instance_id,
+					       param, data, len);
+		if (ret) {
+			dev_err(adev->dev, "send initial module config failed: %d\n", ret);
+			return AVS_IPC_RET(ret);
+		}
+	}
+
+	return 0;
+}
+
+static void avs_path_module_release(struct kobject *kobj)
 {
+	struct avs_path_module *mod = container_of(kobj, struct avs_path_module, kobj);
+
 	kfree(mod);
 }
 
+static ssize_t avs_path_module_fw_id_show(struct kobject *kobj,
+					  struct kobj_attribute *attr, char *buf)
+{
+	struct avs_path_module *mod = container_of(kobj, struct avs_path_module, kobj);
+
+	return sprintf(buf, "%d\n", mod->module_id);
+}
+
+static struct kobj_attribute avs_path_module_fw_id =
+		__ATTR(fw_id, 0444, avs_path_module_fw_id_show, NULL);
+
+static ssize_t avs_path_module_fw_instance_show(struct kobject *kobj,
+						struct kobj_attribute *attr, char *buf)
+{
+	struct avs_path_module *mod = container_of(kobj, struct avs_path_module, kobj);
+
+	return sprintf(buf, "%d\n", mod->instance_id);
+}
+
+static struct kobj_attribute avs_path_module_fw_instance =
+		__ATTR(fw_instance, 0444, avs_path_module_fw_instance_show, NULL);
+
+static struct attribute *avs_path_module_attrs[] = {
+	&avs_path_module_fw_id.attr,
+	&avs_path_module_fw_instance.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(avs_path_module);
+
+static struct kobj_type avs_path_module_ktype = {
+	.release = avs_path_module_release,
+	.default_groups = avs_path_module_groups,
+	.sysfs_ops = &kobj_sysfs_ops,
+};
+
+static void avs_path_module_free(struct avs_dev *adev, struct avs_path_module *mod)
+{
+	kobject_put(&mod->kobj);
+}
+
 static struct avs_path_module *
 avs_path_module_create(struct avs_dev *adev,
 		       struct avs_path_pipeline *owner,
@@ -654,6 +723,19 @@ avs_path_module_create(struct avs_dev *adev,
 		return ERR_PTR(ret);
 	}
 
+	ret = avs_path_module_send_init_configs(adev, mod);
+	if (ret) {
+		kfree(mod);
+		return ERR_PTR(ret);
+	}
+
+	ret = kobject_init_and_add(&mod->kobj, &avs_path_module_ktype,
+				   &owner->kobj, "%d", template->id);
+	if (ret) {
+		kobject_put(&mod->kobj);
+		return ERR_PTR(ret);
+	}
+
 	return mod;
 }
 
@@ -731,6 +813,86 @@ static struct avs_path_binding *avs_path_binding_create(struct avs_dev *adev,
 	return binding;
 }
 
+static void avs_path_pipeline_release(struct kobject *kobj)
+{
+	struct avs_path_pipeline *ppl = container_of(kobj, struct avs_path_pipeline, kobj);
+
+	kfree(ppl);
+}
+
+static const char *pipeline_state_str[] = {
+	[AVS_PPL_STATE_INVALID] = "invalid",
+	[AVS_PPL_STATE_UNINITIALIZED] = "uninitialized",
+	[AVS_PPL_STATE_RESET] = "reset",
+	[AVS_PPL_STATE_PAUSED] = "paused",
+	[AVS_PPL_STATE_RUNNING] = "running",
+	[AVS_PPL_STATE_EOS] = "eos",
+	[AVS_PPL_STATE_ERROR_STOP] = "error_stop",
+	[AVS_PPL_STATE_SAVED] = "saved",
+	[AVS_PPL_STATE_RESTORED] = "restored",
+};
+
+static ssize_t avs_path_pipeline_state_show(struct kobject *kobj,
+					    struct kobj_attribute *attr, char *buf)
+{
+	struct avs_path_pipeline *ppl = container_of(kobj, struct avs_path_pipeline, kobj);
+	struct avs_dev *adev = ppl->owner->owner;
+	enum avs_pipeline_state state;
+	int ret;
+
+	ret = avs_ipc_get_pipeline_state(adev, ppl->instance_id, &state);
+	if (ret) {
+		dev_err(adev->dev, "read pipeline state failed: %d\n", ret);
+		return AVS_IPC_RET(ret);
+	}
+
+	if (state >= ARRAY_SIZE(pipeline_state_str))
+		return -EIO;
+	return sprintf(buf, pipeline_state_str[state]);
+}
+
+static ssize_t avs_path_pipeline_state_store(struct kobject *kobj,
+					     struct kobj_attribute *attr,
+					     const char *buf, size_t len)
+{
+	struct avs_path_pipeline *ppl = container_of(kobj, struct avs_path_pipeline, kobj);
+	struct avs_dev *adev = ppl->owner->owner;
+	enum avs_pipeline_state state;
+	int ret;
+
+	if (sysfs_streq(buf, "reset"))
+		state = AVS_PPL_STATE_RESET;
+	else if (sysfs_streq(buf, "paused"))
+		state = AVS_PPL_STATE_PAUSED;
+	else if (sysfs_streq(buf, "running"))
+		state = AVS_PPL_STATE_RUNNING;
+	else
+		return -EINVAL;
+
+	ret = avs_ipc_set_pipeline_state(adev, ppl->instance_id, state);
+	if (ret) {
+		dev_err(adev->dev, "write pipeline state failed: %d\n", ret);
+		return AVS_IPC_RET(ret);
+	}
+
+	return len;
+}
+
+static struct kobj_attribute avs_path_pipeline_state =
+	__ATTR(state, 0664, avs_path_pipeline_state_show, avs_path_pipeline_state_store);
+
+static struct attribute *avs_path_pipeline_attrs[] = {
+	&avs_path_pipeline_state.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(avs_path_pipeline);
+
+static struct kobj_type avs_path_pipeline_ktype = {
+	.release = avs_path_pipeline_release,
+	.default_groups = avs_path_pipeline_groups,
+	.sysfs_ops = &kobj_sysfs_ops,
+};
+
 static int avs_path_pipeline_arm(struct avs_dev *adev,
 				 struct avs_path_pipeline *ppl)
 {
@@ -785,7 +947,7 @@ static void avs_path_pipeline_free(struct avs_dev *adev,
 	}
 
 	list_del(&ppl->node);
-	kfree(ppl);
+	kobject_put(&ppl->kobj);
 }
 
 static struct avs_path_pipeline *
@@ -816,6 +978,11 @@ avs_path_pipeline_create(struct avs_dev *adev, struct avs_path *owner,
 		return ERR_PTR(ret);
 	}
 
+	ret = kobject_init_and_add(&ppl->kobj, &avs_path_pipeline_ktype,
+				   &owner->kobj, "%d", ppl->template->id);
+	if (ret)
+		goto err;
+
 	list_for_each_entry(tmod, &template->mod_list, node) {
 		struct avs_path_module *mod;
 
@@ -823,7 +990,7 @@ avs_path_pipeline_create(struct avs_dev *adev, struct avs_path *owner,
 		if (IS_ERR(mod)) {
 			ret = PTR_ERR(mod);
 			dev_err(adev->dev, "error creating module %d\n", ret);
-			goto init_err;
+			goto err;
 		}
 
 		list_add_tail(&mod->node, &ppl->mod_list);
@@ -836,7 +1003,7 @@ avs_path_pipeline_create(struct avs_dev *adev, struct avs_path *owner,
 		if (IS_ERR(binding)) {
 			ret = PTR_ERR(binding);
 			dev_err(adev->dev, "error creating binding %d\n", ret);
-			goto init_err;
+			goto err;
 		}
 
 		list_add_tail(&binding->node, &ppl->binding_list);
@@ -844,11 +1011,22 @@ avs_path_pipeline_create(struct avs_dev *adev, struct avs_path *owner,
 
 	return ppl;
 
-init_err:
+err:
 	avs_path_pipeline_free(adev, ppl);
 	return ERR_PTR(ret);
 }
 
+static void avs_path_release(struct kobject *kobj)
+{
+	struct avs_path *path = container_of(kobj, struct avs_path, kobj);
+
+	kfree(path);
+}
+
+static struct kobj_type avs_path_ktype = {
+	.release = avs_path_release,
+};
+
 static int avs_path_init(struct avs_dev *adev, struct avs_path *path,
 			 struct avs_tplg_path *template, u32 dma_id)
 {
@@ -918,19 +1096,30 @@ static void avs_path_free_unlocked(struct avs_path *path)
 	list_for_each_entry_safe(ppl, save, &path->ppl_list, node)
 		avs_path_pipeline_free(path->owner, ppl);
 
-	kfree(path);
+	kobject_put(&path->kobj);
 }
 
 static struct avs_path *avs_path_create_unlocked(struct avs_dev *adev, u32 dma_id,
-						 struct avs_tplg_path *template)
+						 struct avs_tplg_path *template,
+						 const char *prefix)
 {
+	struct avs_soc_component *acomp;
 	struct avs_path *path;
 	int ret;
 
+	acomp = to_avs_soc_component(template->owner->owner->comp);
+
 	path = kzalloc(sizeof(*path), GFP_KERNEL);
 	if (!path)
 		return ERR_PTR(-ENOMEM);
 
+	ret = kobject_init_and_add(&path->kobj, &avs_path_ktype, acomp->kobj, "%s%d:%d",
+				   prefix, template->owner->id, template->id);
+	if (ret) {
+		kobject_put(&path->kobj);
+		return ERR_PTR(ret);
+	}
+
 	ret = avs_path_init(adev, path, template, dma_id);
 	if (ret < 0)
 		goto err;
@@ -972,7 +1161,8 @@ static struct avs_path *avs_condpath_create(struct avs_dev *adev, u32 dma_id,
 	struct avs_path *path;
 	int ret;
 
-	path = avs_path_create_unlocked(adev, dma_id, template);
+	/* condpath sysfs files must differ from standard path ones. */
+	path = avs_path_create_unlocked(adev, dma_id, template, "c");
 	if (IS_ERR(path))
 		return path;
 
@@ -1140,7 +1330,7 @@ struct avs_path *avs_path_create(struct avs_dev *adev, u32 dma_id,
 	/* Satisfy needs of avs_path_find_tplg(). */
 	mutex_lock(&adev->comp_list_mutex);
 
-	path = avs_path_create_unlocked(adev, dma_id, variant);
+	path = avs_path_create_unlocked(adev, dma_id, variant, "");
 	if (IS_ERR(path))
 		goto exit;
 
diff --git a/sound/soc/intel/avs/path.h b/sound/soc/intel/avs/path.h
index a5076c99a070d..4c8bb31ceac65 100644
--- a/sound/soc/intel/avs/path.h
+++ b/sound/soc/intel/avs/path.h
@@ -17,6 +17,7 @@
 #define AVS_COND_TYPE_AECREF	1
 
 struct avs_path {
+	struct kobject kobj;
 	u32 dma_id;
 	struct list_head ppl_list;
 	u32 state;
@@ -38,6 +39,7 @@ struct avs_path {
 };
 
 struct avs_path_pipeline {
+	struct kobject kobj;
 	u8 instance_id;
 	struct list_head mod_list;
 	struct list_head binding_list;
@@ -49,6 +51,7 @@ struct avs_path_pipeline {
 };
 
 struct avs_path_module {
+	struct kobject kobj;
 	u16 module_id;
 	u8 instance_id;
 	union avs_gtw_attributes gtw_attrs;
diff --git a/sound/soc/intel/avs/pcm.c b/sound/soc/intel/avs/pcm.c
index 957afccbe047e..c68ab6bd636c8 100644
--- a/sound/soc/intel/avs/pcm.c
+++ b/sound/soc/intel/avs/pcm.c
@@ -906,6 +906,12 @@ static int avs_component_probe(struct snd_soc_component *component)
 	if (ret < 0)
 		return ret;
 
+	acomp->kobj = kobject_create_and_add(acomp->tplg->name, &component->dev->kobj);
+	if (!acomp->kobj) {
+		ret = -ENOMEM;
+		goto err_kobj_create;
+	}
+
 	ret = avs_component_load_libraries(acomp);
 	if (ret < 0) {
 		dev_err(card->dev, "libraries loading failed: %d\n", ret);
@@ -923,6 +929,8 @@ static int avs_component_probe(struct snd_soc_component *component)
 	return 0;
 
 err_load_libs:
+	kobject_put(acomp->kobj);
+err_kobj_create:
 	avs_remove_topology(component);
 	return ret;
 }
@@ -936,6 +944,8 @@ static void avs_component_remove(struct snd_soc_component *component)
 
 	mach = dev_get_platdata(component->card->dev);
 
+	kobject_put(acomp->kobj);
+
 	mutex_lock(&adev->comp_list_mutex);
 	list_del(&acomp->node);
 	mutex_unlock(&adev->comp_list_mutex);
-- 
2.25.1

