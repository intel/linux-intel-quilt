From 07307bd1c8f4ea8eb65591e5d49f012265c8b24b Mon Sep 17 00:00:00 2001
From: kadarlax <raghuveerx.kadarla@intel.com>
Date: Mon, 6 Sep 2021 19:33:54 +0530
Subject: [PATCH 093/109] misc: xlink-pcie: boot api support

Adding boot api support for flash and boot.

Signed-off-by: kadarlax <raghuveerx.kadarla@intel.com>
---
 drivers/misc/xlink-pcie/common/boot.h        |  85 +++++++++
 drivers/misc/xlink-pcie/common/util.c        |  29 +---
 drivers/misc/xlink-pcie/common/util.h        |   4 +-
 drivers/misc/xlink-pcie/common/xpcie.h       |   2 +-
 drivers/misc/xlink-pcie/local_host/epf.c     |  13 +-
 drivers/misc/xlink-pcie/remote_host/Makefile |   1 +
 drivers/misc/xlink-pcie/remote_host/boot.c   | 172 +++++++++++++++++++
 drivers/misc/xlink-pcie/remote_host/pci.c    | 127 +++++++++++---
 drivers/misc/xlink-pcie/remote_host/pci.h    |  12 +-
 include/linux/mxlk_boot_inf.h                |  24 +++
 10 files changed, 413 insertions(+), 56 deletions(-)
 create mode 100644 drivers/misc/xlink-pcie/common/boot.h
 create mode 100644 drivers/misc/xlink-pcie/remote_host/boot.c
 create mode 100644 include/linux/mxlk_boot_inf.h

diff --git a/drivers/misc/xlink-pcie/common/boot.h b/drivers/misc/xlink-pcie/common/boot.h
new file mode 100644
index 000000000000..98d8b5bc2dda
--- /dev/null
+++ b/drivers/misc/xlink-pcie/common/boot.h
@@ -0,0 +1,85 @@
+/* SPDX-License-Identifier: GPL-2.0 only */
+/********************************************************************/
+/*
+ * Intel Keem Bay XLink PCIe Driver
+ *
+ * Copyright (C) 2019 Intel Corporation
+ */
+/********************************************************************/
+
+#ifndef XPCIE_BOOT_HEADER_
+#define XPCIE_BOOT_HEADER_
+
+#include <linux/types.h>
+
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#define XPCIE_BOOT_MAGIC_ROM "THBROM"
+#define XPCIE_BOOT_MAGIC_EMMC "THBEMMC"
+#else
+#define XPCIE_BOOT_MAGIC_ROM "VPUROM"
+#define XPCIE_BOOT_MAGIC_EMMC "VPUEMMC"
+#endif
+
+#define XPCIE_BOOT_MAGIC_BL2 "VPUBL2"
+#define XPCIE_BOOT_MAGIC_UBOOT "VPUUBOOT"
+#define XPCIE_BOOT_MAGIC_RECOV "VPURECOV"
+#define XPCIE_BOOT_MAGIC_YOCTO "VPUYOCTO"
+
+enum xpcie_stage {
+	STAGE_UNINIT,
+	STAGE_ROM,
+	STAGE_BL2,
+	STAGE_UBOOT,
+	STAGE_RECOV,
+	STAGE_OS
+};
+
+#define XPCIE_BOOT_FIP_ID (0xFFFFFFFF)
+#define XPCIE_BOOT_BOOT_ID (0xFFFFFF4F)
+#define XPCIE_BOOT_SYSTEM_ID (0xFFFFFF46)
+#define XPCIE_BOOT_RAW_ID (0xFFFFFF00)
+#define XPCIE_BOOT_ERASE_ID (0xFFFFFF01)
+#define XPCIE_BOOT_FLASH_ID (0xFFFFFF02)
+
+#define XPCIE_BOOT_STATUS_START (0x55555555)
+#define XPCIE_BOOT_STATUS_INVALID (0xDEADFFFF)
+#define XPCIE_BOOT_STATUS_DOWNLOADED (0xDDDDDDDD)
+#define XPCIE_BOOT_STATUS_ERROR (0xDEADAAAA)
+#define XPCIE_BOOT_STATUS_DONE (0xBBBBBBBB)
+
+#define XPCIE_INT_ENABLE (0x1)
+#define XPCIE_INT_MASK (0x1)
+
+#define XPCIE_BOOT_MAGIC_STRLEN (16)
+#define XPCIE_BOOT_DEST_STRLEN (128)
+
+#define XPCIE_IO_COMM_MAGIC_OFF (offsetof(struct xpcie_bootio, magic))
+#define XPCIE_IO_COMM_MF_READY_OFF (offsetof(struct xpcie_bootio, mf_ready))
+#define XPCIE_IO_COMM_MF_LEN_OFF (offsetof(struct xpcie_bootio, mf_len))
+#define XPCIE_IO_COMM_MF_START_OFF (offsetof(struct xpcie_bootio, mf_start))
+#define XPCIE_IO_COMM_INT_ENABLE_OFF (offsetof(struct xpcie_bootio, int_enable))
+#define XPCIE_IO_COMM_INT_MASK_OFF (offsetof(struct xpcie_bootio, int_mask))
+#define XPCIE_IO_COMM_INT_IDENTITY_OFF (offsetof(struct xpcie_bootio, int_identity))
+#define XPCIE_IO_COMM_MF_OFF (offsetof(struct xpcie_bootio, mf_offset))
+#define XPCIE_IO_COMM_MF_DEST_OFF (offsetof(struct xpcie_bootio, mf_dest))
+#define XPCIE_IO_COMM_DEV_ID_OFF (offsetof(struct xpcie_bootio, dev_id))
+
+/* Structure declarations */
+struct xpcie_bootio {
+	u8 magic[XPCIE_BOOT_MAGIC_STRLEN];
+	u32 mf_ready;
+	u32 mf_len;
+	u64 reserved1;
+	u64 mf_start;
+	u32 int_enable;
+	u32 int_mask;
+	u32 int_identity;
+	u32 reserved2;
+	u64 mf_offset;
+	u8 mf_dest[XPCIE_BOOT_DEST_STRLEN];
+	u64 dev_id;
+} __packed;
+
+/* function declarations */
+void xpcie_device_irq(struct work_struct *work);
+#endif /* XPCIE_BOOT_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/common/util.c b/drivers/misc/xlink-pcie/common/util.c
index d59bcbcc6370..aafdcdbef7a2 100644
--- a/drivers/misc/xlink-pcie/common/util.c
+++ b/drivers/misc/xlink-pcie/common/util.c
@@ -8,9 +8,6 @@
 #include "util.h"
 #include "xpcie.h"
 
-static LIST_HEAD(dev_list);
-static DEFINE_MUTEX(dev_list_mutex);
-
 u32 intel_xpcie_create_sw_id(u8 func_no, u8 max_pcie_fns, u16 pcie_phys_id)
 {
 	u8 slice_id, dev_type = XLINK_DEV_TYPE_KMB;
@@ -124,26 +121,6 @@ int intel_xpcie_get_device_name_by_id(u32 sw_devid, char *device_name,
 	return 0;
 }
 
-struct xpcie *intel_xpcie_get_device_by_name(const char *name)
-{
-	struct xpcie *xpcie = NULL;
-	bool found = false;
-
-	mutex_lock(&dev_list_mutex);
-	list_for_each_entry(xpcie, &dev_list, list) {
-		if (!strncmp(xpcie->name, name, XPCIE_MAX_NAME_LEN)) {
-			found = true;
-			break;
-		}
-	}
-	mutex_unlock(&dev_list_mutex);
-
-	if (!found)
-		return NULL;
-
-	return xpcie;
-}
-
 void intel_xpcie_set_device_status(struct xpcie *xpcie, u32 status)
 {
 	xpcie->status = status;
@@ -333,7 +310,7 @@ bool intel_xpcie_list_empty(struct xpcie_list *list)
 int intel_xpcie_list_put(struct xpcie_list *list, struct xpcie_buf_desc *bd)
 {
 #ifdef XLINK_PCIE_REMOTE
-	unsigned long flags = 0;
+	unsigned long flags;
 #endif
 
 	if (!bd)
@@ -392,7 +369,7 @@ struct xpcie_buf_desc *intel_xpcie_list_get(struct xpcie_list *list)
 {
 	struct xpcie_buf_desc *bd;
 #ifdef XLINK_PCIE_REMOTE
-	unsigned long flags = 0;
+	unsigned long flags;
 
 	spin_lock_irqsave(&list->lock, flags);
 #else
@@ -548,8 +525,8 @@ void intel_xpcie_add_bd_to_interface(struct xpcie *xpcie,
 void *intel_xpcie_cap_find(struct xpcie *xpcie, u32 start, u16 id)
 {
 	int ttl = XPCIE_CAP_TTL;
-	void *hdr;
 	u16 id_out, next;
+	void *hdr;
 
 	/* If user didn't specify start, assume start of mmio */
 	if (!start)
diff --git a/drivers/misc/xlink-pcie/common/util.h b/drivers/misc/xlink-pcie/common/util.h
index fcbd418862cc..fddcc2836316 100644
--- a/drivers/misc/xlink-pcie/common/util.h
+++ b/drivers/misc/xlink-pcie/common/util.h
@@ -31,6 +31,9 @@ enum xpcie_event_type {
 	SWID_UPDATE_EVENT
 };
 
+static LIST_HEAD(dev_list);
+static DEFINE_MUTEX(dev_list_mutex);
+
 void intel_xpcie_set_doorbell(struct xpcie *xpcie,
 			      enum xpcie_doorbell_direction dirt,
 			      enum xpcie_doorbell_type type, u8 value);
@@ -85,7 +88,6 @@ void intel_xpcie_list_add_device(struct xpcie *xpcie);
 void intel_xpcie_list_del_device(struct xpcie *xpcie);
 u32 intel_xpcie_get_device_num(u32 *id_list);
 struct xpcie *intel_xpcie_get_device_by_id(u32 sw_devid);
-struct xpcie *intel_xpcie_get_device_by_name(const char *name);
 int intel_xpcie_get_device_status_by_id(u32 sw_devid, u32 *status);
 int intel_xpcie_get_device_name_by_id(u32 sw_devid, char *device_name,
 				      size_t name_size);
diff --git a/drivers/misc/xlink-pcie/common/xpcie.h b/drivers/misc/xlink-pcie/common/xpcie.h
index 8dd54f5186ce..3bf82ad2442c 100644
--- a/drivers/misc/xlink-pcie/common/xpcie.h
+++ b/drivers/misc/xlink-pcie/common/xpcie.h
@@ -63,7 +63,6 @@ struct xpcie_mmio {
 	u32 htod_rx_bd_list_count;
 	u32 sw_devid;
 	u32 reserved;
-	u8 magic[XPCIE_MAGIC_STRLEN];
 } __packed;
 
 #define XPCIE_MMIO_DEV_STATUS	(offsetof(struct xpcie_mmio, device_status))
@@ -95,6 +94,7 @@ struct xpcie {
 	void *bar0;
 	void *mmio;
 	void *bar4;
+	void *io_comm;
 
 	struct workqueue_struct *rx_wq;
 	struct workqueue_struct *tx_wq;
diff --git a/drivers/misc/xlink-pcie/local_host/epf.c b/drivers/misc/xlink-pcie/local_host/epf.c
index d9b9acb165fd..4aaf6518215f 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.c
+++ b/drivers/misc/xlink-pcie/local_host/epf.c
@@ -14,6 +14,7 @@
 #include <linux/of_reserved_mem.h>
 
 #include "epf.h"
+#include "../common/boot.h"
 
 #define PCIE_REGS_PCIE_INTR_ENABLE	0x18
 #define PCIE_REGS_PCIE_INTR_FLAGS	0x1C
@@ -187,6 +188,7 @@ static void intel_xpcie_cleanup_bars(struct pci_epf *epf)
 	intel_xpcie_cleanup_bar(epf, BAR_0);
 	intel_xpcie_cleanup_bar(epf, BAR_2);
 	intel_xpcie_cleanup_bar(epf, BAR_4);
+	xpcie_epf->xpcie.io_comm = NULL;
 	xpcie_epf->xpcie.mmio = NULL;
 	xpcie_epf->xpcie.bar4 = NULL;
 }
@@ -269,7 +271,8 @@ static int intel_xpcie_setup_bars(struct pci_epf *epf, size_t align)
 	}
 
 	xpcie_epf->comm_bar = BAR_2;
-	xpcie_epf->xpcie.mmio = (void *)xpcie_epf->vaddr[BAR_2] +
+	xpcie_epf->xpcie.io_comm = xpcie_epf->vaddr[BAR_2];
+	xpcie_epf->xpcie.mmio = (void *)xpcie_epf->xpcie.io_comm +
 				XPCIE_MMIO_OFFSET;
 
 	xpcie_epf->bar4 = BAR_4;
@@ -576,15 +579,15 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	intel_xpcie_set_device_status(&xpcie_epf->xpcie, XPCIE_STATUS_RUN);
 	intel_xpcie_set_doorbell(&xpcie_epf->xpcie, FROM_DEVICE,
 				 DEV_EVENT, NO_OP);
-	memcpy(xpcie_epf->xpcie.mmio + XPCIE_MMIO_MAGIC_OFF, XPCIE_MAGIC_YOCTO,
-	       strlen(XPCIE_MAGIC_YOCTO));
+	memcpy(xpcie_epf->xpcie.io_comm + XPCIE_IO_COMM_MAGIC_OFF,
+	       XPCIE_BOOT_MAGIC_YOCTO, strlen(XPCIE_BOOT_MAGIC_YOCTO));
 
 	return 0;
 
 err_uninit_dma:
 	intel_xpcie_set_device_status(&xpcie_epf->xpcie, XPCIE_STATUS_ERROR);
-	memcpy(xpcie_epf->xpcie.mmio + XPCIE_MMIO_MAGIC_OFF, XPCIE_MAGIC_YOCTO,
-	       strlen(XPCIE_MAGIC_YOCTO));
+	memcpy(xpcie_epf->xpcie.io_comm + XPCIE_IO_COMM_MAGIC_OFF,
+	       XPCIE_BOOT_MAGIC_YOCTO, strlen(XPCIE_BOOT_MAGIC_YOCTO));
 
 	intel_xpcie_ep_dma_uninit(epf);
 
diff --git a/drivers/misc/xlink-pcie/remote_host/Makefile b/drivers/misc/xlink-pcie/remote_host/Makefile
index 45d9953e2c82..9d62c71e1da5 100644
--- a/drivers/misc/xlink-pcie/remote_host/Makefile
+++ b/drivers/misc/xlink-pcie/remote_host/Makefile
@@ -4,5 +4,6 @@ obj-$(CONFIG_XLINK_PCIE_RH_DRIVER) += mxlk.o
 mxlk-objs := main.o
 mxlk-objs += pci.o
 mxlk-objs += core.o
+mxlk-objs += boot.o
 mxlk-objs += ../common/util.o
 mxlk-objs += ../common/interface.o
diff --git a/drivers/misc/xlink-pcie/remote_host/boot.c b/drivers/misc/xlink-pcie/remote_host/boot.c
new file mode 100644
index 000000000000..9ba4b4619606
--- /dev/null
+++ b/drivers/misc/xlink-pcie/remote_host/boot.c
@@ -0,0 +1,172 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*****************************************************************************
+ *
+ * Intel Keem Bay XLink PCIe Driver
+ *
+ * Copyright (C) 2021 Intel Corporation
+ *
+ ****************************************************************************/
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/mxlk_boot_inf.h>
+
+#include "pci.h"
+#include "../common/boot.h"
+
+#define STR_EQUAL(a, b) !strncmp(a, b, strlen(b))
+
+enum xpcie_stage intel_xpcie_check_magic(struct xpcie_dev *xdev)
+{
+	char magic[XPCIE_BOOT_MAGIC_STRLEN];
+
+	memcpy_fromio(magic, xdev->xpcie.io_comm + XPCIE_IO_COMM_MAGIC_OFF,
+		      XPCIE_BOOT_MAGIC_STRLEN);
+
+	if (strlen(magic) == 0)
+		return STAGE_UNINIT;
+
+	if (STR_EQUAL(magic, XPCIE_BOOT_MAGIC_ROM))
+		return STAGE_ROM;
+
+	if (STR_EQUAL(magic, XPCIE_BOOT_MAGIC_EMMC))
+		return STAGE_ROM;
+
+	if (STR_EQUAL(magic, XPCIE_BOOT_MAGIC_BL2))
+		return STAGE_BL2;
+
+	if (STR_EQUAL(magic, XPCIE_BOOT_MAGIC_UBOOT))
+		return STAGE_UBOOT;
+
+	if (STR_EQUAL(magic, XPCIE_BOOT_MAGIC_RECOV))
+		return STAGE_RECOV;
+
+	if (STR_EQUAL(magic, XPCIE_BOOT_MAGIC_YOCTO))
+		return STAGE_OS;
+
+	return STAGE_UNINIT;
+}
+
+void xpcie_device_irq(struct work_struct *work)
+{
+	struct xpcie_dev *xdev = container_of(work, struct xpcie_dev,
+			irq_event);
+
+	if (xdev->boot_notif_fn)
+		xdev->boot_notif_fn(xdev->xpcie.sw_devid);
+};
+
+int intel_xpcie_connect_boot_device(const char *dev_name, u32 *phys_dev_id,
+				    mxlk_pcie_boot_event notif_fn)
+{
+	struct xpcie_dev *xdev = intel_xpcie_get_device_by_name(dev_name);
+
+	if (!xdev) {
+		pr_err("Invalid dev_name %s\n", dev_name);
+		return -EINVAL;
+	}
+
+	if (PCI_FUNC(xdev->pci->devfn)) {
+		dev_err(&xdev->pci->dev,
+			"Invalid PCI function %s\n", dev_name);
+		return -EINVAL;
+	}
+
+	if (xdev->boot_dev_link) {
+		dev_err(&xdev->pci->dev,
+			"Already boot device connected for %s\n", dev_name);
+		return -EINVAL;
+	}
+
+	mutex_lock(&xdev->lock);
+	*phys_dev_id = xdev->xpcie.sw_devid;
+	xdev->boot_notif_fn = notif_fn;
+	xdev->boot_dev_link = true;
+	mutex_unlock(&xdev->lock);
+
+	dev_info(&xdev->pci->dev, "Boot device connected devid %x link %d\n",
+		 *phys_dev_id, xdev->boot_dev_link);
+	return 0;
+}
+EXPORT_SYMBOL(intel_xpcie_connect_boot_device);
+
+int intel_xpcie_boot_mmio_write(u32 phys_dev_id, u32 offset, void *data,
+				size_t size)
+{
+	struct xpcie_dev *xdev =
+			intel_xpcie_get_device_by_phys_id(phys_dev_id);
+
+	if (!xdev) {
+		pr_err("Invalid phys_dev_id %d\n", phys_dev_id);
+		return -EINVAL;
+	}
+
+	if (!xdev->boot_dev_link) {
+		dev_err(&xdev->pci->dev,
+			"No boot device connected for id %08x\n", phys_dev_id);
+		return -EINVAL;
+	}
+
+	mutex_lock(&xdev->lock);
+	memcpy_toio((void *)xdev->xpcie.io_comm + offset,
+		    data, size);
+	mutex_unlock(&xdev->lock);
+
+	return size;
+}
+EXPORT_SYMBOL(intel_xpcie_boot_mmio_write);
+
+int intel_xpcie_boot_mmio_read(u32 phys_dev_id, u32 offset, void *status,
+			       size_t size)
+{
+	struct xpcie_dev *xdev =
+			intel_xpcie_get_device_by_phys_id(phys_dev_id);
+
+	if (!xdev) {
+		pr_err("Invalid phys_dev_id %d\n", phys_dev_id);
+		return -EINVAL;
+	}
+
+	if (!xdev->boot_dev_link) {
+		dev_err(&xdev->pci->dev,
+			"No boot device connected for id %08x\n", phys_dev_id);
+		return -EINVAL;
+	}
+
+	mutex_lock(&xdev->lock);
+	memcpy_fromio(status, (void *)xdev->xpcie.io_comm + offset, size);
+	mutex_unlock(&xdev->lock);
+
+	return size;
+}
+EXPORT_SYMBOL(intel_xpcie_boot_mmio_read);
+
+int intel_xpcie_disconnect_boot_device(u32 phys_dev_id)
+{
+	struct xpcie_dev *xdev =
+			intel_xpcie_get_device_by_phys_id(phys_dev_id);
+
+	if (!xdev) {
+		dev_err(&xdev->pci->dev, "Invalid phys_dev_id %d\n",
+			phys_dev_id);
+		return -EINVAL;
+	}
+
+	if (!xdev->boot_dev_link) {
+		dev_err(&xdev->pci->dev,
+			"No boot device connected for id %08x\n", phys_dev_id);
+		return -EINVAL;
+	}
+
+	mutex_lock(&xdev->lock);
+	if (xdev->boot_notif_fn)
+		xdev->boot_notif_fn = NULL;
+
+	xdev->boot_dev_link = false;
+	mutex_unlock(&xdev->lock);
+
+	dev_info(&xdev->pci->dev,
+		 "Boot device disconnected devid %x link %d\n", phys_dev_id,
+		 xdev->boot_dev_link);
+	return 0;
+}
+EXPORT_SYMBOL(intel_xpcie_disconnect_boot_device);
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.c b/drivers/misc/xlink-pcie/remote_host/pci.c
index 53d1125cb3d2..4a6bfe9f0833 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.c
+++ b/drivers/misc/xlink-pcie/remote_host/pci.c
@@ -73,11 +73,14 @@ static void intel_xpcie_pci_unmap_bar(struct xpcie_dev *xdev)
 		xdev->xpcie.bar0 = NULL;
 	}
 
-	if (xdev->xpcie.mmio) {
-		iounmap((void __iomem *)(xdev->xpcie.mmio - XPCIE_MMIO_OFFSET));
-		xdev->xpcie.mmio = NULL;
+	if (xdev->xpcie.io_comm) {
+		iounmap(xdev->xpcie.io_comm);
+		xdev->xpcie.io_comm = NULL;
 	}
 
+	if (xdev->xpcie.mmio)
+		xdev->xpcie.mmio = NULL;
+
 	if (xdev->xpcie.bar4) {
 		iounmap((void __iomem *)xdev->xpcie.bar4);
 		xdev->xpcie.bar4 = NULL;
@@ -91,6 +94,12 @@ static int intel_xpcie_pci_map_bar(struct xpcie_dev *xdev)
 		return -EIO;
 	}
 
+	xdev->xpcie.io_comm = (void __force *)pci_ioremap_bar(xdev->pci, 2);
+	if (!xdev->xpcie.io_comm) {
+		dev_err(&xdev->pci->dev, "failed to ioremap BAR2\n");
+		goto bar_error;
+	}
+
 	xdev->xpcie.bar0 = (void __force *)pci_ioremap_bar(xdev->pci, 0);
 	if (!xdev->xpcie.bar0) {
 		dev_err(&xdev->pci->dev, "failed to ioremap BAR0\n");
@@ -98,7 +107,7 @@ static int intel_xpcie_pci_map_bar(struct xpcie_dev *xdev)
 	}
 
 	xdev->xpcie.mmio = (void __force *)
-			   (pci_ioremap_bar(xdev->pci, 2) + XPCIE_MMIO_OFFSET);
+			   (xdev->xpcie.io_comm + XPCIE_MMIO_OFFSET);
 	if (!xdev->xpcie.mmio) {
 		dev_err(&xdev->pci->dev, "failed to ioremap BAR2\n");
 		goto bar_error;
@@ -117,6 +126,44 @@ static int intel_xpcie_pci_map_bar(struct xpcie_dev *xdev)
 	return -EIO;
 }
 
+static irqreturn_t intel_xpcie_core_interrupt(int irq, void *args)
+{
+	struct xpcie_dev *xdev = args;
+	enum xpcie_stage stage;
+	struct pci_dev *pdev;
+	u8 event;
+
+	pdev = xdev->pci;
+	if (pdev->device == PCI_DEVICE_ID_INTEL_THB_FULL ||
+	    pdev->device == PCI_DEVICE_ID_INTEL_THB_PRIME) {
+		stage = intel_xpcie_check_magic(xdev);
+		if (stage == STAGE_ROM || stage == STAGE_UBOOT || stage == STAGE_RECOV)
+			schedule_work(&xdev->irq_event);
+	}
+
+	event = intel_xpcie_get_doorbell(&xdev->xpcie, FROM_DEVICE, DEV_EVENT);
+	if (event == DEV_SHUTDOWN || event == 0xFF) {
+		pr_info("%s: shutdown_event (event=0x%x)\n", __func__, event);
+		schedule_delayed_work(&xdev->shutdown_event, 0);
+		return IRQ_HANDLED;
+	}
+
+	if (likely(xdev->core_irq_callback))
+		return xdev->core_irq_callback(irq, args);
+
+	return IRQ_HANDLED;
+}
+
+int intel_xpcie_pci_register_irq(struct xpcie_dev *xdev, irq_handler_t irq_handler)
+{
+	if (xdev->xpcie.status != XPCIE_STATUS_READY)
+		return -EINVAL;
+
+	xdev->core_irq_callback = irq_handler;
+
+	return 0;
+}
+
 static void intel_xpcie_pci_irq_cleanup(struct xpcie_dev *xdev)
 {
 	int irq = pci_irq_vector(xdev->pci, 0);
@@ -129,8 +176,7 @@ static void intel_xpcie_pci_irq_cleanup(struct xpcie_dev *xdev)
 	pci_free_irq_vectors(xdev->pci);
 }
 
-static int intel_xpcie_pci_irq_init(struct xpcie_dev *xdev,
-				    irq_handler_t irq_handler)
+static int intel_xpcie_pci_irq_init(struct xpcie_dev *xdev)
 {
 	int rc, irq;
 
@@ -147,7 +193,7 @@ static int intel_xpcie_pci_irq_init(struct xpcie_dev *xdev,
 		rc = irq;
 		goto error_irq;
 	}
-	rc = request_irq(irq, irq_handler, 0,
+	rc = request_irq(irq, &intel_xpcie_core_interrupt, 0,
 			 XPCIE_DRIVER_NAME, xdev);
 	if (rc) {
 		dev_err(&xdev->pci->dev, "failed to request irq\n");
@@ -205,9 +251,20 @@ static void xpcie_device_shutdown(struct work_struct *work)
 
 static int xpcie_device_init(struct xpcie_dev *xdev)
 {
+	struct pci_dev *pdev = xdev->pci;
+	int rc;
+
 	INIT_DELAYED_WORK(&xdev->wait_event, xpcie_device_poll);
 	INIT_DELAYED_WORK(&xdev->shutdown_event, xpcie_device_shutdown);
 
+	if (pdev->device == PCI_DEVICE_ID_INTEL_THB_FULL ||
+	    pdev->device == PCI_DEVICE_ID_INTEL_THB_PRIME)
+		INIT_WORK(&xdev->irq_event, xpcie_device_irq);
+
+	rc = intel_xpcie_pci_irq_init(xdev);
+	if (rc)
+		return rc;
+
 	pci_set_master(xdev->pci);
 
 	xdev->xpcie.status = XPCIE_STATUS_UNINIT;
@@ -277,11 +334,18 @@ int intel_xpcie_pci_init(struct xpcie_dev *xdev, struct pci_dev *pdev)
 
 int intel_xpcie_pci_cleanup(struct xpcie_dev *xdev)
 {
+	struct pci_dev *pdev = xdev->pci;
+
 	if (mutex_lock_interruptible(&xdev->lock))
 		return -EINTR;
 
 	cancel_delayed_work(&xdev->wait_event);
 	cancel_delayed_work(&xdev->shutdown_event);
+
+	if (pdev->device == PCI_DEVICE_ID_INTEL_THB_FULL ||
+	    pdev->device == PCI_DEVICE_ID_INTEL_THB_PRIME)
+		cancel_work_sync(&xdev->irq_event);
+
 	xdev->core_irq_callback = NULL;
 	intel_xpcie_pci_irq_cleanup(xdev);
 
@@ -299,21 +363,6 @@ int intel_xpcie_pci_cleanup(struct xpcie_dev *xdev)
 	return 0;
 }
 
-int intel_xpcie_pci_register_irq(struct xpcie_dev *xdev,
-				 irq_handler_t irq_handler)
-{
-	int rc;
-
-	if (xdev->xpcie.status != XPCIE_STATUS_READY)
-		return -EINVAL;
-
-	rc = intel_xpcie_pci_irq_init(xdev, irq_handler);
-	if (rc)
-		dev_warn(&xdev->pci->dev, "failed to initialize pci irq\n");
-
-	return rc;
-}
-
 int intel_xpcie_pci_raise_irq(struct xpcie_dev *xdev,
 			      enum xpcie_doorbell_type type,
 			      u8 value)
@@ -435,3 +484,37 @@ void intel_xpcie_pci_notify_event(struct xpcie_dev *xdev,
 	if (xdev->event_fn)
 		xdev->event_fn(xdev->xpcie.sw_devid, event_type);
 }
+
+struct xpcie_dev *intel_xpcie_get_device_by_name(const char *name)
+{
+	struct xpcie_dev *p;
+	bool found = false;
+
+	mutex_lock(&dev_list_mutex);
+	list_for_each_entry(p, &dev_list, list) {
+		if (!strncmp(p->name, name, XPCIE_MAX_NAME_LEN)) {
+			found = true;
+			break;
+		}
+	}
+	mutex_unlock(&dev_list_mutex);
+
+	if (!found)
+		p = NULL;
+
+	return p;
+}
+
+struct xpcie_dev *intel_xpcie_get_device_by_phys_id(u32 phys_id)
+{
+	struct xpcie_dev *xdev;
+
+	mutex_lock(&dev_list_mutex);
+	list_for_each_entry(xdev, &dev_list, list) {
+		if (xdev->xpcie.sw_devid == phys_id)
+			break;
+	}
+	mutex_unlock(&dev_list_mutex);
+
+	return xdev;
+}
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.h b/drivers/misc/xlink-pcie/remote_host/pci.h
index e13b2e23a9c7..09499b50fd0e 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.h
+++ b/drivers/misc/xlink-pcie/remote_host/pci.h
@@ -12,8 +12,11 @@
 #include <linux/list.h>
 #include <linux/pci.h>
 #include <linux/xlink_drv_inf.h>
-#include "../common/xpcie.h"
+#include <linux/mxlk_boot_inf.h>
+
+#include "../common/boot.h"
 #include "../common/util.h"
+#include "../common/xpcie.h"
 
 #define XPCIE_DRIVER_NAME "mxlk"
 #define XPCIE_DRIVER_DESC "Intel(R) Keem Bay XLink PCIe driver"
@@ -37,6 +40,10 @@ struct xpcie_dev {
 	struct xpcie xpcie;
 	xlink_device_event event_fn;
 	u8 max_functions;
+	/* boot notification support*/
+	struct work_struct irq_event;
+	bool boot_dev_link;
+	mxlk_pcie_boot_event boot_notif_fn;
 };
 
 static inline struct device *xpcie_to_dev(struct xpcie *xpcie)
@@ -65,4 +72,7 @@ void intel_xpcie_remove_device(struct xpcie_dev *xdev);
 void intel_xpcie_pci_notify_event(struct xpcie_dev *xdev,
 				  enum xlink_device_event_type event_type);
 
+struct xpcie_dev *intel_xpcie_get_device_by_name(const char *name);
+enum xpcie_stage intel_xpcie_check_magic(struct xpcie_dev *xdev);
+struct xpcie_dev *intel_xpcie_get_device_by_phys_id(u32 phys_id);
 #endif /* XPCIE_PCI_HEADER_ */
diff --git a/include/linux/mxlk_boot_inf.h b/include/linux/mxlk_boot_inf.h
new file mode 100644
index 000000000000..d6dc10652089
--- /dev/null
+++ b/include/linux/mxlk_boot_inf.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 only */
+/*****************************************************************************
+ *
+ * Intel Keem Bay XLink PCIe Driver
+ *
+ * Copyright (C) 2019 Intel Corporation
+ *
+ ****************************************************************************/
+
+typedef int (*mxlk_pcie_boot_event)(uint32_t phys_dev_id);
+
+
+int mxlk_pcie_connect_boot_device(const char *dev_name,
+				  uint32_t *phys_dev_id,
+				  mxlk_pcie_boot_event notif_fn);
+int mxlk_pcie_boot_mmio_write(uint32_t phys_dev_id, uint32_t offset,
+			      void *data, size_t size);
+int mxlk_pcie_boot_mmio_read(uint32_t phys_dev_id, uint32_t offset,
+			     void *status, size_t size);
+int mxlk_pcie_disconnect_boot_device(uint32_t phys_dev_id);
+void *xlink_pcie_alloc_dma_memory(u32 phys_dev_id,
+				  size_t size, dma_addr_t *phys_addr);
+int xlink_pcie_free_dma_memory(u32 phys_dev_id, size_t size,
+			       void *dma_buf, dma_addr_t phys_addr);
-- 
2.25.1

