From 7da66d3bd83250c047ffa9dbc59b20ee6266f5cb Mon Sep 17 00:00:00 2001
From: "Luo, Xinanx" <xinanx.luo@intel.com>
Date: Fri, 27 Jul 2018 15:01:13 +0800
Subject: [PATCH 62/62] watchdog: add an IRQ handler to dump log on first
 timeout

Add an IRQ handler to dump kernel logs when i6300esb timeout for
the first time(30s)

Modifications:
1,Alloc an IRQ and register a handler for it at probe of driver
2,Set i6300esb interrupt type of first stage timeout to IRQ
3,Check if it's i6300esb interrupt in handler, if yes,then dump
kernel logs, and then panic. Then system will reboot at second
stage timeout(30s)

Change-Id: I26567fa8b8ab29fcb0c9a99f462e772f4f65d53a
Signed-off-by: Luo, Xinanx <xinanx.luo@intel.com>
Signed-off-by: Tian, Baofeng
---
 drivers/watchdog/Kconfig    |  2 +-
 drivers/watchdog/i6300esb.c | 47 +++++++++++++++++++++++++++++++++++--
 2 files changed, 46 insertions(+), 3 deletions(-)

diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index b2dd4ac2fc63..5396f58b444b 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -1013,7 +1013,7 @@ config WAFER_WDT
 	  module will be called wafer5823wdt.
 
 config I6300ESB_WDT
-	tristate "Intel 6300ESB Timer/Watchdog"
+	bool "Intel 6300ESB Timer/Watchdog"
 	depends on PCI
 	select WATCHDOG_CORE
 	---help---
diff --git a/drivers/watchdog/i6300esb.c b/drivers/watchdog/i6300esb.c
index 950c71a8bb22..676bd72fb524 100644
--- a/drivers/watchdog/i6300esb.c
+++ b/drivers/watchdog/i6300esb.c
@@ -41,6 +41,7 @@
 #include <linux/ioport.h>
 #include <linux/uaccess.h>
 #include <linux/io.h>
+#include <linux/nmi.h>
 
 /* Module and version information */
 #define ESB_MODULE_NAME "i6300ESB timer"
@@ -69,6 +70,9 @@
 #define ESB_WDT_TIMEOUT (0x01 << 9)    /* Watchdog timed out                */
 #define ESB_WDT_RELOAD  (0x01 << 8)    /* prevent timeout                   */
 
+/* General Interrupt Status Register bits*/
+#define ESB_WDT_INTR_ACTIVE	(0x01 << 0) /* Intr happens on first timeout*/
+
 /* Magic constants */
 #define ESB_UNLOCK1     0x80            /* Step 1 to unlock reset registers  */
 #define ESB_UNLOCK2     0x86            /* Step 2 to unlock reset registers  */
@@ -217,9 +221,34 @@ MODULE_DEVICE_TABLE(pci, esb_pci_tbl);
 /*
  *      Init & exit routines
  */
+static irqreturn_t esb_pretimeout(int irq, void *dev_id)
+{
+	u16 val = 0;
+	struct esb_dev *edev = NULL;
 
+	if (!dev_id)
+		return IRQ_NONE;
+	edev = dev_get_drvdata(&((struct pci_dev *)dev_id)->dev);
+	if (!edev)
+		return IRQ_NONE;
+
+	val = readw(ESB_GINTSR_REG(edev));
+	if (val & ESB_WDT_INTR_ACTIVE) {
+		//clear interrupt status bit
+		writew(ESB_WDT_INTR_ACTIVE, ESB_GINTSR_REG(edev));
+
+		//dump logs
+		trigger_all_cpu_backtrace();
+		panic_timeout = 0;
+		panic("Kernel Watchdog");
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
 static unsigned char esb_getdevice(struct esb_dev *edev)
 {
+	int nvec, ret;
+
 	if (pci_enable_device(edev->pdev)) {
 		dev_err(&edev->pdev->dev, "failed to enable device\n");
 		goto err_devput;
@@ -236,7 +265,16 @@ static unsigned char esb_getdevice(struct esb_dev *edev)
 		dev_err(&edev->pdev->dev, "failed to get BASEADDR\n");
 		goto err_release;
 	}
-
+	nvec = pci_alloc_irq_vectors(edev->pdev, 1, 1, PCI_IRQ_ALL_TYPES);
+	if (nvec < 0)
+		pr_err("failed to alloc irq\n");
+	else {
+		edev->pdev->irq = pci_irq_vector(edev->pdev, 0);
+		ret = request_irq(edev->pdev->irq, esb_pretimeout, 0,
+					 "i6300esb", edev->pdev);
+		if (ret)
+			pr_err("failed to request_irq\n");
+	}
 	/* Done */
 	dev_set_drvdata(&edev->pdev->dev, edev);
 	return 1;
@@ -266,7 +304,7 @@ static void esb_initdevice(struct esb_dev *edev)
 	 * any interrupts as there is not much we can do with it
 	 * right now.
 	 */
-	pci_write_config_word(edev->pdev, ESB_CONFIG_REG, 0x0003);
+	pci_write_config_word(edev->pdev, ESB_CONFIG_REG, 0x0000);
 
 	/* Check that the WDT isn't already locked */
 	pci_read_config_byte(edev->pdev, ESB_LOCK_REG, &val1);
@@ -345,6 +383,11 @@ static void esb_remove(struct pci_dev *pdev)
 
 	watchdog_unregister_device(&edev->wdd);
 	iounmap(edev->base);
+
+	if (edev->pdev->irq) {
+		free_irq(edev->pdev->irq, edev->pdev);
+		pci_free_irq_vectors(edev->pdev);
+	}
 	pci_release_region(edev->pdev, 0);
 	pci_disable_device(edev->pdev);
 }
-- 
2.19.1

