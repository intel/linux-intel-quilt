From f8e8505342abb6f0d3f2195358780eac3d5351b6 Mon Sep 17 00:00:00 2001
From: Voon Weifeng <weifeng.voon@intel.com>
Date: Mon, 11 May 2020 13:47:29 +0800
Subject: [PATCH 36/40] REVERTME: net: phy: WA for GPY115 which need a soft
 reset

Added a custom gpy_soft_reset() as the GPY115 need this WA which do a
soft reset even after a hard reset has happen.

Signed-off-by: Voon Weifeng <weifeng.voon@intel.com>
---
 drivers/net/phy/intel-gpy.c | 23 ++++++++++++++++++++++-
 1 file changed, 22 insertions(+), 1 deletion(-)

diff --git a/drivers/net/phy/intel-gpy.c b/drivers/net/phy/intel-gpy.c
index 7d39f9996d07..cc98e847af40 100644
--- a/drivers/net/phy/intel-gpy.c
+++ b/drivers/net/phy/intel-gpy.c
@@ -38,6 +38,9 @@
 #define GPY_VSPEV2_WOL_AD23	0Xe09		/* WOL addr Byte3:Byte4 */
 #define GPY_VSPEV2_WOL_AD45	0xe0a		/* WOL addr Byte1:Byte2 */
 
+/* WA for Q-SPEC GPY115 PHY ID */
+#define INTEL_PHY_ID_GPY115_C22		0x67C9DE00
+
 static int gpy_set_eee(struct phy_device *phydev, struct ethtool_eee *data)
 {
 	int cap, old_adv, adv = 0, ret;
@@ -72,6 +75,24 @@ static int gpy_set_eee(struct phy_device *phydev, struct ethtool_eee *data)
 	return 0;
 }
 
+static int gpy_soft_reset(struct phy_device *phydev)
+{
+	int ret;
+	int phy_id;
+
+	ret = phy_read(phydev, MII_PHYSID1);
+	phy_id = ret << 16;
+
+	ret = phy_read(phydev, MII_PHYSID2);
+	phy_id |= ret;
+
+	/* WA for GPY115 which need a soft reset even after a hard reset */
+	if (phy_id == INTEL_PHY_ID_GPY115_C22)
+		return genphy_soft_reset(phydev);
+
+	return 0;
+}
+
 static int gpy_config_aneg(struct phy_device *phydev)
 {
 	bool changed = false;
@@ -251,7 +272,7 @@ static struct phy_driver intel_gpy_drivers[] = {
 		.name		= "INTEL(R) Ethernet Network Connection GPY",
 		.get_features	= genphy_c45_pma_read_abilities,
 		.aneg_done	= genphy_c45_aneg_done,
-		.soft_reset	= genphy_soft_reset,
+		.soft_reset	= gpy_soft_reset,
 		.set_eee	= gpy_set_eee,
 		.ack_interrupt	= gpy_ack_interrupt,
 		.did_interrupt	= gpy_did_interrupt,
-- 
2.27.0

