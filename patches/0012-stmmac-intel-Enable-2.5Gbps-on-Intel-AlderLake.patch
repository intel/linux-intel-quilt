From 16c890e18631062a1d798c4090e5843bdb00b432 Mon Sep 17 00:00:00 2001
From: Michael Sit Wei Hong <michael.wei.hong.sit@intel.com>
Date: Fri, 4 Jun 2021 11:03:50 +0800
Subject: [PATCH 12/34] stmmac: intel: Enable 2.5Gbps on Intel AlderLake

Intel AlderLake platform is capable of 2.5Gbps.

This patch enables the 2.5Gbps link speed by adding the callback
function in the AlderLake platform data.

Unlike any other platforms, Intel AlderLake uses Synopsys PHY where all
the PHY PLL configurations are controlled by the xPCS at the BIOS
level. If the driver perform a xPCS soft reset on initialization, these
settings will be switched back to the power on reset values.

Signed-off-by: Michael Sit Wei Hong <michael.wei.hong.sit@intel.com>
Signed-off-by: Wong Vee Khee <vee.khee.wong@intel.com>
---
 .../net/ethernet/stmicro/stmmac/dwmac-intel.c  | 18 ++++++++++++------
 1 file changed, 12 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
index 7e8ea2600641..efb858301421 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
@@ -785,6 +785,7 @@ static int adls_sgmii_phy0_data(struct pci_dev *pdev,
 
 	plat->bus_id = 1;
 	plat->phy_interface = PHY_INTERFACE_MODE_SGMII;
+	plat->speed_mode_2500 = intel_speed_mode_2500;
 
 	/* SerDes power up and power down are done in BIOS for ADL */
 
@@ -796,11 +797,13 @@ static int adls_sgmii_phy0_data(struct pci_dev *pdev,
 	if (pdev->revision == PCI_PCH_A0 || pdev->revision == PCI_PCH_A1)
 		plat->dma_cfg->pch_intr_wa = 1;
 
+	plat->skip_xpcs_reset = 1;
+
 	return 0;
 
 }
 
-static struct stmmac_pci_info adls_sgmii1g_phy0_info = {
+static struct stmmac_pci_info adls_sgmii_phy0_info = {
 	.setup = adls_sgmii_phy0_data,
 };
 
@@ -811,6 +814,7 @@ static int adls_sgmii_phy1_data(struct pci_dev *pdev,
 
 	plat->bus_id = 2;
 	plat->phy_interface = PHY_INTERFACE_MODE_SGMII;
+	plat->speed_mode_2500 = intel_speed_mode_2500;
 
 	/* SerDes power up and power down are done in BIOS for ADL */
 
@@ -822,10 +826,12 @@ static int adls_sgmii_phy1_data(struct pci_dev *pdev,
 	if (pdev->revision == PCI_PCH_A0 || pdev->revision == PCI_PCH_A1)
 		plat->dma_cfg->pch_intr_wa = 1;
 
+	plat->skip_xpcs_reset = 1;
+
 	return 0;
 }
 
-static struct stmmac_pci_info adls_sgmii1g_phy1_info = {
+static struct stmmac_pci_info adls_sgmii_phy1_info = {
 	.setup = adls_sgmii_phy1_data,
 };
 static const struct stmmac_pci_func_data galileo_stmmac_func_data[] = {
@@ -1282,8 +1288,8 @@ static const struct dev_pm_ops intel_eth_pm_ops = {
 #define PCI_DEVICE_ID_INTEL_TGLH_SGMII1G_0	0x43ac
 #define PCI_DEVICE_ID_INTEL_TGLH_SGMII1G_1	0x43a2
 #define PCI_DEVICE_ID_INTEL_TGL_SGMII1G		0xa0ac
-#define PCI_DEVICE_ID_INTEL_ADLS_SGMII1G_0	0x7aac
-#define PCI_DEVICE_ID_INTEL_ADLS_SGMII1G_1	0x7aad
+#define PCI_DEVICE_ID_INTEL_ADLS_SGMII_0	0x7aac
+#define PCI_DEVICE_ID_INTEL_ADLS_SGMII_1	0x7aad
 
 static const struct pci_device_id intel_eth_pci_id_table[] = {
 	{ PCI_DEVICE_DATA(INTEL, QUARK, &quark_info) },
@@ -1299,8 +1305,8 @@ static const struct pci_device_id intel_eth_pci_id_table[] = {
 	{ PCI_DEVICE_DATA(INTEL, TGL_SGMII1G, &tgl_sgmii1g_phy0_info) },
 	{ PCI_DEVICE_DATA(INTEL, TGLH_SGMII1G_0, &tgl_sgmii1g_phy0_info) },
 	{ PCI_DEVICE_DATA(INTEL, TGLH_SGMII1G_1, &tgl_sgmii1g_phy1_info) },
-	{ PCI_DEVICE_DATA(INTEL, ADLS_SGMII1G_0, &adls_sgmii1g_phy0_info) },
-	{ PCI_DEVICE_DATA(INTEL, ADLS_SGMII1G_1, &adls_sgmii1g_phy1_info) },
+	{ PCI_DEVICE_DATA(INTEL, ADLS_SGMII_0, &adls_sgmii_phy0_info) },
+	{ PCI_DEVICE_DATA(INTEL, ADLS_SGMII_1, &adls_sgmii_phy1_info) },
 	{}
 };
 MODULE_DEVICE_TABLE(pci, intel_eth_pci_id_table);
-- 
2.32.0

