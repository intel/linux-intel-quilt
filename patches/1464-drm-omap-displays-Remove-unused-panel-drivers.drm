From 775deb41e2e13a4e10dbaa20981f3271bc6124e0 Mon Sep 17 00:00:00 2001
From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Fri, 16 Aug 2019 15:22:28 +0300
Subject: [PATCH 1464/1606] drm/omap: displays: Remove unused panel drivers

drm_panel-based drivers for the ACX565AKM, LB035Q02, LS037V7DW01,
NL8048HL11, TD028TTEC1 and TD043MTEA1 are available, remove the
omapdrm-specific drivers.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
Link: https://patchwork.freedesktop.org/patch/msgid/20190816122228.9475-3-laurent.pinchart@ideasonboard.com
---
 drivers/gpu/drm/omapdrm/displays/Kconfig      |  38 -
 drivers/gpu/drm/omapdrm/displays/Makefile     |   6 -
 .../displays/panel-lgphilips-lb035q02.c       | 251 ------
 .../omapdrm/displays/panel-nec-nl8048hl11.c   | 271 -------
 .../displays/panel-sharp-ls037v7dw01.c        | 262 ------
 .../omapdrm/displays/panel-sony-acx565akm.c   | 755 ------------------
 .../omapdrm/displays/panel-tpo-td028ttec1.c   | 390 ---------
 .../omapdrm/displays/panel-tpo-td043mtea1.c   | 513 ------------
 .../gpu/drm/omapdrm/dss/omapdss-boot-init.c   |   7 -
 9 files changed, 2493 deletions(-)
 delete mode 100644 drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c
 delete mode 100644 drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c
 delete mode 100644 drivers/gpu/drm/omapdrm/displays/panel-sharp-ls037v7dw01.c
 delete mode 100644 drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c
 delete mode 100644 drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c
 delete mode 100644 drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c

diff --git a/drivers/gpu/drm/omapdrm/displays/Kconfig b/drivers/gpu/drm/omapdrm/displays/Kconfig
index c2566da32ac4..240dda102845 100644
--- a/drivers/gpu/drm/omapdrm/displays/Kconfig
+++ b/drivers/gpu/drm/omapdrm/displays/Kconfig
@@ -29,42 +29,4 @@ config DRM_OMAP_PANEL_DSI_CM
 	help
 	  Driver for generic DSI command mode panels.
 
-config DRM_OMAP_PANEL_SONY_ACX565AKM
-	tristate "ACX565AKM Panel"
-	depends on SPI && BACKLIGHT_CLASS_DEVICE
-	help
-	  This is the LCD panel used on Nokia N900
-
-config DRM_OMAP_PANEL_LGPHILIPS_LB035Q02
-	tristate "LG.Philips LB035Q02 LCD Panel"
-	depends on SPI
-	help
-	  LCD Panel used on the Gumstix Overo Palo35
-
-config DRM_OMAP_PANEL_SHARP_LS037V7DW01
-        tristate "Sharp LS037V7DW01 LCD Panel"
-        depends on BACKLIGHT_CLASS_DEVICE
-        help
-          LCD Panel used in TI's SDP3430 and EVM boards
-
-config DRM_OMAP_PANEL_TPO_TD028TTEC1
-        tristate "TPO TD028TTEC1 LCD Panel"
-        depends on SPI
-        help
-          LCD panel used in Openmoko.
-
-config DRM_OMAP_PANEL_TPO_TD043MTEA1
-        tristate "TPO TD043MTEA1 LCD Panel"
-        depends on SPI
-        help
-          LCD Panel used in OMAP3 Pandora
-
-config DRM_OMAP_PANEL_NEC_NL8048HL11
-	tristate "NEC NL8048HL11 Panel"
-	depends on SPI
-	depends on BACKLIGHT_CLASS_DEVICE
-	help
-		This NEC NL8048HL11 panel is TFT LCD used in the
-		Zoom2/3/3630 sdp boards.
-
 endmenu
diff --git a/drivers/gpu/drm/omapdrm/displays/Makefile b/drivers/gpu/drm/omapdrm/displays/Makefile
index 1db34d4fed64..cb76859dc574 100644
--- a/drivers/gpu/drm/omapdrm/displays/Makefile
+++ b/drivers/gpu/drm/omapdrm/displays/Makefile
@@ -4,9 +4,3 @@ obj-$(CONFIG_DRM_OMAP_ENCODER_TPD12S015) += encoder-tpd12s015.o
 obj-$(CONFIG_DRM_OMAP_CONNECTOR_HDMI) += connector-hdmi.o
 obj-$(CONFIG_DRM_OMAP_CONNECTOR_ANALOG_TV) += connector-analog-tv.o
 obj-$(CONFIG_DRM_OMAP_PANEL_DSI_CM) += panel-dsi-cm.o
-obj-$(CONFIG_DRM_OMAP_PANEL_SONY_ACX565AKM) += panel-sony-acx565akm.o
-obj-$(CONFIG_DRM_OMAP_PANEL_LGPHILIPS_LB035Q02) += panel-lgphilips-lb035q02.o
-obj-$(CONFIG_DRM_OMAP_PANEL_SHARP_LS037V7DW01) += panel-sharp-ls037v7dw01.o
-obj-$(CONFIG_DRM_OMAP_PANEL_TPO_TD028TTEC1) += panel-tpo-td028ttec1.o
-obj-$(CONFIG_DRM_OMAP_PANEL_TPO_TD043MTEA1) += panel-tpo-td043mtea1.o
-obj-$(CONFIG_DRM_OMAP_PANEL_NEC_NL8048HL11) += panel-nec-nl8048hl11.o
diff --git a/drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c b/drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c
deleted file mode 100644
index 1fd0d84e6e38..000000000000
--- a/drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c
+++ /dev/null
@@ -1,251 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * LG.Philips LB035Q02 LCD Panel driver
- *
- * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
- * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
- * Based on a driver by: Steve Sakoman <steve@sakoman.com>
- */
-
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/spi/spi.h>
-#include <linux/mutex.h>
-#include <linux/gpio.h>
-#include <linux/gpio/consumer.h>
-
-#include "../dss/omapdss.h"
-
-static const struct videomode lb035q02_vm = {
-	.hactive = 320,
-	.vactive = 240,
-
-	.pixelclock	= 6500000,
-
-	.hsync_len	= 2,
-	.hfront_porch	= 20,
-	.hback_porch	= 68,
-
-	.vsync_len	= 2,
-	.vfront_porch	= 4,
-	.vback_porch	= 18,
-
-	.flags		= DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW,
-};
-
-struct panel_drv_data {
-	struct omap_dss_device dssdev;
-
-	struct spi_device *spi;
-
-	struct videomode vm;
-
-	struct gpio_desc *enable_gpio;
-};
-
-#define to_panel_data(p) container_of(p, struct panel_drv_data, dssdev)
-
-static int lb035q02_write_reg(struct spi_device *spi, u8 reg, u16 val)
-{
-	struct spi_message msg;
-	struct spi_transfer index_xfer = {
-		.len		= 3,
-		.cs_change	= 1,
-	};
-	struct spi_transfer value_xfer = {
-		.len		= 3,
-	};
-	u8	buffer[16];
-
-	spi_message_init(&msg);
-
-	/* register index */
-	buffer[0] = 0x70;
-	buffer[1] = 0x00;
-	buffer[2] = reg & 0x7f;
-	index_xfer.tx_buf = buffer;
-	spi_message_add_tail(&index_xfer, &msg);
-
-	/* register value */
-	buffer[4] = 0x72;
-	buffer[5] = val >> 8;
-	buffer[6] = val;
-	value_xfer.tx_buf = buffer + 4;
-	spi_message_add_tail(&value_xfer, &msg);
-
-	return spi_sync(spi, &msg);
-}
-
-static void init_lb035q02_panel(struct spi_device *spi)
-{
-	/* Init sequence from page 28 of the lb035q02 spec */
-	lb035q02_write_reg(spi, 0x01, 0x6300);
-	lb035q02_write_reg(spi, 0x02, 0x0200);
-	lb035q02_write_reg(spi, 0x03, 0x0177);
-	lb035q02_write_reg(spi, 0x04, 0x04c7);
-	lb035q02_write_reg(spi, 0x05, 0xffc0);
-	lb035q02_write_reg(spi, 0x06, 0xe806);
-	lb035q02_write_reg(spi, 0x0a, 0x4008);
-	lb035q02_write_reg(spi, 0x0b, 0x0000);
-	lb035q02_write_reg(spi, 0x0d, 0x0030);
-	lb035q02_write_reg(spi, 0x0e, 0x2800);
-	lb035q02_write_reg(spi, 0x0f, 0x0000);
-	lb035q02_write_reg(spi, 0x16, 0x9f80);
-	lb035q02_write_reg(spi, 0x17, 0x0a0f);
-	lb035q02_write_reg(spi, 0x1e, 0x00c1);
-	lb035q02_write_reg(spi, 0x30, 0x0300);
-	lb035q02_write_reg(spi, 0x31, 0x0007);
-	lb035q02_write_reg(spi, 0x32, 0x0000);
-	lb035q02_write_reg(spi, 0x33, 0x0000);
-	lb035q02_write_reg(spi, 0x34, 0x0707);
-	lb035q02_write_reg(spi, 0x35, 0x0004);
-	lb035q02_write_reg(spi, 0x36, 0x0302);
-	lb035q02_write_reg(spi, 0x37, 0x0202);
-	lb035q02_write_reg(spi, 0x3a, 0x0a0d);
-	lb035q02_write_reg(spi, 0x3b, 0x0806);
-}
-
-static int lb035q02_connect(struct omap_dss_device *src,
-			    struct omap_dss_device *dst)
-{
-	struct panel_drv_data *ddata = to_panel_data(dst);
-
-	init_lb035q02_panel(ddata->spi);
-
-	return 0;
-}
-
-static void lb035q02_disconnect(struct omap_dss_device *src,
-				struct omap_dss_device *dst)
-{
-}
-
-static void lb035q02_enable(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	if (ddata->enable_gpio)
-		gpiod_set_value_cansleep(ddata->enable_gpio, 1);
-}
-
-static void lb035q02_disable(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	if (ddata->enable_gpio)
-		gpiod_set_value_cansleep(ddata->enable_gpio, 0);
-}
-
-static int lb035q02_get_modes(struct omap_dss_device *dssdev,
-			      struct drm_connector *connector)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	return omapdss_display_get_modes(connector, &ddata->vm);
-}
-
-static const struct omap_dss_device_ops lb035q02_ops = {
-	.connect	= lb035q02_connect,
-	.disconnect	= lb035q02_disconnect,
-
-	.enable		= lb035q02_enable,
-	.disable	= lb035q02_disable,
-
-	.get_modes	= lb035q02_get_modes,
-};
-
-static int lb035q02_probe_of(struct spi_device *spi)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
-	struct gpio_desc *gpio;
-
-	gpio = devm_gpiod_get(&spi->dev, "enable", GPIOD_OUT_LOW);
-	if (IS_ERR(gpio)) {
-		dev_err(&spi->dev, "failed to parse enable gpio\n");
-		return PTR_ERR(gpio);
-	}
-
-	ddata->enable_gpio = gpio;
-
-	return 0;
-}
-
-static int lb035q02_panel_spi_probe(struct spi_device *spi)
-{
-	struct panel_drv_data *ddata;
-	struct omap_dss_device *dssdev;
-	int r;
-
-	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
-	if (ddata == NULL)
-		return -ENOMEM;
-
-	dev_set_drvdata(&spi->dev, ddata);
-
-	ddata->spi = spi;
-
-	r = lb035q02_probe_of(spi);
-	if (r)
-		return r;
-
-	ddata->vm = lb035q02_vm;
-
-	dssdev = &ddata->dssdev;
-	dssdev->dev = &spi->dev;
-	dssdev->ops = &lb035q02_ops;
-	dssdev->type = OMAP_DISPLAY_TYPE_DPI;
-	dssdev->display = true;
-	dssdev->owner = THIS_MODULE;
-	dssdev->of_ports = BIT(0);
-	dssdev->ops_flags = OMAP_DSS_DEVICE_OP_MODES;
-
-	/*
-	 * Note: According to the panel documentation:
-	 * DE is active LOW
-	 * DATA needs to be driven on the FALLING edge
-	 */
-	dssdev->bus_flags = DRM_BUS_FLAG_DE_HIGH
-			  | DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE
-			  | DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
-
-	omapdss_display_init(dssdev);
-	omapdss_device_register(dssdev);
-
-	return 0;
-}
-
-static int lb035q02_panel_spi_remove(struct spi_device *spi)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
-	struct omap_dss_device *dssdev = &ddata->dssdev;
-
-	omapdss_device_unregister(dssdev);
-
-	lb035q02_disable(dssdev);
-
-	return 0;
-}
-
-static const struct of_device_id lb035q02_of_match[] = {
-	{ .compatible = "omapdss,lgphilips,lb035q02", },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, lb035q02_of_match);
-
-static struct spi_driver lb035q02_spi_driver = {
-	.probe		= lb035q02_panel_spi_probe,
-	.remove		= lb035q02_panel_spi_remove,
-	.driver		= {
-		.name	= "panel_lgphilips_lb035q02",
-		.of_match_table = lb035q02_of_match,
-		.suppress_bind_attrs = true,
-	},
-};
-
-module_spi_driver(lb035q02_spi_driver);
-
-MODULE_ALIAS("spi:lgphilips,lb035q02");
-MODULE_AUTHOR("Tomi Valkeinen <tomi.valkeinen@ti.com>");
-MODULE_DESCRIPTION("LG.Philips LB035Q02 LCD Panel driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c b/drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c
deleted file mode 100644
index eba5bd1d702f..000000000000
--- a/drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c
+++ /dev/null
@@ -1,271 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * NEC NL8048HL11 Panel driver
- *
- * Copyright (C) 2010 Texas Instruments Incorporated - http://www.ti.com/
- * Author: Erik Gilling <konkers@android.com>
- * Converted to new DSS device model: Tomi Valkeinen <tomi.valkeinen@ti.com>
- */
-
-#include <linux/delay.h>
-#include <linux/gpio/consumer.h>
-#include <linux/module.h>
-#include <linux/spi/spi.h>
-
-#include "../dss/omapdss.h"
-
-struct panel_drv_data {
-	struct omap_dss_device	dssdev;
-
-	struct videomode vm;
-
-	struct gpio_desc *res_gpio;
-
-	struct spi_device *spi;
-};
-
-#define LCD_XRES		800
-#define LCD_YRES		480
-/*
- * NEC PIX Clock Ratings
- * MIN:21.8MHz TYP:23.8MHz MAX:25.7MHz
- */
-#define LCD_PIXEL_CLOCK		23800000
-
-static const struct {
-	unsigned char addr;
-	unsigned char dat;
-} nec_8048_init_seq[] = {
-	{ 3, 0x01 }, { 0, 0x00 }, { 1, 0x01 }, { 4, 0x00 }, { 5, 0x14 },
-	{ 6, 0x24 }, { 16, 0xD7 }, { 17, 0x00 }, { 18, 0x00 }, { 19, 0x55 },
-	{ 20, 0x01 }, { 21, 0x70 }, { 22, 0x1E }, { 23, 0x25 },	{ 24, 0x25 },
-	{ 25, 0x02 }, { 26, 0x02 }, { 27, 0xA0 }, { 32, 0x2F }, { 33, 0x0F },
-	{ 34, 0x0F }, { 35, 0x0F }, { 36, 0x0F }, { 37, 0x0F },	{ 38, 0x0F },
-	{ 39, 0x00 }, { 40, 0x02 }, { 41, 0x02 }, { 42, 0x02 },	{ 43, 0x0F },
-	{ 44, 0x0F }, { 45, 0x0F }, { 46, 0x0F }, { 47, 0x0F },	{ 48, 0x0F },
-	{ 49, 0x0F }, { 50, 0x00 }, { 51, 0x02 }, { 52, 0x02 }, { 53, 0x02 },
-	{ 80, 0x0C }, { 83, 0x42 }, { 84, 0x42 }, { 85, 0x41 },	{ 86, 0x14 },
-	{ 89, 0x88 }, { 90, 0x01 }, { 91, 0x00 }, { 92, 0x02 },	{ 93, 0x0C },
-	{ 94, 0x1C }, { 95, 0x27 }, { 98, 0x49 }, { 99, 0x27 }, { 102, 0x76 },
-	{ 103, 0x27 }, { 112, 0x01 }, { 113, 0x0E }, { 114, 0x02 },
-	{ 115, 0x0C }, { 118, 0x0C }, { 121, 0x30 }, { 130, 0x00 },
-	{ 131, 0x00 }, { 132, 0xFC }, { 134, 0x00 }, { 136, 0x00 },
-	{ 138, 0x00 }, { 139, 0x00 }, { 140, 0x00 }, { 141, 0xFC },
-	{ 143, 0x00 }, { 145, 0x00 }, { 147, 0x00 }, { 148, 0x00 },
-	{ 149, 0x00 }, { 150, 0xFC }, { 152, 0x00 }, { 154, 0x00 },
-	{ 156, 0x00 }, { 157, 0x00 }, { 2, 0x00 },
-};
-
-static const struct videomode nec_8048_panel_vm = {
-	.hactive	= LCD_XRES,
-	.vactive	= LCD_YRES,
-	.pixelclock	= LCD_PIXEL_CLOCK,
-	.hfront_porch	= 6,
-	.hsync_len	= 1,
-	.hback_porch	= 4,
-	.vfront_porch	= 3,
-	.vsync_len	= 1,
-	.vback_porch	= 4,
-
-	.flags		= DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW,
-};
-
-#define to_panel_data(p) container_of(p, struct panel_drv_data, dssdev)
-
-static int nec_8048_spi_send(struct spi_device *spi, unsigned char reg_addr,
-			unsigned char reg_data)
-{
-	int ret = 0;
-	unsigned int cmd = 0, data = 0;
-
-	cmd = 0x0000 | reg_addr; /* register address write */
-	data = 0x0100 | reg_data; /* register data write */
-	data = (cmd << 16) | data;
-
-	ret = spi_write(spi, (unsigned char *)&data, 4);
-	if (ret)
-		pr_err("error in spi_write %x\n", data);
-
-	return ret;
-}
-
-static int init_nec_8048_wvga_lcd(struct spi_device *spi)
-{
-	unsigned int i;
-	/* Initialization Sequence */
-	/* nec_8048_spi_send(spi, REG, VAL) */
-	for (i = 0; i < (ARRAY_SIZE(nec_8048_init_seq) - 1); i++)
-		nec_8048_spi_send(spi, nec_8048_init_seq[i].addr,
-				nec_8048_init_seq[i].dat);
-	udelay(20);
-	nec_8048_spi_send(spi, nec_8048_init_seq[i].addr,
-				nec_8048_init_seq[i].dat);
-	return 0;
-}
-
-static int nec_8048_connect(struct omap_dss_device *src,
-			    struct omap_dss_device *dst)
-{
-	return 0;
-}
-
-static void nec_8048_disconnect(struct omap_dss_device *src,
-				struct omap_dss_device *dst)
-{
-}
-
-static void nec_8048_enable(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	gpiod_set_value_cansleep(ddata->res_gpio, 1);
-}
-
-static void nec_8048_disable(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	gpiod_set_value_cansleep(ddata->res_gpio, 0);
-}
-
-static int nec_8048_get_modes(struct omap_dss_device *dssdev,
-			      struct drm_connector *connector)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	return omapdss_display_get_modes(connector, &ddata->vm);
-}
-
-static const struct omap_dss_device_ops nec_8048_ops = {
-	.connect	= nec_8048_connect,
-	.disconnect	= nec_8048_disconnect,
-
-	.enable		= nec_8048_enable,
-	.disable	= nec_8048_disable,
-
-	.get_modes	= nec_8048_get_modes,
-};
-
-static int nec_8048_probe(struct spi_device *spi)
-{
-	struct panel_drv_data *ddata;
-	struct omap_dss_device *dssdev;
-	struct gpio_desc *gpio;
-	int r;
-
-	dev_dbg(&spi->dev, "%s\n", __func__);
-
-	spi->mode = SPI_MODE_0;
-	spi->bits_per_word = 32;
-
-	r = spi_setup(spi);
-	if (r < 0) {
-		dev_err(&spi->dev, "spi_setup failed: %d\n", r);
-		return r;
-	}
-
-	init_nec_8048_wvga_lcd(spi);
-
-	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
-	if (ddata == NULL)
-		return -ENOMEM;
-
-	dev_set_drvdata(&spi->dev, ddata);
-
-	ddata->spi = spi;
-
-	gpio = devm_gpiod_get(&spi->dev, "reset", GPIOD_OUT_LOW);
-	if (IS_ERR(gpio)) {
-		dev_err(&spi->dev, "failed to get reset gpio\n");
-		return PTR_ERR(gpio);
-	}
-
-	ddata->res_gpio = gpio;
-
-	ddata->vm = nec_8048_panel_vm;
-
-	dssdev = &ddata->dssdev;
-	dssdev->dev = &spi->dev;
-	dssdev->ops = &nec_8048_ops;
-	dssdev->type = OMAP_DISPLAY_TYPE_DPI;
-	dssdev->display = true;
-	dssdev->owner = THIS_MODULE;
-	dssdev->of_ports = BIT(0);
-	dssdev->ops_flags = OMAP_DSS_DEVICE_OP_MODES;
-	dssdev->bus_flags = DRM_BUS_FLAG_DE_HIGH
-			  | DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE
-			  | DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
-
-	omapdss_display_init(dssdev);
-	omapdss_device_register(dssdev);
-
-	return 0;
-}
-
-static int nec_8048_remove(struct spi_device *spi)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
-	struct omap_dss_device *dssdev = &ddata->dssdev;
-
-	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
-
-	omapdss_device_unregister(dssdev);
-
-	nec_8048_disable(dssdev);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int nec_8048_suspend(struct device *dev)
-{
-	struct spi_device *spi = to_spi_device(dev);
-
-	nec_8048_spi_send(spi, 2, 0x01);
-	mdelay(40);
-
-	return 0;
-}
-
-static int nec_8048_resume(struct device *dev)
-{
-	struct spi_device *spi = to_spi_device(dev);
-
-	/* reinitialize the panel */
-	spi_setup(spi);
-	nec_8048_spi_send(spi, 2, 0x00);
-	init_nec_8048_wvga_lcd(spi);
-
-	return 0;
-}
-static SIMPLE_DEV_PM_OPS(nec_8048_pm_ops, nec_8048_suspend,
-		nec_8048_resume);
-#define NEC_8048_PM_OPS (&nec_8048_pm_ops)
-#else
-#define NEC_8048_PM_OPS NULL
-#endif
-
-static const struct of_device_id nec_8048_of_match[] = {
-	{ .compatible = "omapdss,nec,nl8048hl11", },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, nec_8048_of_match);
-
-static struct spi_driver nec_8048_driver = {
-	.driver = {
-		.name	= "panel-nec-nl8048hl11",
-		.pm	= NEC_8048_PM_OPS,
-		.of_match_table = nec_8048_of_match,
-		.suppress_bind_attrs = true,
-	},
-	.probe	= nec_8048_probe,
-	.remove	= nec_8048_remove,
-};
-
-module_spi_driver(nec_8048_driver);
-
-MODULE_ALIAS("spi:nec,nl8048hl11");
-MODULE_AUTHOR("Erik Gilling <konkers@android.com>");
-MODULE_DESCRIPTION("NEC-NL8048HL11 Driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/omapdrm/displays/panel-sharp-ls037v7dw01.c b/drivers/gpu/drm/omapdrm/displays/panel-sharp-ls037v7dw01.c
deleted file mode 100644
index 3ab50fd1f3f2..000000000000
--- a/drivers/gpu/drm/omapdrm/displays/panel-sharp-ls037v7dw01.c
+++ /dev/null
@@ -1,262 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * LCD panel driver for Sharp LS037V7DW01
- *
- * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
- * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
- */
-
-#include <linux/delay.h>
-#include <linux/gpio/consumer.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <linux/regulator/consumer.h>
-
-#include "../dss/omapdss.h"
-
-struct panel_drv_data {
-	struct omap_dss_device dssdev;
-	struct regulator *vcc;
-
-	struct videomode vm;
-
-	struct gpio_desc *resb_gpio;	/* low = reset active min 20 us */
-	struct gpio_desc *ini_gpio;	/* high = power on */
-	struct gpio_desc *mo_gpio;	/* low = 480x640, high = 240x320 */
-	struct gpio_desc *lr_gpio;	/* high = conventional horizontal scanning */
-	struct gpio_desc *ud_gpio;	/* high = conventional vertical scanning */
-};
-
-static const struct videomode sharp_ls_vm = {
-	.hactive = 480,
-	.vactive = 640,
-
-	.pixelclock	= 19200000,
-
-	.hsync_len	= 2,
-	.hfront_porch	= 1,
-	.hback_porch	= 28,
-
-	.vsync_len	= 1,
-	.vfront_porch	= 1,
-	.vback_porch	= 1,
-
-	.flags		= DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW,
-};
-
-#define to_panel_data(p) container_of(p, struct panel_drv_data, dssdev)
-
-static int sharp_ls_connect(struct omap_dss_device *src,
-			    struct omap_dss_device *dst)
-{
-	return 0;
-}
-
-static void sharp_ls_disconnect(struct omap_dss_device *src,
-				struct omap_dss_device *dst)
-{
-}
-
-static void sharp_ls_pre_enable(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-	int r;
-
-	if (ddata->vcc) {
-		r = regulator_enable(ddata->vcc);
-		if (r)
-			dev_err(dssdev->dev, "%s: failed to enable regulator\n",
-				__func__);
-	}
-}
-
-static void sharp_ls_enable(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	/* wait couple of vsyncs until enabling the LCD */
-	msleep(50);
-
-	if (ddata->resb_gpio)
-		gpiod_set_value_cansleep(ddata->resb_gpio, 1);
-
-	if (ddata->ini_gpio)
-		gpiod_set_value_cansleep(ddata->ini_gpio, 1);
-}
-
-static void sharp_ls_disable(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	if (ddata->ini_gpio)
-		gpiod_set_value_cansleep(ddata->ini_gpio, 0);
-
-	if (ddata->resb_gpio)
-		gpiod_set_value_cansleep(ddata->resb_gpio, 0);
-
-	/* wait at least 5 vsyncs after disabling the LCD */
-	msleep(100);
-}
-
-static void sharp_ls_post_disable(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	if (ddata->vcc)
-		regulator_disable(ddata->vcc);
-}
-
-static int sharp_ls_get_modes(struct omap_dss_device *dssdev,
-			      struct drm_connector *connector)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	return omapdss_display_get_modes(connector, &ddata->vm);
-}
-
-static const struct omap_dss_device_ops sharp_ls_ops = {
-	.connect	= sharp_ls_connect,
-	.disconnect	= sharp_ls_disconnect,
-
-	.pre_enable	= sharp_ls_pre_enable,
-	.enable		= sharp_ls_enable,
-	.disable	= sharp_ls_disable,
-	.post_disable	= sharp_ls_post_disable,
-
-	.get_modes	= sharp_ls_get_modes,
-};
-
-static  int sharp_ls_get_gpio_of(struct device *dev, int index, int val,
-	const char *desc, struct gpio_desc **gpiod)
-{
-	struct gpio_desc *gd;
-
-	*gpiod = NULL;
-
-	gd = devm_gpiod_get_index(dev, desc, index, GPIOD_OUT_LOW);
-	if (IS_ERR(gd))
-		return PTR_ERR(gd);
-
-	*gpiod = gd;
-	return 0;
-}
-
-static int sharp_ls_probe_of(struct platform_device *pdev)
-{
-	struct panel_drv_data *ddata = platform_get_drvdata(pdev);
-	int r;
-
-	ddata->vcc = devm_regulator_get(&pdev->dev, "envdd");
-	if (IS_ERR(ddata->vcc)) {
-		dev_err(&pdev->dev, "failed to get regulator\n");
-		return PTR_ERR(ddata->vcc);
-	}
-
-	/* lcd INI */
-	r = sharp_ls_get_gpio_of(&pdev->dev, 0, 0, "enable", &ddata->ini_gpio);
-	if (r)
-		return r;
-
-	/* lcd RESB */
-	r = sharp_ls_get_gpio_of(&pdev->dev, 0, 0, "reset", &ddata->resb_gpio);
-	if (r)
-		return r;
-
-	/* lcd MO */
-	r = sharp_ls_get_gpio_of(&pdev->dev, 0, 0, "mode", &ddata->mo_gpio);
-	if (r)
-		return r;
-
-	/* lcd LR */
-	r = sharp_ls_get_gpio_of(&pdev->dev, 1, 1, "mode", &ddata->lr_gpio);
-	if (r)
-		return r;
-
-	/* lcd UD */
-	r = sharp_ls_get_gpio_of(&pdev->dev, 2, 1, "mode", &ddata->ud_gpio);
-	if (r)
-		return r;
-
-	return 0;
-}
-
-static int sharp_ls_probe(struct platform_device *pdev)
-{
-	struct panel_drv_data *ddata;
-	struct omap_dss_device *dssdev;
-	int r;
-
-	ddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);
-	if (ddata == NULL)
-		return -ENOMEM;
-
-	platform_set_drvdata(pdev, ddata);
-
-	r = sharp_ls_probe_of(pdev);
-	if (r)
-		return r;
-
-	ddata->vm = sharp_ls_vm;
-
-	dssdev = &ddata->dssdev;
-	dssdev->dev = &pdev->dev;
-	dssdev->ops = &sharp_ls_ops;
-	dssdev->type = OMAP_DISPLAY_TYPE_DPI;
-	dssdev->display = true;
-	dssdev->owner = THIS_MODULE;
-	dssdev->of_ports = BIT(0);
-	dssdev->ops_flags = OMAP_DSS_DEVICE_OP_MODES;
-
-	/*
-	 * Note: According to the panel documentation:
-	 * DATA needs to be driven on the FALLING edge
-	 */
-	dssdev->bus_flags = DRM_BUS_FLAG_DE_HIGH
-			  | DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE
-			  | DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
-
-	omapdss_display_init(dssdev);
-	omapdss_device_register(dssdev);
-
-	return 0;
-}
-
-static int __exit sharp_ls_remove(struct platform_device *pdev)
-{
-	struct panel_drv_data *ddata = platform_get_drvdata(pdev);
-	struct omap_dss_device *dssdev = &ddata->dssdev;
-
-	omapdss_device_unregister(dssdev);
-
-	if (omapdss_device_is_enabled(dssdev)) {
-		sharp_ls_disable(dssdev);
-		sharp_ls_post_disable(dssdev);
-	}
-
-	return 0;
-}
-
-static const struct of_device_id sharp_ls_of_match[] = {
-	{ .compatible = "omapdss,sharp,ls037v7dw01", },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, sharp_ls_of_match);
-
-static struct platform_driver sharp_ls_driver = {
-	.probe = sharp_ls_probe,
-	.remove = __exit_p(sharp_ls_remove),
-	.driver = {
-		.name = "panel-sharp-ls037v7dw01",
-		.of_match_table = sharp_ls_of_match,
-		.suppress_bind_attrs = true,
-	},
-};
-
-module_platform_driver(sharp_ls_driver);
-
-MODULE_AUTHOR("Tomi Valkeinen <tomi.valkeinen@ti.com>");
-MODULE_DESCRIPTION("Sharp LS037V7DW01 Panel Driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c b/drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c
deleted file mode 100644
index 588a1a6bbcc3..000000000000
--- a/drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c
+++ /dev/null
@@ -1,755 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Sony ACX565AKM LCD Panel driver
- *
- * Copyright (C) 2010 Nokia Corporation
- *
- * Original Driver Author: Imre Deak <imre.deak@nokia.com>
- * Based on panel-generic.c by Tomi Valkeinen <tomi.valkeinen@ti.com>
- * Adapted to new DSS2 framework: Roger Quadros <roger.quadros@nokia.com>
- */
-
-#include <linux/backlight.h>
-#include <linux/delay.h>
-#include <linux/gpio/consumer.h>
-#include <linux/jiffies.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/sched.h>
-#include <linux/spi/spi.h>
-
-#include "../dss/omapdss.h"
-
-#define MIPID_CMD_READ_DISP_ID		0x04
-#define MIPID_CMD_READ_RED		0x06
-#define MIPID_CMD_READ_GREEN		0x07
-#define MIPID_CMD_READ_BLUE		0x08
-#define MIPID_CMD_READ_DISP_STATUS	0x09
-#define MIPID_CMD_RDDSDR		0x0F
-#define MIPID_CMD_SLEEP_IN		0x10
-#define MIPID_CMD_SLEEP_OUT		0x11
-#define MIPID_CMD_DISP_OFF		0x28
-#define MIPID_CMD_DISP_ON		0x29
-#define MIPID_CMD_WRITE_DISP_BRIGHTNESS	0x51
-#define MIPID_CMD_READ_DISP_BRIGHTNESS	0x52
-#define MIPID_CMD_WRITE_CTRL_DISP	0x53
-
-#define CTRL_DISP_BRIGHTNESS_CTRL_ON	(1 << 5)
-#define CTRL_DISP_AMBIENT_LIGHT_CTRL_ON	(1 << 4)
-#define CTRL_DISP_BACKLIGHT_ON		(1 << 2)
-#define CTRL_DISP_AUTO_BRIGHTNESS_ON	(1 << 1)
-
-#define MIPID_CMD_READ_CTRL_DISP	0x54
-#define MIPID_CMD_WRITE_CABC		0x55
-#define MIPID_CMD_READ_CABC		0x56
-
-#define MIPID_VER_LPH8923		3
-#define MIPID_VER_LS041Y3		4
-#define MIPID_VER_L4F00311		8
-#define MIPID_VER_ACX565AKM		9
-
-struct panel_drv_data {
-	struct omap_dss_device	dssdev;
-
-	struct gpio_desc *reset_gpio;
-
-	struct videomode vm;
-
-	char		*name;
-	int		enabled;
-	int		model;
-	int		revision;
-	u8		display_id[3];
-	unsigned	has_bc:1;
-	unsigned	has_cabc:1;
-	unsigned	cabc_mode;
-	unsigned long	hw_guard_end;		/* next value of jiffies
-						   when we can issue the
-						   next sleep in/out command */
-	unsigned long	hw_guard_wait;		/* max guard time in jiffies */
-
-	struct spi_device	*spi;
-	struct mutex		mutex;
-
-	struct backlight_device *bl_dev;
-};
-
-static const struct videomode acx565akm_panel_vm = {
-	.hactive	= 800,
-	.vactive	= 480,
-	.pixelclock	= 24000000,
-	.hfront_porch	= 28,
-	.hsync_len	= 4,
-	.hback_porch	= 24,
-	.vfront_porch	= 3,
-	.vsync_len	= 3,
-	.vback_porch	= 4,
-
-	.flags		= DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW,
-};
-
-#define to_panel_data(p) container_of(p, struct panel_drv_data, dssdev)
-
-static void acx565akm_transfer(struct panel_drv_data *ddata, int cmd,
-			      const u8 *wbuf, int wlen, u8 *rbuf, int rlen)
-{
-	struct spi_message	m;
-	struct spi_transfer	*x, xfer[5];
-	int			r;
-
-	BUG_ON(ddata->spi == NULL);
-
-	spi_message_init(&m);
-
-	memset(xfer, 0, sizeof(xfer));
-	x = &xfer[0];
-
-	cmd &=  0xff;
-	x->tx_buf = &cmd;
-	x->bits_per_word = 9;
-	x->len = 2;
-
-	if (rlen > 1 && wlen == 0) {
-		/*
-		 * Between the command and the response data there is a
-		 * dummy clock cycle. Add an extra bit after the command
-		 * word to account for this.
-		 */
-		x->bits_per_word = 10;
-		cmd <<= 1;
-	}
-	spi_message_add_tail(x, &m);
-
-	if (wlen) {
-		x++;
-		x->tx_buf = wbuf;
-		x->len = wlen;
-		x->bits_per_word = 9;
-		spi_message_add_tail(x, &m);
-	}
-
-	if (rlen) {
-		x++;
-		x->rx_buf	= rbuf;
-		x->len		= rlen;
-		spi_message_add_tail(x, &m);
-	}
-
-	r = spi_sync(ddata->spi, &m);
-	if (r < 0)
-		dev_dbg(&ddata->spi->dev, "spi_sync %d\n", r);
-}
-
-static inline void acx565akm_cmd(struct panel_drv_data *ddata, int cmd)
-{
-	acx565akm_transfer(ddata, cmd, NULL, 0, NULL, 0);
-}
-
-static inline void acx565akm_write(struct panel_drv_data *ddata,
-			       int reg, const u8 *buf, int len)
-{
-	acx565akm_transfer(ddata, reg, buf, len, NULL, 0);
-}
-
-static inline void acx565akm_read(struct panel_drv_data *ddata,
-			      int reg, u8 *buf, int len)
-{
-	acx565akm_transfer(ddata, reg, NULL, 0, buf, len);
-}
-
-static void hw_guard_start(struct panel_drv_data *ddata, int guard_msec)
-{
-	ddata->hw_guard_wait = msecs_to_jiffies(guard_msec);
-	ddata->hw_guard_end = jiffies + ddata->hw_guard_wait;
-}
-
-static void hw_guard_wait(struct panel_drv_data *ddata)
-{
-	unsigned long wait = ddata->hw_guard_end - jiffies;
-
-	if ((long)wait > 0 && wait <= ddata->hw_guard_wait) {
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(wait);
-	}
-}
-
-static void set_sleep_mode(struct panel_drv_data *ddata, int on)
-{
-	int cmd;
-
-	if (on)
-		cmd = MIPID_CMD_SLEEP_IN;
-	else
-		cmd = MIPID_CMD_SLEEP_OUT;
-	/*
-	 * We have to keep 120msec between sleep in/out commands.
-	 * (8.2.15, 8.2.16).
-	 */
-	hw_guard_wait(ddata);
-	acx565akm_cmd(ddata, cmd);
-	hw_guard_start(ddata, 120);
-}
-
-static void set_display_state(struct panel_drv_data *ddata, int enabled)
-{
-	int cmd = enabled ? MIPID_CMD_DISP_ON : MIPID_CMD_DISP_OFF;
-
-	acx565akm_cmd(ddata, cmd);
-}
-
-static int panel_enabled(struct panel_drv_data *ddata)
-{
-	__be32 v;
-	u32 disp_status;
-	int enabled;
-
-	acx565akm_read(ddata, MIPID_CMD_READ_DISP_STATUS, (u8 *)&v, 4);
-	disp_status = __be32_to_cpu(v);
-	enabled = (disp_status & (1 << 17)) && (disp_status & (1 << 10));
-	dev_dbg(&ddata->spi->dev,
-		"LCD panel %senabled by bootloader (status 0x%04x)\n",
-		enabled ? "" : "not ", disp_status);
-	return enabled;
-}
-
-static int panel_detect(struct panel_drv_data *ddata)
-{
-	acx565akm_read(ddata, MIPID_CMD_READ_DISP_ID, ddata->display_id, 3);
-	dev_dbg(&ddata->spi->dev, "MIPI display ID: %02x%02x%02x\n",
-		ddata->display_id[0],
-		ddata->display_id[1],
-		ddata->display_id[2]);
-
-	switch (ddata->display_id[0]) {
-	case 0x10:
-		ddata->model = MIPID_VER_ACX565AKM;
-		ddata->name = "acx565akm";
-		ddata->has_bc = 1;
-		ddata->has_cabc = 1;
-		break;
-	case 0x29:
-		ddata->model = MIPID_VER_L4F00311;
-		ddata->name = "l4f00311";
-		break;
-	case 0x45:
-		ddata->model = MIPID_VER_LPH8923;
-		ddata->name = "lph8923";
-		break;
-	case 0x83:
-		ddata->model = MIPID_VER_LS041Y3;
-		ddata->name = "ls041y3";
-		break;
-	default:
-		ddata->name = "unknown";
-		dev_err(&ddata->spi->dev, "invalid display ID\n");
-		return -ENODEV;
-	}
-
-	ddata->revision = ddata->display_id[1];
-
-	dev_info(&ddata->spi->dev, "omapfb: %s rev %02x LCD detected\n",
-			ddata->name, ddata->revision);
-
-	return 0;
-}
-
-/*----------------------Backlight Control-------------------------*/
-
-static void enable_backlight_ctrl(struct panel_drv_data *ddata, int enable)
-{
-	u16 ctrl;
-
-	acx565akm_read(ddata, MIPID_CMD_READ_CTRL_DISP, (u8 *)&ctrl, 1);
-	if (enable) {
-		ctrl |= CTRL_DISP_BRIGHTNESS_CTRL_ON |
-			CTRL_DISP_BACKLIGHT_ON;
-	} else {
-		ctrl &= ~(CTRL_DISP_BRIGHTNESS_CTRL_ON |
-			  CTRL_DISP_BACKLIGHT_ON);
-	}
-
-	ctrl |= 1 << 8;
-	acx565akm_write(ddata, MIPID_CMD_WRITE_CTRL_DISP, (u8 *)&ctrl, 2);
-}
-
-static void set_cabc_mode(struct panel_drv_data *ddata, unsigned int mode)
-{
-	u16 cabc_ctrl;
-
-	ddata->cabc_mode = mode;
-	if (!ddata->enabled)
-		return;
-	cabc_ctrl = 0;
-	acx565akm_read(ddata, MIPID_CMD_READ_CABC, (u8 *)&cabc_ctrl, 1);
-	cabc_ctrl &= ~3;
-	cabc_ctrl |= (1 << 8) | (mode & 3);
-	acx565akm_write(ddata, MIPID_CMD_WRITE_CABC, (u8 *)&cabc_ctrl, 2);
-}
-
-static unsigned int get_cabc_mode(struct panel_drv_data *ddata)
-{
-	return ddata->cabc_mode;
-}
-
-static unsigned int get_hw_cabc_mode(struct panel_drv_data *ddata)
-{
-	u8 cabc_ctrl;
-
-	acx565akm_read(ddata, MIPID_CMD_READ_CABC, &cabc_ctrl, 1);
-	return cabc_ctrl & 3;
-}
-
-static void acx565akm_set_brightness(struct panel_drv_data *ddata, int level)
-{
-	int bv;
-
-	bv = level | (1 << 8);
-	acx565akm_write(ddata, MIPID_CMD_WRITE_DISP_BRIGHTNESS, (u8 *)&bv, 2);
-
-	if (level)
-		enable_backlight_ctrl(ddata, 1);
-	else
-		enable_backlight_ctrl(ddata, 0);
-}
-
-static int acx565akm_get_actual_brightness(struct panel_drv_data *ddata)
-{
-	u8 bv;
-
-	acx565akm_read(ddata, MIPID_CMD_READ_DISP_BRIGHTNESS, &bv, 1);
-
-	return bv;
-}
-
-
-static int acx565akm_bl_update_status(struct backlight_device *dev)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);
-	int level;
-
-	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
-
-	if (dev->props.fb_blank == FB_BLANK_UNBLANK &&
-			dev->props.power == FB_BLANK_UNBLANK)
-		level = dev->props.brightness;
-	else
-		level = 0;
-
-	if (ddata->has_bc)
-		acx565akm_set_brightness(ddata, level);
-	else
-		return -ENODEV;
-
-	return 0;
-}
-
-static int acx565akm_bl_get_intensity(struct backlight_device *dev)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);
-
-	dev_dbg(&dev->dev, "%s\n", __func__);
-
-	if (!ddata->has_bc)
-		return -ENODEV;
-
-	if (dev->props.fb_blank == FB_BLANK_UNBLANK &&
-			dev->props.power == FB_BLANK_UNBLANK) {
-		if (ddata->has_bc)
-			return acx565akm_get_actual_brightness(ddata);
-		else
-			return dev->props.brightness;
-	}
-
-	return 0;
-}
-
-static int acx565akm_bl_update_status_locked(struct backlight_device *dev)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);
-	int r;
-
-	mutex_lock(&ddata->mutex);
-	r = acx565akm_bl_update_status(dev);
-	mutex_unlock(&ddata->mutex);
-
-	return r;
-}
-
-static int acx565akm_bl_get_intensity_locked(struct backlight_device *dev)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);
-	int r;
-
-	mutex_lock(&ddata->mutex);
-	r = acx565akm_bl_get_intensity(dev);
-	mutex_unlock(&ddata->mutex);
-
-	return r;
-}
-
-static const struct backlight_ops acx565akm_bl_ops = {
-	.get_brightness = acx565akm_bl_get_intensity_locked,
-	.update_status  = acx565akm_bl_update_status_locked,
-};
-
-/*--------------------Auto Brightness control via Sysfs---------------------*/
-
-static const char * const cabc_modes[] = {
-	"off",		/* always used when CABC is not supported */
-	"ui",
-	"still-image",
-	"moving-image",
-};
-
-static ssize_t show_cabc_mode(struct device *dev,
-		struct device_attribute *attr,
-		char *buf)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(dev);
-	const char *mode_str;
-	int mode;
-	int len;
-
-	if (!ddata->has_cabc)
-		mode = 0;
-	else
-		mode = get_cabc_mode(ddata);
-	mode_str = "unknown";
-	if (mode >= 0 && mode < ARRAY_SIZE(cabc_modes))
-		mode_str = cabc_modes[mode];
-	len = snprintf(buf, PAGE_SIZE, "%s\n", mode_str);
-
-	return len < PAGE_SIZE - 1 ? len : PAGE_SIZE - 1;
-}
-
-static ssize_t store_cabc_mode(struct device *dev,
-		struct device_attribute *attr,
-		const char *buf, size_t count)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(dev);
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(cabc_modes); i++) {
-		const char *mode_str = cabc_modes[i];
-		int cmp_len = strlen(mode_str);
-
-		if (count > 0 && buf[count - 1] == '\n')
-			count--;
-		if (count != cmp_len)
-			continue;
-
-		if (strncmp(buf, mode_str, cmp_len) == 0)
-			break;
-	}
-
-	if (i == ARRAY_SIZE(cabc_modes))
-		return -EINVAL;
-
-	if (!ddata->has_cabc && i != 0)
-		return -EINVAL;
-
-	mutex_lock(&ddata->mutex);
-	set_cabc_mode(ddata, i);
-	mutex_unlock(&ddata->mutex);
-
-	return count;
-}
-
-static ssize_t show_cabc_available_modes(struct device *dev,
-		struct device_attribute *attr,
-		char *buf)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(dev);
-	int len;
-	int i;
-
-	if (!ddata->has_cabc)
-		return snprintf(buf, PAGE_SIZE, "%s\n", cabc_modes[0]);
-
-	for (i = 0, len = 0;
-	     len < PAGE_SIZE && i < ARRAY_SIZE(cabc_modes); i++)
-		len += snprintf(&buf[len], PAGE_SIZE - len, "%s%s%s",
-			i ? " " : "", cabc_modes[i],
-			i == ARRAY_SIZE(cabc_modes) - 1 ? "\n" : "");
-
-	return len < PAGE_SIZE ? len : PAGE_SIZE - 1;
-}
-
-static DEVICE_ATTR(cabc_mode, S_IRUGO | S_IWUSR,
-		show_cabc_mode, store_cabc_mode);
-static DEVICE_ATTR(cabc_available_modes, S_IRUGO,
-		show_cabc_available_modes, NULL);
-
-static struct attribute *bldev_attrs[] = {
-	&dev_attr_cabc_mode.attr,
-	&dev_attr_cabc_available_modes.attr,
-	NULL,
-};
-
-static const struct attribute_group bldev_attr_group = {
-	.attrs = bldev_attrs,
-};
-
-static int acx565akm_connect(struct omap_dss_device *src,
-			     struct omap_dss_device *dst)
-{
-	return 0;
-}
-
-static void acx565akm_disconnect(struct omap_dss_device *src,
-				 struct omap_dss_device *dst)
-{
-}
-
-static int acx565akm_panel_power_on(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
-
-	/*FIXME tweak me */
-	msleep(50);
-
-	if (ddata->reset_gpio)
-		gpiod_set_value(ddata->reset_gpio, 1);
-
-	if (ddata->enabled) {
-		dev_dbg(&ddata->spi->dev, "panel already enabled\n");
-		return 0;
-	}
-
-	/*
-	 * We have to meet all the following delay requirements:
-	 * 1. tRW: reset pulse width 10usec (7.12.1)
-	 * 2. tRT: reset cancel time 5msec (7.12.1)
-	 * 3. Providing PCLK,HS,VS signals for 2 frames = ~50msec worst
-	 *    case (7.6.2)
-	 * 4. 120msec before the sleep out command (7.12.1)
-	 */
-	msleep(120);
-
-	set_sleep_mode(ddata, 0);
-	ddata->enabled = 1;
-
-	/* 5msec between sleep out and the next command. (8.2.16) */
-	usleep_range(5000, 10000);
-	set_display_state(ddata, 1);
-	set_cabc_mode(ddata, ddata->cabc_mode);
-
-	return acx565akm_bl_update_status(ddata->bl_dev);
-}
-
-static void acx565akm_panel_power_off(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	dev_dbg(dssdev->dev, "%s\n", __func__);
-
-	if (!ddata->enabled)
-		return;
-
-	set_display_state(ddata, 0);
-	set_sleep_mode(ddata, 1);
-	ddata->enabled = 0;
-	/*
-	 * We have to provide PCLK,HS,VS signals for 2 frames (worst case
-	 * ~50msec) after sending the sleep in command and asserting the
-	 * reset signal. We probably could assert the reset w/o the delay
-	 * but we still delay to avoid possible artifacts. (7.6.1)
-	 */
-	msleep(50);
-
-	if (ddata->reset_gpio)
-		gpiod_set_value(ddata->reset_gpio, 0);
-
-	/* FIXME need to tweak this delay */
-	msleep(100);
-}
-
-static void acx565akm_enable(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	mutex_lock(&ddata->mutex);
-	acx565akm_panel_power_on(dssdev);
-	mutex_unlock(&ddata->mutex);
-}
-
-static void acx565akm_disable(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	mutex_lock(&ddata->mutex);
-	acx565akm_panel_power_off(dssdev);
-	mutex_unlock(&ddata->mutex);
-}
-
-static int acx565akm_get_modes(struct omap_dss_device *dssdev,
-			       struct drm_connector *connector)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	return omapdss_display_get_modes(connector, &ddata->vm);
-}
-
-static const struct omap_dss_device_ops acx565akm_ops = {
-	.connect	= acx565akm_connect,
-	.disconnect	= acx565akm_disconnect,
-
-	.enable		= acx565akm_enable,
-	.disable	= acx565akm_disable,
-
-	.get_modes	= acx565akm_get_modes,
-};
-
-static int acx565akm_probe(struct spi_device *spi)
-{
-	struct panel_drv_data *ddata;
-	struct omap_dss_device *dssdev;
-	struct backlight_device *bldev;
-	int max_brightness, brightness;
-	struct backlight_properties props;
-	struct gpio_desc *gpio;
-	int r;
-
-	dev_dbg(&spi->dev, "%s\n", __func__);
-
-	spi->mode = SPI_MODE_3;
-
-	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
-	if (ddata == NULL)
-		return -ENOMEM;
-
-	dev_set_drvdata(&spi->dev, ddata);
-
-	ddata->spi = spi;
-
-	mutex_init(&ddata->mutex);
-
-	gpio = devm_gpiod_get_optional(&spi->dev, "reset", GPIOD_OUT_LOW);
-	if (IS_ERR(gpio)) {
-		dev_err(&spi->dev, "failed to parse reset gpio\n");
-		return PTR_ERR(gpio);
-	}
-
-	ddata->reset_gpio = gpio;
-
-	if (ddata->reset_gpio)
-		gpiod_set_value(ddata->reset_gpio, 1);
-
-	/*
-	 * After reset we have to wait 5 msec before the first
-	 * command can be sent.
-	 */
-	usleep_range(5000, 10000);
-
-	ddata->enabled = panel_enabled(ddata);
-
-	r = panel_detect(ddata);
-
-	if (!ddata->enabled && ddata->reset_gpio)
-		gpiod_set_value(ddata->reset_gpio, 0);
-
-	if (r) {
-		dev_err(&spi->dev, "%s panel detect error\n", __func__);
-		return r;
-	}
-
-	memset(&props, 0, sizeof(props));
-	props.fb_blank = FB_BLANK_UNBLANK;
-	props.power = FB_BLANK_UNBLANK;
-	props.type = BACKLIGHT_RAW;
-
-	bldev = backlight_device_register("acx565akm", &ddata->spi->dev,
-			ddata, &acx565akm_bl_ops, &props);
-	if (IS_ERR(bldev))
-		return PTR_ERR(bldev);
-	ddata->bl_dev = bldev;
-	if (ddata->has_cabc) {
-		r = sysfs_create_group(&bldev->dev.kobj, &bldev_attr_group);
-		if (r) {
-			dev_err(&bldev->dev,
-				"%s failed to create sysfs files\n", __func__);
-			goto err_backlight_unregister;
-		}
-		ddata->cabc_mode = get_hw_cabc_mode(ddata);
-	}
-
-	max_brightness = 255;
-
-	if (ddata->has_bc)
-		brightness = acx565akm_get_actual_brightness(ddata);
-	else
-		brightness = 0;
-
-	bldev->props.max_brightness = max_brightness;
-	bldev->props.brightness = brightness;
-
-	acx565akm_bl_update_status(bldev);
-
-
-	ddata->vm = acx565akm_panel_vm;
-
-	dssdev = &ddata->dssdev;
-	dssdev->dev = &spi->dev;
-	dssdev->ops = &acx565akm_ops;
-	dssdev->type = OMAP_DISPLAY_TYPE_SDI;
-	dssdev->display = true;
-	dssdev->owner = THIS_MODULE;
-	dssdev->of_ports = BIT(0);
-	dssdev->ops_flags = OMAP_DSS_DEVICE_OP_MODES;
-	dssdev->bus_flags = DRM_BUS_FLAG_DE_HIGH
-			  | DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE
-			  | DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
-
-	omapdss_display_init(dssdev);
-	omapdss_device_register(dssdev);
-
-	return 0;
-
-err_backlight_unregister:
-	backlight_device_unregister(bldev);
-	return r;
-}
-
-static int acx565akm_remove(struct spi_device *spi)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
-	struct omap_dss_device *dssdev = &ddata->dssdev;
-
-	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
-
-	sysfs_remove_group(&ddata->bl_dev->dev.kobj, &bldev_attr_group);
-	backlight_device_unregister(ddata->bl_dev);
-
-	omapdss_device_unregister(dssdev);
-
-	if (omapdss_device_is_enabled(dssdev))
-		acx565akm_disable(dssdev);
-
-	return 0;
-}
-
-static const struct of_device_id acx565akm_of_match[] = {
-	{ .compatible = "omapdss,sony,acx565akm", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, acx565akm_of_match);
-
-static struct spi_driver acx565akm_driver = {
-	.driver = {
-		.name	= "acx565akm",
-		.of_match_table = acx565akm_of_match,
-		.suppress_bind_attrs = true,
-	},
-	.probe	= acx565akm_probe,
-	.remove	= acx565akm_remove,
-};
-
-module_spi_driver(acx565akm_driver);
-
-MODULE_ALIAS("spi:sony,acx565akm");
-MODULE_AUTHOR("Nokia Corporation");
-MODULE_DESCRIPTION("acx565akm LCD Driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c b/drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c
deleted file mode 100644
index c885018ac6ce..000000000000
--- a/drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c
+++ /dev/null
@@ -1,390 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Toppoly TD028TTEC1 panel support
- *
- * Copyright (C) 2008 Nokia Corporation
- * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
- *
- * Neo 1973 code (jbt6k74.c):
- * Copyright (C) 2006-2007 by OpenMoko, Inc.
- * Author: Harald Welte <laforge@openmoko.org>
- *
- * Ported and adapted from Neo 1973 U-Boot by:
- * H. Nikolaus Schaller <hns@goldelico.com>
- */
-
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/spi/spi.h>
-
-#include "../dss/omapdss.h"
-
-struct panel_drv_data {
-	struct omap_dss_device dssdev;
-
-	struct videomode vm;
-
-	struct backlight_device *backlight;
-
-	struct spi_device *spi_dev;
-};
-
-static const struct videomode td028ttec1_panel_vm = {
-	.hactive	= 480,
-	.vactive	= 640,
-	.pixelclock	= 22153000,
-	.hfront_porch	= 24,
-	.hsync_len	= 8,
-	.hback_porch	= 8,
-	.vfront_porch	= 4,
-	.vsync_len	= 2,
-	.vback_porch	= 2,
-
-	.flags		= DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW,
-};
-
-#define JBT_COMMAND	0x000
-#define JBT_DATA	0x100
-
-static int jbt_ret_write_0(struct panel_drv_data *ddata, u8 reg)
-{
-	int rc;
-	u16 tx_buf = JBT_COMMAND | reg;
-
-	rc = spi_write(ddata->spi_dev, (u8 *)&tx_buf,
-			1*sizeof(u16));
-	if (rc != 0)
-		dev_err(&ddata->spi_dev->dev,
-			"jbt_ret_write_0 spi_write ret %d\n", rc);
-
-	return rc;
-}
-
-static int jbt_reg_write_1(struct panel_drv_data *ddata, u8 reg, u8 data)
-{
-	int rc;
-	u16 tx_buf[2];
-
-	tx_buf[0] = JBT_COMMAND | reg;
-	tx_buf[1] = JBT_DATA | data;
-	rc = spi_write(ddata->spi_dev, (u8 *)tx_buf,
-			2*sizeof(u16));
-	if (rc != 0)
-		dev_err(&ddata->spi_dev->dev,
-			"jbt_reg_write_1 spi_write ret %d\n", rc);
-
-	return rc;
-}
-
-static int jbt_reg_write_2(struct panel_drv_data *ddata, u8 reg, u16 data)
-{
-	int rc;
-	u16 tx_buf[3];
-
-	tx_buf[0] = JBT_COMMAND | reg;
-	tx_buf[1] = JBT_DATA | (data >> 8);
-	tx_buf[2] = JBT_DATA | (data & 0xff);
-
-	rc = spi_write(ddata->spi_dev, (u8 *)tx_buf,
-			3*sizeof(u16));
-
-	if (rc != 0)
-		dev_err(&ddata->spi_dev->dev,
-			"jbt_reg_write_2 spi_write ret %d\n", rc);
-
-	return rc;
-}
-
-enum jbt_register {
-	JBT_REG_SLEEP_IN		= 0x10,
-	JBT_REG_SLEEP_OUT		= 0x11,
-
-	JBT_REG_DISPLAY_OFF		= 0x28,
-	JBT_REG_DISPLAY_ON		= 0x29,
-
-	JBT_REG_RGB_FORMAT		= 0x3a,
-	JBT_REG_QUAD_RATE		= 0x3b,
-
-	JBT_REG_POWER_ON_OFF		= 0xb0,
-	JBT_REG_BOOSTER_OP		= 0xb1,
-	JBT_REG_BOOSTER_MODE		= 0xb2,
-	JBT_REG_BOOSTER_FREQ		= 0xb3,
-	JBT_REG_OPAMP_SYSCLK		= 0xb4,
-	JBT_REG_VSC_VOLTAGE		= 0xb5,
-	JBT_REG_VCOM_VOLTAGE		= 0xb6,
-	JBT_REG_EXT_DISPL		= 0xb7,
-	JBT_REG_OUTPUT_CONTROL		= 0xb8,
-	JBT_REG_DCCLK_DCEV		= 0xb9,
-	JBT_REG_DISPLAY_MODE1		= 0xba,
-	JBT_REG_DISPLAY_MODE2		= 0xbb,
-	JBT_REG_DISPLAY_MODE		= 0xbc,
-	JBT_REG_ASW_SLEW		= 0xbd,
-	JBT_REG_DUMMY_DISPLAY		= 0xbe,
-	JBT_REG_DRIVE_SYSTEM		= 0xbf,
-
-	JBT_REG_SLEEP_OUT_FR_A		= 0xc0,
-	JBT_REG_SLEEP_OUT_FR_B		= 0xc1,
-	JBT_REG_SLEEP_OUT_FR_C		= 0xc2,
-	JBT_REG_SLEEP_IN_LCCNT_D	= 0xc3,
-	JBT_REG_SLEEP_IN_LCCNT_E	= 0xc4,
-	JBT_REG_SLEEP_IN_LCCNT_F	= 0xc5,
-	JBT_REG_SLEEP_IN_LCCNT_G	= 0xc6,
-
-	JBT_REG_GAMMA1_FINE_1		= 0xc7,
-	JBT_REG_GAMMA1_FINE_2		= 0xc8,
-	JBT_REG_GAMMA1_INCLINATION	= 0xc9,
-	JBT_REG_GAMMA1_BLUE_OFFSET	= 0xca,
-
-	JBT_REG_BLANK_CONTROL		= 0xcf,
-	JBT_REG_BLANK_TH_TV		= 0xd0,
-	JBT_REG_CKV_ON_OFF		= 0xd1,
-	JBT_REG_CKV_1_2			= 0xd2,
-	JBT_REG_OEV_TIMING		= 0xd3,
-	JBT_REG_ASW_TIMING_1		= 0xd4,
-	JBT_REG_ASW_TIMING_2		= 0xd5,
-
-	JBT_REG_HCLOCK_VGA		= 0xec,
-	JBT_REG_HCLOCK_QVGA		= 0xed,
-};
-
-#define to_panel_data(p) container_of(p, struct panel_drv_data, dssdev)
-
-static int td028ttec1_panel_connect(struct omap_dss_device *src,
-				    struct omap_dss_device *dst)
-{
-	return 0;
-}
-
-static void td028ttec1_panel_disconnect(struct omap_dss_device *src,
-					struct omap_dss_device *dst)
-{
-}
-
-static void td028ttec1_panel_enable(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-	int r = 0;
-
-	dev_dbg(dssdev->dev, "%s: state %d\n", __func__, dssdev->state);
-
-	/* three times command zero */
-	r |= jbt_ret_write_0(ddata, 0x00);
-	usleep_range(1000, 2000);
-	r |= jbt_ret_write_0(ddata, 0x00);
-	usleep_range(1000, 2000);
-	r |= jbt_ret_write_0(ddata, 0x00);
-	usleep_range(1000, 2000);
-
-	if (r) {
-		dev_warn(dssdev->dev, "%s: transfer error\n", __func__);
-		return;
-	}
-
-	/* deep standby out */
-	r |= jbt_reg_write_1(ddata, JBT_REG_POWER_ON_OFF, 0x17);
-
-	/* RGB I/F on, RAM write off, QVGA through, SIGCON enable */
-	r |= jbt_reg_write_1(ddata, JBT_REG_DISPLAY_MODE, 0x80);
-
-	/* Quad mode off */
-	r |= jbt_reg_write_1(ddata, JBT_REG_QUAD_RATE, 0x00);
-
-	/* AVDD on, XVDD on */
-	r |= jbt_reg_write_1(ddata, JBT_REG_POWER_ON_OFF, 0x16);
-
-	/* Output control */
-	r |= jbt_reg_write_2(ddata, JBT_REG_OUTPUT_CONTROL, 0xfff9);
-
-	/* Sleep mode off */
-	r |= jbt_ret_write_0(ddata, JBT_REG_SLEEP_OUT);
-
-	/* at this point we have like 50% grey */
-
-	/* initialize register set */
-	r |= jbt_reg_write_1(ddata, JBT_REG_DISPLAY_MODE1, 0x01);
-	r |= jbt_reg_write_1(ddata, JBT_REG_DISPLAY_MODE2, 0x00);
-	r |= jbt_reg_write_1(ddata, JBT_REG_RGB_FORMAT, 0x60);
-	r |= jbt_reg_write_1(ddata, JBT_REG_DRIVE_SYSTEM, 0x10);
-	r |= jbt_reg_write_1(ddata, JBT_REG_BOOSTER_OP, 0x56);
-	r |= jbt_reg_write_1(ddata, JBT_REG_BOOSTER_MODE, 0x33);
-	r |= jbt_reg_write_1(ddata, JBT_REG_BOOSTER_FREQ, 0x11);
-	r |= jbt_reg_write_1(ddata, JBT_REG_BOOSTER_FREQ, 0x11);
-	r |= jbt_reg_write_1(ddata, JBT_REG_OPAMP_SYSCLK, 0x02);
-	r |= jbt_reg_write_1(ddata, JBT_REG_VSC_VOLTAGE, 0x2b);
-	r |= jbt_reg_write_1(ddata, JBT_REG_VCOM_VOLTAGE, 0x40);
-	r |= jbt_reg_write_1(ddata, JBT_REG_EXT_DISPL, 0x03);
-	r |= jbt_reg_write_1(ddata, JBT_REG_DCCLK_DCEV, 0x04);
-	/*
-	 * default of 0x02 in JBT_REG_ASW_SLEW responsible for 72Hz requirement
-	 * to avoid red / blue flicker
-	 */
-	r |= jbt_reg_write_1(ddata, JBT_REG_ASW_SLEW, 0x04);
-	r |= jbt_reg_write_1(ddata, JBT_REG_DUMMY_DISPLAY, 0x00);
-
-	r |= jbt_reg_write_1(ddata, JBT_REG_SLEEP_OUT_FR_A, 0x11);
-	r |= jbt_reg_write_1(ddata, JBT_REG_SLEEP_OUT_FR_B, 0x11);
-	r |= jbt_reg_write_1(ddata, JBT_REG_SLEEP_OUT_FR_C, 0x11);
-	r |= jbt_reg_write_2(ddata, JBT_REG_SLEEP_IN_LCCNT_D, 0x2040);
-	r |= jbt_reg_write_2(ddata, JBT_REG_SLEEP_IN_LCCNT_E, 0x60c0);
-	r |= jbt_reg_write_2(ddata, JBT_REG_SLEEP_IN_LCCNT_F, 0x1020);
-	r |= jbt_reg_write_2(ddata, JBT_REG_SLEEP_IN_LCCNT_G, 0x60c0);
-
-	r |= jbt_reg_write_2(ddata, JBT_REG_GAMMA1_FINE_1, 0x5533);
-	r |= jbt_reg_write_1(ddata, JBT_REG_GAMMA1_FINE_2, 0x00);
-	r |= jbt_reg_write_1(ddata, JBT_REG_GAMMA1_INCLINATION, 0x00);
-	r |= jbt_reg_write_1(ddata, JBT_REG_GAMMA1_BLUE_OFFSET, 0x00);
-
-	r |= jbt_reg_write_2(ddata, JBT_REG_HCLOCK_VGA, 0x1f0);
-	r |= jbt_reg_write_1(ddata, JBT_REG_BLANK_CONTROL, 0x02);
-	r |= jbt_reg_write_2(ddata, JBT_REG_BLANK_TH_TV, 0x0804);
-
-	r |= jbt_reg_write_1(ddata, JBT_REG_CKV_ON_OFF, 0x01);
-	r |= jbt_reg_write_2(ddata, JBT_REG_CKV_1_2, 0x0000);
-
-	r |= jbt_reg_write_2(ddata, JBT_REG_OEV_TIMING, 0x0d0e);
-	r |= jbt_reg_write_2(ddata, JBT_REG_ASW_TIMING_1, 0x11a4);
-	r |= jbt_reg_write_1(ddata, JBT_REG_ASW_TIMING_2, 0x0e);
-
-	r |= jbt_ret_write_0(ddata, JBT_REG_DISPLAY_ON);
-
-	if (r)
-		dev_err(dssdev->dev, "%s: write error\n", __func__);
-
-	backlight_enable(ddata->backlight);
-}
-
-static void td028ttec1_panel_disable(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	backlight_disable(ddata->backlight);
-
-	dev_dbg(dssdev->dev, "td028ttec1_panel_disable()\n");
-
-	jbt_ret_write_0(ddata, JBT_REG_DISPLAY_OFF);
-	jbt_reg_write_2(ddata, JBT_REG_OUTPUT_CONTROL, 0x8002);
-	jbt_ret_write_0(ddata, JBT_REG_SLEEP_IN);
-	jbt_reg_write_1(ddata, JBT_REG_POWER_ON_OFF, 0x00);
-}
-
-static int td028ttec1_panel_get_modes(struct omap_dss_device *dssdev,
-				      struct drm_connector *connector)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	return omapdss_display_get_modes(connector, &ddata->vm);
-}
-
-static const struct omap_dss_device_ops td028ttec1_ops = {
-	.connect	= td028ttec1_panel_connect,
-	.disconnect	= td028ttec1_panel_disconnect,
-
-	.enable		= td028ttec1_panel_enable,
-	.disable	= td028ttec1_panel_disable,
-
-	.get_modes	= td028ttec1_panel_get_modes,
-};
-
-static int td028ttec1_panel_probe(struct spi_device *spi)
-{
-	struct panel_drv_data *ddata;
-	struct omap_dss_device *dssdev;
-	int r;
-
-	dev_dbg(&spi->dev, "%s\n", __func__);
-
-	spi->bits_per_word = 9;
-	spi->mode = SPI_MODE_3;
-
-	r = spi_setup(spi);
-	if (r < 0) {
-		dev_err(&spi->dev, "spi_setup failed: %d\n", r);
-		return r;
-	}
-
-	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
-	if (ddata == NULL)
-		return -ENOMEM;
-
-	ddata->backlight = devm_of_find_backlight(&spi->dev);
-	if (IS_ERR(ddata->backlight))
-		return PTR_ERR(ddata->backlight);
-
-	dev_set_drvdata(&spi->dev, ddata);
-
-	ddata->spi_dev = spi;
-
-	ddata->vm = td028ttec1_panel_vm;
-
-	dssdev = &ddata->dssdev;
-	dssdev->dev = &spi->dev;
-	dssdev->ops = &td028ttec1_ops;
-	dssdev->type = OMAP_DISPLAY_TYPE_DPI;
-	dssdev->display = true;
-	dssdev->owner = THIS_MODULE;
-	dssdev->of_ports = BIT(0);
-	dssdev->ops_flags = OMAP_DSS_DEVICE_OP_MODES;
-
-	/*
-	 * Note: According to the panel documentation:
-	 * SYNC needs to be driven on the FALLING edge
-	 */
-	dssdev->bus_flags = DRM_BUS_FLAG_DE_HIGH
-			  | DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE
-			  | DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE;
-
-	omapdss_display_init(dssdev);
-	omapdss_device_register(dssdev);
-
-	return 0;
-}
-
-static int td028ttec1_panel_remove(struct spi_device *spi)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
-	struct omap_dss_device *dssdev = &ddata->dssdev;
-
-	dev_dbg(&ddata->spi_dev->dev, "%s\n", __func__);
-
-	omapdss_device_unregister(dssdev);
-
-	td028ttec1_panel_disable(dssdev);
-
-	return 0;
-}
-
-static const struct of_device_id td028ttec1_of_match[] = {
-	{ .compatible = "omapdss,tpo,td028ttec1", },
-	/* keep to not break older DTB */
-	{ .compatible = "omapdss,toppoly,td028ttec1", },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, td028ttec1_of_match);
-
-static const struct spi_device_id td028ttec1_ids[] = {
-	{ "toppoly,td028ttec1", 0 },
-	{ "tpo,td028ttec1", 0},
-	{ /* sentinel */ }
-};
-
-MODULE_DEVICE_TABLE(spi, td028ttec1_ids);
-
-
-static struct spi_driver td028ttec1_spi_driver = {
-	.probe		= td028ttec1_panel_probe,
-	.remove		= td028ttec1_panel_remove,
-	.id_table	= td028ttec1_ids,
-
-	.driver         = {
-		.name   = "panel-tpo-td028ttec1",
-		.of_match_table = td028ttec1_of_match,
-		.suppress_bind_attrs = true,
-	},
-};
-
-module_spi_driver(td028ttec1_spi_driver);
-
-MODULE_AUTHOR("H. Nikolaus Schaller <hns@goldelico.com>");
-MODULE_DESCRIPTION("Toppoly TD028TTEC1 panel driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c b/drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c
deleted file mode 100644
index ce09217da597..000000000000
--- a/drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c
+++ /dev/null
@@ -1,513 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * TPO TD043MTEA1 Panel driver
- *
- * Author: Gražvydas Ignotas <notasas@gmail.com>
- * Converted to new DSS device model: Tomi Valkeinen <tomi.valkeinen@ti.com>
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/gpio/consumer.h>
-#include <linux/module.h>
-#include <linux/regulator/consumer.h>
-#include <linux/slab.h>
-#include <linux/spi/spi.h>
-
-#include "../dss/omapdss.h"
-
-#define TPO_R02_MODE(x)		((x) & 7)
-#define TPO_R02_MODE_800x480	7
-#define TPO_R02_NCLK_RISING	BIT(3)
-#define TPO_R02_HSYNC_HIGH	BIT(4)
-#define TPO_R02_VSYNC_HIGH	BIT(5)
-
-#define TPO_R03_NSTANDBY	BIT(0)
-#define TPO_R03_EN_CP_CLK	BIT(1)
-#define TPO_R03_EN_VGL_PUMP	BIT(2)
-#define TPO_R03_EN_PWM		BIT(3)
-#define TPO_R03_DRIVING_CAP_100	BIT(4)
-#define TPO_R03_EN_PRE_CHARGE	BIT(6)
-#define TPO_R03_SOFTWARE_CTL	BIT(7)
-
-#define TPO_R04_NFLIP_H		BIT(0)
-#define TPO_R04_NFLIP_V		BIT(1)
-#define TPO_R04_CP_CLK_FREQ_1H	BIT(2)
-#define TPO_R04_VGL_FREQ_1H	BIT(4)
-
-#define TPO_R03_VAL_NORMAL (TPO_R03_NSTANDBY | TPO_R03_EN_CP_CLK | \
-			TPO_R03_EN_VGL_PUMP |  TPO_R03_EN_PWM | \
-			TPO_R03_DRIVING_CAP_100 | TPO_R03_EN_PRE_CHARGE | \
-			TPO_R03_SOFTWARE_CTL)
-
-#define TPO_R03_VAL_STANDBY (TPO_R03_DRIVING_CAP_100 | \
-			TPO_R03_EN_PRE_CHARGE | TPO_R03_SOFTWARE_CTL)
-
-static const u16 tpo_td043_def_gamma[12] = {
-	105, 315, 381, 431, 490, 537, 579, 686, 780, 837, 880, 1023
-};
-
-struct panel_drv_data {
-	struct omap_dss_device	dssdev;
-
-	struct videomode vm;
-
-	struct spi_device *spi;
-	struct regulator *vcc_reg;
-	struct gpio_desc *reset_gpio;
-	u16 gamma[12];
-	u32 mode;
-	u32 vmirror:1;
-	u32 powered_on:1;
-	u32 spi_suspended:1;
-	u32 power_on_resume:1;
-};
-
-static const struct videomode tpo_td043_vm = {
-	.hactive	= 800,
-	.vactive	= 480,
-
-	.pixelclock	= 36000000,
-
-	.hsync_len	= 1,
-	.hfront_porch	= 68,
-	.hback_porch	= 214,
-
-	.vsync_len	= 1,
-	.vfront_porch	= 39,
-	.vback_porch	= 34,
-
-	.flags		= DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW,
-};
-
-#define to_panel_data(p) container_of(p, struct panel_drv_data, dssdev)
-
-static int tpo_td043_write(struct spi_device *spi, u8 addr, u8 data)
-{
-	struct spi_message	m;
-	struct spi_transfer	xfer;
-	u16			w;
-	int			r;
-
-	spi_message_init(&m);
-
-	memset(&xfer, 0, sizeof(xfer));
-
-	w = ((u16)addr << 10) | (1 << 8) | data;
-	xfer.tx_buf = &w;
-	xfer.bits_per_word = 16;
-	xfer.len = 2;
-	spi_message_add_tail(&xfer, &m);
-
-	r = spi_sync(spi, &m);
-	if (r < 0)
-		dev_warn(&spi->dev, "failed to write to LCD reg (%d)\n", r);
-	return r;
-}
-
-static void tpo_td043_write_gamma(struct spi_device *spi, u16 gamma[12])
-{
-	u8 i, val;
-
-	/* gamma bits [9:8] */
-	for (val = i = 0; i < 4; i++)
-		val |= (gamma[i] & 0x300) >> ((i + 1) * 2);
-	tpo_td043_write(spi, 0x11, val);
-
-	for (val = i = 0; i < 4; i++)
-		val |= (gamma[i+4] & 0x300) >> ((i + 1) * 2);
-	tpo_td043_write(spi, 0x12, val);
-
-	for (val = i = 0; i < 4; i++)
-		val |= (gamma[i+8] & 0x300) >> ((i + 1) * 2);
-	tpo_td043_write(spi, 0x13, val);
-
-	/* gamma bits [7:0] */
-	for (val = i = 0; i < 12; i++)
-		tpo_td043_write(spi, 0x14 + i, gamma[i] & 0xff);
-}
-
-static int tpo_td043_write_mirror(struct spi_device *spi, bool h, bool v)
-{
-	u8 reg4 = TPO_R04_NFLIP_H | TPO_R04_NFLIP_V |
-		TPO_R04_CP_CLK_FREQ_1H | TPO_R04_VGL_FREQ_1H;
-	if (h)
-		reg4 &= ~TPO_R04_NFLIP_H;
-	if (v)
-		reg4 &= ~TPO_R04_NFLIP_V;
-
-	return tpo_td043_write(spi, 4, reg4);
-}
-
-static ssize_t tpo_td043_vmirror_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(dev);
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", ddata->vmirror);
-}
-
-static ssize_t tpo_td043_vmirror_store(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(dev);
-	int val;
-	int ret;
-
-	ret = kstrtoint(buf, 0, &val);
-	if (ret < 0)
-		return ret;
-
-	val = !!val;
-
-	ret = tpo_td043_write_mirror(ddata->spi, false, val);
-	if (ret < 0)
-		return ret;
-
-	ddata->vmirror = val;
-
-	return count;
-}
-
-static ssize_t tpo_td043_mode_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(dev);
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", ddata->mode);
-}
-
-static ssize_t tpo_td043_mode_store(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(dev);
-	long val;
-	int ret;
-
-	ret = kstrtol(buf, 0, &val);
-	if (ret != 0 || val & ~7)
-		return -EINVAL;
-
-	ddata->mode = val;
-
-	val |= TPO_R02_NCLK_RISING;
-	tpo_td043_write(ddata->spi, 2, val);
-
-	return count;
-}
-
-static ssize_t tpo_td043_gamma_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(dev);
-	ssize_t len = 0;
-	int ret;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(ddata->gamma); i++) {
-		ret = snprintf(buf + len, PAGE_SIZE - len, "%u ",
-				ddata->gamma[i]);
-		if (ret < 0)
-			return ret;
-		len += ret;
-	}
-	buf[len - 1] = '\n';
-
-	return len;
-}
-
-static ssize_t tpo_td043_gamma_store(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(dev);
-	unsigned int g[12];
-	int ret;
-	int i;
-
-	ret = sscanf(buf, "%u %u %u %u %u %u %u %u %u %u %u %u",
-			&g[0], &g[1], &g[2], &g[3], &g[4], &g[5],
-			&g[6], &g[7], &g[8], &g[9], &g[10], &g[11]);
-
-	if (ret != 12)
-		return -EINVAL;
-
-	for (i = 0; i < 12; i++)
-		ddata->gamma[i] = g[i];
-
-	tpo_td043_write_gamma(ddata->spi, ddata->gamma);
-
-	return count;
-}
-
-static DEVICE_ATTR(vmirror, S_IRUGO | S_IWUSR,
-		tpo_td043_vmirror_show, tpo_td043_vmirror_store);
-static DEVICE_ATTR(mode, S_IRUGO | S_IWUSR,
-		tpo_td043_mode_show, tpo_td043_mode_store);
-static DEVICE_ATTR(gamma, S_IRUGO | S_IWUSR,
-		tpo_td043_gamma_show, tpo_td043_gamma_store);
-
-static struct attribute *tpo_td043_attrs[] = {
-	&dev_attr_vmirror.attr,
-	&dev_attr_mode.attr,
-	&dev_attr_gamma.attr,
-	NULL,
-};
-
-static const struct attribute_group tpo_td043_attr_group = {
-	.attrs = tpo_td043_attrs,
-};
-
-static int tpo_td043_power_on(struct panel_drv_data *ddata)
-{
-	int r;
-
-	if (ddata->powered_on)
-		return 0;
-
-	r = regulator_enable(ddata->vcc_reg);
-	if (r != 0)
-		return r;
-
-	/* wait for panel to stabilize */
-	msleep(160);
-
-	gpiod_set_value(ddata->reset_gpio, 0);
-
-	tpo_td043_write(ddata->spi, 2,
-			TPO_R02_MODE(ddata->mode) | TPO_R02_NCLK_RISING);
-	tpo_td043_write(ddata->spi, 3, TPO_R03_VAL_NORMAL);
-	tpo_td043_write(ddata->spi, 0x20, 0xf0);
-	tpo_td043_write(ddata->spi, 0x21, 0xf0);
-	tpo_td043_write_mirror(ddata->spi, false, ddata->vmirror);
-	tpo_td043_write_gamma(ddata->spi, ddata->gamma);
-
-	ddata->powered_on = 1;
-	return 0;
-}
-
-static void tpo_td043_power_off(struct panel_drv_data *ddata)
-{
-	if (!ddata->powered_on)
-		return;
-
-	tpo_td043_write(ddata->spi, 3,
-			TPO_R03_VAL_STANDBY | TPO_R03_EN_PWM);
-
-	gpiod_set_value(ddata->reset_gpio, 1);
-
-	/* wait for at least 2 vsyncs before cutting off power */
-	msleep(50);
-
-	tpo_td043_write(ddata->spi, 3, TPO_R03_VAL_STANDBY);
-
-	regulator_disable(ddata->vcc_reg);
-
-	ddata->powered_on = 0;
-}
-
-static int tpo_td043_connect(struct omap_dss_device *src,
-			     struct omap_dss_device *dst)
-{
-	return 0;
-}
-
-static void tpo_td043_disconnect(struct omap_dss_device *src,
-				 struct omap_dss_device *dst)
-{
-}
-
-static void tpo_td043_enable(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-	int r;
-
-	/*
-	 * If we are resuming from system suspend, SPI clocks might not be
-	 * enabled yet, so we'll program the LCD from SPI PM resume callback.
-	 */
-	if (!ddata->spi_suspended) {
-		r = tpo_td043_power_on(ddata);
-		if (r) {
-			dev_err(&ddata->spi->dev, "%s: power on failed (%d)\n",
-				__func__, r);
-			return;
-		}
-	}
-}
-
-static void tpo_td043_disable(struct omap_dss_device *dssdev)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	if (!ddata->spi_suspended)
-		tpo_td043_power_off(ddata);
-}
-
-static int tpo_td043_get_modes(struct omap_dss_device *dssdev,
-			       struct drm_connector *connector)
-{
-	struct panel_drv_data *ddata = to_panel_data(dssdev);
-
-	return omapdss_display_get_modes(connector, &ddata->vm);
-}
-
-static const struct omap_dss_device_ops tpo_td043_ops = {
-	.connect	= tpo_td043_connect,
-	.disconnect	= tpo_td043_disconnect,
-
-	.enable		= tpo_td043_enable,
-	.disable	= tpo_td043_disable,
-
-	.get_modes	= tpo_td043_get_modes,
-};
-
-static int tpo_td043_probe(struct spi_device *spi)
-{
-	struct panel_drv_data *ddata;
-	struct omap_dss_device *dssdev;
-	struct gpio_desc *gpio;
-	int r;
-
-	dev_dbg(&spi->dev, "%s\n", __func__);
-
-	spi->bits_per_word = 16;
-	spi->mode = SPI_MODE_0;
-
-	r = spi_setup(spi);
-	if (r < 0) {
-		dev_err(&spi->dev, "spi_setup failed: %d\n", r);
-		return r;
-	}
-
-	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
-	if (ddata == NULL)
-		return -ENOMEM;
-
-	dev_set_drvdata(&spi->dev, ddata);
-
-	ddata->spi = spi;
-
-	ddata->mode = TPO_R02_MODE_800x480;
-	memcpy(ddata->gamma, tpo_td043_def_gamma, sizeof(ddata->gamma));
-
-	ddata->vcc_reg = devm_regulator_get(&spi->dev, "vcc");
-	if (IS_ERR(ddata->vcc_reg)) {
-		dev_err(&spi->dev, "failed to get LCD VCC regulator\n");
-		return PTR_ERR(ddata->vcc_reg);
-	}
-
-	gpio = devm_gpiod_get(&spi->dev, "reset", GPIOD_OUT_HIGH);
-	if (IS_ERR(gpio)) {
-		dev_err(&spi->dev, "failed to get reset gpio\n");
-		return PTR_ERR(gpio);
-	}
-
-	ddata->reset_gpio = gpio;
-
-	r = sysfs_create_group(&spi->dev.kobj, &tpo_td043_attr_group);
-	if (r) {
-		dev_err(&spi->dev, "failed to create sysfs files\n");
-		return r;
-	}
-
-	ddata->vm = tpo_td043_vm;
-
-	dssdev = &ddata->dssdev;
-	dssdev->dev = &spi->dev;
-	dssdev->ops = &tpo_td043_ops;
-	dssdev->type = OMAP_DISPLAY_TYPE_DPI;
-	dssdev->display = true;
-	dssdev->owner = THIS_MODULE;
-	dssdev->of_ports = BIT(0);
-	dssdev->ops_flags = OMAP_DSS_DEVICE_OP_MODES;
-
-	/*
-	 * Note: According to the panel documentation:
-	 * SYNC needs to be driven on the FALLING edge
-	 */
-	dssdev->bus_flags = DRM_BUS_FLAG_DE_HIGH
-			  | DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE
-			  | DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE;
-
-	omapdss_display_init(dssdev);
-	omapdss_device_register(dssdev);
-
-	return 0;
-}
-
-static int tpo_td043_remove(struct spi_device *spi)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
-	struct omap_dss_device *dssdev = &ddata->dssdev;
-
-	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
-
-	omapdss_device_unregister(dssdev);
-
-	if (omapdss_device_is_enabled(dssdev))
-		tpo_td043_disable(dssdev);
-
-	sysfs_remove_group(&spi->dev.kobj, &tpo_td043_attr_group);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int tpo_td043_spi_suspend(struct device *dev)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(dev);
-
-	dev_dbg(dev, "tpo_td043_spi_suspend, tpo %p\n", ddata);
-
-	ddata->power_on_resume = ddata->powered_on;
-	tpo_td043_power_off(ddata);
-	ddata->spi_suspended = 1;
-
-	return 0;
-}
-
-static int tpo_td043_spi_resume(struct device *dev)
-{
-	struct panel_drv_data *ddata = dev_get_drvdata(dev);
-	int ret;
-
-	dev_dbg(dev, "tpo_td043_spi_resume\n");
-
-	if (ddata->power_on_resume) {
-		ret = tpo_td043_power_on(ddata);
-		if (ret)
-			return ret;
-	}
-	ddata->spi_suspended = 0;
-
-	return 0;
-}
-#endif
-
-static SIMPLE_DEV_PM_OPS(tpo_td043_spi_pm,
-	tpo_td043_spi_suspend, tpo_td043_spi_resume);
-
-static const struct of_device_id tpo_td043_of_match[] = {
-	{ .compatible = "omapdss,tpo,td043mtea1", },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, tpo_td043_of_match);
-
-static struct spi_driver tpo_td043_spi_driver = {
-	.driver = {
-		.name	= "panel-tpo-td043mtea1",
-		.pm	= &tpo_td043_spi_pm,
-		.of_match_table = tpo_td043_of_match,
-		.suppress_bind_attrs = true,
-	},
-	.probe	= tpo_td043_probe,
-	.remove	= tpo_td043_remove,
-};
-
-module_spi_driver(tpo_td043_spi_driver);
-
-MODULE_ALIAS("spi:tpo,td043mtea1");
-MODULE_AUTHOR("Gražvydas Ignotas <notasas@gmail.com>");
-MODULE_DESCRIPTION("TPO TD043MTEA1 LCD Driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/omapdrm/dss/omapdss-boot-init.c b/drivers/gpu/drm/omapdrm/dss/omapdss-boot-init.c
index a140de79c50e..31502857f013 100644
--- a/drivers/gpu/drm/omapdrm/dss/omapdss-boot-init.c
+++ b/drivers/gpu/drm/omapdrm/dss/omapdss-boot-init.c
@@ -176,17 +176,10 @@ static const struct of_device_id omapdss_of_match[] __initconst = {
 static const struct of_device_id omapdss_of_fixups_whitelist[] __initconst = {
 	{ .compatible = "composite-video-connector" },
 	{ .compatible = "hdmi-connector" },
-	{ .compatible = "lgphilips,lb035q02" },
-	{ .compatible = "nec,nl8048hl11" },
 	{ .compatible = "panel-dsi-cm" },
-	{ .compatible = "sharp,ls037v7dw01" },
-	{ .compatible = "sony,acx565akm" },
 	{ .compatible = "svideo-connector" },
 	{ .compatible = "ti,opa362" },
 	{ .compatible = "ti,tpd12s015" },
-	{ .compatible = "toppoly,td028ttec1" },
-	{ .compatible = "tpo,td028ttec1" },
-	{ .compatible = "tpo,td043mtea1" },
 	{},
 };
 
-- 
2.17.1

