From bd88ae168ffd8e94116f03d810e8783163e79d9b Mon Sep 17 00:00:00 2001
From: "Randy G. Duran" <randy.g.duran@intel.com>
Date: Tue, 2 Apr 2019 12:46:43 -0700
Subject: [PATCH 289/292] clean up for
 sandbox/fyang16/mainline-tracking-base-5.0-ww10.3

---
 drivers/char/tpm/tpm2-cmd.c |  6 +--
 drivers/misc/mei/dma-ring.c | 39 +++++++++++--------
 drivers/misc/mei/hbm.c      | 15 +++-----
 drivers/misc/mei/hw.h       |  1 +
 drivers/tee/tee_core.c      |  1 -
 include/linux/tee_drv.h     | 76 ++++++++++++++++++++++++++++++++++++-
 sound/soc/soc-topology.c    |  5 ---
 7 files changed, 108 insertions(+), 35 deletions(-)

diff --git a/drivers/char/tpm/tpm2-cmd.c b/drivers/char/tpm/tpm2-cmd.c
index a6bec13afa69..ba94dd5f11a4 100644
--- a/drivers/char/tpm/tpm2-cmd.c
+++ b/drivers/char/tpm/tpm2-cmd.c
@@ -342,9 +342,9 @@ int tpm2_get_random(struct tpm_chip *chip, u8 *dest, size_t max)
 
 /**
  * tpm2_flush_context_cmd() - execute a TPM2_FlushContext command
- * @chip:	TPM chip to use
- * @handle:	context handle
- * @flags:	tpm transmit flags - bitmap
+ * @chip: TPM chip to use
+ * @handle: context handle
+ * @flags: tpm transmit flags - bitmap
  *
  */
 void tpm2_flush_context_cmd(struct tpm_chip *chip, u32 handle,
diff --git a/drivers/misc/mei/dma-ring.c b/drivers/misc/mei/dma-ring.c
index 795641b82181..f809db5c0129 100644
--- a/drivers/misc/mei/dma-ring.c
+++ b/drivers/misc/mei/dma-ring.c
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
 /*
  * Copyright(c) 2016 - 2018 Intel Corporation. All rights reserved.
  */
@@ -8,15 +8,15 @@
 #include "mei_dev.h"
 
 /**
- * mei_dmam_dscr_alloc() - allocate a managed coherent buffer
+ * mei_dmam_dscr_alloc - allocate a managed coherent buffer
  *     for the dma descriptor
+ *
  * @dev: mei_device
  * @dscr: dma descriptor
  *
- * Return:
- * * 0       - on success or zero allocation request
- * * -EINVAL - if size is not power of 2
- * * -ENOMEM - of allocation has failed
+ * Return: 0 on success or zero allocation request
+ *         -EINVAL if size is not power of 2
+ *         -ENOMEM of allocation has failed
  */
 static int mei_dmam_dscr_alloc(struct mei_device *dev,
 			       struct mei_dma_dscr *dscr)
@@ -39,8 +39,9 @@ static int mei_dmam_dscr_alloc(struct mei_device *dev,
 }
 
 /**
- * mei_dmam_dscr_free() - free a managed coherent buffer
+ * mei_dmam_dscr_free - free a managed coherent buffer
  *     from the dma descriptor
+ *
  * @dev: mei_device
  * @dscr: dma descriptor
  */
@@ -55,7 +56,8 @@ static void mei_dmam_dscr_free(struct mei_device *dev,
 }
 
 /**
- * mei_dmam_ring_free() - free dma ring buffers
+ * mei_dmam_ring_free - free dma ring buffers
+ *
  * @dev: mei device
  */
 void mei_dmam_ring_free(struct mei_device *dev)
@@ -67,7 +69,8 @@ void mei_dmam_ring_free(struct mei_device *dev)
 }
 
 /**
- * mei_dmam_ring_alloc() - allocate dma ring buffers
+ * mei_dmam_ring_alloc - allocate dma ring buffers
+ *
  * @dev: mei device
  *
  * Return: -ENOMEM on allocation failure 0 otherwise
@@ -88,7 +91,8 @@ int mei_dmam_ring_alloc(struct mei_device *dev)
 }
 
 /**
- * mei_dma_ring_is_allocated() - check if dma ring is allocated
+ * mei_dma_ring_is_allocated - check if dma ring is allocated
+ *
  * @dev: mei device
  *
  * Return: true if dma ring is allocated
@@ -105,7 +109,8 @@ struct hbm_dma_ring_ctrl *mei_dma_ring_ctrl(struct mei_device *dev)
 }
 
 /**
- * mei_dma_ring_reset() - reset the dma control block
+ * mei_dma_ring_reset - reset the dma control block
+ *
  * @dev: mei device
  */
 void mei_dma_ring_reset(struct mei_device *dev)
@@ -119,7 +124,8 @@ void mei_dma_ring_reset(struct mei_device *dev)
 }
 
 /**
- * mei_dma_copy_from() - copy from dma ring into buffer
+ * mei_dma_ring_reset - copy from dma ring into buffer
+ *
  * @dev: mei device
  * @buf: data buffer
  * @offset: offset in slots.
@@ -139,7 +145,8 @@ static size_t mei_dma_copy_from(struct mei_device *dev, unsigned char *buf,
 }
 
 /**
- * mei_dma_copy_to() - copy to a buffer to the dma ring
+ * mei_dma_copy_to - copy to a buffer to the dma ring
+ *
  * @dev: mei device
  * @buf: data buffer
  * @offset: offset in slots.
@@ -159,7 +166,8 @@ static size_t mei_dma_copy_to(struct mei_device *dev, unsigned char *buf,
 }
 
 /**
- * mei_dma_ring_read() - read data from the ring
+ * mei_dma_ring_read - read data from the ring
+ *
  * @dev: mei device
  * @buf: buffer to read into: may be NULL in case of droping the data.
  * @len: length to read.
@@ -205,7 +213,8 @@ static inline u32 mei_dma_ring_hbuf_depth(struct mei_device *dev)
 }
 
 /**
- * mei_dma_ring_empty_slots() - calaculate number of empty slots in dma ring
+ * mei_dma_ring_empty_slots - calaculate number of empty slots in dma ring
+ *
  * @dev: mei_device
  *
  * Return: number of empty slots
diff --git a/drivers/misc/mei/hbm.c b/drivers/misc/mei/hbm.c
index a3c2976ada13..c361fe721d40 100644
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@ -293,7 +293,8 @@ int mei_hbm_start_req(struct mei_device *dev)
 }
 
 /**
- * mei_hbm_dma_setup_req() - setup DMA request
+ * mei_hbm_dma_setup_req - setup DMA request
+ *
  * @dev: the device structure
  *
  * Return: 0 on success and < 0 on failure
@@ -1268,15 +1269,9 @@ int mei_hbm_dispatch(struct mei_device *dev, struct mei_msg_hdr *hdr)
 		dma_setup_res = (struct hbm_dma_setup_response *)mei_msg;
 
 		if (dma_setup_res->status) {
-			u8 status = dma_setup_res->status;
-
-			if (status == MEI_HBMS_NOT_ALLOWED) {
-				dev_dbg(dev->dev, "hbm: dma setup not allowed\n");
-			} else {
-				dev_info(dev->dev, "hbm: dma setup response: failure = %d %s\n",
-					 status,
-					 mei_hbm_status_str(status));
-			}
+			dev_info(dev->dev, "hbm: dma setup response: failure = %d %s\n",
+				dma_setup_res->status,
+				mei_hbm_status_str(dma_setup_res->status));
 			dev->hbm_f_dr_supported = 0;
 			mei_dmam_ring_free(dev);
 		}
diff --git a/drivers/misc/mei/hw.h b/drivers/misc/mei/hw.h
index 90d118ae8434..0787526460f5 100644
--- a/drivers/misc/mei/hw.h
+++ b/drivers/misc/mei/hw.h
@@ -36,6 +36,7 @@
  * MEI Version
  */
 #define HBM_MINOR_VERSION                   2
+
 #define HBM_MAJOR_VERSION                   2
 
 /*
diff --git a/drivers/tee/tee_core.c b/drivers/tee/tee_core.c
index 7e409d23b959..2fdd9807fe56 100644
--- a/drivers/tee/tee_core.c
+++ b/drivers/tee/tee_core.c
@@ -64,7 +64,6 @@ static struct tee_context *teedev_open(struct tee_device *teedev)
 	kfree(ctx);
 	tee_device_put(teedev);
 	return ERR_PTR(rc);
-
 }
 
 void teedev_ctx_get(struct tee_context *ctx)
diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index b09bab8e8409..91653d9b0f62 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -550,4 +550,78 @@ static inline bool tee_param_is_memref(struct tee_param *param)
 	}
 }
 
-#endif /*__TEE_DRV_H*/
+/**
+    * tee_client_open_context() - Open a TEE context
+    * @start:	if not NULL, continue search after this context
+    * @match:	function to check TEE device
+    * @data:	data for match function
+    * @vers:	if not NULL, version data of TEE device of the context returned
+    *
+    * This function does an operation similar to open("/dev/teeX") in user space.
+    * A returned context must be released with tee_client_close_context().
+    *
+    * Returns a TEE context of the first TEE device matched by the match()
+    * callback or an ERR_PTR.
+    */
+struct tee_context *
+tee_client_open_context(struct tee_context *start,
+					int (*match)(struct tee_ioctl_version_data *,
+							     const void *),
+					const void *data, struct tee_ioctl_version_data *vers);
+
+/**
+    * tee_client_close_context() - Close a TEE context
+    * @ctx:	TEE context to close
+    *
+    * Note that all sessions previously opened with this context will be
+    * closed when this function is called.
+    */
+void tee_client_close_context(struct tee_context *ctx);
+
+/**
+    * tee_client_get_version() - Query version of TEE
+    * @ctx:	TEE context to TEE to query
+    * @vers:	Pointer to version data
+    */
+void tee_client_get_version(struct tee_context *ctx,
+		+			    struct tee_ioctl_version_data *vers);
+
+/**
+    * tee_client_open_session() - Open a session to a Trusted Application
+    * @ctx:	TEE context
+    * @arg:	Open session arguments, see description of
+    *		struct tee_ioctl_open_session_arg
+    * @param:	Parameters passed to the Trusted Application
+    *
+    * Returns < 0 on error else see @arg->ret for result. If @arg->ret
+    * is TEEC_SUCCESS the session identifier is available in @arg->session.
+    */
+int tee_client_open_session(struct tee_context *ctx,
+		+			    struct tee_ioctl_open_session_arg *arg,
+		+			    struct tee_param *param);
+
+/**
+    * tee_client_close_session() - Close a session to a Trusted Application
+    * @ctx:	TEE Context
+    * @session:	Session id
+    *
+    * Return < 0 on error else 0, regardless the session will not be
+    * valid after this function has returned.
+    */
++int tee_client_close_session(struct tee_context *ctx, u32 session);
+
+/**
+    * tee_client_invoke_func() - Invoke a function in a Trusted Application
+    * @ctx:	TEE Context
+    * @arg:	Invoke arguments, see description of
+    *		struct tee_ioctl_invoke_arg
+    * @param:	Parameters passed to the Trusted Application
+    *
+    * Returns < 0 on error else see @arg->ret for result.
+    */
+int tee_client_invoke_func(struct tee_context *ctx,
+		+			   struct tee_ioctl_invoke_arg *arg,
+		+			   struct tee_param *param);
+
+
+ #endif /*__TEE_DRV_H*/
diff --git a/sound/soc/soc-topology.c b/sound/soc/soc-topology.c
index 6856a0889428..911d301c20cf 100644
--- a/sound/soc/soc-topology.c
+++ b/sound/soc/soc-topology.c
@@ -504,7 +504,6 @@ static void remove_widget(struct snd_soc_component *comp,
 static void remove_dai(struct snd_soc_component *comp,
 	struct snd_soc_dobj *dobj, int pass)
 {
-	struct snd_soc_dai *dai;
 	struct snd_soc_dai_driver *dai_drv =
 		container_of(dobj, struct snd_soc_dai_driver, dobj);
 	struct snd_soc_dai *dai;
@@ -515,10 +514,6 @@ static void remove_dai(struct snd_soc_component *comp,
 	if (dobj->ops && dobj->ops->dai_unload)
 		dobj->ops->dai_unload(comp, dobj);
 
-	list_for_each_entry(dai, &comp->dai_list, list)
-		if (dai->driver == dai_drv)
-			dai->driver = NULL;
-
 	for_each_component_dais(comp, dai) {
 		if (dai->driver == dai_drv) {
 			dai->driver = NULL;
-- 
2.21.0

