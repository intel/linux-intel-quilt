From e57eb6e1bfa3f7fe5e685917d83dcce94f03a4b5 Mon Sep 17 00:00:00 2001
From: "Dillibabu, Karthikx" <karthikx.dillibabu@intel.com>
Date: Tue, 9 Mar 2021 15:56:58 +0530
Subject: [PATCH 9/9] FIX for Tx/Rx using shared DMA for PSE_HostOwned_SPI
 fails with VT-D enabled

The original using of the DMA API such as dma_alloc_coherent(), dma_map_sg() ..etc,
was using DMA device as the initiator, but it was found out that with PSE + DMA,
it has to use the peripheral itself.

Signed-off-by: Dillibabu, Karthikx <karthikx.dillibabu@intel.com>
---
 drivers/spi/spi.c | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index e1205d72be52..6bb34344c745 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -33,6 +33,7 @@
 #include <linux/highmem.h>
 #include <linux/idr.h>
 #include <linux/platform_data/x86/apple.h>
+#include <linux/pci.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/spi.h>
@@ -41,6 +42,18 @@ EXPORT_TRACEPOINT_SYMBOL(spi_transfer_stop);
 
 #include "internals.h"
 
+static bool pse_dma_quirk;
+
+static void quirk_pse_dma(struct pci_dev *dev)
+{
+	pse_dma_quirk = true;
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b84, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b85, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b86, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b87, quirk_pse_dma);
+
 static DEFINE_IDR(spi_master_idr);
 
 static void spidev_release(struct device *dev)
@@ -925,6 +938,12 @@ static int __spi_map_msg(struct spi_controller *ctlr, struct spi_message *msg)
 	else
 		rx_dev = ctlr->dev.parent;
 
+	/* Hack for PSE SPI */
+	if (pse_dma_quirk) {
+		tx_dev = ctlr->dev.parent;
+		rx_dev = ctlr->dev.parent;
+	}
+
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		if (!ctlr->can_dma(ctlr, msg->spi, xfer))
 			continue;
@@ -972,6 +991,12 @@ static int __spi_unmap_msg(struct spi_controller *ctlr, struct spi_message *msg)
 	else
 		rx_dev = ctlr->dev.parent;
 
+	/* Hack fo PSE SPI */
+	if (pse_dma_quirk) {
+		tx_dev = ctlr->dev.parent;
+		rx_dev = ctlr->dev.parent;
+	}
+
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		if (!ctlr->can_dma(ctlr, msg->spi, xfer))
 			continue;
-- 
2.17.1

