From 1f1ac80eb91f9cc8dc0aeefc762855be7e48743c Mon Sep 17 00:00:00 2001
From: Thomas Zimmermann <tzimmermann@suse.de>
Date: Tue, 21 May 2019 13:08:30 +0200
Subject: [PATCH 298/529] drm: Rename reserve/unreserve to lock/unlock in GEM
 VRAM helpers

To align with the rest of DRM terminology, the GEM VRAM helpers now use
lock and unlock in places where reserve and unreserve where used before.
All callers have been adapted.

Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Link: http://patchwork.freedesktop.org/patch/msgid/20190521110831.20200-3-tzimmermann@suse.de
Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
---
 drivers/gpu/drm/ast/ast_fb.c             | 11 +++----
 drivers/gpu/drm/ast/ast_mode.c           | 12 +++----
 drivers/gpu/drm/drm_gem_vram_helper.c    | 32 +++++++++----------
 drivers/gpu/drm/mgag200/mgag200_cursor.c | 40 ++++++++++++------------
 drivers/gpu/drm/mgag200/mgag200_fb.c     | 11 +++----
 include/drm/drm_gem_vram_helper.h        |  8 ++---
 6 files changed, 56 insertions(+), 58 deletions(-)

diff --git a/drivers/gpu/drm/ast/ast_fb.c b/drivers/gpu/drm/ast/ast_fb.c
index 505e602855c0..05f45222b702 100644
--- a/drivers/gpu/drm/ast/ast_fb.c
+++ b/drivers/gpu/drm/ast/ast_fb.c
@@ -62,13 +62,12 @@ static void ast_dirty_update(struct ast_fbdev *afbdev,
 	obj = afbdev->afb.obj;
 	gbo = drm_gem_vram_of_gem(obj);
 
-	/*
-	 * try and reserve the BO, if we fail with busy
-	 * then the BO is being moved and we should
-	 * store up the damage until later.
+	/* Try to lock the BO. If we fail with -EBUSY then
+	 * the BO is being moved and we should store up the
+	 * damage until later.
 	 */
 	if (drm_can_sleep())
-		ret = drm_gem_vram_reserve(gbo, true);
+		ret = drm_gem_vram_lock(gbo, true);
 	if (ret) {
 		if (ret != -EBUSY)
 			return;
@@ -127,7 +126,7 @@ static void ast_dirty_update(struct ast_fbdev *afbdev,
 		drm_gem_vram_kunmap(gbo);
 
 out:
-	drm_gem_vram_unreserve(gbo);
+	drm_gem_vram_unlock(gbo);
 }
 
 static void ast_fillrect(struct fb_info *info,
diff --git a/drivers/gpu/drm/ast/ast_mode.c b/drivers/gpu/drm/ast/ast_mode.c
index fbafe3994654..fb700d620b64 100644
--- a/drivers/gpu/drm/ast/ast_mode.c
+++ b/drivers/gpu/drm/ast/ast_mode.c
@@ -1201,7 +1201,7 @@ static int ast_cursor_set(struct drm_crtc *crtc,
 	}
 	gbo = drm_gem_vram_of_gem(obj);
 
-	ret = drm_gem_vram_reserve(gbo, false);
+	ret = drm_gem_vram_lock(gbo, false);
 	if (ret)
 		goto fail;
 
@@ -1209,7 +1209,7 @@ static int ast_cursor_set(struct drm_crtc *crtc,
 	src = drm_gem_vram_kmap_at(gbo, true, &src_isiomem, &uobj_map);
 	if (IS_ERR(src)) {
 		ret = PTR_ERR(src);
-		goto fail_unreserve;
+		goto fail_unlock;
 	}
 	if (src_isiomem == true)
 		DRM_ERROR("src cursor bo should be in main memory\n");
@@ -1218,7 +1218,7 @@ static int ast_cursor_set(struct drm_crtc *crtc,
 				   false, &dst_isiomem, &ast->cache_kmap);
 	if (IS_ERR(dst)) {
 		ret = PTR_ERR(dst);
-		goto fail_unreserve;
+		goto fail_unlock;
 	}
 	if (dst_isiomem == false)
 		DRM_ERROR("dst bo should be in VRAM\n");
@@ -1229,7 +1229,7 @@ static int ast_cursor_set(struct drm_crtc *crtc,
 	csum = copy_cursor_image(src, dst, width, height);
 
 	drm_gem_vram_kunmap_at(gbo, &uobj_map);
-	drm_gem_vram_unreserve(gbo);
+	drm_gem_vram_unlock(gbo);
 
 	/* write checksum + signature */
 	{
@@ -1262,8 +1262,8 @@ static int ast_cursor_set(struct drm_crtc *crtc,
 	drm_gem_object_put_unlocked(obj);
 	return 0;
 
-fail_unreserve:
-	drm_gem_vram_unreserve(gbo);
+fail_unlock:
+	drm_gem_vram_unlock(gbo);
 fail:
 	drm_gem_object_put_unlocked(obj);
 	return ret;
diff --git a/drivers/gpu/drm/drm_gem_vram_helper.c b/drivers/gpu/drm/drm_gem_vram_helper.c
index b341b70832be..aefb0c361486 100644
--- a/drivers/gpu/drm/drm_gem_vram_helper.c
+++ b/drivers/gpu/drm/drm_gem_vram_helper.c
@@ -152,7 +152,7 @@ void drm_gem_vram_put(struct drm_gem_vram_object *gbo)
 EXPORT_SYMBOL(drm_gem_vram_put);
 
 /**
- * drm_gem_vram_reserve() - Reserves a VRAM-backed GEM object
+ * drm_gem_vram_lock() - Locks a VRAM-backed GEM object
  * @gbo:	the GEM VRAM object
  * @no_wait:	don't wait for buffer object to become available
  *
@@ -162,24 +162,24 @@ EXPORT_SYMBOL(drm_gem_vram_put);
  * 0 on success, or
  * a negative error code otherwise
  */
-int drm_gem_vram_reserve(struct drm_gem_vram_object *gbo, bool no_wait)
+int drm_gem_vram_lock(struct drm_gem_vram_object *gbo, bool no_wait)
 {
 	return ttm_bo_reserve(&gbo->bo, true, no_wait, NULL);
 }
-EXPORT_SYMBOL(drm_gem_vram_reserve);
+EXPORT_SYMBOL(drm_gem_vram_lock);
 
 /**
- * drm_gem_vram_unreserve() - \
-	Release a reservation acquired by drm_gem_vram_reserve()
+ * drm_gem_vram_unlock() - \
+	Release a reservation acquired by drm_gem_vram_lock()
  * @gbo:	the GEM VRAM object
  *
  * See ttm_bo_unreserve() for more information.
  */
-void drm_gem_vram_unreserve(struct drm_gem_vram_object *gbo)
+void drm_gem_vram_unlock(struct drm_gem_vram_object *gbo)
 {
 	ttm_bo_unreserve(&gbo->bo);
 }
-EXPORT_SYMBOL(drm_gem_vram_unreserve);
+EXPORT_SYMBOL(drm_gem_vram_unlock);
 
 /**
  * drm_gem_vram_mmap_offset() - Returns a GEM VRAM object's mmap offset
@@ -263,7 +263,7 @@ int drm_gem_vram_pin(struct drm_gem_vram_object *gbo, unsigned long pl_flag)
 EXPORT_SYMBOL(drm_gem_vram_pin);
 
 /**
- * drm_gem_vram_pin_reserved() - Pins a GEM VRAM object in a region.
+ * drm_gem_vram_pin_locked() - Pins a GEM VRAM object in a region.
  * @gbo:	the GEM VRAM object
  * @pl_flag:	a bitmask of possible memory regions
  *
@@ -272,14 +272,14 @@ EXPORT_SYMBOL(drm_gem_vram_pin);
  * it can be pinned to another region.
  *
  * This function pins a GEM VRAM object that has already been
- * reserved. Use drm_gem_vram_pin() if possible.
+ * locked. Use drm_gem_vram_pin() if possible.
  *
  * Returns:
  * 0 on success, or
  * a negative error code otherwise.
  */
-int drm_gem_vram_pin_reserved(struct drm_gem_vram_object *gbo,
-			      unsigned long pl_flag)
+int drm_gem_vram_pin_locked(struct drm_gem_vram_object *gbo,
+			    unsigned long pl_flag)
 {
 	int i, ret;
 	struct ttm_operation_ctx ctx = { false, false };
@@ -301,7 +301,7 @@ int drm_gem_vram_pin_reserved(struct drm_gem_vram_object *gbo,
 
 	return 0;
 }
-EXPORT_SYMBOL(drm_gem_vram_pin_reserved);
+EXPORT_SYMBOL(drm_gem_vram_pin_locked);
 
 /**
  * drm_gem_vram_unpin() - Unpins a GEM VRAM object
@@ -346,17 +346,17 @@ int drm_gem_vram_unpin(struct drm_gem_vram_object *gbo)
 EXPORT_SYMBOL(drm_gem_vram_unpin);
 
 /**
- * drm_gem_vram_unpin_reserved() - Unpins a GEM VRAM object
+ * drm_gem_vram_unpin_locked() - Unpins a GEM VRAM object
  * @gbo:	the GEM VRAM object
  *
  * This function unpins a GEM VRAM object that has already been
- * reserved. Use drm_gem_vram_unpin() if possible.
+ * locked. Use drm_gem_vram_unpin() if possible.
  *
  * Returns:
  * 0 on success, or
  * a negative error code otherwise.
  */
-int drm_gem_vram_unpin_reserved(struct drm_gem_vram_object *gbo)
+int drm_gem_vram_unpin_locked(struct drm_gem_vram_object *gbo)
 {
 	int i, ret;
 	struct ttm_operation_ctx ctx = { false, false };
@@ -377,7 +377,7 @@ int drm_gem_vram_unpin_reserved(struct drm_gem_vram_object *gbo)
 
 	return 0;
 }
-EXPORT_SYMBOL(drm_gem_vram_unpin_reserved);
+EXPORT_SYMBOL(drm_gem_vram_unpin_locked);
 
 /**
  * drm_gem_vram_kmap_at() - Maps a GEM VRAM object into kernel address space
diff --git a/drivers/gpu/drm/mgag200/mgag200_cursor.c b/drivers/gpu/drm/mgag200/mgag200_cursor.c
index 4b4a62a0cda7..de94a650077b 100644
--- a/drivers/gpu/drm/mgag200/mgag200_cursor.c
+++ b/drivers/gpu/drm/mgag200/mgag200_cursor.c
@@ -20,9 +20,9 @@ static void mga_hide_cursor(struct mga_device *mdev)
 	WREG8(MGA_CURPOSXL, 0);
 	WREG8(MGA_CURPOSXH, 0);
 	if (mdev->cursor.pixels_1->pin_count)
-		drm_gem_vram_unpin_reserved(mdev->cursor.pixels_1);
+		drm_gem_vram_unpin_locked(mdev->cursor.pixels_1);
 	if (mdev->cursor.pixels_2->pin_count)
-		drm_gem_vram_unpin_reserved(mdev->cursor.pixels_2);
+		drm_gem_vram_unpin_locked(mdev->cursor.pixels_2);
 }
 
 int mga_crtc_cursor_set(struct drm_crtc *crtc,
@@ -77,53 +77,53 @@ int mga_crtc_cursor_set(struct drm_crtc *crtc,
 	if (!obj)
 		return -ENOENT;
 
-	ret = drm_gem_vram_reserve(pixels_1, true);
+	ret = drm_gem_vram_lock(pixels_1, true);
 	if (ret) {
 		WREG8(MGA_CURPOSXL, 0);
 		WREG8(MGA_CURPOSXH, 0);
 		goto out_unref;
 	}
-	ret = drm_gem_vram_reserve(pixels_2, true);
+	ret = drm_gem_vram_lock(pixels_2, true);
 	if (ret) {
 		WREG8(MGA_CURPOSXL, 0);
 		WREG8(MGA_CURPOSXH, 0);
-		drm_gem_vram_unreserve(pixels_1);
-		goto out_unreserve1;
+		drm_gem_vram_unlock(pixels_1);
+		goto out_unlock1;
 	}
 
 	/* Move cursor buffers into VRAM if they aren't already */
 	if (!pixels_1->pin_count) {
-		ret = drm_gem_vram_pin_reserved(pixels_1,
-						DRM_GEM_VRAM_PL_FLAG_VRAM);
+		ret = drm_gem_vram_pin_locked(pixels_1,
+					      DRM_GEM_VRAM_PL_FLAG_VRAM);
 		if (ret)
 			goto out1;
 		gpu_addr = drm_gem_vram_offset(pixels_1);
 		if (gpu_addr < 0) {
-			drm_gem_vram_unpin_reserved(pixels_1);
+			drm_gem_vram_unpin_locked(pixels_1);
 			goto out1;
 		}
 		mdev->cursor.pixels_1_gpu_addr = gpu_addr;
 	}
 	if (!pixels_2->pin_count) {
-		ret = drm_gem_vram_pin_reserved(pixels_2,
-						DRM_GEM_VRAM_PL_FLAG_VRAM);
+		ret = drm_gem_vram_pin_locked(pixels_2,
+					      DRM_GEM_VRAM_PL_FLAG_VRAM);
 		if (ret) {
-			drm_gem_vram_unpin_reserved(pixels_1);
+			drm_gem_vram_unpin_locked(pixels_1);
 			goto out1;
 		}
 		gpu_addr = drm_gem_vram_offset(pixels_2);
 		if (gpu_addr < 0) {
-			drm_gem_vram_unpin_reserved(pixels_1);
-			drm_gem_vram_unpin_reserved(pixels_2);
+			drm_gem_vram_unpin_locked(pixels_1);
+			drm_gem_vram_unpin_locked(pixels_2);
 			goto out1;
 		}
 		mdev->cursor.pixels_2_gpu_addr = gpu_addr;
 	}
 
 	gbo = drm_gem_vram_of_gem(obj);
-	ret = drm_gem_vram_reserve(gbo, true);
+	ret = drm_gem_vram_lock(gbo, true);
 	if (ret) {
-		dev_err(&dev->pdev->dev, "failed to reserve user bo\n");
+		dev_err(&dev->pdev->dev, "failed to lock user bo\n");
 		goto out1;
 	}
 	src = drm_gem_vram_kmap(gbo, true, NULL);
@@ -247,13 +247,13 @@ int mga_crtc_cursor_set(struct drm_crtc *crtc,
  out3:
 	drm_gem_vram_kunmap(gbo);
  out2:
-	drm_gem_vram_unreserve(gbo);
+	drm_gem_vram_unlock(gbo);
  out1:
 	if (ret)
 		mga_hide_cursor(mdev);
-	drm_gem_vram_unreserve(pixels_1);
-out_unreserve1:
-	drm_gem_vram_unreserve(pixels_2);
+	drm_gem_vram_unlock(pixels_1);
+out_unlock1:
+	drm_gem_vram_unlock(pixels_2);
 out_unref:
 	drm_gem_object_put_unlocked(obj);
 
diff --git a/drivers/gpu/drm/mgag200/mgag200_fb.c b/drivers/gpu/drm/mgag200/mgag200_fb.c
index 6eaaf69d4d66..37e8b8cf37ea 100644
--- a/drivers/gpu/drm/mgag200/mgag200_fb.c
+++ b/drivers/gpu/drm/mgag200/mgag200_fb.c
@@ -33,13 +33,12 @@ static void mga_dirty_update(struct mga_fbdev *mfbdev,
 	obj = mfbdev->mfb.obj;
 	gbo = drm_gem_vram_of_gem(obj);
 
-	/*
-	 * try and reserve the BO, if we fail with busy
-	 * then the BO is being moved and we should
-	 * store up the damage until later.
+	/* Try to lock the BO. If we fail with -EBUSY then
+	 * the BO is being moved and we should store up the
+	 * damage until later.
 	 */
 	if (drm_can_sleep())
-		ret = drm_gem_vram_reserve(gbo, true);
+		ret = drm_gem_vram_lock(gbo, true);
 	if (ret) {
 		if (ret != -EBUSY)
 			return;
@@ -98,7 +97,7 @@ static void mga_dirty_update(struct mga_fbdev *mfbdev,
 		drm_gem_vram_kunmap(gbo);
 
 out:
-	drm_gem_vram_unreserve(gbo);
+	drm_gem_vram_unlock(gbo);
 }
 
 static void mga_fillrect(struct fb_info *info,
diff --git a/include/drm/drm_gem_vram_helper.h b/include/drm/drm_gem_vram_helper.h
index 22e52d7dfbb7..4d1d2c1bf32b 100644
--- a/include/drm/drm_gem_vram_helper.h
+++ b/include/drm/drm_gem_vram_helper.h
@@ -77,15 +77,15 @@ struct drm_gem_vram_object *drm_gem_vram_create(struct drm_device *dev,
 						unsigned long pg_align,
 						bool interruptible);
 void drm_gem_vram_put(struct drm_gem_vram_object *gbo);
-int drm_gem_vram_reserve(struct drm_gem_vram_object *gbo, bool no_wait);
-void drm_gem_vram_unreserve(struct drm_gem_vram_object *gbo);
+int drm_gem_vram_lock(struct drm_gem_vram_object *gbo, bool no_wait);
+void drm_gem_vram_unlock(struct drm_gem_vram_object *gbo);
 u64 drm_gem_vram_mmap_offset(struct drm_gem_vram_object *gbo);
 s64 drm_gem_vram_offset(struct drm_gem_vram_object *gbo);
 int drm_gem_vram_pin(struct drm_gem_vram_object *gbo, unsigned long pl_flag);
-int drm_gem_vram_pin_reserved(struct drm_gem_vram_object *gbo,
+int drm_gem_vram_pin_locked(struct drm_gem_vram_object *gbo,
 			      unsigned long pl_flag);
 int drm_gem_vram_unpin(struct drm_gem_vram_object *gbo);
-int drm_gem_vram_unpin_reserved(struct drm_gem_vram_object *gbo);
+int drm_gem_vram_unpin_locked(struct drm_gem_vram_object *gbo);
 void *drm_gem_vram_kmap_at(struct drm_gem_vram_object *gbo, bool map,
 			   bool *is_iomem, struct ttm_bo_kmap_obj *kmap);
 void *drm_gem_vram_kmap(struct drm_gem_vram_object *gbo, bool map,
-- 
2.17.1

