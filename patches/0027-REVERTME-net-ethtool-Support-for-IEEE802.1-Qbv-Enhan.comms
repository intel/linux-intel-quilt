From 2529f0f1ade559e726fe5ca60f96761c8efb65a7 Mon Sep 17 00:00:00 2001
From: Ong Boon Leong <boon.leong.ong@intel.com>
Date: Tue, 3 Jul 2018 02:01:46 +0800
Subject: [PATCH 27/58] REVERTME: net: ethtool: Support for IEEE802.1 Qbv
 Enhancements for Scheduled Traffics

This patch is kept here for IP validation purpose. It will be dropped
once Linux mainline traffic-control TSN framework has matured.

IEEE802.1 Qbv Enhancements for Scheduled Traffics (EST) defines the
technology in Ethernet MAC controller to control the state (open, close)
of Tx queues for a period of time (time interval). The series of such
control operations are defined in Gate Control List (GCL). If a Tx queue
or gate is open, Ethernet frames from such Tx queue are available for Tx
selection. A new copy GCL from Admin that is transferred to HW
(Operational) is started at base time and repeated there after at every
integral multiple of cycle time. Cycle time extension may be used to
extend the time of the last GCL operation before a new GCL is executed by
MAC.

Hardware IP may or may not have capability to DMA transfer the entire GCL
in one shot. Certain IP may offer users to read/write GCL on entry at a
time. It is with this reason, we design the ethtool interface for GCL
programming, set_est_gcl() and get_est_gcl() to be generic here so that
respective driver can handle read/write operation according to its
hardware capability.

We add the depth of GCL to drvinfo so that user may check it by
using ethtool -i.

Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
---
 include/linux/ethtool.h      |  21 +++++
 include/uapi/linux/ethtool.h | 114 ++++++++++++++++++++++
 net/core/ethtool.c           | 219 +++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 354 insertions(+)

diff --git a/include/linux/ethtool.h b/include/linux/ethtool.h
index f8a2245..9eb68f9 100644
--- a/include/linux/ethtool.h
+++ b/include/linux/ethtool.h
@@ -315,6 +315,15 @@ bool ethtool_convert_link_mode_to_legacy_u32(u32 *legacy_u32,
  * @get_ethtool_phy_stats: Return extended statistics about the PHY device.
  *	This is only useful if the device maintains PHY statistics and
  *	cannot use the standard PHY library helpers.
+ * @get_est_gcl_depth: Get the length of GCL.
+ * @get_est_gcl_length: Get the maximum length(depth) of GCL.
+ * @get_est_gcl: Get the entire GCL.
+ * @set_est_gcl: Set the entire GCL.
+ * @get_est_gce: Get a gate control entry.
+ * @set_est_gce: Set a gate control entry.
+ * @get_est_info: Get IEEE802.1 Qbv EST info, e.g. base time, cycle time
+ *	& cycle time extension.
+ * @set_est_info: Set IEEE802.1 Qbv EST info.
  *
  * All operations are optional (i.e. the function pointer may be set
  * to %NULL) and callers must take this into account.  Callers must
@@ -412,5 +421,17 @@ struct ethtool_ops {
 				      struct ethtool_fecparam *);
 	void	(*get_ethtool_phy_stats)(struct net_device *,
 					 struct ethtool_stats *, u64 *);
+	int	(*get_est_gcl_depth)(struct net_device *);
+	int	(*get_est_gcl_length)(struct net_device *, int);
+	int	(*get_est_gcl)(struct net_device *,
+			       struct ethtool_gcl *, void *);
+	int	(*set_est_gcl)(struct net_device *,
+			       struct ethtool_gcl *, void *);
+	int	(*get_est_gce)(struct net_device *, struct ethtool_gce *);
+	int	(*set_est_gce)(struct net_device *, struct ethtool_gce *);
+	int	(*get_est_info)(struct net_device *,
+				struct ethtool_est_info *);
+	int	(*set_est_info)(struct net_device *,
+				struct ethtool_est_info *);
 };
 #endif /* _LINUX_ETHTOOL_H */
diff --git a/include/uapi/linux/ethtool.h b/include/uapi/linux/ethtool.h
index 7363f18..077b3e6 100644
--- a/include/uapi/linux/ethtool.h
+++ b/include/uapi/linux/ethtool.h
@@ -170,6 +170,7 @@ static inline __u32 ethtool_cmd_speed(const struct ethtool_cmd *ep)
  *	and %ETHTOOL_SEEPROM commands, in bytes
  * @regdump_len: Size of register dump returned by the %ETHTOOL_GREGS
  *	command, in bytes
+ * @gcl_depth: Maximum length/depth of (IEEE802.1 Qbv) Gate Control List
  *
  * Users can use the %ETHTOOL_GSSET_INFO command to get the number of
  * strings in any string set (from Linux 2.6.34).
@@ -191,6 +192,7 @@ struct ethtool_drvinfo {
 	__u32	testinfo_len;
 	__u32	eedump_len;
 	__u32	regdump_len;
+	__u32	gcl_depth;
 };
 
 #define SOPASS_MAX	6
@@ -1302,6 +1304,110 @@ enum ethtool_fec_config_bits {
 #define ETHTOOL_FEC_RS			(1 << ETHTOOL_FEC_RS_BIT)
 #define ETHTOOL_FEC_BASER		(1 << ETHTOOL_FEC_BASER_BIT)
 
+/*
+ * enum ethtool_gate_op - gate operation ID
+ * @ETH_GATEOP_SET_GATE_STATES: Set gate states only.
+ */
+enum ethtool_gate_op {
+	ETH_GATEOP_SET_GATE_STATES	= 0,
+};
+
+/**
+ * struct ethtool_gc_entry - basic gate control entity
+ * @opid: gate operation ID %ethtool_gate_op
+ * @gates: gate states
+ *         0 : Closed.
+ *         1 : Open.
+ *         Where least significant bit represents traffic class-0.
+ *         So, 0x31 means TC5, TC4 & TC0 are open.
+ * @ti_ns: time interval of GC entry in nano-seconds.
+ */
+struct ethtool_gc_entry {
+	__u8	opid;
+	__u8	gates;
+	__u8	reserved[2];
+	__u32	ti_ns;
+};
+
+/**
+ * struct ethtool_gce - Gate Control Entry.
+ * @cmd: Command number - %ETHTOOL_{G,S}GCE.
+ * @own: Ownership of GC entry.
+ *        0: Operational.
+ *        1: Admin.
+ *        Note: Operational means the configuration is owned by hardware.
+ * @row: On entry, this field specifies which row in GCL read or written.
+ * @gce: gate control entry read or write.
+ */
+struct ethtool_gce {
+	__u32	cmd;
+	__u32	own;
+	__u32	row;
+	struct ethtool_gc_entry gce;
+};
+
+/**
+ * struct ethtool_gcl - Gate Control List.
+ * @cmd: Command number - %ETHTOOL_{G,S}GCL.
+ * @own: Ownership of GCL.
+ *        0: Operational.
+ *        1: Admin.
+ *        Note: Operational means the configuration is owned by hardware.
+ * @len: For %ETHTOOL_SGC{E,L}, on entry, this specifies the length
+ *       of GC entries list to write. In success return, this field
+ *       specifies the length of GCL read or written.
+ *       On fail return, this field should be ignored by caller.
+ * @gcl: Array that contains GC read or written.
+ */
+struct ethtool_gcl {
+	__u32	cmd;
+	__u32	own;
+	__u32	len;
+	struct ethtool_gc_entry gcl[0];
+};
+
+/**
+ * struct ethtool_lgcl - Length of GCL.
+ * @cmd: Command number - %ETHTOOL_GLGCL.
+ * @own: Ownership of GCL.
+ *        0: Operational.
+ *        1: Admin.
+ *        Note: Operational means the configuration is owned by hardware.
+ * @len: In success return, this field specifies the length of GCL to read.
+ *       On fail return, this field should be ignored by caller.
+ */
+struct ethtool_lgcl {
+	__u32	cmd;
+	__u32	own;
+	__u32	len;
+};
+
+/**
+ * struct ethtool_est_info - configuring IEEE802.1 Qbv Enhancements for
+ * Scheduled Traffic (EST).
+ * @cmd: Command number - %ETHTOOL_{G,S}ESTINFO.
+ * @own: Ownership of EST info.
+ *        0: Operational.
+ *        1: Admin.
+ *        Note: Operational means the configuration owned by hardware.
+ * @cycle_s: Numerator of cycle time in seconds.
+ * @cycle_ns: Denominator of cycle time in nano-seconds.
+ * @extension_s: Numerator of cycle time extension in seconds.
+ * @extension_ns: Denominator of cycle time extension in nano-seconds.
+ * @base_s: Numerator of base time in seconds.
+ * @base_ns: Denominator of base time in nano-seconds.
+ */
+struct ethtool_est_info {
+	__u32	cmd;
+	__u32	own;
+	__u32	cycle_s;
+	__u32	cycle_ns;
+	__u32	extension_s;
+	__u32	extension_ns;
+	__u32	base_s;
+	__u32	base_ns;
+};
+
 /* CMDs currently supported */
 #define ETHTOOL_GSET		0x00000001 /* DEPRECATED, Get settings.
 					    * Please use ETHTOOL_GLINKSETTINGS
@@ -1397,6 +1503,14 @@ enum ethtool_fec_config_bits {
 #define ETHTOOL_GFECPARAM	0x00000050 /* Get FEC settings */
 #define ETHTOOL_SFECPARAM	0x00000051 /* Set FEC settings */
 
+#define ETHTOOL_GLGCL		0x00000052 /* Get Length of EST GCL */
+#define ETHTOOL_GGCL		0x00000053 /* Get EST Gate Control List */
+#define ETHTOOL_SGCL		0x00000054 /* Set EST Gate Control List */
+#define ETHTOOL_GGCE		0x00000055 /* Get EST Gate Control Entry */
+#define ETHTOOL_SGCE		0x00000056 /* Set EST Gate Control Entry */
+#define ETHTOOL_GESTINFO	0x00000057 /* Get EST Info */
+#define ETHTOOL_SESTINFO	0x00000058 /* Set EST Info */
+
 /* compatibility with older code */
 #define SPARC_ETH_GSET		ETHTOOL_GSET
 #define SPARC_ETH_SSET		ETHTOOL_SSET
diff --git a/net/core/ethtool.c b/net/core/ethtool.c
index 2216de2..9593a13 100644
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@ -885,6 +885,8 @@ static noinline_for_stack int ethtool_get_drvinfo(struct net_device *dev,
 		info.regdump_len = ops->get_regs_len(dev);
 	if (ops->get_eeprom_len)
 		info.eedump_len = ops->get_eeprom_len(dev);
+	if (ops->get_est_gcl_depth)
+		info.gcl_depth = ops->get_est_gcl_depth(dev);
 
 	if (copy_to_user(useraddr, &info, sizeof(info)))
 		return -EFAULT;
@@ -2585,6 +2587,198 @@ static int ethtool_set_fecparam(struct net_device *dev, void __user *useraddr)
 	return dev->ethtool_ops->set_fecparam(dev, &fecparam);
 }
 
+static int ethtool_get_lgcl(struct net_device *dev, void __user *useraddr)
+{
+	struct ethtool_lgcl lgcl;
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+
+	if (!ops->get_est_gcl_length)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&lgcl, useraddr, sizeof(lgcl)))
+		return -EFAULT;
+
+	lgcl.len = ops->get_est_gcl_length(dev, lgcl.own);
+
+	if (!lgcl.len)
+		return -EINVAL;
+
+	if (copy_to_user(useraddr, &lgcl, sizeof(lgcl)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int ethtool_get_gcl(struct net_device *dev, void __user *useraddr)
+{
+	int ret;
+	void *gclbuf;
+	struct ethtool_gcl gcl;
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+
+	if (!ops->get_est_gcl || !ops->get_est_gcl_length)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&gcl, useraddr, sizeof(gcl)))
+		return -EFAULT;
+
+	gcl.len = ops->get_est_gcl_length(dev, gcl.own);
+
+	if (!gcl.len)
+		return -EINVAL;
+
+	gclbuf = vzalloc(gcl.len * sizeof(struct ethtool_gc_entry));
+	if (!gclbuf)
+		return -ENOMEM;
+
+	ret = ops->get_est_gcl(dev, &gcl, gclbuf);
+	if (ret)
+		goto out;
+
+	ret = -EFAULT;
+	if (copy_to_user(useraddr, &gcl, sizeof(gcl)))
+		goto out;
+
+	useraddr += offsetof(struct ethtool_gcl, gcl);
+
+	if (gclbuf && copy_to_user(useraddr, gclbuf,
+				   (gcl.len * sizeof(struct ethtool_gc_entry))))
+		goto out;
+
+	ret = 0;
+
+out:
+	vfree(gclbuf);
+	return ret;
+}
+
+static int ethtool_set_gcl(struct net_device *dev, void __user *useraddr)
+{
+	int ret;
+	u32 depth;
+	void *gclbuf;
+	struct ethtool_gcl gcl;
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+
+	if (!ops->set_est_gcl || !ops->get_est_gcl_depth)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&gcl, useraddr, sizeof(gcl)))
+		return -EFAULT;
+
+	depth = ops->get_est_gcl_depth(dev);
+
+	if (!gcl.len || gcl.len > depth) {
+		pr_warn("GCL: length exceeds depth(%u) ", depth);
+		return -EINVAL;
+	}
+
+	gclbuf = vzalloc(gcl.len * sizeof(struct ethtool_gc_entry));
+	if (!gclbuf)
+		return -ENOMEM;
+
+	useraddr += offsetof(struct ethtool_gcl, gcl);
+	ret = -EFAULT;
+
+	if (copy_from_user(gclbuf, useraddr,
+			   (gcl.len * sizeof(struct ethtool_gc_entry))))
+		goto out;
+
+	ret = ops->set_est_gcl(dev, &gcl, gclbuf);
+
+out:
+	vfree(gclbuf);
+	return ret;
+}
+
+static int ethtool_get_gce(struct net_device *dev, void __user *useraddr)
+{
+	int ret;
+	int length;
+	struct ethtool_gce gce;
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+
+	if (!ops->get_est_gce || !ops->get_est_gcl_length)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&gce, useraddr, sizeof(gce)))
+		return -EFAULT;
+
+	length = ops->get_est_gcl_length(dev, gce.own);
+
+	if (!length || gce.row >= length) {
+		pr_warn("GCE: row exceeds length(%u) ", length);
+		return -EINVAL;
+	}
+
+	ret = ops->get_est_gce(dev, &gce);
+	if (ret)
+		return -EFAULT;
+
+	if (copy_to_user(useraddr, &gce, sizeof(gce)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int ethtool_set_gce(struct net_device *dev, void __user *useraddr)
+{
+	int depth;
+	struct ethtool_gce gce;
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+
+	if (!ops->set_est_gce || !ops->get_est_gcl_depth)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&gce, useraddr, sizeof(gce)))
+		return -EFAULT;
+
+	depth = ops->get_est_gcl_depth(dev);
+
+	if (gce.row >= depth) {
+		pr_warn("GCE: row exceeds depth(%u) ", depth);
+		return -EINVAL;
+	}
+
+	return ops->set_est_gce(dev, &gce);
+}
+
+static int ethtool_get_est_info(struct net_device *dev, void __user *useraddr)
+{
+	int ret;
+	struct ethtool_est_info est_info;
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+
+	if (!ops->get_est_info)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&est_info, useraddr, sizeof(est_info)))
+		return -EFAULT;
+
+	ret = ops->get_est_info(dev, &est_info);
+	if (ret)
+		return ret;
+
+	if (copy_to_user(useraddr, &est_info, sizeof(est_info)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int ethtool_set_est_info(struct net_device *dev, void __user *useraddr)
+{
+	struct ethtool_est_info est_info;
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+
+	if (!ops->set_est_info)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&est_info, useraddr, sizeof(est_info)))
+		return -EFAULT;
+
+	return ops->set_est_info(dev, &est_info);
+}
+
 /* The main entry point in this file.  Called from net/core/dev_ioctl.c */
 
 int dev_ethtool(struct net *net, struct ifreq *ifr)
@@ -2644,6 +2838,10 @@ int dev_ethtool(struct net *net, struct ifreq *ifr)
 	case ETHTOOL_PHY_GTUNABLE:
 	case ETHTOOL_GLINKSETTINGS:
 	case ETHTOOL_GFECPARAM:
+	case ETHTOOL_GLGCL:
+	case ETHTOOL_GGCL:
+	case ETHTOOL_GGCE:
+	case ETHTOOL_GESTINFO:
 		break;
 	default:
 		if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
@@ -2859,6 +3057,27 @@ int dev_ethtool(struct net *net, struct ifreq *ifr)
 	case ETHTOOL_SFECPARAM:
 		rc = ethtool_set_fecparam(dev, useraddr);
 		break;
+	case ETHTOOL_GLGCL:
+		rc = ethtool_get_lgcl(dev, useraddr);
+		break;
+	case ETHTOOL_GGCL:
+		rc = ethtool_get_gcl(dev, useraddr);
+		break;
+	case ETHTOOL_SGCL:
+		rc = ethtool_set_gcl(dev, useraddr);
+		break;
+	case ETHTOOL_GGCE:
+		rc = ethtool_get_gce(dev, useraddr);
+		break;
+	case ETHTOOL_SGCE:
+		rc = ethtool_set_gce(dev, useraddr);
+		break;
+	case ETHTOOL_GESTINFO:
+		rc = ethtool_get_est_info(dev, useraddr);
+		break;
+	case ETHTOOL_SESTINFO:
+		rc = ethtool_set_est_info(dev, useraddr);
+		break;
 	default:
 		rc = -EOPNOTSUPP;
 	}
-- 
2.7.4

