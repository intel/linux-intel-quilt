From 161341d9863ba89b7115ce1eda567c0f2ca6eea3 Mon Sep 17 00:00:00 2001
From: YuanXin <xin.yuan@intel.com>
Date: Wed, 19 Feb 2025 14:17:04 +0800
Subject: [PATCH 06/20] Add hypercall to access MSR

Add hypercall to access MSR

Signed-off-by: YuanXin <xin.yuan@intel.com>
---
 drivers/virt/acrn/hsm.c       | 28 +++++++++++++++++++++++++++-
 drivers/virt/acrn/hypercall.h | 13 +++++++++++++
 include/uapi/linux/acrn.h     | 29 +++++++++++++++++++++++++++++
 3 files changed, 69 insertions(+), 1 deletion(-)

diff --git a/drivers/virt/acrn/hsm.c b/drivers/virt/acrn/hsm.c
index d924f0911a92..687abe82d268 100644
--- a/drivers/virt/acrn/hsm.c
+++ b/drivers/virt/acrn/hsm.c
@@ -116,6 +116,8 @@ static long acrn_dev_ioctl(struct file *filp, unsigned int cmd,
 	struct acrn_vm_memmap memmap;
 	struct acrn_mmiodev *mmiodev;
 	struct acrn_piodev *piodev;
+	struct acrn_msrlist *msrlist;
+	struct acrn_msrentry *msrentry;
 	struct acrn_msi_entry *msi;
 	struct acrn_pcidev *pcidev;
 	struct acrn_irqfd irqfd;
@@ -124,12 +126,14 @@ static long acrn_dev_ioctl(struct file *filp, unsigned int cmd,
 	u64 cstate_cmd;
 	int i, ret = 0;
 
-	if (vm->vmid == ACRN_INVALID_VMID && cmd != ACRN_IOCTL_CREATE_VM) {
+	if (vm->vmid == ACRN_INVALID_VMID && cmd != ACRN_IOCTL_CREATE_VM &&
+			cmd != ACRN_IOCTL_MSR_ACCESS) {
 		dev_dbg(acrn_dev.this_device,
 			"ioctl 0x%x: Invalid VM state!\n", cmd);
 		return -EINVAL;
 	}
 
+
 	switch (cmd) {
 	case ACRN_IOCTL_CREATE_VM:
 		vm_param = memdup_user((void __user *)ioctl_param,
@@ -349,6 +353,28 @@ static long acrn_dev_ioctl(struct file *filp, unsigned int cmd,
 				"Failed to deassign PIO resource!\n");
 		kfree(piodev);
 		break;
+	case ACRN_IOCTL_MSR_ACCESS:
+		msrlist = memdup_user((void __user *)ioctl_param,
+				       sizeof(struct acrn_msrlist));
+		if (IS_ERR(msrlist))
+			return PTR_ERR(msrlist);
+
+		msrentry = memdup_user((void __user *)msrlist->entry_addr,
+				msrlist->entry_num*sizeof(struct acrn_msrentry));
+		if (IS_ERR(msrentry))
+			return PTR_ERR(msrentry);
+
+		ret = hcall_msr_access(msrlist->entry_num, virt_to_phys(msrentry));
+		if (ret < 0)
+			dev_dbg(acrn_dev.this_device,
+				"Failed to read MSR register!\n");
+		else
+			ret = __copy_to_user((void __user *)msrlist->entry_addr, msrentry,
+					msrlist->entry_num*sizeof(struct acrn_msrentry));
+
+		kfree(msrentry);
+		kfree(msrlist);
+		break;
 	case ACRN_IOCTL_SET_IRQLINE:
 		ret = hcall_set_irqline(vm->vmid, ioctl_param);
 		if (ret < 0)
diff --git a/drivers/virt/acrn/hypercall.h b/drivers/virt/acrn/hypercall.h
index 224eca709506..238c59651050 100644
--- a/drivers/virt/acrn/hypercall.h
+++ b/drivers/virt/acrn/hypercall.h
@@ -47,6 +47,7 @@
 #define HC_DESTROY_VDEV			_HC_ID(HC_ID, HC_ID_PCI_BASE + 0x0A)
 #define HC_ASSIGN_PIODEV		_HC_ID(HC_ID, HC_ID_PCI_BASE + 0x0B)
 #define HC_DEASSIGN_PIODEV		_HC_ID(HC_ID, HC_ID_PCI_BASE + 0x0C)
+#define HC_MSR_ACCESS			_HC_ID(HC_ID, HC_ID_PCI_BASE + 0x0D)
 
 #define HC_ID_PM_BASE			0x80UL
 #define HC_PM_GET_CPU_STATE		_HC_ID(HC_ID, HC_ID_PM_BASE + 0x00)
@@ -320,6 +321,18 @@ static inline long hcall_deassign_piodev(u64 vmid, u64 addr)
 	return acrn_hypercall2(HC_DEASSIGN_PIODEV, vmid, addr);
 }
 
+/**
+ * hcall_msr_access() - Access single/multiple MSR registers through hypervisor
+ * @entry_num   The number of MSR registers to be accessed
+ * @entry_addr	The address of data structure of entry list
+ *
+ * Return: 0 on success, <0 on failure
+ */
+static inline long hcall_msr_access(u64 entry_num, u64 entry_addr)
+{
+	return acrn_hypercall2(HC_MSR_ACCESS, entry_num, entry_addr);
+}
+
 /*
  * hcall_get_cpu_state() - Get P-states and C-states info from the hypervisor
  * @state:	Service VM GPA of buffer of P-states and C-states
diff --git a/include/uapi/linux/acrn.h b/include/uapi/linux/acrn.h
index b1646fed657c..4dfa6576040e 100644
--- a/include/uapi/linux/acrn.h
+++ b/include/uapi/linux/acrn.h
@@ -456,6 +456,33 @@ struct acrn_piodev {
 	} res;
 };
 
+/**
+ * struct acrn_msrlist - Info for msr access structure
+ * @entry_num:			Number of entry in structure.
+ * @entry_addr:			Physical address of MSR entry structure
+ *
+ * This structure will not be passed to hypervisor directly.
+ */
+struct acrn_msrlist {
+	__u32   entry_num;
+	__u32   reserved;
+	__u64   entry_addr;
+};
+
+/**
+ * struct acrn_msrentry - Info for msr access entry
+ * @lapic_id:			Lapic id of msr to access
+ * @msr_addr:			Msr address to access
+ * @val:			Msr value
+ *
+ * This structure will not be passed to hypervisor directly.
+ */
+struct acrn_msrentry {
+	__u32 lapic_id;
+	__u32 msr_addr;
+	__u64 val;
+};
+
 /**
  * struct acrn_vdev - Info for creating or destroying a virtual device
  * @id:				Union of identifier of the virtual device
@@ -657,6 +684,8 @@ struct acrn_irqfd {
 	_IOW(ACRN_IOCTL_TYPE, 0x5B, struct acrn_piodev)
 #define ACRN_IOCTL_DEASSIGN_PIODEV	\
 	_IOW(ACRN_IOCTL_TYPE, 0x5C, struct acrn_piodev)
+#define ACRN_IOCTL_MSR_ACCESS		\
+	_IOWR(ACRN_IOCTL_TYPE, 0x5D, struct acrn_msrlist)
 
 #define ACRN_IOCTL_PM_GET_CPU_STATE	\
 	_IOWR(ACRN_IOCTL_TYPE, 0x60, __u64)
-- 
2.34.1

