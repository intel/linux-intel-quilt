From 152248d5a4f8e399930e82b18c59adc1393c6102 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Tue, 18 Feb 2025 22:58:49 +0200
Subject: [PATCH 1010/1107] drm/i915/dsb: Allow DSB based commits when scalers
 are in use
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Have DSB perform plane scaler programming as well. Changes
to pfit/pipe scaler are not being done on the dsb since those
take the fastset path. However we do now allow DSB based plane
updates when the pfit/pipe scaler is currently enabled (the
pfit/pipe scaler just won't be touched by the DSB).

Fortunately the hardware issue where some scaler registers
are latched at frame start and some at start of vblank has
been fixed on icl+ (IIRC), and since DSB is tgl+ only we
don't have to do any changes to the DSB vblank evasion.
Not that we handle that hardware issue correctly in the
CPU vblank evasion either...

Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20250218205850.1422-4-ville.syrjala@linux.intel.com
Reviewed-by: Uma Shankar <uma.shakar@intel.com>
---
 drivers/gpu/drm/i915/display/intel_display.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_display.c b/drivers/gpu/drm/i915/display/intel_display.c
index 27b9ffd4e87b..0966d5f26b36 100644
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@ -7144,8 +7144,6 @@ static void intel_atomic_dsb_prepare(struct intel_atomic_state *state,
 				     struct intel_crtc *crtc)
 {
 	struct intel_display *display = to_intel_display(state);
-	const struct intel_crtc_state *old_crtc_state =
-		intel_atomic_get_old_crtc_state(state, crtc);
 	struct intel_crtc_state *new_crtc_state =
 		intel_atomic_get_new_crtc_state(state, crtc);
 
@@ -7159,8 +7157,6 @@ static void intel_atomic_dsb_prepare(struct intel_atomic_state *state,
 	new_crtc_state->use_dsb =
 		!new_crtc_state->do_async_flip &&
 		(DISPLAY_VER(display) >= 20 || !new_crtc_state->has_psr) &&
-		!new_crtc_state->scaler_state.scaler_users &&
-		!old_crtc_state->scaler_state.scaler_users &&
 		!intel_crtc_needs_modeset(new_crtc_state) &&
 		!intel_crtc_needs_fastset(new_crtc_state);
 
@@ -7170,6 +7166,7 @@ static void intel_atomic_dsb_prepare(struct intel_atomic_state *state,
 static void intel_atomic_dsb_finish(struct intel_atomic_state *state,
 				    struct intel_crtc *crtc)
 {
+	struct intel_display *display = to_intel_display(state);
 	struct intel_crtc_state *new_crtc_state =
 		intel_atomic_get_new_crtc_state(state, crtc);
 
@@ -7216,6 +7213,10 @@ static void intel_atomic_dsb_finish(struct intel_atomic_state *state,
 		intel_crtc_planes_update_arm(new_crtc_state->dsb_commit,
 					     state, crtc);
 
+		if (DISPLAY_VER(display) >= 9)
+			skl_detach_scalers(new_crtc_state->dsb_commit,
+					   new_crtc_state);
+
 		if (!new_crtc_state->dsb_color_vblank) {
 			intel_dsb_wait_vblanks(new_crtc_state->dsb_commit, 1);
 
-- 
2.25.1

