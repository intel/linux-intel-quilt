From 66c1997644d3482cd7761dabf4e1d26b426cf822 Mon Sep 17 00:00:00 2001
From: "Song, Yoong Siang" <yoong.siang.song@intel.com>
Date: Thu, 12 Mar 2020 19:19:23 +0800
Subject: [PATCH 4/9] net: stmmac: move a2h packet copying function out from
 proxy isr

napi_gro_receive() should not be used inside interrupt service routine.
Therefore, use request_threaded_irq() to create another thread to
handle a2h packet copying function and driver resume function.

Signed-off-by: Song, Yoong Siang <yoong.siang.song@intel.com>
---
 drivers/net/ethernet/stmicro/stmmac/stmmac.h  |  1 -
 .../net/ethernet/stmicro/stmmac/stmmac_main.c |  7 ++-
 .../ethernet/stmicro/stmmac/stmmac_netproxy.c | 56 +++++++++----------
 .../ethernet/stmicro/stmmac/stmmac_netproxy.h |  3 +-
 4 files changed, 33 insertions(+), 34 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index 5e16e4cf77da..5928c83c00e5 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -280,7 +280,6 @@ struct stmmac_priv {
 #ifdef CONFIG_STMMAC_NETWORK_PROXY
 	/* Network Proxy A2H Worker */
 	struct workqueue_struct *netprox_wq;
-	struct work_struct netprox_task;
 	bool networkproxy_exit;
 #endif
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index dda8c11660ea..08988b2606b1 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -3335,9 +3335,10 @@ static int stmmac_request_irq(struct net_device *dev)
 		if (priv->netprox_irq > 0 && priv->netprox_irq != dev->irq) {
 			int_name = priv->int_name_netprox_irq;
 			sprintf(int_name, "%s:%s", dev->name, "netprox");
-			ret = request_irq(priv->netprox_irq,
-					  netproxy_irq,
-					  0, int_name, dev);
+			ret = request_threaded_irq(priv->netprox_irq,
+						   netproxy_isr,
+						   netproxy_isr_thread, 0,
+						   int_name, dev);
 			if (unlikely(ret < 0)) {
 				netdev_err(priv->dev,
 					   "%s: alloc netprox MSI %d (error: %d)\n",
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.c
index 558ed1f7f21f..38a781771f0c 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.c
@@ -29,37 +29,39 @@
 static struct np_netdev np_netdev = { 0 };
 static struct np_shm np_shm = { NULL };
 
-/**
- * netprox_resume_task - stmmac network proxy resume task
- * @work: work item to retrieve stmmac_priv
- * Description: Add task to resume stmmac Ethernet driver.
+/*  netproxy_isr - Network Proxy interrupt service routine
+ *  @irq: interrupt number.
+ *  @dev_id: to pass the net device pointer.
+ *  Description: ISR to service Network Proxy interrupt.
  */
-static void netprox_resume_task(struct work_struct *work)
+irqreturn_t netproxy_isr(int irq, void *dev_id)
 {
-	struct stmmac_priv *priv = container_of(work, struct stmmac_priv,
-						netprox_task);
-	struct net_device *ndev = priv->dev;
+	struct net_device *ndev = (struct net_device *)dev_id;
+	struct stmmac_priv *priv = netdev_priv(ndev);
+	u32 value;
 
-	priv->networkproxy_exit = 1;
-	stmmac_resume_common(priv, ndev);
-	priv->networkproxy_exit = 0;
+	value = readl(priv->ioaddr + GBE_PROXYMODE_EXIT_STS_REG);
+	writel(value, priv->ioaddr + GBE_PROXYMODE_EXIT_STS_REG);
 
-	if (ndev->phydev)
-		phy_start_machine(ndev->phydev);
+	if (!netif_running(ndev)) {
+		netdev_err(priv->dev,
+			   "Netprox exit failed: netdev is not running\n");
+		return IRQ_HANDLED;
+	}
 
-	netif_device_attach(ndev);
+	return IRQ_WAKE_THREAD;
 }
 
 #define EHL_PSE_ETH_DMA_MISC_OFFSET		0x10000
 #define EHL_PSE_ETH_DMA_MISC_DTM_DRAM		3
 #define EHL_PSE_ETH_DMA_TOTAL_CH		16
 
-/*  netproxy_irq - Network Proxy interrupt handling
+/*  netproxy_isr_thread - Network Proxy ISR thread
  *  @irq: interrupt number.
  *  @dev_id: to pass the net device pointer.
- *  Description: ISR to service Network Proxy interrupt.
+ *  Description: Thread to service Network Proxy interrupt.
  */
-irqreturn_t netproxy_irq(int irq, void *dev_id)
+irqreturn_t netproxy_isr_thread(int irq, void *dev_id)
 {
 	struct net_device *ndev = (struct net_device *)dev_id;
 	struct stmmac_priv *priv = netdev_priv(ndev);
@@ -74,15 +76,6 @@ irqreturn_t netproxy_irq(int irq, void *dev_id)
 	void __iomem *a2h_mem_ptr = priv->ioaddr + NETWORK_PROXY_SHMEM_OFFSET;
 	u32 value;
 
-	value = readl(priv->ioaddr + GBE_PROXYMODE_EXIT_STS_REG);
-	writel(value, priv->ioaddr + GBE_PROXYMODE_EXIT_STS_REG);
-
-	if (!netif_running(ndev)) {
-		netdev_err(priv->dev,
-			   "Netprox exit failed: netdev is not running\n");
-		return IRQ_HANDLED;
-	}
-
 	/* Get A2H memory pool header */
 	memcpy_fromio((void *)&a2h_hdr, a2h_mem_ptr, a2h_hdr_len);
 	a2h_mem_ptr += a2h_hdr_len;
@@ -137,7 +130,14 @@ irqreturn_t netproxy_irq(int irq, void *dev_id)
 		       + i * sizeof(u32));
 	}
 
-	queue_work(priv->netprox_wq, &priv->netprox_task);
+	priv->networkproxy_exit = 1;
+	stmmac_resume_common(priv, ndev);
+	priv->networkproxy_exit = 0;
+
+	if (ndev->phydev)
+		phy_start_machine(ndev->phydev);
+
+	netif_device_attach(ndev);
 
 	return IRQ_HANDLED;
 }
@@ -243,8 +243,6 @@ int stmmac_netproxy_register(struct net_device *ndev)
 		return -1;
 	}
 
-	INIT_WORK(&priv->netprox_task, netprox_resume_task);
-
 	np_netdev.netdev = ndev;
 	np_netdev.proxy_enter = &stmmac_netproxy_enter;
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.h b/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.h
index 413b02354adc..f05d114ca53a 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.h
@@ -33,6 +33,7 @@
 
 int stmmac_netproxy_register(struct net_device *netdev);
 int stmmac_netproxy_deregister(struct net_device *netdev);
-irqreturn_t netproxy_irq(int irq, void *dev_id);
+irqreturn_t netproxy_isr(int irq, void *dev_id);
+irqreturn_t netproxy_isr_thread(int irq, void *dev_id);
 
 #endif /* __STMMAC_NETWORK_PROXY_H__ */
-- 
2.17.1

