From 110333243d197b0740c216a5692b182cdf81f1a0 Mon Sep 17 00:00:00 2001
From: "Luo, XinanX" <xinanx.luo@intel.com>
Date: Thu, 14 Jun 2018 23:29:47 +0000
Subject: [PATCH 61/63] wdt:reboot at second watchdog timeout

This patch is to implement watchdog dump kernel logs on first
timeout, and then reboot on second timeout. Only for the platforms
that iTCO watchdog can't trigger NMI interrupts. Because iTCO can
only trigger SMI, need BIOS/Bootloader use SMM to translate it to
NMI. But on some platforms, BIOS/Bootloader doesn't support SMM.

Modifications:
1, Add a perf_event to trigger periodic NMI interrupt, because some
platforms' iTCO can't trigger NMI interrupts for use.

2, Disable reboot bit when first timeout, then it will not reboot
after about 2s(HW default). It will waiting for a NMI interrupt
and check the iTCO status. If timeout, then dump kernel log and
enable the second timeout in iTCO to reboot system.

3, This implement are controlled by a config: CONFIG_ITCO_NO_NMI_INTR
defaut n. If iTCO can't trigger NMI interrupts, set
CONFIG_ITCO_NO_NMI_INTR=y to enable it.

Change-Id: Id41cb5f5b480c1614afa53732dd92a8febf1362f
Signed-off-by: Luo, XinanX <xinanx.luo@intel.com>
---
 drivers/watchdog/Kconfig    |  9 ++++
 drivers/watchdog/iTCO_wdt.c | 94 ++++++++++++++++++++++++++++++++++++-
 2 files changed, 101 insertions(+), 2 deletions(-)

diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 8bf318d44a88..b2dd4ac2fc63 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -1083,6 +1083,15 @@ config ITCO_WDT
 	  To compile this driver as a module, choose M here: the
 	  module will be called iTCO_wdt.
 
+config ITCO_NO_NMI_INTR
+	bool "Intel TCO Watchdog NMI interrupt state"
+	depends on ITCO_WDT
+	default n
+	help
+	  On some platforms, the iTCO watchdog can't trigger a NMI
+	  interrupt on the first timeout. Need to set this flag to enable
+	  another way instead.
+
 config ITCO_VENDOR_SUPPORT
 	bool "Intel TCO Timer/Watchdog Specific Vendor Support"
 	depends on ITCO_WDT
diff --git a/drivers/watchdog/iTCO_wdt.c b/drivers/watchdog/iTCO_wdt.c
index 26cdfd4126c1..0285c0be8907 100755
--- a/drivers/watchdog/iTCO_wdt.c
+++ b/drivers/watchdog/iTCO_wdt.c
@@ -70,6 +70,7 @@
 
 #include <linux/nmi.h>
 #include <asm/nmi.h>
+#include <linux/perf_event.h>
 #include "iTCO_vendor.h"
 
 /* Address definitions for the TCO */
@@ -124,6 +125,9 @@ static struct {
 	unsigned int iTCO_version;
 	bool pretimeout_occurred;
 	unsigned int second_to_ticks;
+#ifdef CONFIG_ITCO_NO_NMI_INTR
+	struct iTCO_wdt_private *wdt_priv;
+#endif
 } iTCO_wdt_sub;
 
 
@@ -257,6 +261,61 @@ static void iTCO_wdt_no_reboot_bit_setup(struct iTCO_wdt_private *p,
 
 	p->no_reboot_priv = p;
 }
+/* iTCO need to wait for a NMI interrupt on first timeout, in order to dump kernel
+** logs in the interrupt handler-iTCO_pretimeout. But on some platforms iTCO timeout
+** can't triger NMI interrupts.These functions will trigger periodly NMI
+** interrupts by perf_event. In iTCO_pretimeout will check iTCO status, if timeout, then
+** dump logs and reboot.
+*/
+#ifdef CONFIG_ITCO_NO_NMI_INTR
+static struct perf_event_attr wd_hw_attr = {
+	.type		= PERF_TYPE_HARDWARE,
+	.config		= PERF_COUNT_HW_CPU_CYCLES,
+	.size		= sizeof(struct perf_event_attr),
+	.pinned		= 1,
+	.disabled	= 1,
+};
+static struct perf_event *itco_perf_evt = NULL;
+static unsigned int itco_perf_sample_period = 10; //default 10 seconds
+static int itco_perf_event_create(void)
+{
+	unsigned int cpu = smp_processor_id();
+	struct perf_event_attr *wd_attr;
+
+	wd_attr = &wd_hw_attr;
+	wd_attr->sample_period = (u64)(cpu_khz) * 1000 * itco_perf_sample_period;
+
+	/* Try to register using hardware perf events */
+	itco_perf_evt = perf_event_create_kernel_counter(wd_attr, cpu, NULL,
+					       NULL, NULL);
+	if (IS_ERR(itco_perf_evt)) {
+		pr_err("Perf event create on CPU %d failed with %ld\n", cpu,
+			PTR_ERR(itco_perf_evt));
+		return PTR_ERR(itco_perf_evt);
+	}
+	return 0;
+}
+static void itco_perf_event_enable(void)
+{
+	if (itco_perf_evt)
+		perf_event_enable(itco_perf_evt);
+}
+static void itco_perf_event_disable(void)
+{
+	if (itco_perf_evt)
+		perf_event_disable(itco_perf_evt);
+}
+static void itco_perf_event_remove(void)
+{
+	if (itco_perf_evt)
+		perf_event_release_kernel(itco_perf_evt);
+}
+#else
+static int itco_perf_event_create(void) { return 0; }
+static void itco_perf_event_enable(void) { }
+static void itco_perf_event_disable(void) { }
+static void itco_perf_event_remove(void) { }
+#endif
 
 static int iTCO_wdt_start(struct watchdog_device *wd_dev)
 {
@@ -267,16 +326,27 @@ static int iTCO_wdt_start(struct watchdog_device *wd_dev)
 	if (force_no_reboot)
 		return -EIO;
 
+	itco_perf_event_enable();
+
 	spin_lock(&p->io_lock);
 
 	iTCO_vendor_pre_start(p->smi_res, wd_dev->timeout);
 
+#ifdef CONFIG_ITCO_NO_NMI_INTR
+	/* Set the NO_REBOOT bit to prevent reboots of first timeout */
+	if (p->update_no_reboot_bit(p->no_reboot_priv, true)) {
+		spin_unlock(&p->io_lock);
+		pr_err("failed to set NO_REBOOT flag\n");
+		return -EIO;
+	}
+#else
 	/* disable chipset's NO_REBOOT bit */
 	if (p->update_no_reboot_bit(p->no_reboot_priv, false)) {
 		spin_unlock(&p->io_lock);
 		pr_err("failed to reset NO_REBOOT flag, reboot disabled by hardware/BIOS/rc_cmd\n");
 		return -EIO;
 	}
+#endif
 
 	/* Force the timer to its reload value by writing to the TCO_RLD
 	   register */
@@ -302,6 +372,8 @@ static int iTCO_wdt_stop(struct watchdog_device *wd_dev)
 	struct iTCO_wdt_private *p = watchdog_get_drvdata(wd_dev);
 	unsigned int val;
 
+	itco_perf_event_disable();
+
 	spin_lock(&p->io_lock);
 
 	iTCO_vendor_pre_stop(p->smi_res);
@@ -449,6 +521,9 @@ static const struct watchdog_ops iTCO_wdt_ops = {
 static int iTCO_pretimeout(unsigned int cmd, struct pt_regs *unused_regs)
 {
 	resource_size_t tco_base_address;
+#ifdef CONFIG_ITCO_NO_NMI_INTR
+	struct iTCO_wdt_private *p = iTCO_wdt_sub.wdt_priv;
+#endif
 
 	/* Prevent re-entrance */
 	if (iTCO_wdt_sub.pretimeout_occurred)
@@ -459,6 +534,10 @@ static int iTCO_pretimeout(unsigned int cmd, struct pt_regs *unused_regs)
 	/* Check the NMI is from the TCO first expiration */
 	if (inw(TCO1_STS_sub(tco_base_address)) & 0x8) {
 		iTCO_wdt_sub.pretimeout_occurred = true;
+#ifdef CONFIG_ITCO_NO_NMI_INTR
+		/*Enable reboot for the second timeout*/
+		p->update_no_reboot_bit(p->no_reboot_priv, false);
+#endif
 
 		/* Forward next expiration */
 		outw(iTCO_wdt_sub.second_to_ticks, TCOv2_TMR_sub(tco_base_address));
@@ -606,11 +685,20 @@ static int iTCO_wdt_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	/*create a perf_event to generate nmi interrupt*/
+	ret = itco_perf_event_create();
+	if (ret != 0) {
+		pr_err("cannot create perf event (err=%d)\n", ret);
+		return ret;
+	}
+
     /* init vars that used for nmi handler */
 	iTCO_wdt_sub.iTCO_version = p->iTCO_version;
 	iTCO_wdt_sub.second_to_ticks = seconds_to_ticks(p, 10);
 	iTCO_wdt_sub.tco_base_address = TCOBASE(p);
-
+#ifdef CONFIG_ITCO_NO_NMI_INTR
+	iTCO_wdt_sub.wdt_priv = p;
+#endif
 	ret = register_nmi_handler(NMI_LOCAL, iTCO_pretimeout, 0 ,"iTCO_wdt");
 	if (ret != 0) {
 		pr_err("cannot register nmi handler (err=%d)\n", ret);
@@ -628,8 +716,10 @@ static int iTCO_wdt_remove(struct platform_device *pdev)
 	struct iTCO_wdt_private *p = platform_get_drvdata(pdev);
 
 	/* Stop the timer before we leave */
-	if (!nowayout)
+	if (!nowayout) {
 		iTCO_wdt_stop(&p->wddev);
+		itco_perf_event_remove();
+	}
 
 	return 0;
 }
-- 
2.17.1

