From 7d73a1eaad1e018d1639f0ea1a1bb54a6c057a0a Mon Sep 17 00:00:00 2001
From: Piotr Maziarz <piotrx.maziarz@linux.intel.com>
Date: Tue, 12 May 2020 13:45:36 +0200
Subject: [PATCH 1195/1214] ASoC: Intel: common: Remove IPC message lists

Since only one message can be sent at a time lists are obsolete.

Change-Id: I8da6464b41384ed85ac5bc8fd5395f7606d002a5
Tracked-On: PKT-3636, OAM-91517
Signed-off-by: Piotr Maziarz <piotrx.maziarz@linux.intel.com>
---
 sound/soc/intel/baytrail/sst-baytrail-ipc.c |   7 -
 sound/soc/intel/common/sst-ipc.c            | 219 +++++++---------------------
 sound/soc/intel/common/sst-ipc.h            |   8 +-
 sound/soc/intel/haswell/sst-haswell-ipc.c   |   7 -
 sound/soc/intel/skylake/cnl-sst.c           |   3 -
 sound/soc/intel/skylake/skl-sst-ipc.c       |  25 +---
 6 files changed, 61 insertions(+), 208 deletions(-)

diff --git a/sound/soc/intel/baytrail/sst-baytrail-ipc.c b/sound/soc/intel/baytrail/sst-baytrail-ipc.c
index 403dac3..536f74f 100644
--- a/sound/soc/intel/baytrail/sst-baytrail-ipc.c
+++ b/sound/soc/intel/baytrail/sst-baytrail-ipc.c
@@ -36,8 +36,6 @@
 #define IPC_TIMEOUT_MSECS	300
 #define IPC_BOOT_MSECS		200
 
-#define IPC_EMPTY_LIST_SIZE	8
-
 /* IPC header bits */
 #define IPC_HEADER_MSG_ID_MASK	0xff
 #define IPC_HEADER_MSG_ID(x)	((x) & IPC_HEADER_MSG_ID_MASK)
@@ -256,7 +254,6 @@ static int sst_byt_process_reply(struct sst_byt *byt, u64 header)
 	/* update any stream states */
 	sst_byt_stream_update(byt, msg);
 
-	list_del(&msg->list);
 	/* wake up */
 	sst_ipc_tx_msg_reply_complete(&byt->ipc, msg);
 
@@ -336,9 +333,6 @@ static irqreturn_t sst_byt_irq_thread(int irq, void *context)
 
 	spin_unlock_irqrestore(&sst->spinlock, flags);
 
-	/* continue to send any remaining messages... */
-	schedule_work(&ipc->kwork);
-
 	return IRQ_HANDLED;
 }
 
@@ -578,7 +572,6 @@ int sst_byt_dsp_suspend_late(struct device *dev, struct sst_pdata *pdata)
 
 	dev_dbg(byt->dev, "dsp reset\n");
 	sst_dsp_reset(byt->dsp);
-	sst_ipc_drop_all(&byt->ipc);
 	dev_dbg(byt->dev, "dsp in reset\n");
 
 	dev_dbg(byt->dev, "free all blocks and unload fw\n");
diff --git a/sound/soc/intel/common/sst-ipc.c b/sound/soc/intel/common/sst-ipc.c
index ce796b3..48cedd4 100644
--- a/sound/soc/intel/common/sst-ipc.c
+++ b/sound/soc/intel/common/sst-ipc.c
@@ -35,38 +35,44 @@
 /* IPC message timeout (msecs) */
 #define IPC_TIMEOUT_MSECS	300
 
-#define IPC_EMPTY_LIST_SIZE	8
-
-/* locks held by caller */
-static struct ipc_message *msg_get_empty(struct sst_generic_ipc *ipc)
+static int msg_init(struct sst_generic_ipc *ipc)
 {
-	struct ipc_message *msg = NULL;
+	ipc->msg = kzalloc(sizeof(struct ipc_message), GFP_KERNEL);
+	if (ipc->msg == NULL)
+		return -ENOMEM;
+
+	ipc->msg->tx_data = kzalloc(ipc->tx_data_max_size, GFP_KERNEL);
+	if (ipc->msg->tx_data == NULL)
+		goto free_mem;
 
-	if (!list_empty(&ipc->empty_list)) {
-		msg = list_first_entry(&ipc->empty_list, struct ipc_message,
-			list);
-		list_del(&msg->list);
+	ipc->msg->rx_data = kzalloc(ipc->rx_data_max_size, GFP_KERNEL);
+	if (ipc->msg->rx_data == NULL) {
+		kfree(ipc->msg->tx_data);
+		goto free_mem;
 	}
 
-	return msg;
+	return 0;
+
+free_mem:
+	kfree(ipc->msg);
+	return -ENOMEM;
 }
 
 static int tx_wait_done(struct sst_generic_ipc *ipc,
-	struct ipc_message *msg, void *rx_data, size_t *rx_bytes)
+			void *rx_data, size_t *rx_bytes)
 {
 	unsigned long flags;
 	int ret;
 
-	wait_event(msg->waitq, ipc->sent);
 again:
 	/* wait for DSP completion (in all cases atm inc pending) */
-	ret = wait_event_timeout(msg->waitq, msg->complete,
+	ret = wait_event_timeout(ipc->msg->waitq, ipc->msg->complete,
 		msecs_to_jiffies(IPC_TIMEOUT_MSECS));
 
 	if (ipc->dsp->ipc_state == IPC_STATE_RECEIVED) {
 		/* fw did its job, now wait until it's processed */
 		if (!ret) {
-			wait_event(msg->waitq, msg->complete);
+			wait_event(ipc->msg->waitq, ipc->msg->complete);
 			ret = 1;
 		}
 	}
@@ -74,8 +80,8 @@ static int tx_wait_done(struct sst_generic_ipc *ipc,
 	if (ipc->dsp->ipc_state == IPC_STATE_DEFERRED) {
 		/* reply delayed due to nofitication */
 		if (!ret)
-			wait_event(msg->waitq, msg->complete);
-		msg->complete = false;
+			wait_event(ipc->msg->waitq, ipc->msg->complete);
+		ipc->msg->complete = false;
 		ipc->dsp->ipc_state = IPC_STATE_RESET;
 		goto again;
 	}
@@ -85,13 +91,12 @@ static int tx_wait_done(struct sst_generic_ipc *ipc,
 		if (ipc->ops.shim_dbg != NULL)
 			ipc->ops.shim_dbg(ipc, "message timeout");
 
-		list_del(&msg->list);
 		ret = -ETIMEDOUT;
 	} else {
 
 		/* copy the data returned from DSP */
 		if ((rx_bytes != NULL) &&
-				(msg->rx_size > *rx_bytes)) {
+				(ipc->msg->rx_size > *rx_bytes)) {
 			dev_err(ipc->dev, "rx size is more than expected\n");
 			ret = -EINVAL;
 			goto err;
@@ -99,13 +104,12 @@ static int tx_wait_done(struct sst_generic_ipc *ipc,
 
 		if (rx_data) {
 			if (rx_bytes != NULL)
-				*rx_bytes = msg->rx_size;
-			memcpy(rx_data, msg->rx_data, msg->rx_size);
+				*rx_bytes = ipc->msg->rx_size;
+			memcpy(rx_data, ipc->msg->rx_data, ipc->msg->rx_size);
 		}
-		ret = msg->errno;
+		ret = ipc->msg->errno;
 	}
 err:
-	list_add_tail(&msg->list, &ipc->empty_list);
 	spin_unlock_irqrestore(&ipc->dsp->spinlock, flags);
 	return ret;
 }
@@ -114,16 +118,19 @@ static int ipc_tx_message(struct sst_generic_ipc *ipc, u64 header,
 	void *tx_data, size_t tx_bytes, void *rx_data,
 	size_t *rx_bytes, int wait)
 {
+	int ret = 0;
 	struct ipc_message *msg;
 	unsigned long flags;
 
+	if (!ipc->msg) {
+		dev_err(ipc->dev, "No msg allocated, invalid state\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&ipc->mutex);
 	spin_lock_irqsave(&ipc->dsp->spinlock, flags);
 
-	msg = msg_get_empty(ipc);
-	if (msg == NULL) {
-		spin_unlock_irqrestore(&ipc->dsp->spinlock, flags);
-		return -EBUSY;
-	}
+	msg = ipc->msg;
 
 	msg->header = header;
 	msg->tx_size = tx_bytes;
@@ -137,90 +144,20 @@ static int ipc_tx_message(struct sst_generic_ipc *ipc, u64 header,
 	msg->errno = 0;
 	msg->pending = false;
 	msg->complete = false;
-	ipc->sent = false;
 	ipc->dsp->ipc_state = IPC_STATE_RESET;
 
 	if ((tx_bytes) && (ipc->ops.tx_data_copy != NULL))
 		ipc->ops.tx_data_copy(msg, tx_data, tx_bytes);
 
-	list_add_tail(&msg->list, &ipc->tx_list);
-	queue_work(system_highpri_wq, &ipc->kwork);
+	if (ipc->ops.tx_msg != NULL)
+		ipc->ops.tx_msg(ipc, ipc->msg);
         spin_unlock_irqrestore(&ipc->dsp->spinlock, flags);
 
 	if (wait)
-		return tx_wait_done(ipc, msg, rx_data,
+		ret = tx_wait_done(ipc, rx_data,
 				rx_bytes);
-	else
-		return 0;
-}
-
-static int msg_empty_list_init(struct sst_generic_ipc *ipc)
-{
-	int i;
-
-	ipc->msg = kcalloc(IPC_EMPTY_LIST_SIZE, sizeof(struct ipc_message),
-			   GFP_KERNEL);
-	if (ipc->msg == NULL)
-		return -ENOMEM;
-
-	for (i = 0; i < IPC_EMPTY_LIST_SIZE; i++) {
-		ipc->msg[i].tx_data = kzalloc(ipc->tx_data_max_size, GFP_KERNEL);
-		if (ipc->msg[i].tx_data == NULL)
-			goto free_mem;
-
-		ipc->msg[i].rx_data = kzalloc(ipc->rx_data_max_size, GFP_KERNEL);
-		if (ipc->msg[i].rx_data == NULL) {
-			kfree(ipc->msg[i].tx_data);
-			goto free_mem;
-		}
-
-		init_waitqueue_head(&ipc->msg[i].waitq);
-		list_add(&ipc->msg[i].list, &ipc->empty_list);
-	}
-
-	return 0;
-
-free_mem:
-	while (i > 0) {
-		kfree(ipc->msg[i-1].tx_data);
-		kfree(ipc->msg[i-1].rx_data);
-		--i;
-	}
-	kfree(ipc->msg);
-
-	return -ENOMEM;
-}
-
-static void ipc_tx_msgs(struct work_struct *work)
-{
-	struct sst_generic_ipc *ipc =
-		container_of(work, struct sst_generic_ipc, kwork);
-	struct ipc_message *msg;
-
-	spin_lock_irq(&ipc->dsp->spinlock);
-
-	while (!list_empty(&ipc->tx_list) && !ipc->pending) {
-		/* if the DSP is busy, we will TX messages after IRQ.
-		 * also postpone if we are in the middle of processing
-		 * completion irq
-		 */
-		if (ipc->ops.is_dsp_busy && ipc->ops.is_dsp_busy(ipc->dsp)) {
-			dev_dbg(ipc->dev, "ipc_tx_msgs dsp busy\n");
-			break;
-		}
-
-		msg = list_first_entry(&ipc->tx_list, struct ipc_message, list);
-		list_move(&msg->list, &ipc->rx_list);
-
-		if (ipc->ops.tx_msg != NULL) {
-			ipc->ops.tx_msg(ipc, msg);
-			ipc->sent = true;
-			if (msg->wait)
-				wake_up(&msg->waitq);
-		}
-	}
-
-	spin_unlock_irq(&ipc->dsp->spinlock);
+	mutex_unlock(&ipc->mutex);
+	return ret;
 }
 
 int sst_ipc_tx_message_wait(struct sst_generic_ipc *ipc, u64 header,
@@ -268,24 +205,21 @@ EXPORT_SYMBOL_GPL(sst_ipc_tx_message_nopm);
 struct ipc_message *sst_ipc_reply_find_msg(struct sst_generic_ipc *ipc,
 	u64 header)
 {
-	struct ipc_message *msg;
 	u64 mask;
 
+	if (!ipc->msg) {
+		dev_err(ipc->dev, "Received 0x%llx, but no ongoing communication\n",
+			header);
+		return NULL;
+	}
+
 	if (ipc->ops.reply_msg_match != NULL)
 		header = ipc->ops.reply_msg_match(header, &mask);
 	else
 		mask = (u64)-1;
 
-	if (list_empty(&ipc->rx_list)) {
-		dev_err(ipc->dev, "error: rx list empty but received 0x%llx\n",
-			header);
-		return NULL;
-	}
-
-	list_for_each_entry(msg, &ipc->rx_list, list) {
-		if ((msg->header & mask) == header)
-			return msg;
-	}
+	if ((ipc->msg->header & mask) == header)
+		return ipc->msg;
 
 	return NULL;
 }
@@ -297,71 +231,26 @@ void sst_ipc_tx_msg_reply_complete(struct sst_generic_ipc *ipc,
 {
 	msg->complete = true;
 
-	if (!msg->wait)
-		list_add_tail(&msg->list, &ipc->empty_list);
-	else
+	if (msg->wait)
 		wake_up(&msg->waitq);
 }
 EXPORT_SYMBOL_GPL(sst_ipc_tx_msg_reply_complete);
 
-void sst_ipc_drop_all(struct sst_generic_ipc *ipc)
-{
-	struct ipc_message *msg, *tmp;
-	unsigned long flags;
-	int tx_drop_cnt = 0, rx_drop_cnt = 0;
-
-	/* drop all TX and Rx messages before we stall + reset DSP */
-	spin_lock_irqsave(&ipc->dsp->spinlock, flags);
-
-	list_for_each_entry_safe(msg, tmp, &ipc->tx_list, list) {
-		list_move(&msg->list, &ipc->empty_list);
-		tx_drop_cnt++;
-	}
-
-	list_for_each_entry_safe(msg, tmp, &ipc->rx_list, list) {
-		list_move(&msg->list, &ipc->empty_list);
-		rx_drop_cnt++;
-	}
-
-	spin_unlock_irqrestore(&ipc->dsp->spinlock, flags);
-
-	if (tx_drop_cnt || rx_drop_cnt)
-		dev_err(ipc->dev, "dropped IPC msg RX=%d, TX=%d\n",
-			tx_drop_cnt, rx_drop_cnt);
-}
-EXPORT_SYMBOL_GPL(sst_ipc_drop_all);
-
 int sst_ipc_init(struct sst_generic_ipc *ipc)
 {
-	int ret;
-
-	INIT_LIST_HEAD(&ipc->tx_list);
-	INIT_LIST_HEAD(&ipc->rx_list);
-	INIT_LIST_HEAD(&ipc->empty_list);
 	init_waitqueue_head(&ipc->wait_txq);
+	mutex_init(&ipc->mutex);
 
-	ret = msg_empty_list_init(ipc);
-	if (ret < 0)
-		return -ENOMEM;
-
-	INIT_WORK(&ipc->kwork, ipc_tx_msgs);
-	return 0;
+	return msg_init(ipc);
 }
 EXPORT_SYMBOL_GPL(sst_ipc_init);
 
 void sst_ipc_fini(struct sst_generic_ipc *ipc)
 {
-	int i;
-
-	cancel_work_sync(&ipc->kwork);
-
-	if (ipc->msg) {
-		for (i = 0; i < IPC_EMPTY_LIST_SIZE; i++) {
-			kfree(ipc->msg[i].tx_data);
-			kfree(ipc->msg[i].rx_data);
-		}
-		kfree(ipc->msg);
-	}
+	kfree(ipc->msg->tx_data);
+	kfree(ipc->msg->rx_data);
+	kfree(ipc->msg);
+	ipc->msg = NULL;
 }
 EXPORT_SYMBOL_GPL(sst_ipc_fini);
 
diff --git a/sound/soc/intel/common/sst-ipc.h b/sound/soc/intel/common/sst-ipc.h
index d8865df..4b96495 100644
--- a/sound/soc/intel/common/sst-ipc.h
+++ b/sound/soc/intel/common/sst-ipc.h
@@ -27,7 +27,6 @@
 #define IPC_MAX_MAILBOX_BYTES	256
 
 struct ipc_message {
-	struct list_head list;
 	u64 header;
 
 	/* direction wrt host CPU */
@@ -60,13 +59,9 @@ struct sst_generic_ipc {
 	struct sst_dsp *dsp;
 
 	/* IPC messaging */
-	struct list_head tx_list;
-	struct list_head rx_list;
-	struct list_head empty_list;
+	struct mutex mutex;
 	wait_queue_head_t wait_txq;
 	struct task_struct *tx_thread;
-	struct work_struct kwork;
-	bool sent;
 	bool pending;
 	struct ipc_message *msg;
 	int tx_data_max_size;
@@ -91,7 +86,6 @@ struct ipc_message *sst_ipc_reply_find_msg(struct sst_generic_ipc *ipc,
 void sst_ipc_tx_msg_reply_complete(struct sst_generic_ipc *ipc,
 	struct ipc_message *msg);
 
-void sst_ipc_drop_all(struct sst_generic_ipc *ipc);
 int sst_ipc_init(struct sst_generic_ipc *ipc);
 void sst_ipc_fini(struct sst_generic_ipc *ipc);
 
diff --git a/sound/soc/intel/haswell/sst-haswell-ipc.c b/sound/soc/intel/haswell/sst-haswell-ipc.c
index 557f780..d87062a 100644
--- a/sound/soc/intel/haswell/sst-haswell-ipc.c
+++ b/sound/soc/intel/haswell/sst-haswell-ipc.c
@@ -98,7 +98,6 @@
 #define IPC_FW_READY		(0x1 << 29)
 #define IPC_STATUS_MASK		(0x3 << 30)
 
-#define IPC_EMPTY_LIST_SIZE	8
 #define IPC_MAX_STREAMS		4
 
 /* Mailbox */
@@ -633,7 +632,6 @@ static int hsw_process_reply(struct sst_hsw *hsw, u32 header)
 		hsw_stream_update(hsw, msg);
 
 	/* wake up and return the error if we have waiters on this message ? */
-	list_del(&msg->list);
 	sst_ipc_tx_msg_reply_complete(&hsw->ipc, msg);
 
 	return 1;
@@ -816,9 +814,6 @@ static irqreturn_t hsw_irq_thread(int irq, void *context)
 
 	spin_unlock_irqrestore(&sst->spinlock, flags);
 
-	/* continue to send any remaining messages... */
-	schedule_work(&ipc->kwork);
-
 	return IRQ_HANDLED;
 }
 
@@ -1659,8 +1654,6 @@ int sst_hsw_dsp_runtime_suspend(struct sst_hsw *hsw)
 	if (ret < 0)
 		return ret;
 
-	sst_ipc_drop_all(&hsw->ipc);
-
 	return 0;
 }
 
diff --git a/sound/soc/intel/skylake/cnl-sst.c b/sound/soc/intel/skylake/cnl-sst.c
index 9883de9..cc727da 100644
--- a/sound/soc/intel/skylake/cnl-sst.c
+++ b/sound/soc/intel/skylake/cnl-sst.c
@@ -466,9 +466,6 @@ static irqreturn_t cnl_dsp_irq_thread_handler(int irq, void *context)
 
 		cnl_ipc_int_enable(dsp);
 
-		/* continue to send any remaining messages */
-		schedule_work(&ipc->kwork);
-
 		return IRQ_HANDLED;
 	}
 
diff --git a/sound/soc/intel/skylake/skl-sst-ipc.c b/sound/soc/intel/skylake/skl-sst-ipc.c
index afd1823..43f0278 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.c
+++ b/sound/soc/intel/skylake/skl-sst-ipc.c
@@ -42,8 +42,6 @@
 
 #define IPC_TIMEOUT_MSECS		3000
 
-#define IPC_EMPTY_LIST_SIZE		8
-
 #define IPC_MSG_TARGET_SHIFT		30
 #define IPC_MSG_TARGET_MASK		0x1
 #define IPC_MSG_TARGET(x)		(((x) & IPC_MSG_TARGET_MASK) \
@@ -371,21 +369,14 @@ int skl_ipc_check_D0i0(struct sst_dsp *dsp, bool state)
 static struct ipc_message *skl_ipc_reply_get_msg(struct sst_generic_ipc *ipc,
 				u64 ipc_header)
 {
-	struct ipc_message *msg =  NULL;
-	struct skl_ipc_header *header = (struct skl_ipc_header *)(&ipc_header);
-
-	if (list_empty(&ipc->rx_list)) {
-		dev_err(ipc->dev, "ipc: rx list is empty but received 0x%x\n",
-			header->primary);
-		goto out;
+	if (!ipc->msg) {
+		dev_err(ipc->dev,
+			"Received 0x%llx, no ongoing communication\n",
+			ipc_header);
+		return NULL;
 	}
 
-	msg = list_first_entry(&ipc->rx_list, struct ipc_message, list);
-
-	list_del(&msg->list);
-out:
-	return msg;
-
+	return ipc->msg;
 }
 
 static int skl_process_module_notification(struct skl_sst *skl)
@@ -772,10 +763,6 @@ irqreturn_t skl_dsp_irq_thread_handler(int irq, void *context)
 
 		skl_ipc_int_enable(dsp);
 
-		/* continue to send any remaining messages... */
-		if (!list_empty(&ipc->tx_list))
-			queue_work(system_highpri_wq, &ipc->kwork);
-
 		ret = IRQ_HANDLED;
 	}
 
-- 
2.7.4

