From eb71bf576ea5e5a99f020df3068851ab4b1efd24 Mon Sep 17 00:00:00 2001
From: "David E. Box" <david.e.box@linux.intel.com>
Date: Fri, 5 Jun 2020 20:03:44 -0700
Subject: [PATCH 14/15] platform/x86: pmt_core: Split out common code

Split out common funcitons from telemetry, watcher, and crashlog drivers
and create a common structure for the different headers.

Also for watcher:
- Fix code to get base address for the cfg_base, not the
smplr_data_start.
- Use early_hw function from common code to apply client fixes
- Use local variable for header resource instead of carrying one in
  entry struct
- Replace names from original watcher_header to names in common
  pmt_header

Signed-off-by: David E. Box <david.e.box@linux.intel.com>
---
 drivers/platform/x86/Kconfig               |   6 +
 drivers/platform/x86/Makefile              |   1 +
 drivers/platform/x86/intel_pmt_core.c      | 134 ++++++++++++++++++
 drivers/platform/x86/intel_pmt_core.h      |  41 ++++++
 drivers/platform/x86/intel_pmt_crashlog.c  | 112 +++------------
 drivers/platform/x86/intel_pmt_telemetry.c | 118 +++-------------
 drivers/platform/x86/intel_pmt_watcher.c   | 157 +++++----------------
 7 files changed, 258 insertions(+), 311 deletions(-)
 create mode 100644 drivers/platform/x86/intel_pmt_core.c
 create mode 100644 drivers/platform/x86/intel_pmt_core.h

diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 0763d09b36f5..386aac527b4c 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -1362,8 +1362,12 @@ config INTEL_PMC_CORE
 		- LTR Ignore
 		- MPHY/PLL gating status (Sunrisepoint PCH only)
 
+config INTEL_PMT_CORE
+	tristate
+
 config INTEL_PMT_CRASHLOG
 	tristate "Intel Platform Monitoring Technology (PMT) Crashlog driver"
+	select INTEL_PMT_CORE
 	help
 	 The Intel Platform Monitoring Technology (PMT) crashlog driver provides
 	 access to hardware crashlog capabilities on devices that support the
@@ -1374,6 +1378,7 @@ config INTEL_PMT_CRASHLOG
 
 config INTEL_PMT_TELEMETRY
 	tristate "Intel Platform Monitoring Technology (PMT) Telemetry driver"
+	select INTEL_PMT_CORE
 	help
 	  The Intel Platform Monitory Technology (PMT) Telemetry driver provides
 	  access to hardware telemetry metrics on devices that support the
@@ -1384,6 +1389,7 @@ config INTEL_PMT_TELEMETRY
 
 config INTEL_PMT_WATCHER
 	tristate "Intel Platform Monitoring Technology (PMT) Watcher driver"
+	select INTEL_PMT_CORE
 	help
 	 The Intel Platform Monitoring Technology (PMT) Watcher driver provides
 	 access to hardware sampling and tracing capabilities on devices that
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index 6dd029d4dee4..8c36758432e6 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -140,6 +140,7 @@ obj-$(CONFIG_INTEL_MFLD_THERMAL)	+= intel_mid_thermal.o
 obj-$(CONFIG_INTEL_MID_POWER_BUTTON)	+= intel_mid_powerbtn.o
 obj-$(CONFIG_INTEL_MRFLD_PWRBTN)	+= intel_mrfld_pwrbtn.o
 obj-$(CONFIG_INTEL_PMC_CORE)		+= intel_pmc_core.o intel_pmc_core_pltdrv.o
+obj-$(CONFIG_INTEL_PMT_CORE)		+= intel_pmt_core.o
 obj-$(CONFIG_INTEL_PMT_CRASHLOG)	+= intel_pmt_crashlog.o
 obj-$(CONFIG_INTEL_PMT_TELEMETRY)	+= intel_pmt_telemetry.o
 obj-$(CONFIG_INTEL_PMT_WATCHER)		+= intel_pmt_watcher.o
diff --git a/drivers/platform/x86/intel_pmt_core.c b/drivers/platform/x86/intel_pmt_core.c
new file mode 100644
index 000000000000..528bdaf4c5b8
--- /dev/null
+++ b/drivers/platform/x86/intel_pmt_core.c
@@ -0,0 +1,134 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Intel Platform Monitory Technology Core driver
+ *
+ * Copyright (c) 2020, Intel Corporation.
+ * All Rights Reserved.
+ *
+ * Author: "David E. Box" <david.e.box@linux.intel.com>
+ */
+
+#include <linux/bits.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+
+#include "intel_pmt_core.h"
+
+/* Access types */
+#define ACCESS_BARID		2
+#define ACCESS_LOCAL		3
+
+#define ACCESS(v)		((v) & GENMASK(3, 0))
+#define TYPE(v)			(((v) & GENMASK(11, 4)) >> 4)
+/* size is in bytes */
+#define SIZE(v)			(((v) & GENMASK(27, 12)) >> 10)
+#define IRQ_EN(v)		((v) & BIT(28))
+#define BIR(v)			((v) & GENMASK(2, 0))
+
+#define CRASHLOG_VERSION(v)	(((v) & GENMASK(19, 16)) >> 16)
+
+static const struct pci_device_id pmt_early_client_pci_ids[] = {
+	{ PCI_VDEVICE(INTEL, 0x9a0d) },
+	{ PCI_VDEVICE(INTEL, 0x490e) },
+	{ PCI_VDEVICE(INTEL, 0x467d) },
+	{ }
+};
+
+bool pmt_is_early_client_hw(struct device *dev)
+{
+	struct pci_dev *parent;
+
+	parent = to_pci_dev(dev->parent);
+	if (pci_match_id(pmt_early_client_pci_ids, parent))
+		return true;
+
+	return false;
+}
+EXPORT_SYMBOL_GPL(pmt_is_early_client_hw);
+
+void pmt_populate_header(enum pmt_cap cap, void __iomem *disc_offset,
+			 struct pmt_header *header)
+{
+	u32 discovery_header = readl(disc_offset);
+
+	header->access_type = ACCESS(discovery_header);
+	header->type = TYPE(discovery_header);
+	header->guid = readl(disc_offset + GUID_OFFSET);
+	header->base_offset = readl(disc_offset + BASE_OFFSET);
+	/*
+	 * For non-local access types the lower 3 bits of base offset
+	 * contains the index of the base address register where the
+	 * telemetry can be found.
+	 */
+	header->bir = BIR(header->base_offset);
+	header->base_offset ^= header->bir;
+
+	switch (cap) {
+	case PMT_CAP_TELEM:
+	case PMT_CAP_WATCHER:
+		header->size = SIZE(readl(disc_offset));
+
+		if (cap == PMT_CAP_WATCHER)
+			header->irq_support = !!(IRQ_EN(readl(disc_offset)));
+		break;
+	case PMT_CAP_CRASHLOG:
+	        /* Size is measured in DWORDs */
+		header->crashlog_size = readl(disc_offset +
+					      CRASHLOG_SIZE_OFFSET);
+		header->crashlog_version = CRASHLOG_VERSION(discovery_header);
+	}
+}
+EXPORT_SYMBOL_GPL(pmt_populate_header);
+
+int pmt_get_base_address(struct device *dev, struct pmt_header *header,
+			 struct resource *header_res, unsigned long *address)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev->parent);
+	/* Local access and BARID only for now */
+	switch (header->access_type) {
+	case ACCESS_LOCAL:
+		if (header->bir) {
+			dev_err(dev,
+				"Unsupported BAR index %d for access type %d\n",
+				header->bir, header->access_type);
+			return -EINVAL;
+		}
+
+		*address = header_res->start + resource_size(header_res) +
+			   header->base_offset;
+
+		/*
+		 * XXX: For Intel internal use only to address hardware bug
+		 * that will be fixed in production. In the bug, local refers to
+		 * an address in the same bar the header but at a fixed instead
+		 * of relative offset.
+		 */
+		if (pmt_is_early_client_hw(dev)) {
+			unsigned long pf_addr, mask;
+
+			dev_info(dev, "FW Bug quirk for base offset\n");
+			pf_addr = PFN_PHYS(PHYS_PFN(header_res->start)) +
+					   header->base_offset;
+			mask = ~GENMASK(fls(header->base_offset), 0);
+			*address = (pf_addr & mask) + header->base_offset;
+		}
+		break;
+
+	case ACCESS_BARID:
+		*address = pci_resource_start(pci_dev, header->bir) +
+			   header->base_offset;
+		break;
+
+	default:
+		dev_err(dev, "Unsupported access type %d\n",
+			header->access_type);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pmt_get_base_address);
+
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/platform/x86/intel_pmt_core.h b/drivers/platform/x86/intel_pmt_core.h
new file mode 100644
index 000000000000..5bec24d93ede
--- /dev/null
+++ b/drivers/platform/x86/intel_pmt_core.h
@@ -0,0 +1,41 @@
+// SPDX-License-Identifier: GPL-2.0
+#ifndef _INTEL_PMT_CORE_H
+#define _INTEL_PMT_CORE_H
+
+#include <linux/types.h>
+
+/* PMT device names */
+#define TELEM_DEV_NAME		"pmt_telemetry"
+#define WATCHER_DEV_NAME	"pmt_watcher"
+#define CRASHLOG_DEV_NAME	"pmt_crashlog"
+
+#define GUID_OFFSET		0x4
+#define BASE_OFFSET		0x8
+#define CRASHLOG_SIZE_OFFSET	0xC
+
+enum pmt_cap {
+	PMT_CAP_TELEM = 2,
+	PMT_CAP_WATCHER,
+	PMT_CAP_CRASHLOG
+};
+
+struct pmt_header {
+	u8	access_type;
+	u8	type;
+	u16	size;
+	bool	irq_support;
+	u32	guid;
+	u32	base_offset;
+	u8	bir;
+	u32	crashlog_size;
+	u8	crashlog_flag;
+	u8	crashlog_version;
+};
+
+bool pmt_is_early_client_hw(struct device *dev);
+void pmt_populate_header(enum pmt_cap cap,void __iomem *disc_offset,
+			 struct pmt_header *header);
+int pmt_get_base_address(struct device *dev, struct pmt_header *header,
+			 struct resource *header_res, unsigned long *address);
+
+#endif
diff --git a/drivers/platform/x86/intel_pmt_crashlog.c b/drivers/platform/x86/intel_pmt_crashlog.c
index e8ebb7f19fc8..83a1d0363918 100644
--- a/drivers/platform/x86/intel_pmt_crashlog.c
+++ b/drivers/platform/x86/intel_pmt_crashlog.c
@@ -17,12 +17,9 @@
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 
-#define DRV_NAME		"pmt_crashlog"
+#include "intel_pmt_core.h"
 
-/* Crashlog access types */
-#define ACCESS_FUTURE		1
-#define ACCESS_BARID		2
-#define ACCESS_LOCAL		3
+#define DRV_NAME		"pmt_crashlog"
 
 /* Crashlog discovery header types */
 #define CRASH_TYPE_OOBMSM	1
@@ -34,36 +31,15 @@
 #define CRASHLOG_FLAG_COMPLETE	BIT(31)
 #define CRASHLOG_FLAG_MASK	GENMASK(31, 28)
 
-/* Common Header */
 #define CONTROL_OFFSET		0x0
-#define GUID_OFFSET		0x4
-#define BASE_OFFSET		0x8
-#define SIZE_OFFSET		0xC
-#define GET_ACCESS(v)		((v) & GENMASK(3, 0))
-#define GET_TYPE(v)		(((v) & GENMASK(7, 4)) >> 4)
-#define GET_VERSION(v)		(((v) & GENMASK(19, 16)) >> 16)
-
-#define GET_ADDRESS(v)		((v) & GENMASK(31, 3))
-#define GET_BIR(v)		((v) & GENMASK(2, 0))
 
 static DEFINE_IDA(crashlog_devid_ida);
 
-struct crashlog_header {
-	u32	base_offset;
-	u32	size;
-	u32	guid;
-	u8	bir;
-	u8	access_type;
-	u8	crash_type;
-	u8	version;
-};
-
 struct pmt_crashlog_priv;
 
 struct crashlog_entry {
 	struct pmt_crashlog_priv	*priv;
-	struct crashlog_header		header;
-	struct resource			*header_res;
+	struct pmt_header		header;
 	void __iomem			*disc_table;
 	unsigned long			crashlog_data;
 	size_t				crashlog_data_size;
@@ -384,79 +360,31 @@ static int pmt_crashlog_make_dev(struct pmt_crashlog_priv *priv,
 	return PTR_ERR_OR_ZERO(dev);
 }
 
-static void
-pmt_crashlog_populate_header(void __iomem *disc_offset,
-			     struct crashlog_header *header)
-{
-	u32 discovery_header = readl(disc_offset);
-
-	header->access_type = GET_ACCESS(discovery_header);
-	header->crash_type = GET_TYPE(discovery_header);
-	header->version = GET_VERSION(discovery_header);
-	header->guid = readl(disc_offset + GUID_OFFSET);
-	header->base_offset = readl(disc_offset + BASE_OFFSET);
-
-	/*
-	 * For non-local access types the lower 3 bits of base offset
-	 * contains the index of the base address register where the
-	 * crashlogetry can be found.
-	 */
-	header->bir = GET_BIR(header->base_offset);
-	header->base_offset ^= header->bir;
-
-	/* Size is measured in DWORDs */
-	header->size = readl(disc_offset + SIZE_OFFSET);
-}
-
 static int pmt_crashlog_add_entry(struct pmt_crashlog_priv *priv,
-				  struct crashlog_entry *entry)
+				  struct crashlog_entry *entry,
+				  struct resource *header_res)
 {
-	struct resource *res = entry->header_res;
 	int ret;
 
-	pmt_crashlog_populate_header(entry->disc_table, &entry->header);
-
-	/* Local access and BARID only for now */
-	switch (entry->header.access_type) {
-	case ACCESS_LOCAL:
-		dev_info(priv->dev, "access_type: LOCAL\n");
-		if (entry->header.bir) {
-			dev_err(priv->dev,
-				"Unsupported BAR index %d for access type %d\n",
-				entry->header.bir, entry->header.access_type);
-			return -EINVAL;
-		}
-
-		entry->crashlog_data = res->start + resource_size(res) +
-				       entry->header.base_offset;
-		break;
-
-	case ACCESS_BARID:
-		dev_info(priv->dev, "access_type: BARID\n");
-		entry->crashlog_data =
-			priv->parent->resource[entry->header.bir].start +
-			entry->header.base_offset;
-		break;
-
-	default:
-		dev_err(priv->dev, "Unsupported access type %d\n",
-			entry->header.access_type);
-		return -EINVAL;
-	}
+	pmt_populate_header(PMT_CAP_CRASHLOG, entry->disc_table,
+			    &entry->header);
 
-	dev_info(priv->dev, "crashlod_data address: 0x%lx\n", entry->crashlog_data);
+	ret = pmt_get_base_address(priv->dev, &entry->header, header_res,
+				   &entry->crashlog_data);
+	if (ret)
+		return ret;
 
 	entry->crashlog_data_size = entry->header.size * 4;
 
-	if (entry->header.crash_type != CRASH_TYPE_OOBMSM) {
+	if (entry->header.type != CRASH_TYPE_OOBMSM) {
 		dev_err(priv->dev, "Unsupported crashlog header type %d\n",
-			entry->header.crash_type);
+			entry->header.type);
 		return -EINVAL;
 	}
 
-	if (entry->header.version != 0) {
+	if (entry->header.crashlog_version != 0) {
 		dev_err(priv->dev, "Unsupported version value %d\n",
-			entry->header.version);
+			entry->header.crashlog_version);
 		return -EINVAL;
 	}
 
@@ -506,17 +434,17 @@ static int pmt_crashlog_probe(struct platform_device *pdev)
 
 	for (i = 0, entry = priv->entry; i < pdev->num_resources;
 	     i++, entry++) {
+		struct resource *res;
 		int ret;
 
-		entry->header_res = platform_get_resource(pdev, IORESOURCE_MEM,
-							  i);
-		if (!entry->header_res) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!res) {
 			pmt_crashlog_remove_entries(priv);
 			return -ENODEV;
 		}
 
 		dev_info(&pdev->dev, "%d res start: 0x%llx, end 0x%llx\n", i,
-			 entry->header_res->start, entry->header_res->end);
+			 res->start, res->end);
 
 		entry->disc_table = devm_platform_ioremap_resource(pdev, i);
 		if (IS_ERR(entry->disc_table)) {
@@ -524,7 +452,7 @@ static int pmt_crashlog_probe(struct platform_device *pdev)
 			return PTR_ERR(entry->disc_table);
 		}
 
-		ret = pmt_crashlog_add_entry(priv, entry);
+		ret = pmt_crashlog_add_entry(priv, entry, res);
 		if (ret) {
 			pmt_crashlog_remove_entries(priv);
 			return ret;
diff --git a/drivers/platform/x86/intel_pmt_telemetry.c b/drivers/platform/x86/intel_pmt_telemetry.c
index adf9f156fe98..c3751baf8772 100644
--- a/drivers/platform/x86/intel_pmt_telemetry.c
+++ b/drivers/platform/x86/intel_pmt_telemetry.c
@@ -20,23 +20,11 @@
 #include <linux/uaccess.h>
 #include <linux/xarray.h>
 
+#include "intel_pmt_core.h"
 #include "intel_pmt_telem.h"
 
 #define TELEM_DEV_NAME		"pmt_telemetry"
 
-/* Telemetry access types */
-#define TELEM_ACCESS_FUTURE	1
-#define TELEM_ACCESS_BARID	2
-#define TELEM_ACCESS_LOCAL	3
-
-#define TELEM_GUID_OFFSET	0x4
-#define TELEM_BASE_OFFSET	0x8
-#define TELEM_TBIR_MASK		GENMASK(2, 0)
-#define TELEM_ACCESS(v)		((v) & GENMASK(3, 0))
-#define TELEM_TYPE(v)		(((v) & GENMASK(7, 4)) >> 4)
-/* size is in bytes */
-#define TELEM_SIZE(v)		(((v) & GENMASK(27, 12)) >> 10)
-
 #define TELEM_XA_START		1
 #define TELEM_XA_MAX		INT_MAX
 #define TELEM_XA_LIMIT		XA_LIMIT(TELEM_XA_START, TELEM_XA_MAX)
@@ -54,7 +42,7 @@ static BLOCKING_NOTIFIER_HEAD(telem_notifier);
 
 struct telem_endpoint {
 	struct pci_dev			*parent;
-	struct telem_header		header;
+	struct pmt_header		header;
 	void __iomem			*base;
 	struct resource			res;
 	bool				present;
@@ -64,9 +52,9 @@ struct telem_endpoint {
 struct pmt_telem_priv;
 
 struct pmt_telem_entry {
-	struct pmt_telem_priv		*priv;
 	struct telem_endpoint		*ep;
-	struct telem_header		header;
+	struct pmt_telem_priv		*priv;
+	struct pmt_header		header;
 	unsigned long			base_addr;
 	void __iomem			*disc_table;
 	struct cdev			cdev;
@@ -281,7 +269,12 @@ int pmt_telem_get_endpoint_info(int devid,
 	}
 
 	info->pdev = ep->parent;
-	info->header = ep->header;
+	info->header.access_type = ep->header.access_type;
+	info->header.telem_type = ep->header.type;
+	info->header.size = ep->header.size;
+	info->header.guid = ep->header.guid;
+	info->header.base_offset = ep->header.base_offset;
+	info->header.tbir = ep->header.bir;
 
 unlock:
 	mutex_unlock(&list_lock);
@@ -383,20 +376,6 @@ EXPORT_SYMBOL(pmt_telem_unregister_notifier);
 /*
  * driver initialization
  */
-static const struct pci_device_id pmt_telem_early_client_pci_ids[] = {
-	{ PCI_VDEVICE(INTEL, 0x9a0d) }, /* TGL */
-	{ PCI_VDEVICE(INTEL, 0x490e) }, /* DG1 */
-	{ PCI_VDEVICE(INTEL, 0x467d) }, /* ADL */
-	{ }
-};
-
-static bool pmt_telem_is_early_client_hw(struct device *dev)
-{
-	struct pci_dev *parent = to_pci_dev(dev->parent);
-
-	return !!pci_match_id(pmt_telem_early_client_pci_ids, parent);
-}
-
 static int pmt_telem_create_dev(struct pmt_telem_priv *priv,
 				struct pmt_telem_entry *entry)
 {
@@ -475,83 +454,22 @@ static int pmt_telem_add_endpoint(struct pmt_telem_priv *priv,
 	return err;
 }
 
-static void pmt_telem_populate_header(void __iomem *disc_offset,
-				      struct telem_header *header)
-{
-	header->access_type = TELEM_ACCESS(readb(disc_offset));
-	header->telem_type = TELEM_TYPE(readb(disc_offset));
-	header->size = TELEM_SIZE(readl(disc_offset));
-	header->guid = readl(disc_offset + TELEM_GUID_OFFSET);
-	header->base_offset = readl(disc_offset + TELEM_BASE_OFFSET);
-
-	/*
-	 * For non-local access types the lower 3 bits of base offset
-	 * contains the index of the base address register where the
-	 * telemetry can be found.
-	 */
-	header->tbir = header->base_offset & TELEM_TBIR_MASK;
-	header->base_offset ^= header->tbir;
-}
-
 static int pmt_telem_add_entry(struct pmt_telem_priv *priv,
 			       struct pmt_telem_entry *entry,
 			       struct resource *header_res)
 {
-	struct pci_dev *pci_dev = to_pci_dev(priv->dev->parent);
-	struct telem_header *header = &entry->header;
-	struct device *dev = &pci_dev->dev;
 	int ret;
 
-	pmt_telem_populate_header(entry->disc_table, &entry->header);
-
-	/* Ony Local access and BARID access modes only for now */
-	switch (entry->header.access_type) {
-	case TELEM_ACCESS_LOCAL:
-		if (header->tbir) {
-			dev_err(priv->dev,
-				"Unsupported BAR index %d for access type %d\n",
-				header->tbir, header->access_type);
-			return -EINVAL;
-		}
-
-		/*
-		 * For access_type LOCAL, the base address is as follows:
-		 * base address = header address + header length + base offset
-		 */
-		entry->base_addr = header_res->start + resource_size(header_res) +
-				   header->base_offset;
+	pmt_populate_header(PMT_CAP_TELEM, entry->disc_table, &entry->header);
 
-		/*
-		 * XXX: For Intel internal use only to address hardware bug
-		 * that will be fixed in production. In the bug, local refers to
-		 * an address in the same bar the header but at a fixed instead
-		 * of relative offset.
-		 */
-                if (pmt_telem_is_early_client_hw(dev)) {
-                        unsigned long pf_addr, mask;
-
-                        dev_info(dev, "applying quirk for local base address\n");
-                        pf_addr = PFN_PHYS(PHYS_PFN(header_res->start)) +
-                                           header->base_offset;
-                        mask = ~GENMASK(fls(header->base_offset), 0);
-                        entry->base_addr = (pf_addr & mask) + header->base_offset;
-                }
-		break;
-
-	case TELEM_ACCESS_BARID:
-		entry->base_addr = pci_dev->resource[header->tbir].start +
-				   header->base_offset;
-		break;
-
-	default:
-		dev_err(dev, "Unsupported access type %d\n",
-			entry->header.access_type);
-		return -EINVAL;
-	}
+	ret = pmt_get_base_address(priv->dev, &entry->header, header_res,
+				   &entry->base_addr);
+	if (ret)
+		return ret;
 
 	ret = alloc_chrdev_region(&entry->devt, 0, 1, TELEM_DEV_NAME);
 	if (ret) {
-		dev_err(dev, "PMT telemetry chrdev_region error: %d\n", ret);
+		dev_err(priv->dev, "PMT telemetry chrdev_region error: %d\n", ret);
 		return ret;
 	}
 
@@ -588,7 +506,7 @@ static bool pmt_telem_region_overlaps(struct platform_device *pdev,
 {
 	u32 guid;
 
-	guid = readl(disc_table + TELEM_GUID_OFFSET);
+	guid = readl(disc_table + GUID_OFFSET);
 
 	return guid == TELEM_CLIENT_FIXED_BLOCK_GUID;
 }
@@ -642,7 +560,7 @@ static int pmt_telem_probe(struct platform_device *pdev)
 			return PTR_ERR(entry->disc_table);
 		}
 
-		if (pmt_telem_is_early_client_hw(&pdev->dev) &&
+		if (pmt_is_early_client_hw(&pdev->dev) &&
 		    pmt_telem_region_overlaps(pdev, entry->disc_table))
 			continue;
 
diff --git a/drivers/platform/x86/intel_pmt_watcher.c b/drivers/platform/x86/intel_pmt_watcher.c
index 4bfafe6bc899..6c8e876ca2dc 100644
--- a/drivers/platform/x86/intel_pmt_watcher.c
+++ b/drivers/platform/x86/intel_pmt_watcher.c
@@ -18,6 +18,8 @@
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 
+#include "intel_pmt_core.h"
+
 #define DRV_NAME		"pmt_watcher"
 #define SMPLR_DEV_PREFIX	"smplr"
 #define TRCR_DEV_PREFIX		"trcr"
@@ -33,20 +35,6 @@
 #define MODE_ONESHOT		2
 #define MODE_SHARED		3
 
-/* Watcher access types */
-#define ACCESS_FUTURE		1
-#define ACCESS_BARID		2
-#define ACCESS_LOCAL		3
-
-/* Common Header */
-#define GUID_OFFSET		0x4
-#define BASE_OFFSET		0x8
-#define GET_ACCESS(v)		((v) & GENMASK(3, 0))
-#define GET_TYPE(v)		(((v) & GENMASK(11, 4)) >> 4)
-#define GET_SIZE(v)		(((v) & GENMASK(27, 12)) >> 10)
-#define GET_IRQ_EN(v)		((v) & BIT(23))
-#define GET_BIR(v)		((v) & 0x7)
-
 /* Common Config fields */
 #define GET_MODE(v)		((v) & 0x3)
 #define MODE_MASK		GENMASK(1, 0)
@@ -107,16 +95,6 @@ static const char * const tracer_destination[] = {
 static DEFINE_IDA(sampler_devid_ida);
 static DEFINE_IDA(tracer_devid_ida);
 
-struct watcher_header {
-	u32	access_type;
-	u32	watcher_type;
-	u32	size;
-	bool	irq_support;
-	u32	guid;
-	u32	base_offset;
-	u8	bir;
-};
-
 struct watcher_config {
 	u32		control;
 	u32		period;
@@ -130,8 +108,7 @@ struct pmt_watcher_priv;
 
 struct watcher_entry {
 	struct pmt_watcher_priv	*priv;
-	struct watcher_header	header;
-	struct resource		*header_res;
+	struct pmt_header	header;
 	void __iomem		*disc_table;
 	struct watcher_config	config;
 	void __iomem		*cfg_base;
@@ -158,26 +135,26 @@ struct pmt_watcher_priv {
 
 static inline bool pmt_watcher_is_sampler(struct watcher_entry *entry)
 {
-	return entry->header.watcher_type == TYPE_SAMPLER1 ||
-	       entry->header.watcher_type == TYPE_SAMPLER2;
+	return entry->header.type == TYPE_SAMPLER1 ||
+	       entry->header.type == TYPE_SAMPLER2;
 }
 
 static inline bool pmt_watcher_is_tracer(struct watcher_entry *entry)
 {
-	return entry->header.watcher_type == TYPE_TRACER1 ||
-	       entry->header.watcher_type == TYPE_TRACER2;
+	return entry->header.type == TYPE_TRACER1 ||
+	       entry->header.type == TYPE_TRACER2;
 }
 
 static inline bool pmt_watcher_select_limited(struct watcher_entry *entry)
 {
 	return pmt_watcher_is_sampler(entry) ||
-	       entry->header.watcher_type == TYPE_TRACER2;
+	       entry->header.type == TYPE_TRACER2;
 }
 
 static inline bool pmt_watcher_is_type2(struct watcher_entry *entry)
 {
-	return entry->header.watcher_type == TYPE_SAMPLER2 ||
-	       entry->header.watcher_type == TYPE_TRACER2;
+	return entry->header.type == TYPE_SAMPLER2 ||
+	       entry->header.type == TYPE_TRACER2;
 }
 
 /*
@@ -880,16 +857,6 @@ pmt_watcher_create_entry(struct pmt_watcher_priv *priv,
 			 struct watcher_entry *entry)
 {
 	int vector_sz_in_bytes = entry->header.size - entry->vector_start;
-	struct resource res;
-
-	res.start = pci_resource_start(priv->parent, entry->header.bir) +
-		    entry->header.base_offset;
-	res.end = res.start + entry->header.size - 1;
-	res.flags = IORESOURCE_MEM;
-
-	entry->cfg_base = devm_ioremap_resource(priv->dev, &res);
-	if (IS_ERR(entry->cfg_base))
-		return PTR_ERR(entry->cfg_base);
 
 	/*
 	 * If there is already some request that is stuck in the hardware
@@ -921,51 +888,6 @@ pmt_watcher_create_entry(struct pmt_watcher_priv *priv,
 	if (pmt_watcher_is_sampler(entry)) {
 		unsigned int sample_limit;
 
-		switch (entry->header.access_type) {
-		case ACCESS_LOCAL:
-			dev_info(priv->dev, "access_type: LOCAL\n");
-			if (entry->header.bir) {
-				dev_err(priv->dev,
-					"Unsupported BAR index %d for access type %d\n",
-					entry->header.bir, entry->header.access_type);
-				return -EINVAL;
-			}
-
-			entry->smplr_data_start = entry->header_res->start +
-						  resource_size(entry->header_res) +
-						  readl(entry->cfg_base);
-#if 0
-		/*
-		 * XXX: For Intel internal use only to address hardware bug
-		 * that will be fixed in production
-		 */
-		if (pmt_watcher_is_early_client_hw(priv->dev)) {
-			unsigned long pf_addr, mask;
-
-			pf_addr = PFN_PHYS(PHYS_PFN(res->start)) +
-					   entry->header.base_offset;
-
-			mask = ~GENMASK(fls(entry->header.base_offset), 0);
-			entry->base_addr = (pf_addr & mask) +
-					   entry->header.base_offset;
-		}
-#endif
-			break;
-
-		case ACCESS_BARID:
-			dev_info(priv->dev, "access_type: BARID\n");
-			entry->smplr_data_start = pci_resource_start(priv->parent,
-							     entry->header.bir) +
-						  readl(entry->cfg_base);
-			break;
-
-		default:
-			dev_err(priv->dev, "Unsupported access type %d\n",
-				entry->header.access_type);
-			return -EINVAL;
-		}
-		dev_info(priv->dev, "sampler buffer start: 0x%lx\n", entry->smplr_data_start);
-
 		/*
 		 * For sampler only, get the physical address and size of
 		 * the result buffer for the mmap as well as the vector
@@ -1008,32 +930,29 @@ pmt_watcher_create_entry(struct pmt_watcher_priv *priv,
 	return 0;
 }
 
-static void
-pmt_watcher_populate_header(void __iomem *disc_offset,
-			    struct watcher_header *header)
-{
-	header->access_type = GET_ACCESS(readb(disc_offset));
-	header->watcher_type = GET_TYPE(readb(disc_offset));
-	header->size = GET_SIZE(readl(disc_offset));
-	header->irq_support = GET_IRQ_EN(readl(disc_offset));
-	header->guid = readl(disc_offset + GUID_OFFSET);
-	header->base_offset = readl(disc_offset + BASE_OFFSET);
-
-	/*
-	 * For non-local access types the lower 3 bits of base offset
-	 * contains the index of the base address register where the
-	 * watcher can be found.
-	 */
-	header->bir = GET_BIR(header->base_offset);
-	header->base_offset ^= header->bir;
-}
-
 static int pmt_watcher_add_entry(struct pmt_watcher_priv *priv,
-				 struct watcher_entry *entry)
+				 struct watcher_entry *entry,
+				 struct resource *header_res)
 {
+	unsigned long base_address;
+	struct resource res;
 	int ret;
 
-	pmt_watcher_populate_header(entry->disc_table, &entry->header);
+	pmt_populate_header(PMT_CAP_WATCHER, entry->disc_table,
+			    &entry->header);
+
+	ret = pmt_get_base_address(priv->dev, &entry->header,
+				   header_res, &base_address);
+	if (ret)
+		return ret;
+
+	res.start = base_address;
+	res.end = res.start + entry->header.size - 1;
+	res.flags = IORESOURCE_MEM;
+
+	entry->cfg_base = devm_ioremap_resource(priv->dev, &res);
+	if (IS_ERR(entry->cfg_base))
+		return PTR_ERR(entry->cfg_base);
 
 	if (pmt_watcher_is_tracer(entry)) {
 		entry->ida = &tracer_devid_ida;
@@ -1047,8 +966,8 @@ static int pmt_watcher_add_entry(struct pmt_watcher_priv *priv,
 		entry->stream_uid_offset = -1;
 	}
 
-	/* Add quirks related to TGL part */
-	if (priv->parent->device == 0x9a0d) {
+	/* Add quirks related to client parts */
+	if (pmt_is_early_client_hw(priv->dev)) {
 		/* tracer for TGL does not have support for stream UID */
 		entry->stream_uid_offset = -1;
 		/* strip section that would have been stream UID */
@@ -1061,7 +980,7 @@ static int pmt_watcher_add_entry(struct pmt_watcher_priv *priv,
 		 * Add offset for watcher type to account for type1 vs
 		 * type2 values.
 		 */
-		entry->header.watcher_type += TYPE_TRACER1;
+		entry->header.type += TYPE_TRACER1;
 	}
 
 	ret = pmt_watcher_create_entry(priv, entry);
@@ -1089,7 +1008,7 @@ static void pmt_watcher_remove_entries(struct pmt_watcher_priv *priv)
 
 	for (i = 0; i < priv->num_entries; i++) {
 		device_destroy(&pmt_watcher_class, priv->entry[i].devt);
-		if (pmt_watcher_is_sampler(priv->entry))
+		if (pmt_watcher_is_sampler(&priv->entry[i]))
 			cdev_del(&priv->entry[i].cdev);
 
 		unregister_chrdev_region(priv->entry[i].devt, 1);
@@ -1119,17 +1038,17 @@ static int pmt_watcher_probe(struct platform_device *pdev)
 
 	for (i = 0, entry = priv->entry; i < pdev->num_resources;
 	     i++, entry++) {
+		struct resource *res;
 		int ret;
 
-		entry->header_res = platform_get_resource(pdev, IORESOURCE_MEM,
-							  i);
-		if (!entry->header_res) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!res) {
 			pmt_watcher_remove_entries(priv);
 			return -ENODEV;
 		}
 
 		dev_info(&pdev->dev, "%d res start: 0x%llx, end 0x%llx\n", i,
-			 entry->header_res->start, entry->header_res->end);
+			 res->start, res->end);
 
 		entry->disc_table = devm_platform_ioremap_resource(pdev, i);
 		if (IS_ERR(entry->disc_table)) {
@@ -1137,7 +1056,7 @@ static int pmt_watcher_probe(struct platform_device *pdev)
 			return PTR_ERR(entry->disc_table);
 		}
 
-		ret = pmt_watcher_add_entry(priv, entry);
+		ret = pmt_watcher_add_entry(priv, entry, res);
 		if (ret) {
 			pmt_watcher_remove_entries(priv);
 			return ret;
-- 
2.27.0

