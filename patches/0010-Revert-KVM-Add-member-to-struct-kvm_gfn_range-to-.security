From ee8cf845eceaf32539f79e5b0fc8f22863001dd9 Mon Sep 17 00:00:00 2001
From: "Baoli.Zhang" <baoli.zhang@intel.com>
Date: Mon, 14 Jul 2025 16:35:10 +0800
Subject: [PATCH 010/147] Revert "KVM: Add member to struct kvm_gfn_range to
 indicate private/shared"

This reverts commit 3d962ec543e597b11df159283d31ab91d03ee488.

Signed-off-by: Baoli.Zhang <baoli.zhang@intel.com>
---
 arch/x86/kvm/mmu/mmu.c   |  6 ------
 include/linux/kvm_host.h |  6 ------
 virt/kvm/guest_memfd.c   |  2 --
 virt/kvm/kvm_main.c      | 14 --------------
 4 files changed, 28 deletions(-)

diff --git a/arch/x86/kvm/mmu/mmu.c b/arch/x86/kvm/mmu/mmu.c
index 4943732e07cd..9242c0649adf 100644
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@ -7633,12 +7633,6 @@ bool kvm_arch_pre_set_memory_attributes(struct kvm *kvm,
 	if (WARN_ON_ONCE(!kvm_arch_has_private_mem(kvm)))
 		return false;
 
-	/* Unmap the old attribute page. */
-	if (range->arg.attributes & KVM_MEMORY_ATTRIBUTE_PRIVATE)
-		range->attr_filter = KVM_FILTER_SHARED;
-	else
-		range->attr_filter = KVM_FILTER_PRIVATE;
-
 	return kvm_unmap_gfn_range(kvm, range);
 }
 
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index 2e836d44f738..15206450929d 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -260,17 +260,11 @@ union kvm_mmu_notifier_arg {
 	unsigned long attributes;
 };
 
-enum kvm_gfn_range_filter {
-	KVM_FILTER_SHARED		= BIT(0),
-	KVM_FILTER_PRIVATE		= BIT(1),
-};
-
 struct kvm_gfn_range {
 	struct kvm_memory_slot *slot;
 	gfn_t start;
 	gfn_t end;
 	union kvm_mmu_notifier_arg arg;
-	enum kvm_gfn_range_filter attr_filter;
 	bool may_block;
 };
 bool kvm_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range);
diff --git a/virt/kvm/guest_memfd.c b/virt/kvm/guest_memfd.c
index bb062d3d2457..8f079a61a56d 100644
--- a/virt/kvm/guest_memfd.c
+++ b/virt/kvm/guest_memfd.c
@@ -118,8 +118,6 @@ static void kvm_gmem_invalidate_begin(struct kvm_gmem *gmem, pgoff_t start,
 			.end = slot->base_gfn + min(pgoff + slot->npages, end) - pgoff,
 			.slot = slot,
 			.may_block = true,
-			/* guest memfd is relevant to only private mappings. */
-			.attr_filter = KVM_FILTER_PRIVATE,
 		};
 
 		if (!found_memslot) {
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index aba4078ae225..9983b6f05a0f 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -632,11 +632,6 @@ static __always_inline kvm_mn_ret_t __kvm_handle_hva_range(struct kvm *kvm,
 			 */
 			gfn_range.arg = range->arg;
 			gfn_range.may_block = range->may_block;
-			/*
-			 * HVA-based notifications aren't relevant to private
-			 * mappings as they don't have a userspace mapping.
-			 */
-			gfn_range.attr_filter = KVM_FILTER_SHARED;
 
 			/*
 			 * {gfn(page) | page intersects with [hva_start, hva_end)} =
@@ -2459,14 +2454,6 @@ static __always_inline void kvm_handle_gfn_range(struct kvm *kvm,
 	gfn_range.arg = range->arg;
 	gfn_range.may_block = range->may_block;
 
-	/*
-	 * If/when KVM supports more attributes beyond private .vs shared, this
-	 * _could_ set KVM_FILTER_{SHARED,PRIVATE} appropriately if the entire target
-	 * range already has the desired private vs. shared state (it's unclear
-	 * if that is a net win).  For now, KVM reaches this point if and only
-	 * if the private flag is being toggled, i.e. all mappings are in play.
-	 */
-
 	for (i = 0; i < kvm_arch_nr_memslot_as_ids(kvm); i++) {
 		slots = __kvm_memslots(kvm, i);
 
@@ -2523,7 +2510,6 @@ static int kvm_vm_set_mem_attributes(struct kvm *kvm, gfn_t start, gfn_t end,
 	struct kvm_mmu_notifier_range pre_set_range = {
 		.start = start,
 		.end = end,
-		.arg.attributes = attributes,
 		.handler = kvm_pre_set_memory_attributes,
 		.on_lock = kvm_mmu_invalidate_begin,
 		.flush_on_ret = true,
-- 
2.34.1

