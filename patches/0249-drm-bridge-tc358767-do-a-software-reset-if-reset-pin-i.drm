From fcfc42a5e7f923d7392723ff3cb1a700e3f0f102 Mon Sep 17 00:00:00 2001
From: Lucas Stach <l.stach@pengutronix.de>
Date: Thu, 27 Jun 2019 10:59:58 +0200
Subject: [PATCH 0249/1606] drm/bridge: tc358767: do a software reset if reset
 pin isn't connected

To get the chip into the expected state, even when the hardware reset pin
isn't connected, do a software reset in this case. It isn't as thorough as
the hardware reset, as the I2C communication block can not be reset for
obvious reasons, but it's getting the chip into a defined state.

Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190627085958.28331-1-l.stach@pengutronix.de
---
 drivers/gpu/drm/bridge/tc358767.c | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)

diff --git a/drivers/gpu/drm/bridge/tc358767.c b/drivers/gpu/drm/bridge/tc358767.c
index e1ce4954e6af..42f03a985ac0 100644
--- a/drivers/gpu/drm/bridge/tc358767.c
+++ b/drivers/gpu/drm/bridge/tc358767.c
@@ -80,6 +80,13 @@
 #define DP0_VIDSRC_DSI_RX		(1 << 0)
 #define DP0_VIDSRC_DPI_RX		(2 << 0)
 #define DP0_VIDSRC_COLOR_BAR		(3 << 0)
+#define SYSRSTENB		0x050c
+#define ENBI2C				(1 << 0)
+#define ENBLCD0				(1 << 2)
+#define ENBBM				(1 << 3)
+#define ENBDSIRX			(1 << 4)
+#define ENBREG				(1 << 5)
+#define ENBHDCP				(1 << 8)
 #define GPIOM			0x0540
 #define GPIOC			0x0544
 #define GPIOO			0x0548
@@ -1597,6 +1604,22 @@ static int tc_probe(struct i2c_client *client, const struct i2c_device_id *id)
 
 	tc->assr = (tc->rev == 0x6601); /* Enable ASSR for eDP panels */
 
+	if (!tc->reset_gpio) {
+		/*
+		 * If the reset pin isn't present, do a software reset. It isn't
+		 * as thorough as the hardware reset, as we can't reset the I2C
+		 * communication block for obvious reasons, but it's getting the
+		 * chip into a defined state.
+		 */
+		regmap_update_bits(tc->regmap, SYSRSTENB,
+				ENBLCD0 | ENBBM | ENBDSIRX | ENBREG | ENBHDCP,
+				0);
+		regmap_update_bits(tc->regmap, SYSRSTENB,
+				ENBLCD0 | ENBBM | ENBDSIRX | ENBREG | ENBHDCP,
+				ENBLCD0 | ENBBM | ENBDSIRX | ENBREG | ENBHDCP);
+		usleep_range(5000, 10000);
+	}
+
 	if (tc->hpd_pin >= 0) {
 		u32 lcnt_reg = tc->hpd_pin == 0 ? INT_GP0_LCNT : INT_GP1_LCNT;
 		u32 h_lc = INT_GPIO_H(tc->hpd_pin) | INT_GPIO_LC(tc->hpd_pin);
-- 
2.17.1

