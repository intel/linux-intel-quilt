From 6fc5139db2264b0fcddfb6f62f382638993a024c Mon Sep 17 00:00:00 2001
From: Reinette Chatre <reinette.chatre@intel.com>
Date: Fri, 2 Nov 2018 13:46:50 -0700
Subject: [PATCH 12/13] x86/resctrl: Recognize 0x8C for pseudo-locking support

0x8C is added to the list of platforms for which Cache
Pseudo-Locking is supported. The assumption here is that it supports the
same prefetch disable register and bits as Skylake and also the same
performance events.

Cache pseudo-locking is only supported on 0x8C platforms with an
inclusive cache that support L2 as well as L3 CAT. To ensure only these
platforms are enabled a test specific to this requirement used.

Signed-off-by: Reinette Chatre <reinette.chatre@intel.com>
---
 arch/x86/kernel/cpu/resctrl/pseudo_lock.c | 25 +++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/arch/x86/kernel/cpu/resctrl/pseudo_lock.c b/arch/x86/kernel/cpu/resctrl/pseudo_lock.c
index b4fff88572bd..c777946cb40a 100644
--- a/arch/x86/kernel/cpu/resctrl/pseudo_lock.c
+++ b/arch/x86/kernel/cpu/resctrl/pseudo_lock.c
@@ -74,7 +74,9 @@ static u64 get_prefetch_disable_bits(void)
 		return 0;
 
 	switch (boot_cpu_data.x86_model) {
+	/* Assume that 0x8C follows register use of Skylake Architecture */
 	case INTEL_FAM6_BROADWELL_X:
+	case 0x8C:
 		/*
 		 * SDM defines bits of MSR_MISC_FEATURE_CONTROL register
 		 * as:
@@ -972,6 +974,22 @@ int rdtgroup_locksetup_enter(struct rdtgroup *rdtgrp)
 		return -EINVAL;
 	}
 
+	/*
+	 * Add extra check for 0x8C platform until all SKUs are
+	 * understood.
+	 * Prefetch disable bits will be known but only
+	 * some of its SKUs support Cache Pseudo-Locking. Goal is to have
+	 * this be determined generically (L2 CAT and L3 CAT supported and
+	 * cache is inclusive) but some SKUs that do not support cache
+	 * pseudo-locking only support L2 CAT, which is
+	 * a valid resource to pseudo-lock.
+	 */
+	if (boot_cpu_data.x86_model == 0x8C &&
+	    !get_cache_inclusive(0, 3)) {
+		rdt_last_cmd_puts("Pseudo-locking not supported\n");
+		return -EINVAL;
+	}
+
 	if (rdtgroup_monitor_in_progress(rdtgrp)) {
 		rdt_last_cmd_puts("Monitoring in progress\n");
 		return -EINVAL;
@@ -1342,6 +1360,7 @@ static int measure_l2_residency(void *_plr)
 	switch (boot_cpu_data.x86_model) {
 	case INTEL_FAM6_ATOM_GOLDMONT:
 	case INTEL_FAM6_ATOM_GOLDMONT_PLUS:
+	case 0x8C:
 		perf_miss_attr.config = X86_CONFIG(.event = 0xd1,
 						   .umask = 0x10);
 		perf_hit_attr.config = X86_CONFIG(.event = 0xd1,
@@ -1386,6 +1405,12 @@ static int measure_l3_residency(void *_plr)
 		perf_miss_attr.config = X86_CONFIG(.event = 0x2e,
 						   .umask = 0x41);
 		break;
+	case 0x8C:
+		perf_miss_attr.config = X86_CONFIG(.event = 0xd1,
+						   .umask = 0x20);
+		perf_hit_attr.config = X86_CONFIG(.event = 0xd1,
+						  .umask = 0x4);
+		break;
 	default:
 		goto out;
 	}
-- 
2.17.1

