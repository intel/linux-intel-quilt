From 1e684afe4e72ca658d8ef92c8fb304fb9e1b56a3 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 2 Aug 2019 00:36:16 +0100
Subject: [PATCH 1050/1606] drm/i915/pmu: Atomically acquire the gt_pm wakeref

Currently, we only sample if the intel_gt is awake, but we acquire our
own runtime_pm wakeref. Since intel_gt has transitioned to tracking its
own wakeref, we can atomically test and acquire that wakeref instead.

v2: Take engine->wakeref for engine sampling

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190801233616.23007-1-chris@chris-wilson.co.uk
---
 drivers/gpu/drm/i915/gt/intel_gt_pm.h |  8 +++++-
 drivers/gpu/drm/i915/i915_pmu.c       | 40 ++++++++++++---------------
 2 files changed, 24 insertions(+), 24 deletions(-)

diff --git a/drivers/gpu/drm/i915/gt/intel_gt_pm.h b/drivers/gpu/drm/i915/gt/intel_gt_pm.h
index 527894fe1345..e8a18d4b27c9 100644
--- a/drivers/gpu/drm/i915/gt/intel_gt_pm.h
+++ b/drivers/gpu/drm/i915/gt/intel_gt_pm.h
@@ -9,7 +9,8 @@
 
 #include <linux/types.h>
 
-struct intel_gt;
+#include "intel_gt_types.h"
+#include "intel_wakeref.h"
 
 enum {
 	INTEL_GT_UNPARK,
@@ -19,6 +20,11 @@ enum {
 void intel_gt_pm_get(struct intel_gt *gt);
 void intel_gt_pm_put(struct intel_gt *gt);
 
+static inline bool intel_gt_pm_get_if_awake(struct intel_gt *gt)
+{
+	return intel_wakeref_get_if_active(&gt->wakeref);
+}
+
 void intel_gt_pm_init_early(struct intel_gt *gt);
 
 void intel_gt_sanitize(struct intel_gt *gt, bool force);
diff --git a/drivers/gpu/drm/i915/i915_pmu.c b/drivers/gpu/drm/i915/i915_pmu.c
index e0e0180bca7c..c2e5f6d5c1e0 100644
--- a/drivers/gpu/drm/i915/i915_pmu.c
+++ b/drivers/gpu/drm/i915/i915_pmu.c
@@ -8,6 +8,8 @@
 #include <linux/pm_runtime.h>
 
 #include "gt/intel_engine.h"
+#include "gt/intel_engine_pm.h"
+#include "gt/intel_gt_pm.h"
 
 #include "i915_drv.h"
 #include "i915_pmu.h"
@@ -165,30 +167,26 @@ static void
 engines_sample(struct intel_gt *gt, unsigned int period_ns)
 {
 	struct drm_i915_private *i915 = gt->i915;
-	struct intel_uncore *uncore = gt->uncore;
 	struct intel_engine_cs *engine;
 	enum intel_engine_id id;
-	intel_wakeref_t wakeref;
-	unsigned long flags;
 
 	if ((i915->pmu.enable & ENGINE_SAMPLE_MASK) == 0)
 		return;
 
-	wakeref = 0;
-	if (READ_ONCE(gt->awake))
-		wakeref = intel_runtime_pm_get_if_in_use(&i915->runtime_pm);
-	if (!wakeref)
-		return;
-
-	spin_lock_irqsave(&uncore->lock, flags);
 	for_each_engine(engine, i915, id) {
 		struct intel_engine_pmu *pmu = &engine->pmu;
+		unsigned long flags;
 		bool busy;
 		u32 val;
 
+		if (!intel_engine_pm_get_if_awake(engine))
+			continue;
+
+		spin_lock_irqsave(&engine->uncore->lock, flags);
+
 		val = ENGINE_READ_FW(engine, RING_CTL);
 		if (val == 0) /* powerwell off => engine idle */
-			continue;
+			goto skip;
 
 		if (val & RING_WAIT)
 			add_sample(&pmu->sample[I915_SAMPLE_WAIT], period_ns);
@@ -209,10 +207,11 @@ engines_sample(struct intel_gt *gt, unsigned int period_ns)
 		}
 		if (busy)
 			add_sample(&pmu->sample[I915_SAMPLE_BUSY], period_ns);
-	}
-	spin_unlock_irqrestore(&uncore->lock, flags);
 
-	intel_runtime_pm_put(&i915->runtime_pm, wakeref);
+skip:
+		spin_unlock_irqrestore(&engine->uncore->lock, flags);
+		intel_engine_pm_put(engine);
+	}
 }
 
 static void
@@ -232,15 +231,10 @@ frequency_sample(struct intel_gt *gt, unsigned int period_ns)
 		u32 val;
 
 		val = i915->gt_pm.rps.cur_freq;
-		if (gt->awake) {
-			intel_wakeref_t wakeref;
-
-			with_intel_runtime_pm_if_in_use(&i915->runtime_pm,
-							wakeref) {
-				val = intel_uncore_read_notrace(uncore,
-								GEN6_RPSTAT1);
-				val = intel_get_cagf(i915, val);
-			}
+		if (intel_gt_pm_get_if_awake(gt)) {
+			val = intel_uncore_read_notrace(uncore, GEN6_RPSTAT1);
+			val = intel_get_cagf(i915, val);
+			intel_gt_pm_put(gt);
 		}
 
 		add_sample_mult(&pmu->sample[__I915_SAMPLE_FREQ_ACT],
-- 
2.17.1

