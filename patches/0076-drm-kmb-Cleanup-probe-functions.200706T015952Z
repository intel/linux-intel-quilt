From af95d58bc603ae973fcf3cc64412b2e447dbb5f7 Mon Sep 17 00:00:00 2001
From: Edmund Dea <edmund.j.dea@intel.com>
Date: Sat, 21 Sep 2019 11:28:37 -0700
Subject: [PATCH 076/131] drm/kmb: Cleanup probe functions

- Removed deprecated code blocks within probe functions
- In kmb_remove, unregister MIPI DSI host
- In kmb_probe, if kmb_load fails, then unregister MIPI DSI host
- Change kmb_dsi_host_bridge_init to return error codes using ERR_PTR
- Do clock intitialization earlier
- Rename kmb_drm_unbind to kmb_drm_unload.
- Get mmio info from device tree

Signed-off-by: Edmund Dea <edmund.j.dea@intel.com>
Signed-off-by: Anitha Chrisanthus <anitha.chrisanthus@intel.com>
---
 drivers/gpu/drm/kmb/kmb_drv.c | 336 +++++++++++++++++++---------------
 drivers/gpu/drm/kmb/kmb_drv.h |   1 +
 drivers/gpu/drm/kmb/kmb_dsi.c |  85 ++++-----
 3 files changed, 218 insertions(+), 204 deletions(-)

diff --git a/drivers/gpu/drm/kmb/kmb_drv.c b/drivers/gpu/drm/kmb/kmb_drv.c
index 8f535a3e3ec6..c7f978215957 100644
--- a/drivers/gpu/drm/kmb/kmb_drv.c
+++ b/drivers/gpu/drm/kmb/kmb_drv.c
@@ -50,18 +50,18 @@
 #include "kmb_dsi.h"
 
 #define DEBUG
+
 /*IRQ handler*/
 static irqreturn_t kmb_isr(int irq, void *arg);
 
 static struct clk *clk_lcd;
 static struct clk *clk_mipi;
 
-static int probe_deferred;
 struct drm_bridge *adv_bridge;
 
 static int kmb_display_clk_enable(void)
 {
-	int ret;
+	int ret = 0;
 
 	ret = clk_prepare_enable(clk_lcd);
 	if (ret) {
@@ -87,86 +87,142 @@ static int kmb_display_clk_disable(void)
 	return 0;
 }
 
+static void __iomem *kmb_map_mmio(struct platform_device *pdev, char *name)
+{
+	struct resource *res;
+	u32 size;
+	void __iomem *mem;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);
+	if (!res) {
+		DRM_ERROR("failed to get resource for %s\n", name);
+		return ERR_PTR(-ENOMEM);
+	}
+	size = resource_size(res);
+	if (!request_mem_region(res->start, size, name)) {
+		DRM_ERROR("failed to reserve %s registers\n", name);
+		return ERR_PTR(-ENOMEM);
+	}
+	mem = ioremap_nocache(res->start, size);
+	if (!mem) {
+		DRM_ERROR("failed to ioremap %s registers\n", name);
+		release_mem_region(res->start, size);
+		return ERR_PTR(-ENOMEM);
+	}
+	return mem;
+}
+
 static int kmb_load(struct drm_device *drm, unsigned long flags)
 {
 	struct kmb_drm_private *dev_p = drm->dev_private;
 	struct platform_device *pdev = to_platform_device(drm->dev);
-/*	struct drm_bridge *bridge;*/
-	/*struct resource *res;*/
 	/*u32 version;*/
-	int ret;
-/*	struct device_node *encoder_node;*/
-
-	/* TBD - not sure if clock_get needs to be called here */
-	/*
-	 *dev_p->clk = devm_clk_get(drm->dev, "pxlclk");
-	 *if (IS_ERR(dev_p->clk))
-	 *	return PTR_ERR(dev_p->clk);
-	 */
-	/*
-	 * TBD call this in the future when device tree is ready,
-	 * use hardcoded value for now
-	 */
-	/*
-	 * res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	 * dev_p->lcd_mmio = devm_ioremap_resource(drm->dev, res);
-
-	 *if (IS_ERR(dev_p->lcd_mmio)) {
-	 *	DRM_ERROR("failed to map control registers area\n");
-	 *	ret = PTR_ERR(dev_p->lcd_mmio);
-	 *	dev_p->lcd_mmio = NULL;
-	 *	return ret;
-	 *}
-	 */
-	/* LCD mmio */
-	probe_deferred = 1;
+	int ret = 0;
 
-	if (!request_mem_region(LCD_BASE_ADDR, LCD_MMIO_SIZE, "kmb-lcd")) {
-		DRM_ERROR("failed to reserve LCD registers\n");
-		return -ENOMEM;
-	}
-	dev_p->lcd_mmio = ioremap_nocache(LCD_BASE_ADDR, LCD_MMIO_SIZE);
-	if (!dev_p->lcd_mmio) {
+	/* Map LCD MMIO registers */
+	dev_p->lcd_mmio = kmb_map_mmio(pdev, "lcd_regs");
+	if (IS_ERR(dev_p->lcd_mmio)) {
 		DRM_ERROR("failed to map LCD registers\n");
 		return -ENOMEM;
 	}
-	/* Mipi mmio */
-	if (!request_mem_region(MIPI_BASE_ADDR, MIPI_MMIO_SIZE, "kmb-mipi")) {
-		DRM_ERROR("failed to reserve MIPI registers\n");
+
+	/* Map MIPI MMIO registers */
+	dev_p->mipi_mmio = kmb_map_mmio(pdev, "mipi_regs");
+
+	if (IS_ERR(dev_p->mipi_mmio)) {
+		DRM_ERROR("failed to map MIPI registers\n");
 		iounmap(dev_p->lcd_mmio);
 		return -ENOMEM;
 	}
-	dev_p->mipi_mmio = ioremap_nocache(MIPI_BASE_ADDR, MIPI_MMIO_SIZE);
-	if (!dev_p->mipi_mmio) {
-		DRM_ERROR("failed to map MIPI registers\n");
+
+	/* This is only for MIPI_TX_MSS_LCD_MIPI_CFG and MSS_CAM_CLK_CTRL
+	 * register
+	 */
+	dev_p->msscam_mmio = kmb_map_mmio(pdev, "msscam_regs");
+	if (IS_ERR(dev_p->msscam_mmio)) {
+		DRM_ERROR("failed to map MSSCAM registers\n");
 		iounmap(dev_p->lcd_mmio);
+		iounmap(dev_p->mipi_mmio);
 		return -ENOMEM;
 	}
-	/*this is only for MIPI_TX_MSS_LCD_MIPI_CFG register */
-	if (!dev_p->msscam_mmio) {
-		dev_p->msscam_mmio = ioremap_nocache(MSS_CAM_BASE_ADDR,
-			MSS_CAM_MMIO_SIZE);
+
+	/* enable display clocks*/
+	clk_lcd = clk_get(&pdev->dev, "clk_lcd");
+	if (!clk_lcd) {
+		DRM_ERROR("clk_get() failed clk_lcd\n");
+		goto setup_fail;
+	}
+	DRM_INFO("%s : %d\n", __func__, __LINE__);
+
+	clk_mipi = clk_get(&pdev->dev, "clk_mipi");
+	if (!clk_mipi) {
+		DRM_ERROR("clk_get() failed clk_mipi\n");
+		goto setup_fail;
 	}
+	DRM_INFO("%s : %d\n", __func__, __LINE__);
+	ret = kmb_display_clk_enable();
 
-	/* register irqs here - section 17.3 in databook
+	/* set LCD clock to 200 Mhz*/
+	DRM_INFO("Get clk_lcd before set = %ld\n", clk_get_rate(clk_lcd));
+	ret = clk_set_rate(clk_lcd, 200000000);
+	DRM_INFO("Setting LCD clock tp 200Mhz ret = %d\n", ret);
+	DRM_INFO("Get clk_lcd after set = %ld\n", clk_get_rate(clk_lcd));
+	/* set MIPI clock to 24 Mhz*/
+	DRM_INFO("Get clk_mipi before set = %ld\n", clk_get_rate(clk_mipi));
+	ret = clk_set_rate(clk_mipi, 24000000);
+	DRM_INFO("Setting MIPI clock tp 24Mhz ret = %d\n", ret);
+	DRM_INFO("Get clk_mipi after set = %ld\n", clk_get_rate(clk_mipi));
+
+#ifdef WIP
+	/* Register irqs here - section 17.3 in databook
 	 * lists LCD at 79 and 82 for MIPI under MSS CPU -
 	 * firmware has to redirect it to A53
 	 */
+	DRM_INFO("platform_get_irq_byname %pOF\n", drm->dev->of_node);
+
+	/* Allocate LCD interrupt resources, enable interrupt line,
+	 * and setup IRQ handling
+	 */
+	irq_lcd = platform_get_irq_byname(pdev, "irq_lcd");
+	if (irq_lcd < 0) {
+		DRM_ERROR("irq_lcd not found");
+		return irq_lcd;
+	}
+
+	pr_info("irq_lcd platform_get_irq = %d\n", irq_lcd);
+
+	ret = request_irq(irq_lcd, kmb_isr, IRQF_SHARED, "irq_lcd", dev_p);
+	dev_p->irq_lcd = irq_lcd;
+
+	/* Allocate MIPI interrupt resources, enable interrupt line,
+	 * and setup IRQ handling
+	 */
+	irq_mipi = platform_get_irq_byname(pdev, "irq_mipi");
+	if (irq_mipi < 0) {
+		DRM_ERROR("irq_mipi not found");
+		return irq_mipi;
+	}
 
-		/*TBD read and check for correct product version here */
+	pr_info("irq_mipi platform_get_irq = %d\n", irq_mipi);
+	ret = request_irq(irq_mipi, kmb_isr, IRQF_SHARED, "irq_mipi", dev_p);
+	dev_p->irq_mipi = irq_mipi;
+#endif
+	/* TBD read and check for correct product version here */
 
-		/* Get the optional framebuffer memory resource */
+	/* Get the optional framebuffer memory resource */
 	ret = of_reserved_mem_device_init(drm->dev);
 	if (ret && ret != -ENODEV)
 		return ret;
 
 	spin_lock_init(&dev_p->irq_lock);
+
 	ret = kmb_setup_crtc(drm);
 	if (ret < 0) {
 		DRM_ERROR("failed to create crtc\n");
 		goto setup_fail;
 	}
 
+	/* Initialize MIPI DSI */
 	ret = kmb_dsi_init(drm, adv_bridge);
 	if (ret == -EPROBE_DEFER) {
 		DRM_INFO("%s: wait for external bridge driver DT", __func__);
@@ -175,26 +231,23 @@ static int kmb_load(struct drm_device *drm, unsigned long flags)
 		DRM_ERROR("failed to initialize DSI\n");
 		goto setup_fail;
 	}
-	/* enable display clocks*/
-	clk_lcd = clk_get(&pdev->dev, "clk_lcd");
-	if (!clk_lcd) {
-		DRM_ERROR("clk_get() failed clk_lcd\n");
-		goto setup_fail;
-	}
+
 	DRM_INFO("%s : %d\n", __func__, __LINE__);
-	clk_mipi = clk_get(&pdev->dev, "clk_mipi");
-	if (!clk_mipi) {
-		DRM_ERROR("clk_get() failed clk_mipi\n");
-		goto setup_fail;
+#ifdef WIP
+	ret = drm_irq_install(drm, platform_get_irq(pdev, 0));
+	if (ret < 0) {
+		DRM_ERROR("failed to install IRQ handler\n");
+		goto irq_fail;
 	}
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
-	ret = kmb_display_clk_enable();
-
-	DRM_INFO("%s : %d clk enabling ret=%d\n", __func__, __LINE__, ret);
+#endif
 	return 0;
 
+#ifdef WIP
+irq_fail:
 	drm_crtc_cleanup(&dev_p->crtc);
+#endif
 setup_fail:
+	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	of_reserved_mem_device_release(drm->dev);
 
 	return ret;
@@ -305,62 +358,113 @@ static struct drm_driver kmb_driver = {
 	.minor = 0,
 };
 
-static int kmb_drm_bind(struct device *dev)
+static void kmb_drm_unload(struct device *dev)
 {
+	struct drm_device *drm = dev_get_drvdata(dev);
+	struct kmb_drm_private *dev_p = drm->dev_private;
+
+	dump_stack();
+	drm_dev_unregister(drm);
+	drm_kms_helper_poll_fini(drm);
+	of_node_put(dev_p->crtc.port);
+	dev_p->crtc.port = NULL;
+	pm_runtime_get_sync(drm->dev);
+	drm_irq_uninstall(drm);
+	pm_runtime_put_sync(drm->dev);
+	pm_runtime_disable(drm->dev);
+
+	if (dev_p->lcd_mmio) {
+		iounmap(dev_p->lcd_mmio);
+		release_mem_region(LCD_BASE_ADDR, LCD_MMIO_SIZE);
+	}
+
+	if (dev_p->mipi_mmio) {
+		iounmap(dev_p->mipi_mmio);
+		release_mem_region(MIPI_BASE_ADDR, MIPI_MMIO_SIZE);
+	}
+
+	if (dev_p->msscam_mmio)
+		iounmap(dev_p->msscam_mmio);
+
+	of_reserved_mem_device_release(drm->dev);
+	drm_mode_config_cleanup(drm);
+
+	/*release clks */
+	kmb_display_clk_disable();
+	clk_put(clk_lcd);
+	clk_put(clk_mipi);
+
+	drm_dev_put(drm);
+	drm->dev_private = NULL;
+	dev_set_drvdata(dev, NULL);
+
+	/* Unregister DSI host */
+	mipi_dsi_host_unregister(dsi_host);
+}
+
+static int kmb_probe(struct platform_device *pdev)
+{
+	struct device *dev = get_device(&pdev->dev);
 	struct drm_device *drm = NULL;
 	struct kmb_drm_private *lcd;
-	int ret;
+	int ret = 0;
+
+	/* The bridge (ADV 7535) will return -EPROBE_DEFER until it
+	 * has a mipi_dsi_host to register its device to. So, we
+	 * first register the DSI host during probe time, and then return
+	 * -EPROBE_DEFER until the bridge is loaded. Probe will be called again
+	 *  and then the rest of the driver initialization can procees
+	 *  afterwards and the bridge can be successfully attached.
+	 */
+	adv_bridge =  kmb_dsi_host_bridge_init(dev);
+	if (adv_bridge == ERR_PTR(-EPROBE_DEFER))
+		return -EPROBE_DEFER;
+	else if (IS_ERR(adv_bridge)) {
+		DRM_ERROR("probe failed to initialize DSI host bridge\n");
+		return PTR_ERR(adv_bridge);
+	}
 
-	DRM_DEBUG("%s : ENTER", __func__);
+	/* Create DRM device */
 	drm = drm_dev_alloc(&kmb_driver, dev);
 	if (IS_ERR(drm))
 		return PTR_ERR(drm);
 
-	DRM_DEBUG("%s : after alloc drm", __func__);
 	lcd = devm_kzalloc(dev, sizeof(*lcd), GFP_KERNEL);
 	if (!lcd)
 		return -ENOMEM;
 
-	DRM_DEBUG("%s : after alloc lcd", __func__);
 	drm->dev_private = lcd;
-
 	kmb_setup_mode_config(drm);
 	dev_set_drvdata(dev, drm);
 
-	/* load the driver */
+	/* Load driver */
 	ret = kmb_load(drm, 0);
-	DRM_INFO("%s : %d ret = %d\n", __func__, __LINE__, ret);
 	if (ret == -EPROBE_DEFER) {
-		DRM_INFO("kmb_bind: wait for external bridge driver DT\n");
+		DRM_INFO("wait for external bridge driver DT\n");
 		return -EPROBE_DEFER;
 	} else if (ret)
 		goto err_free;
 
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	/* Set the CRTC's port so that the encoder component can find it */
 	lcd->crtc.port = of_graph_get_port_by_id(dev->of_node, 0);
-	DRM_INFO("crtc port = %pOF\n", lcd->crtc.port);
+
 	ret = drm_vblank_init(drm, drm->mode_config.num_crtc);
 	if (ret < 0) {
-		DRM_ERROR("failed to initialise vblank\n");
+		DRM_ERROR("failed to initialize vblank\n");
 		goto err_vblank;
 	}
 
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	drm_mode_config_reset(drm);
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	drm_kms_helper_poll_init(drm);
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 
+	/* Register graphics device with the kernel */
 	ret = drm_dev_register(drm, 0);
-	DRM_INFO("%s : %d ret = %d\n", __func__, __LINE__, ret);
 
 	lcd->n_layers = KMB_MAX_PLANES;
 	if (ret)
 		goto err_register;
 
 	drm_fbdev_generic_setup(drm, 32);
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 
 	return 0;
 
@@ -368,86 +472,18 @@ static int kmb_drm_bind(struct device *dev)
 	drm_kms_helper_poll_fini(drm);
 err_vblank:
 	pm_runtime_disable(drm->dev);
-	of_node_put(lcd->crtc.port);
-	lcd->crtc.port = NULL;
-	drm_irq_uninstall(drm);
-	of_reserved_mem_device_release(drm->dev);
 err_free:
 	drm_mode_config_cleanup(drm);
 	dev_set_drvdata(dev, NULL);
 	drm_dev_put(drm);
+	mipi_dsi_host_unregister(dsi_host);
 
 	return ret;
 }
 
-static void kmb_drm_unbind(struct device *dev)
-{
-	struct drm_device *drm = dev_get_drvdata(dev);
-	struct kmb_drm_private *dev_p = drm->dev_private;
-
-	dump_stack();
-	drm_dev_unregister(drm);
-	drm_kms_helper_poll_fini(drm);
-	of_node_put(dev_p->crtc.port);
-	dev_p->crtc.port = NULL;
-	pm_runtime_get_sync(drm->dev);
-	drm_irq_uninstall(drm);
-	pm_runtime_put_sync(drm->dev);
-	pm_runtime_disable(drm->dev);
-
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
-	if (dev_p->lcd_mmio) {
-		DRM_INFO("%s : %d\n", __func__, __LINE__);
-		iounmap(dev_p->lcd_mmio);
-		release_mem_region(LCD_BASE_ADDR, LCD_MMIO_SIZE);
-	}
-
-	if (dev_p->mipi_mmio) {
-		DRM_INFO("%s : %d\n", __func__, __LINE__);
-		iounmap(dev_p->mipi_mmio);
-		release_mem_region(MIPI_BASE_ADDR, MIPI_MMIO_SIZE);
-	}
-
-	if (dev_p->msscam_mmio)
-		iounmap(dev_p->msscam_mmio);
-
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
-	of_reserved_mem_device_release(drm->dev);
-	drm_mode_config_cleanup(drm);
-
-	/*release clks */
-	kmb_display_clk_disable();
-	clk_put(clk_lcd);
-	clk_put(clk_mipi);
-
-	drm_dev_put(drm);
-	drm->dev_private = NULL;
-	dev_set_drvdata(dev, NULL);
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
-}
-
-static int kmb_probe(struct platform_device *pdev)
-{
-	struct device *device = get_device(&pdev->dev);
-
-	/* there is only one output port inside each device, find it */
-	DRM_DEBUG("%s : ENTER", __func__);
-
-	adv_bridge =  kmb_dsi_host_bridge_init(device);
-	if (adv_bridge == ERR_PTR(-EPROBE_DEFER))
-		return -EPROBE_DEFER;
-	else if (adv_bridge < 0) {
-		DRM_ERROR(" PROBE failed\n");
-		return -EINVAL;
-	}
-
-	return kmb_drm_bind(&pdev->dev);
-}
-
 static int kmb_remove(struct platform_device *pdev)
 {
-//	component_master_del(&pdev->dev, &kmb_master_ops);
-	kmb_drm_unbind(&pdev->dev);
+	kmb_drm_unload(&pdev->dev);
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/kmb/kmb_drv.h b/drivers/gpu/drm/kmb/kmb_drv.h
index 6c1d687b2f8b..c87e60867a6b 100644
--- a/drivers/gpu/drm/kmb/kmb_drv.h
+++ b/drivers/gpu/drm/kmb/kmb_drv.h
@@ -31,6 +31,7 @@
 #define KMB_MAX_WIDTH			16384	/*max width in pixels */
 #define KMB_MAX_HEIGHT			16384	/*max height in pixels */
 
+extern struct mipi_dsi_host *dsi_host;
 struct kmb_drm_private {
 	struct drm_device		drm;
 	void __iomem			*lcd_mmio;
diff --git a/drivers/gpu/drm/kmb/kmb_dsi.c b/drivers/gpu/drm/kmb/kmb_dsi.c
index b42884b6e701..8beb6997731b 100644
--- a/drivers/gpu/drm/kmb/kmb_dsi.c
+++ b/drivers/gpu/drm/kmb/kmb_dsi.c
@@ -79,7 +79,7 @@
 #define PLL_M_MAX	623
 #define PLL_FVCO_MAX	1250
 
-static struct mipi_dsi_host *dsi_host;
+struct mipi_dsi_host *dsi_host;
 static struct mipi_dsi_device *dsi_device;
 
 /*
@@ -314,10 +314,10 @@ static struct kmb_dsi_host *kmb_dsi_host_init(struct drm_device *drm,
 
 struct drm_bridge *kmb_dsi_host_bridge_init(struct device *dev)
 {
-	int ret;
 	struct device_node *encoder_node;
 	struct drm_bridge *bridge;
 
+	/* Create and register MIPI DSI host */
 	if (!dsi_host) {
 		dsi_host = kzalloc(sizeof(*dsi_host), GFP_KERNEL);
 		if (!dsi_host)
@@ -325,31 +325,27 @@ struct drm_bridge *kmb_dsi_host_bridge_init(struct device *dev)
 
 		dsi_host->ops = &kmb_dsi_host_ops;
 
-		if (!dsi_device)
-			dsi_device = kzalloc(sizeof(*dsi_device), GFP_KERNEL);
 		if (!dsi_device) {
-			kfree(dsi_host);
-			return ERR_PTR(-ENOMEM);
+			dsi_device = kzalloc(sizeof(*dsi_device), GFP_KERNEL);
+			if (!dsi_device) {
+				kfree(dsi_host);
+				return ERR_PTR(-ENOMEM);
+			}
 		}
 
 		dsi_host->dev = dev;
-		ret = mipi_dsi_host_register(dsi_host);
-		if (ret < 0) {
-			DRM_ERROR("failed to register DSI host: %d\n", ret);
-			kfree(dsi_host);
-			kfree(dsi_device);
-			return ERR_PTR(ret);
-		}
+		mipi_dsi_host_register(dsi_host);
 	}
 
 	/* find ADV7535 node and initialize it */
-	DRM_DEBUG("trying to get bridge info %pOF\n", dev->of_node);
+	DRM_INFO("trying to get bridge info %pOF\n", dev->of_node);
 	encoder_node = of_parse_phandle(dev->of_node, "encoder-slave", 0);
-	DRM_DEBUG("encoder node =  %pOF\n", encoder_node);
+	DRM_INFO("encoder node =  %pOF\n", encoder_node);
 	if (!encoder_node) {
 		DRM_ERROR("failed to get bridge info from DT\n");
-		ret = -EINVAL;
+		return ERR_PTR(-EINVAL);
 	}
+
 	/* Locate drm bridge from the hdmi encoder DT node */
 	bridge = of_drm_find_bridge(encoder_node);
 	of_node_put(encoder_node);
@@ -357,6 +353,7 @@ struct drm_bridge *kmb_dsi_host_bridge_init(struct device *dev)
 		DRM_INFO("wait for external bridge driver DT\n");
 		return ERR_PTR(-EPROBE_DEFER);
 	}
+
 	return bridge;
 }
 
@@ -487,9 +484,9 @@ static u32 mipi_tx_fg_section_cfg_regs(struct kmb_drm_private *dev_p,
 	u32 ctrl_no = MIPI_CTRL6;
 	u32 reg_adr;
 
-	/*frame section packet header */
-	/*word count */
-	cfg = (ph_cfg->wc & MIPI_TX_SECT_WC_MASK) << 0;	/* bits [15:0] */
+	/*frame section packet header*/
+	/*word count*/
+	cfg = (ph_cfg->wc & MIPI_TX_SECT_WC_MASK) << 0; /* bits [15:0]*/
 	/*data type */
 	cfg |= ((ph_cfg->data_type & MIPI_TX_SECT_DT_MASK)
 		<< MIPI_TX_SECT_DT_SHIFT);	/* bits [21:16] */
@@ -502,7 +499,6 @@ static u32 mipi_tx_fg_section_cfg_regs(struct kmb_drm_private *dev_p,
 	cfg |= MIPI_TX_SECT_DMA_PACKED;
 	kmb_write_mipi(dev_p, (MIPI_TXm_HS_FGn_SECTo_PH(ctrl_no, frame_id,
 					section)), cfg);
-
 	/*unpacked bytes */
 	/*there are 4 frame generators and each fg has 4 sections
 	 *there are 2 registers for unpacked bytes -
@@ -513,7 +509,7 @@ static u32 mipi_tx_fg_section_cfg_regs(struct kmb_drm_private *dev_p,
 	reg_adr = MIPI_TXm_HS_FGn_SECT_UNPACKED_BYTES0(ctrl_no, frame_id)
 	+ (section/2)*4;
 	kmb_write_bits_mipi(dev_p, reg_adr, (section % 2)*16, 16,
-		unpacked_bytes);
+			unpacked_bytes);
 
 	/* line config */
 	reg_adr = MIPI_TXm_HS_FGn_SECTo_LINE_CFG(ctrl_no, frame_id, section);
@@ -531,10 +527,9 @@ static u32 mipi_tx_fg_section_cfg(struct kmb_drm_private *dev_p, u8 frame_id,
 	struct mipi_data_type_params data_type_parameters;
 	struct mipi_tx_frame_sect_phcfg ph_cfg;
 
-	ret =
-	    mipi_get_datatype_params(frame_scfg->data_type,
-				     frame_scfg->data_mode,
-				     &data_type_parameters);
+	ret = mipi_get_datatype_params(frame_scfg->data_type,
+			frame_scfg->data_mode,
+			&data_type_parameters);
 	if (ret)
 		return ret;
 	/*
@@ -542,7 +537,7 @@ static u32 mipi_tx_fg_section_cfg(struct kmb_drm_private *dev_p, u8 frame_id,
 	 * (in pixels) set for each data type
 	 */
 	if (frame_scfg->width_pixels %
-	    data_type_parameters.size_constraint_pixels != 0)
+		data_type_parameters.size_constraint_pixels != 0)
 		return -EINVAL;
 
 	*wc = compute_wc(frame_scfg->width_pixels,
@@ -558,8 +553,8 @@ static u32 mipi_tx_fg_section_cfg(struct kmb_drm_private *dev_p, u8 frame_id,
 	ph_cfg.vchannel = frame_id;
 
 	mipi_tx_fg_section_cfg_regs(dev_p, frame_id, section,
-			frame_scfg->height_lines,
-			unpacked_bytes, &ph_cfg);
+		frame_scfg->height_lines,
+		unpacked_bytes, &ph_cfg);
 
 	/*caller needs bits_per_clk for additional caluclations */
 	*bits_per_pclk = data_type_parameters.bits_per_pclk;
@@ -720,7 +715,6 @@ static void mipi_tx_ctrl_cfg(struct kmb_drm_private *dev_p, u8 fg_id,
 	u32 sync_cfg = 0, ctrl = 0, fg_en;
 	u32 ctrl_no = MIPI_CTRL6;
 
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	/*MIPI_TX_HS_SYNC_CFG*/
 	if (ctrl_cfg->tx_ctrl_cfg.line_sync_pkt_en)
 		sync_cfg |= LINE_SYNC_PKT_ENABLE;
@@ -732,7 +726,6 @@ static void mipi_tx_ctrl_cfg(struct kmb_drm_private *dev_p, u8 fg_id,
 		sync_cfg |= DSI_V_BLANKING;
 	if (ctrl_cfg->tx_ctrl_cfg.tx_dsi_cfg->hsa_blanking)
 		sync_cfg |= DSI_HSA_BLANKING;
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	if (ctrl_cfg->tx_ctrl_cfg.tx_dsi_cfg->hbp_blanking)
 		sync_cfg |= DSI_HBP_BLANKING;
 	if (ctrl_cfg->tx_ctrl_cfg.tx_dsi_cfg->hfp_blanking)
@@ -744,7 +737,6 @@ static void mipi_tx_ctrl_cfg(struct kmb_drm_private *dev_p, u8 fg_id,
 	if (ctrl_cfg->tx_ctrl_cfg.tx_dsi_cfg->lpm_last_vfp_line)
 		sync_cfg |= DSI_LPM_LAST_VFP_LINE;
 	/* enable frame generator */
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	fg_en = 1 << fg_id;
 	sync_cfg |= FRAME_GEN_EN(fg_en);
 	if (ctrl_cfg->tx_ctrl_cfg.tx_always_use_hact)
@@ -763,9 +755,7 @@ static void mipi_tx_ctrl_cfg(struct kmb_drm_private *dev_p, u8 fg_id,
 	/*67 ns stop time */
 	ctrl |= HSEXIT_CNT(0x43);
 
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	kmb_write_mipi(dev_p, MIPI_TXm_HS_SYNC_CFG(ctrl_no), sync_cfg);
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	kmb_write_mipi(dev_p, MIPI_TXm_HS_CTRL(ctrl_no), ctrl);
 }
 
@@ -786,18 +776,20 @@ static u32 mipi_tx_init_cntrl(struct kmb_drm_private *dev_p,
 	 * set mipitxcctrlcfg
 	 */
 
+	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	for (frame_id = 0; frame_id < 4; frame_id++) {
 		/* find valid frame, assume only one valid frame */
 		if (ctrl_cfg->tx_ctrl_cfg.frames[frame_id] == NULL)
 			continue;
 
+		DRM_INFO("%s : %d\n", __func__, __LINE__);
 		/* Frame Section configuration */
 		/*TODO - assume there is only one valid section in a frame, so
 		 * bits_per_pclk and word_count are only set once
 		 */
 		for (sect = 0; sect < MIPI_CTRL_VIRTUAL_CHANNELS; sect++) {
 			if (ctrl_cfg->tx_ctrl_cfg.frames[frame_id]->sections[sect]
-			    == NULL)
+				== NULL)
 				continue;
 
 			ret = mipi_tx_fg_section_cfg(dev_p, frame_id, sect,
@@ -810,9 +802,9 @@ static u32 mipi_tx_init_cntrl(struct kmb_drm_private *dev_p,
 
 		/* set frame specific parameters */
 		mipi_tx_fg_cfg(dev_p, frame_id, ctrl_cfg->active_lanes,
-				bits_per_pclk,
-				word_count, ctrl_cfg->lane_rate_mbps,
-				ctrl_cfg->tx_ctrl_cfg.frames[frame_id]);
+			bits_per_pclk,
+			word_count, ctrl_cfg->lane_rate_mbps,
+			ctrl_cfg->tx_ctrl_cfg.frames[frame_id]);
 
 		active_vchannels++;
 
@@ -1348,7 +1340,6 @@ void mipi_tx_handle_irqs(struct kmb_drm_private *dev_p)
 }
 
 int kmb_dsi_init(struct drm_device *dev, struct drm_bridge *bridge)
-//int kmb_dsi_init(struct drm_device *dev)
 {
 	struct kmb_dsi *kmb_dsi;
 	struct drm_encoder *encoder;
@@ -1358,7 +1349,6 @@ int kmb_dsi_init(struct drm_device *dev, struct drm_bridge *bridge)
 	struct kmb_drm_private *dev_p = dev->dev_private;
 	int ret = 0;
 
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	kmb_dsi = kzalloc(sizeof(*kmb_dsi), GFP_KERNEL);
 	if (!kmb_dsi) {
 		DRM_ERROR("failed to allocate kmb_dsi\n");
@@ -1372,12 +1362,9 @@ int kmb_dsi_init(struct drm_device *dev, struct drm_bridge *bridge)
 		return -ENOMEM;
 	}
 
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	kmb_dsi->attached_connector = kmb_connector;
 
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	host = kmb_dsi_host_init(dev, kmb_dsi);
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	if (!host) {
 		DRM_ERROR("Faile to allocate host\n");
 //		drm_encoder_cleanup(encoder);
@@ -1386,30 +1373,23 @@ int kmb_dsi_init(struct drm_device *dev, struct drm_bridge *bridge)
 		return -ENOMEM;
 	}
 
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	connector = &kmb_connector->base;
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	encoder = &kmb_dsi->base;
 	encoder->possible_crtcs = 1;
 	encoder->possible_clones = 0;
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	drm_encoder_init(dev, encoder, &kmb_dsi_funcs, DRM_MODE_ENCODER_DSI,
 			"MIPI-DSI");
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 
 	drm_connector_init(dev, connector, &kmb_dsi_connector_funcs,
 						   DRM_MODE_CONNECTOR_DSI);
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	drm_connector_helper_add(connector, &kmb_dsi_connector_helper_funcs);
 
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
-//	connector->encoder = encoder;
 	DRM_INFO("%s : %d connector = %s encoder = %s\n", __func__,
 			__LINE__, connector->name, encoder->name);
 
 	ret = drm_connector_attach_encoder(connector, encoder);
+
 	/* Link drm_bridge to encoder */
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 	ret = drm_bridge_attach(encoder, bridge, NULL);
 	if (ret) {
 		DRM_ERROR("failed to attach bridge to MIPI\n");
@@ -1417,18 +1397,15 @@ int kmb_dsi_init(struct drm_device *dev, struct drm_bridge *bridge)
 		return ret;
 	}
 
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
+	DRM_INFO("%s : %d Bridge attached : SUCCESS\n", __func__, __LINE__);
 	/* initialize mipi controller */
 	mipi_tx_init_cntrl(dev_p, &mipi_tx_init_cfg);
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 
 	/*d-phy initialization */
 	mipi_tx_init_dphy(dev_p, &mipi_tx_init_cfg);
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 
 	/* irq initialization */
 	mipi_tx_init_irqs(dev_p, &int_cfg, &mipi_tx_init_cfg.tx_ctrl_cfg);
-	DRM_INFO("%s : %d\n", __func__, __LINE__);
 
 	return 0;
 }
-- 
2.17.1

