From bf62a1f8b9173aedf3036c0ec99edcbf1d187fe8 Mon Sep 17 00:00:00 2001
From: "Dillibabu, Karthikx" <karthikx.dillibabu@intel.com>
Date: Tue, 9 Mar 2021 15:56:58 +0530
Subject: [PATCH] FIX for Tx/Rx using shared DMA for PSE_HostOwned_SPI fails
 with VT-D enabled

The original using of the DMA API such as dma_alloc_coherent(), dma_map_sg() ..etc,
was using DMA device as the initiator, but it was found out that with PSE + DMA,
it has to use the peripheral itself.

Signed-off-by: Dillibabu, Karthikx <karthikx.dillibabu@intel.com>
---
 drivers/spi/spi.c | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 97b5a811bd7f..d30547883c62 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -33,6 +33,7 @@
 #include <linux/highmem.h>
 #include <linux/idr.h>
 #include <linux/platform_data/x86/apple.h>
+#include <linux/pci.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/spi.h>
@@ -41,6 +42,18 @@ EXPORT_TRACEPOINT_SYMBOL(spi_transfer_stop);
 
 #include "internals.h"
 
+static bool pse_dma_quirk;
+
+static void quirk_pse_dma(struct pci_dev *dev)
+{
+	pse_dma_quirk = true;
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b84, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b85, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b86, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b87, quirk_pse_dma);
+
 static DEFINE_IDR(spi_master_idr);
 
 static void spidev_release(struct device *dev)
@@ -1034,6 +1047,12 @@ static int __spi_map_msg(struct spi_controller *ctlr, struct spi_message *msg)
 	else
 		rx_dev = ctlr->dev.parent;
 
+	/* Hack for PSE SPI */
+	if (pse_dma_quirk) {
+		tx_dev = ctlr->dev.parent;
+		rx_dev = ctlr->dev.parent;
+	}
+
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		if (!ctlr->can_dma(ctlr, msg->spi, xfer))
 			continue;
@@ -1081,6 +1100,12 @@ static int __spi_unmap_msg(struct spi_controller *ctlr, struct spi_message *msg)
 	else
 		rx_dev = ctlr->dev.parent;
 
+	/* Hack fo PSE SPI */
+	if (pse_dma_quirk) {
+		tx_dev = ctlr->dev.parent;
+		rx_dev = ctlr->dev.parent;
+	}
+
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		if (!ctlr->can_dma(ctlr, msg->spi, xfer))
 			continue;
-- 
2.31.0

