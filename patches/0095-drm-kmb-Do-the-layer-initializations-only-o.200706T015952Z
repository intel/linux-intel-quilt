From 2e6cbe8f7a96868bf4ab9a3220d1b9f05401293a Mon Sep 17 00:00:00 2001
From: Anitha Chrisanthus <anitha.chrisanthus@intel.com>
Date: Wed, 22 Jan 2020 07:26:56 -0800
Subject: [PATCH 095/131] drm/kmb: Do the layer initializations only once

The issue was video starts fine, but towards the end, the color disappers.
Do the layer initializations only once, but update the DMA registers
for every frame. Also changed DRM_INFO to DRM_DEBUG.

Signed-off-by: Anitha Chrisanthus <anitha.chrisanthus@intel.com>
Reviewed-by: Bob Paauwe <bob.j.paauwe@intel.com>
---
 drivers/gpu/drm/kmb/kmb_plane.c | 150 ++++++++++++++------------------
 1 file changed, 66 insertions(+), 84 deletions(-)

diff --git a/drivers/gpu/drm/kmb/kmb_plane.c b/drivers/gpu/drm/kmb/kmb_plane.c
index ad91160b94e5..a6cb59ea992d 100644
--- a/drivers/gpu/drm/kmb/kmb_plane.c
+++ b/drivers/gpu/drm/kmb/kmb_plane.c
@@ -118,6 +118,9 @@ static const u32 csc_coef_lcd[] = {
 	-179, 125, -226
 };
 
+/*plane initialization status */
+static int plane_init_status[KMB_MAX_PLANES] = { 0, 0, 0, 0 };
+
 static unsigned int check_pixel_format(struct drm_plane *plane, u32 format)
 {
 	int i;
@@ -178,9 +181,9 @@ static void kmb_plane_atomic_disable(struct drm_plane *plane,
 	kmb_clr_bitmask_lcd(dev_p, LCD_LAYERn_DMA_CFG(plane_id),
 			    LCD_DMA_LAYER_ENABLE);
 	kmb_clr_bitmask_lcd(dev_p, LCD_CONTROL, ctrl);
-	DRM_INFO("%s : %d lcd_ctrl = 0x%x lcd_int_enable=0x%x\n",
-		 __func__, __LINE__, kmb_read_lcd(dev_p, LCD_CONTROL),
-		 kmb_read_lcd(dev_p, LCD_INT_ENABLE));
+	DRM_DEBUG("%s : %d lcd_ctrl = 0x%x lcd_int_enable=0x%x\n",
+		  __func__, __LINE__, kmb_read_lcd(dev_p, LCD_CONTROL),
+		  kmb_read_lcd(dev_p, LCD_INT_ENABLE));
 }
 
 unsigned int set_pixel_format(u32 format)
@@ -338,8 +341,6 @@ static void kmb_plane_atomic_update(struct drm_plane *plane,
 	unsigned int src_w, src_h, crtc_x, crtc_y;
 	unsigned char plane_id;
 	int num_planes;
-	/*plane initialization status */
-	static int plane_init_status[KMB_MAX_PLANES] = { 0, 0, 0, 0 };
 	static dma_addr_t addr[MAX_SUB_PLANES] = { 0, 0, 0 };
 
 	if (!plane || !plane->state || !state)
@@ -360,9 +361,56 @@ static void kmb_plane_atomic_update(struct drm_plane *plane,
 	crtc_x = plane->state->crtc_x;
 	crtc_y = plane->state->crtc_y;
 
-	DRM_INFO
+	DRM_DEBUG
 	    ("%s : %d src_w=%d src_h=%d, fb->format->format=0x%x fb->flags=0x%x",
 	     __func__, __LINE__, src_w, src_h, fb->format->format, fb->flags);
+
+	width = fb->width;
+	height = fb->height;
+	dma_len = (width * height * fb->format->cpp[0]);
+	DRM_DEBUG("%s : %d dma_len=%d ", __func__, __LINE__, dma_len);
+	kmb_write_lcd(dev_p, LCD_LAYERn_DMA_LEN(plane_id), dma_len);
+	kmb_write_lcd(dev_p, LCD_LAYERn_DMA_LEN_SHADOW(plane_id), dma_len);
+
+	kmb_write_lcd(dev_p, LCD_LAYERn_DMA_LINE_VSTRIDE(plane_id),
+		      fb->pitches[0]);
+	kmb_write_lcd(dev_p, LCD_LAYERn_DMA_LINE_WIDTH(plane_id),
+		      (width * fb->format->cpp[0]));
+
+	addr[Y_PLANE] = drm_fb_cma_get_gem_addr(fb, plane->state, 0);
+	dev_p->fb_addr = (dma_addr_t) addr;
+	kmb_write_lcd(dev_p, LCD_LAYERn_DMA_START_ADDR(plane_id),
+		      addr[Y_PLANE] + fb->offsets[0]);
+	/*program Cb/Cr for planar formats */
+	if (num_planes > 1) {
+		if (fb->format->format == DRM_FORMAT_YUV420 ||
+		    fb->format->format == DRM_FORMAT_YVU420)
+			width /= 2;
+		kmb_write_lcd(dev_p,
+			      LCD_LAYERn_DMA_CB_LINE_VSTRIDE(plane_id),
+			      fb->pitches[LAYER_1]);
+		kmb_write_lcd(dev_p,
+			      LCD_LAYERn_DMA_CB_LINE_WIDTH(plane_id),
+			      (width * fb->format->cpp[0]));
+		addr[U_PLANE] = drm_fb_cma_get_gem_addr(fb, plane->state,
+							U_PLANE);
+		kmb_write_lcd(dev_p, LCD_LAYERn_DMA_START_CB_ADR(plane_id),
+			      addr[U_PLANE]);
+		if (num_planes == 3) {
+			kmb_write_lcd(dev_p,
+				      LCD_LAYERn_DMA_CR_LINE_VSTRIDE(plane_id),
+				      fb->pitches[LAYER_2]);
+			kmb_write_lcd(dev_p,
+				      LCD_LAYERn_DMA_CR_LINE_WIDTH(plane_id),
+				      (width * fb->format->cpp[0]));
+			addr[V_PLANE] = drm_fb_cma_get_gem_addr(fb,
+								plane->state,
+								V_PLANE);
+			kmb_write_lcd(dev_p,
+				      LCD_LAYERn_DMA_START_CR_ADR(plane_id),
+				      addr[V_PLANE]);
+		}
+	}
 	if (plane_init_status[plane_id] != INITIALIZED) {
 		kmb_write_lcd(dev_p, LCD_LAYERn_WIDTH(plane_id), src_w - 1);
 		kmb_write_lcd(dev_p, LCD_LAYERn_HEIGHT(plane_id), src_h - 1);
@@ -375,55 +423,6 @@ static void kmb_plane_atomic_update(struct drm_plane *plane,
 		val |= LCD_LAYER_FIFO_100;
 		kmb_write_lcd(dev_p, LCD_LAYERn_CFG(plane_id), val);
 
-		/*re-initialize interrupts */
-		kmb_clr_bitmask_lcd(dev_p, LCD_INT_ENABLE,
-				    layer_irqs[plane_id]);
-		kmb_set_bitmask_lcd(dev_p, LCD_INT_CLEAR, layer_irqs[plane_id]);
-
-		dma_cfg = LCD_DMA_LAYER_ENABLE | LCD_DMA_LAYER_VSTRIDE_EN |
-		    LCD_DMA_LAYER_CONT_UPDATE | LCD_DMA_LAYER_AXI_BURST_16;
-
-		width = fb->width;
-		height = fb->height;
-		dma_len = (width * height * fb->format->cpp[0]);
-		DRM_INFO("%s : %d dma_len=%d ", __func__, __LINE__, dma_len);
-		kmb_write_lcd(dev_p, LCD_LAYERn_DMA_LEN(plane_id), dma_len);
-		kmb_write_lcd(dev_p, LCD_LAYERn_DMA_LEN_SHADOW(plane_id),
-			      dma_len);
-
-		kmb_write_lcd(dev_p, LCD_LAYERn_DMA_LINE_VSTRIDE(plane_id),
-			      fb->pitches[0]);
-		kmb_write_lcd(dev_p, LCD_LAYERn_DMA_LINE_WIDTH(plane_id),
-			      (width * fb->format->cpp[0]));
-
-		/*program Cb/Cr for planar formats */
-		if (num_planes > 1) {
-			if (fb->format->format == DRM_FORMAT_YUV420 ||
-			    fb->format->format == DRM_FORMAT_YVU420)
-				width /= 2;
-			kmb_write_lcd(dev_p,
-				      LCD_LAYERn_DMA_CB_LINE_VSTRIDE(plane_id),
-				      fb->pitches[LAYER_1]);
-			kmb_write_lcd(dev_p,
-				      LCD_LAYERn_DMA_CB_LINE_WIDTH(plane_id),
-				      (width * fb->format->cpp[0]));
-			if (num_planes == 3) {
-				kmb_write_lcd(dev_p,
-					      LCD_LAYERn_DMA_CR_LINE_VSTRIDE
-					      (plane_id), fb->pitches[LAYER_2]);
-				kmb_write_lcd(dev_p,
-					      LCD_LAYERn_DMA_CR_LINE_WIDTH
-					      (plane_id),
-					      (width * fb->format->cpp[0]));
-			}
-		}
-
-		/* enable DMA */
-		kmb_write_lcd(dev_p, LCD_LAYERn_DMA_CFG(plane_id), dma_cfg);
-		DRM_INFO("%s : %d dma_cfg=0x%x LCD_DMA_CFG=0x%x\n",
-			 __func__, __LINE__, dma_cfg,
-			 kmb_read_lcd(dev_p, LCD_LAYERn_DMA_CFG(plane_id)));
-
 		switch (plane_id) {
 		case LAYER_0:
 			ctrl = LCD_CTRL_VL1_ENABLE;
@@ -465,38 +464,18 @@ static void kmb_plane_atomic_update(struct drm_plane *plane,
 		/* do not interleave RGB channels for mipi Tx compatibility */
 		out_format |= LCD_OUTF_MIPI_RGB_MODE;
 		kmb_write_lcd(dev_p, LCD_OUT_FORMAT_CFG, out_format);
-
-		kmb_set_bitmask_lcd(dev_p, LCD_INT_ENABLE,
-				    layer_irqs[plane_id]);
 		plane_init_status[plane_id] = INITIALIZED;
 	}
 
-	addr[Y_PLANE] = drm_fb_cma_get_gem_addr(fb, plane->state, 0);
-	dev_p->fb_addr = (dma_addr_t) addr;
-	if (num_planes > 1) {
-		addr[U_PLANE] = drm_fb_cma_get_gem_addr(fb, plane->state,
-							U_PLANE);
-		if (num_planes == 3)
-			addr[V_PLANE] =
-			    drm_fb_cma_get_gem_addr(fb, plane->state, V_PLANE);
-	}
-	/* disable DMA first */
-	kmb_clr_bitmask_lcd(dev_p, LCD_LAYERn_DMA_CFG(plane_id),
-			    LCD_DMA_LAYER_ENABLE);
-	kmb_write_lcd(dev_p, LCD_LAYERn_DMA_START_ADDR(plane_id),
-		      addr[Y_PLANE] + fb->offsets[0]);
-	if (num_planes > 1) {
-		kmb_write_lcd(dev_p, LCD_LAYERn_DMA_START_CB_ADR(plane_id),
-			      addr[U_PLANE]);
-		if (num_planes == 3)
-			kmb_write_lcd(dev_p,
-				      LCD_LAYERn_DMA_START_CR_ADR(plane_id),
-				      addr[V_PLANE]);
-	}
-	/* Enable DMA */
-	kmb_set_bitmask_lcd(dev_p, LCD_LAYERn_DMA_CFG(plane_id),
-			    LCD_DMA_LAYER_ENABLE);
-	DRM_INFO("%s : %d flipping.....\n", __func__, __LINE__);
+	dma_cfg = LCD_DMA_LAYER_ENABLE | LCD_DMA_LAYER_VSTRIDE_EN |
+	    LCD_DMA_LAYER_CONT_UPDATE | LCD_DMA_LAYER_AXI_BURST_16;
+
+	/* enable DMA */
+	kmb_write_lcd(dev_p, LCD_LAYERn_DMA_CFG(plane_id), dma_cfg);
+	DRM_DEBUG("%s : %d dma_cfg=0x%x LCD_DMA_CFG=0x%x\n",
+		  __func__, __LINE__, dma_cfg,
+		  kmb_read_lcd(dev_p, LCD_LAYERn_DMA_CFG(plane_id)));
+
 	return;
 
 #endif
@@ -610,6 +589,9 @@ struct kmb_plane *kmb_plane_init(struct drm_device *drm)
 			     ret);
 			goto cleanup;
 		}
+		DRM_DEBUG("%s : %d plane=%px\n i=%d type=%d",
+			  __func__, __LINE__, &plane->base_plane,
+			  i, plane_type);
 
 		drm_plane_helper_add(&plane->base_plane,
 				     &kmb_plane_helper_funcs);
-- 
2.17.1

